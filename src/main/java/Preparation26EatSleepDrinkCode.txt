package companywidetests.walmartlabs;

/**
 * Created by hadoop on 28/10/17.
 */
import java.io.*;
import java.math.BigInteger;
import java.util.*;
public class TestClass {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        Task solver = new Task();
        solver.solve(1, in, out);
        out.close();
    }
}
class Task {
    public void solve(int testNumber, InputReader in, OutputWriter out) {
        int testcase = in.readInt();
        while (testcase-->0) {
            System.out.println("test case"+testcase);
            String toBepalinString = in.readString();
            String ans = getMaxPalndrome(toBepalinString,out);
            System.out.println("here");
            System.out.println(ans);
        }

    }

    private String getMaxPalndrome(String toBepalinString, OutputWriter out) {
        System.out.println("enter");
        int count [] = new int[256];
        for(char x:toBepalinString.toCharArray()){
            count[x-'a']++;
        }
        String returnedAns = new String();
        List<Character> charOddCount = new ArrayList<>();

        for(int i=0;i<256;i++){
            if (count[i]%2 == 1){
                charOddCount.add((char)(i+'a'));
                count[i]--;
                i--;
            }
            else if(count[i] !=0 && count[i]%2 ==0) {
                while (count[i]>0){
                    returnedAns = returnedAns+(char)(i+'a');
                    count[i] = count[i]-2;
                }
            }
        }
        StringBuilder sb =  new StringBuilder(returnedAns);
        if(charOddCount.size()>0) {
            returnedAns = sb.toString() + charOddCount.get(0) + sb.reverse().toString();
        }
        else {
            returnedAns = sb.toString() + sb.reverse().toString();
        }
        System.out.println(returnedAns);
        out.print(returnedAns);
        out.print("\n");
        return returnedAns;
    }
}
class InputReader {
    private boolean finished = false;

    private InputStream stream;
    private byte[] buf = new byte[1024];
    private int curChar;
    private int numChars;
    private SpaceCharFilter filter;

    public InputReader(InputStream stream) {
        this.stream = stream;
    }

    public int read() {
        if (numChars == -1)
            throw new InputMismatchException();
        if (curChar >= numChars) {
            curChar = 0;
            try {
                numChars = stream.read(buf);
            } catch (IOException e) {
                throw new InputMismatchException();
            }
            if (numChars <= 0)
                return -1;
        }
        return buf[curChar++];
    }

    public int peek() {
        if (numChars == -1)
            return -1;
        if (curChar >= numChars) {
            curChar = 0;
            try {
                numChars = stream.read(buf);
            } catch (IOException e) {
                return -1;
            }
            if (numChars <= 0)
                return -1;
        }
        return buf[curChar];
    }

    public int readInt() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        int res = 0;
        do {
            if (c < '0' || c > '9')
                throw new InputMismatchException();
            res *= 10;
            res += c - '0';
            c = read();
        } while (!isSpaceChar(c));
        return res * sgn;
    }

    public long readLong() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        long res = 0;
        do {
            if (c < '0' || c > '9')
                throw new InputMismatchException();
            res *= 10;
            res += c - '0';
            c = read();
        } while (!isSpaceChar(c));
        return res * sgn;
    }

    public String readString() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        StringBuilder res = new StringBuilder();
        do {
            if (Character.isValidCodePoint(c))
                res.appendCodePoint(c);
            c = read();
        } while (!isSpaceChar(c));
        return res.toString();
    }

    public boolean isSpaceChar(int c) {
        if (filter != null)
            return filter.isSpaceChar(c);
        return isWhitespace(c);
    }

    public static boolean isWhitespace(int c) {
        return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
    }

    private String readLine0() {
        StringBuilder buf = new StringBuilder();
        int c = read();
        while (c != '\n' && c != -1) {
            if (c != '\r')
                buf.appendCodePoint(c);
            c = read();
        }
        return buf.toString();
    }

    public String readLine() {
        String s = readLine0();
        while (s.trim().length() == 0)
            s = readLine0();
        return s;
    }

    public String readLine(boolean ignoreEmptyLines) {
        if (ignoreEmptyLines)
            return readLine();
        else
            return readLine0();
    }

    public BigInteger readBigInteger() {
        try {
            return new BigInteger(readString());
        } catch (NumberFormatException e) {
            throw new InputMismatchException();
        }
    }

    public char readCharacter() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        return (char) c;
    }

    public double readDouble() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        double res = 0;
        while (!isSpaceChar(c) && c != '.') {
            if (c == 'e' || c == 'E')
                return res * Math.pow(10, readInt());
            if (c < '0' || c > '9')
                throw new InputMismatchException();
            res *= 10;
            res += c - '0';
            c = read();
        }
        if (c == '.') {
            c = read();
            double m = 1;
            while (!isSpaceChar(c)) {
                if (c == 'e' || c == 'E')
                    return res * Math.pow(10, readInt());
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                m /= 10;
                res += (c - '0') * m;
                c = read();
            }
        }
        return res * sgn;
    }

    public boolean isExhausted() {
        int value;
        while (isSpaceChar(value = peek()) && value != -1)
            read();
        return value == -1;
    }

    public String next() {
        return readString();
    }

    public SpaceCharFilter getFilter() {
        return filter;
    }

    public void setFilter(SpaceCharFilter filter) {
        this.filter = filter;
    }

    public interface SpaceCharFilter {
        public boolean isSpaceChar(int ch);
    }
}

class OutputWriter {
    private final PrintWriter writer;

    public OutputWriter(OutputStream outputStream) {
        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(
                outputStream)));
    }

    public OutputWriter(Writer writer) {
        this.writer = new PrintWriter(writer);
    }

    public void print(char[] array) {
        writer.print(array);
    }

    public void print(Object... objects) {
        for (int i = 0; i < objects.length; i++) {
            if (i != 0)
                writer.print(' ');
            writer.print(objects[i]);
        }
    }

    public void print(int[] array) {
        for (int i = 0; i < array.length; i++) {
            if (i != 0)
                writer.print(' ');
            writer.print(array[i]);
        }
    }

    public void print(long[] array) {
        for (int i = 0; i < array.length; i++) {
            if (i != 0)
                writer.print(' ');
            writer.print(array[i]);
        }
    }

    public void printLine(int[] array) {
        print(array);
        writer.println();
    }

    public void printLine(long[] array) {
        print(array);
        writer.println();
    }

    public void printLine() {
        writer.println();
    }

    public void printLine(Object... objects) {
        print(objects);
        writer.println();
    }

    public void print(char i) {
        writer.print(i);
    }

    public void printLine(char i) {
        writer.println(i);
    }

    public void printLine(char[] array) {
        writer.println(array);
    }

    public void printFormat(String format, Object... objects) {
        writer.printf(format, objects);
    }

    public void close() {
        writer.close();
    }

    public void flush() {
        writer.flush();
    }

    public void print(long i) {
        writer.print(i);
    }

    public void printLine(long i) {
        writer.println(i);
    }

    public void print(int i) {
        writer.print(i);
    }

    public void printLine(int i) {
        writer.println(i);
    }
}//package companywidetests.walmartlabs;
//
///**
// * Created by hadoop on 28/10/17.
// */
//import java.io.*;
//import java.math.Bi   gInteger;
//import java.util.*;
//
//public class TestWalmart28oct {
//    public static void main(String[] args) {
//        InputStream inputStream = System.in;
//        OutputStream outputStream = System.out;
//        InputReader in = new InputReader(inputStream);
//        OutputWriter out = new OutputWriter(outputStream);
//        Task solver = new Task();
//        solver.solve(1, in, out);
//        out.close();
//    }
//}
//
//class Task {
//    public void solve(int testNumber, InputReader in, OutputWriter out) {
//        int testcase = in.readInt();
//        while (testcase-->0) {
//            String toBepalinString = in.readString();
//            String ans = getMaxPalndrome(toBepalinString);
//            System.out.println(ans);
//        }
//    }
//
//    private String getMaxPalndrome(String toBepalinString) {
//        int count [] = new int[256];
//        for(char x:toBepalinString.toCharArray()){
//            count[x-'a']++;
//        }
//        String returnedAns = new String();
//        List<Character> charOddCount = new ArrayList<>();
//
//        for(int i=0;i<256;i++){
//            if (count[i]%2 == 1){
//                charOddCount.add((char)(i+'a'));
//                count[i]--;
//                i--;
//            }
//            else if(count[i] !=0 && count[i]%2 ==0) {
//                while (count[i]>0){
//                    returnedAns = returnedAns+(char)(i+'a');
//                    count[i] = count[i]-2;
//                }
//            }
//        }
//        StringBuilder sb =  new StringBuilder(returnedAns);
//        if(charOddCount.size()>0) {
//            returnedAns = sb.toString() + charOddCount.get(0) + sb.reverse().toString();
//        }
//        else {
//            returnedAns = sb.toString() + sb.reverse().toString();
//        }
//        return returnedAns;
//    }
//}
//
//class Graph {
//    public static final int REMOVED_BIT = 0;
//
//    protected int vertexCount;
//    protected int edgeCount;
//
//    private int[] firstOutbound;
//    private int[] firstInbound;
//
//    private Edge[] edges;
//    private int[] nextInbound;
//    private int[] nextOutbound;
//    private int[] from;
//    private int[] to;
//    private long[] weight;
//    public long[] capacity;
//    private int[] reverseEdge;
//    private int[] flags;
//
//    public Graph(int vertexCount) {
//        this(vertexCount, vertexCount);
//    }
//
//    public Graph(int vertexCount, int edgeCapacity) {
//        this.vertexCount = vertexCount;
//        firstOutbound = new int[vertexCount];
//        Arrays.fill(firstOutbound, -1);
//
//        from = new int[edgeCapacity];
//        to = new int[edgeCapacity];
//        nextOutbound = new int[edgeCapacity];
//        flags = new int[edgeCapacity];
//    }
//
//    public static Graph createGraph(int vertexCount, int[] from, int[] to) {
//        Graph graph = new Graph(vertexCount, from.length);
//        for (int i = 0; i < from.length; i++)
//            graph.addSimpleEdge(from[i], to[i]);
//        return graph;
//    }
//
//    public static Graph createWeightedGraph(int vertexCount, int[] from,
//                                            int[] to, long[] weight) {
//        Graph graph = new Graph(vertexCount, from.length);
//        for (int i = 0; i < from.length; i++)
//            graph.addWeightedEdge(from[i], to[i], weight[i]);
//        return graph;
//    }
//
//    public static Graph createFlowGraph(int vertexCount, int[] from, int[] to,
//                                        long[] capacity) {
//        Graph graph = new Graph(vertexCount, from.length * 2);
//        for (int i = 0; i < from.length; i++)
//            graph.addFlowEdge(from[i], to[i], capacity[i]);
//        return graph;
//    }
//
//    public static Graph createFlowWeightedGraph(int vertexCount, int[] from,
//                                                int[] to, long[] weight, long[] capacity) {
//        Graph graph = new Graph(vertexCount, from.length * 2);
//        for (int i = 0; i < from.length; i++)
//            graph.addFlowWeightedEdge(from[i], to[i], weight[i], capacity[i]);
//        return graph;
//    }
//
//    public static Graph createTree(int[] parent) {
//        Graph graph = new Graph(parent.length + 1, parent.length);
//        for (int i = 0; i < parent.length; i++)
//            graph.addSimpleEdge(parent[i], i + 1);
//        return graph;
//    }
//
//    public int addEdge(int fromID, int toID, long weight, long capacity,
//                       int reverseEdge) {
//        ensureEdgeCapacity(edgeCount + 1);
//        if (firstOutbound[fromID] != -1)
//            nextOutbound[edgeCount] = firstOutbound[fromID];
//        else
//            nextOutbound[edgeCount] = -1;
//        firstOutbound[fromID] = edgeCount;
//        if (firstInbound != null) {
//            if (firstInbound[toID] != -1)
//                nextInbound[edgeCount] = firstInbound[toID];
//            else
//                nextInbound[edgeCount] = -1;
//            firstInbound[toID] = edgeCount;
//        }
//        this.from[edgeCount] = fromID;
//        this.to[edgeCount] = toID;
//        if (capacity != 0) {
//            if (this.capacity == null)
//                this.capacity = new long[from.length];
//            this.capacity[edgeCount] = capacity;
//        }
//        if (weight != 0) {
//            if (this.weight == null)
//                this.weight = new long[from.length];
//            this.weight[edgeCount] = weight;
//        }
//        if (reverseEdge != -1) {
//            if (this.reverseEdge == null) {
//                this.reverseEdge = new int[from.length];
//                Arrays.fill(this.reverseEdge, 0, edgeCount, -1);
//            }
//            this.reverseEdge[edgeCount] = reverseEdge;
//        }
//        if (edges != null)
//            edges[edgeCount] = createEdge(edgeCount);
//        return edgeCount++;
//    }
//
//    protected final GraphEdge createEdge(int id) {
//        return new GraphEdge(id);
//    }
//
//    public final int addFlowWeightedEdge(int from, int to, long weight,
//                                         long capacity) {
//        if (capacity == 0) {
//            return addEdge(from, to, weight, 0, -1);
//        } else {
//            int lastEdgeCount = edgeCount;
//            addEdge(to, from, -weight, 0, lastEdgeCount + entriesPerEdge());
//            return addEdge(from, to, weight, capacity, lastEdgeCount);
//        }
//    }
//
//    protected int entriesPerEdge() {
//        return 1;
//    }
//
//    public final int addFlowEdge(int from, int to, long capacity) {
//        return addFlowWeightedEdge(from, to, 0, capacity);
//    }
//
//    public final int addWeightedEdge(int from, int to, long weight) {
//        return addFlowWeightedEdge(from, to, weight, 0);
//    }
//
//    public final int addSimpleEdge(int from, int to) {
//        return addWeightedEdge(from, to, 0);
//    }
//
//    public final int vertexCount() {
//        return vertexCount;
//    }
//
//    public final int edgeCount() {
//        return edgeCount;
//    }
//
//    protected final int edgeCapacity() {
//        return from.length;
//    }
//
//    public final Edge edge(int id) {
//        initEdges();
//        return edges[id];
//    }
//
//    public final int firstOutbound(int vertex) {
//        int id = firstOutbound[vertex];
//        while (id != -1 && isRemoved(id))
//            id = nextOutbound[id];
//        return id;
//    }
//
//    public final int nextOutbound(int id) {
//        id = nextOutbound[id];
//        while (id != -1 && isRemoved(id))
//            id = nextOutbound[id];
//        return id;
//    }
//
//    public final int firstInbound(int vertex) {
//        initInbound();
//        int id = firstInbound[vertex];
//        while (id != -1 && isRemoved(id))
//            id = nextInbound[id];
//        return id;
//    }
//
//    public final int nextInbound(int id) {
//        initInbound();
//        id = nextInbound[id];
//        while (id != -1 && isRemoved(id))
//            id = nextInbound[id];
//        return id;
//    }
//
//    public final int source(int id) {
//        return from[id];
//    }
//
//    public final int destination(int id) {
//        return to[id];
//    }
//
//    public final long weight(int id) {
//        if (weight == null)
//            return 0;
//        return weight[id];
//    }
//
//    public final long capacity(int id) {
//        if (capacity == null)
//            return 0;
//        return capacity[id];
//    }
//
//    public final long flow(int id) {
//        if (reverseEdge == null)
//            return 0;
//        return capacity[reverseEdge[id]];
//    }
//
//    public final void pushFlow(int id, long flow) {
//        if (flow == 0)
//            return;
//        if (flow > 0) {
//            if (capacity(id) < flow)
//                throw new IllegalArgumentException("Not enough capacity");
//        } else {
//            if (flow(id) < -flow)
//                throw new IllegalArgumentException("Not enough capacity");
//        }
//        capacity[id] -= flow;
//        capacity[reverseEdge[id]] += flow;
//    }
//
//    public int transposed(int id) {
//        return -1;
//    }
//
//    public final int reverse(int id) {
//        if (reverseEdge == null)
//            return -1;
//        return reverseEdge[id];
//    }
//
//    public final void addVertices(int count) {
//        ensureVertexCapacity(vertexCount + count);
//        Arrays.fill(firstOutbound, vertexCount, vertexCount + count, -1);
//        if (firstInbound != null)
//            Arrays.fill(firstInbound, vertexCount, vertexCount + count, -1);
//        vertexCount += count;
//    }
//
//    protected final void initEdges() {
//        if (edges == null) {
//            edges = new Edge[from.length];
//            for (int i = 0; i < edgeCount; i++)
//                edges[i] = createEdge(i);
//        }
//    }
//
//    public final void removeVertex(int vertex) {
//        int id = firstOutbound[vertex];
//        while (id != -1) {
//            removeEdge(id);
//            id = nextOutbound[id];
//        }
//        initInbound();
//        id = firstInbound[vertex];
//        while (id != -1) {
//            removeEdge(id);
//            id = nextInbound[id];
//        }
//    }
//
//    private void initInbound() {
//        if (firstInbound == null) {
//            firstInbound = new int[firstOutbound.length];
//            Arrays.fill(firstInbound, 0, vertexCount, -1);
//            nextInbound = new int[from.length];
//            for (int i = 0; i < edgeCount; i++) {
//                nextInbound[i] = firstInbound[to[i]];
//                firstInbound[to[i]] = i;
//            }
//        }
//    }
//
//    public final boolean flag(int id, int bit) {
//        return (flags[id] >> bit & 1) != 0;
//    }
//
//    public final void setFlag(int id, int bit) {
//        flags[id] |= 1 << bit;
//    }
//
//    public final void removeFlag(int id, int bit) {
//        flags[id] &= -1 - (1 << bit);
//    }
//
//    public final void removeEdge(int id) {
//        setFlag(id, REMOVED_BIT);
//    }
//
//    public final void restoreEdge(int id) {
//        removeFlag(id, REMOVED_BIT);
//    }
//
//    public final boolean isRemoved(int id) {
//        return flag(id, REMOVED_BIT);
//    }
//
//    public final Iterable<Edge> outbound(final int id) {
//        initEdges();
//        return new Iterable<Edge>() {
//            public Iterator<Edge> iterator() {
//                return new EdgeIterator(id, firstOutbound, nextOutbound);
//            }
//        };
//    }
//
//    public final Iterable<Edge> inbound(final int id) {
//        initEdges();
//        initInbound();
//        return new Iterable<Edge>() {
//            public Iterator<Edge> iterator() {
//                return new EdgeIterator(id, firstInbound, nextInbound);
//            }
//        };
//    }
//
//    protected void ensureEdgeCapacity(int size) {
//        if (from.length < size) {
//            int newSize = Math.max(size, 2 * from.length);
//            if (edges != null)
//                edges = resize(edges, newSize);
//            from = resize(from, newSize);
//            to = resize(to, newSize);
//            nextOutbound = resize(nextOutbound, newSize);
//            if (nextInbound != null)
//                nextInbound = resize(nextInbound, newSize);
//            if (weight != null)
//                weight = resize(weight, newSize);
//            if (capacity != null)
//                capacity = resize(capacity, newSize);
//            if (reverseEdge != null)
//                reverseEdge = resize(reverseEdge, newSize);
//            flags = resize(flags, newSize);
//        }
//    }
//
//    private void ensureVertexCapacity(int size) {
//        if (firstOutbound.length < size) {
//            int newSize = Math.max(size, 2 * from.length);
//            firstOutbound = resize(firstOutbound, newSize);
//            if (firstInbound != null)
//                firstInbound = resize(firstInbound, newSize);
//        }
//    }
//
//    protected final int[] resize(int[] array, int size) {
//        int[] newArray = new int[size];
//        System.arraycopy(array, 0, newArray, 0, array.length);
//        return newArray;
//    }
//
//    private long[] resize(long[] array, int size) {
//        long[] newArray = new long[size];
//        System.arraycopy(array, 0, newArray, 0, array.length);
//        return newArray;
//    }
//
//    private Edge[] resize(Edge[] array, int size) {
//        Edge[] newArray = new Edge[size];
//        System.arraycopy(array, 0, newArray, 0, array.length);
//        return newArray;
//    }
//
//    public final boolean isSparse() {
//        return vertexCount == 0 || edgeCount * 20 / vertexCount <= vertexCount;
//    }
//
//    protected class GraphEdge implements Edge {
//        protected int id;
//
//        protected GraphEdge(int id) {
//            this.id = id;
//        }
//
//        public int getSource() {
//            return source(id);
//        }
//
//        public int getDestination() {
//            return destination(id);
//        }
//
//        public long getWeight() {
//            return weight(id);
//        }
//
//        public long getCapacity() {
//            return capacity(id);
//        }
//
//        public long getFlow() {
//            return flow(id);
//        }
//
//        public void pushFlow(long flow) {
//            Graph.this.pushFlow(id, flow);
//        }
//
//        public boolean getFlag(int bit) {
//            return flag(id, bit);
//        }
//
//        public void setFlag(int bit) {
//            Graph.this.setFlag(id, bit);
//        }
//
//        public void removeFlag(int bit) {
//            Graph.this.removeFlag(id, bit);
//        }
//
//        public int getTransposedID() {
//            return transposed(id);
//        }
//
//        public Edge getTransposedEdge() {
//            int reverseID = getTransposedID();
//            if (reverseID == -1)
//                return null;
//            initEdges();
//            return edge(reverseID);
//        }
//
//        public int getReverseID() {
//            return reverse(id);
//        }
//
//        public Edge getReverseEdge() {
//            int reverseID = getReverseID();
//            if (reverseID == -1)
//                return null;
//            initEdges();
//            return edge(reverseID);
//        }
//
//        public int getID() {
//            return id;
//        }
//
//        public void remove() {
//            removeEdge(id);
//        }
//
//        public void restore() {
//            restoreEdge(id);
//        }
//    }
//
//    public class EdgeIterator implements Iterator<Edge> {
//        private int edgeID;
//        private final int[] next;
//        private int lastID = -1;
//
//        public EdgeIterator(int id, int[] first, int[] next) {
//            this.next = next;
//            edgeID = nextEdge(first[id]);
//        }
//
//        private int nextEdge(int id) {
//            while (id != -1 && isRemoved(id))
//                id = next[id];
//            return id;
//        }
//
//        public boolean hasNext() {
//            return edgeID != -1;
//        }
//
//        public Edge next() {
//            if (edgeID == -1)
//                throw new NoSuchElementException();
//            lastID = edgeID;
//            edgeID = nextEdge(next[lastID]);
//            return edges[lastID];
//        }
//
//        public void remove() {
//            if (lastID == -1)
//                throw new IllegalStateException();
//            removeEdge(lastID);
//            lastID = -1;
//        }
//    }
//
//}
//
//interface Edge {
//    public int getSource();
//
//    public int getDestination();
//
//    public long getWeight();
//
//    public long getCapacity();
//
//    public long getFlow();
//
//    public void pushFlow(long flow);
//
//    public boolean getFlag(int bit);
//
//    public void setFlag(int bit);
//
//    public void removeFlag(int bit);
//
//    public int getTransposedID();
//
//    public Edge getTransposedEdge();
//
//    public int getReverseID();
//
//    public Edge getReverseEdge();
//
//    public int getID();
//
//    public void remove();
//
//    public void restore();
//}
//
//class BidirectionalGraph extends Graph {
//    public int[] transposedEdge;
//
//    public BidirectionalGraph(int vertexCount) {
//        this(vertexCount, vertexCount);
//    }
//
//    public BidirectionalGraph(int vertexCount, int edgeCapacity) {
//        super(vertexCount, 2 * edgeCapacity);
//        transposedEdge = new int[2 * edgeCapacity];
//    }
//
//    public static BidirectionalGraph createGraph(int vertexCount, int[] from,
//                                                 int[] to) {
//        BidirectionalGraph graph = new BidirectionalGraph(vertexCount,
//                from.length);
//        for (int i = 0; i < from.length; i++)
//            graph.addSimpleEdge(from[i], to[i]);
//        return graph;
//    }
//
//    public static BidirectionalGraph createWeightedGraph(int vertexCount,
//                                                         int[] from, int[] to, long[] weight) {
//        BidirectionalGraph graph = new BidirectionalGraph(vertexCount,
//                from.length);
//        for (int i = 0; i < from.length; i++)
//            graph.addWeightedEdge(from[i], to[i], weight[i]);
//        return graph;
//    }
//
//    public static BidirectionalGraph createFlowGraph(int vertexCount,
//                                                     int[] from, int[] to, long[] capacity) {
//        BidirectionalGraph graph = new BidirectionalGraph(vertexCount,
//                from.length * 2);
//        for (int i = 0; i < from.length; i++)
//            graph.addFlowEdge(from[i], to[i], capacity[i]);
//        return graph;
//    }
//
//    public static BidirectionalGraph createFlowWeightedGraph(int vertexCount,
//                                                             int[] from, int[] to, long[] weight, long[] capacity) {
//        BidirectionalGraph graph = new BidirectionalGraph(vertexCount,
//                from.length * 2);
//        for (int i = 0; i < from.length; i++)
//            graph.addFlowWeightedEdge(from[i], to[i], weight[i], capacity[i]);
//        return graph;
//    }
//
//    @Override
//    public int addEdge(int fromID, int toID, long weight, long capacity,
//                       int reverseEdge) {
//        int lastEdgeCount = edgeCount;
//        super.addEdge(fromID, toID, weight, capacity, reverseEdge);
//        super.addEdge(toID, fromID, weight, capacity, reverseEdge == -1 ? -1
//                : reverseEdge + 1);
//        this.transposedEdge[lastEdgeCount] = lastEdgeCount + 1;
//        this.transposedEdge[lastEdgeCount + 1] = lastEdgeCount;
//        return lastEdgeCount;
//    }
//
//    @Override
//    protected int entriesPerEdge() {
//        return 2;
//    }
//
//    @Override
//    public final int transposed(int id) {
//        return transposedEdge[id];
//    }
//
//    @Override
//    protected void ensureEdgeCapacity(int size) {
//        if (size > edgeCapacity()) {
//            super.ensureEdgeCapacity(size);
//            transposedEdge = resize(transposedEdge, edgeCapacity());
//        }
//    }
//}
//
//class IOUtils {
//    public static long[] readLongArray(InputReader in, int size) {
//        long[] array = new long[size];
//        for (int i = 0; i < size; i++)
//            array[i] = in.readLong();
//        return array;
//    }
//
//    public static int[] readIntArray(InputReader in, int size) {
//        int[] array = new int[size];
//        for (int i = 0; i < size; i++)
//            array[i] = in.readInt();
//        return array;
//    }
//}
//
//interface Function<A, V> {
//    public abstract V value(A argument);
//}
//
//class IntegerUtils {
//
//    public static List<Pair<Long, Integer>> factorize(long number) {
//        List<Pair<Long, Integer>> result = new ArrayList<Pair<Long, Integer>>();
//        for (long i = 2; i * i <= number; i++) {
//            if (number % i == 0) {
//                int power = 0;
//                do {
//                    power++;
//                    number /= i;
//                } while (number % i == 0);
//                result.add(Pair.makePair(i, power));
//            }
//        }
//        if (number != 1)
//            result.add(Pair.makePair(number, 1));
//        return result;
//    }
//
//    public static List<Long> getDivisors(long number) {
//        List<Pair<Long, Integer>> primeDivisors = factorize(number);
//        return getDivisorsImpl(primeDivisors, 0, 1, new ArrayList<Long>());
//    }
//
//    private static List<Long> getDivisorsImpl(
//            List<Pair<Long, Integer>> primeDivisors, int index, long current,
//            List<Long> result) {
//        if (index == primeDivisors.size()) {
//            result.add(current);
//            return result;
//        }
//        long p = primeDivisors.get(index).first;
//        int power = primeDivisors.get(index).second;
//        for (int i = 0; i <= power; i++) {
//            getDivisorsImpl(primeDivisors, index + 1, current, result);
//            current *= p;
//        }
//        return result;
//    }
//}
//
//class Pair<U, V> implements Comparable<Pair<U, V>> {
//    public final U first;
//    public final V second;
//
//    public static <U, V> Pair<U, V> makePair(U first, V second) {
//        return new Pair<U, V>(first, second);
//    }
//
//    private Pair(U first, V second) {
//        this.first = first;
//        this.second = second;
//    }
//
//    @Override
//    public boolean equals(Object o) {
//        if (this == o)
//            return true;
//        if (o == null || getClass() != o.getClass())
//            return false;
//
//        Pair pair = (Pair) o;
//
//        return !(first != null ? !first.equals(pair.first) : pair.first != null)
//                && !(second != null ? !second.equals(pair.second)
//                : pair.second != null);
//
//    }
//
//    @Override
//    public int hashCode() {
//        int result = first != null ? first.hashCode() : 0;
//        result = 31 * result + (second != null ? second.hashCode() : 0);
//        return result;
//    }
//
//    public Pair<V, U> swap() {
//        return makePair(second, first);
//    }
//
//    @Override
//    public String toString() {
//        return "(" + first + "," + second + ")";
//    }
//
//    @SuppressWarnings({ "unchecked" })
//    public int compareTo(Pair<U, V> o) {
//        int value = ((Comparable<U>) first).compareTo(o.first);
//        if (value != 0)
//            return value;
//        return ((Comparable<V>) second).compareTo(o.second);
//    }
//}
//
//class InputReader {
//    private boolean finished = false;
//
//    private InputStream stream;
//    private byte[] buf = new byte[1024];
//    private int curChar;
//    private int numChars;
//    private SpaceCharFilter filter;
//
//    public InputReader(InputStream stream) {
//        this.stream = stream;
//    }
//
//    public int read() {
//        if (numChars == -1)
//            throw new InputMismatchException();
//        if (curChar >= numChars) {
//            curChar = 0;
//            try {
//                numChars = stream.read(buf);
//            } catch (IOException e) {
//                throw new InputMismatchException();
//            }
//            if (numChars <= 0)
//                return -1;
//        }
//        return buf[curChar++];
//    }
//
//    public int peek() {
//        if (numChars == -1)
//            return -1;
//        if (curChar >= numChars) {
//            curChar = 0;
//            try {
//                numChars = stream.read(buf);
//            } catch (IOException e) {
//                return -1;
//            }
//            if (numChars <= 0)
//                return -1;
//        }
//        return buf[curChar];
//    }
//
//    public int readInt() {
//        int c = read();
//        while (isSpaceChar(c))
//            c = read();
//        int sgn = 1;
//        if (c == '-') {
//            sgn = -1;
//            c = read();
//        }
//        int res = 0;
//        do {
//            if (c < '0' || c > '9')
//                throw new InputMismatchException();
//            res *= 10;
//            res += c - '0';
//            c = read();
//        } while (!isSpaceChar(c));
//        return res * sgn;
//    }
//
//    public long readLong() {
//        int c = read();
//        while (isSpaceChar(c))
//            c = read();
//        int sgn = 1;
//        if (c == '-') {
//            sgn = -1;
//            c = read();
//        }
//        long res = 0;
//        do {
//            if (c < '0' || c > '9')
//                throw new InputMismatchException();
//            res *= 10;
//            res += c - '0';
//            c = read();
//        } while (!isSpaceChar(c));
//        return res * sgn;
//    }
//
//    public String readString() {
//        int c = read();
//        while (isSpaceChar(c))
//            c = read();
//        StringBuilder res = new StringBuilder();
//        do {
//            if (Character.isValidCodePoint(c))
//                res.appendCodePoint(c);
//            c = read();
//        } while (!isSpaceChar(c));
//        return res.toString();
//    }
//
//    public boolean isSpaceChar(int c) {
//        if (filter != null)
//            return filter.isSpaceChar(c);
//        return isWhitespace(c);
//    }
//
//    public static boolean isWhitespace(int c) {
//        return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
//    }
//
//    private String readLine0() {
//        StringBuilder buf = new StringBuilder();
//        int c = read();
//        while (c != '\n' && c != -1) {
//            if (c != '\r')
//                buf.appendCodePoint(c);
//            c = read();
//        }
//        return buf.toString();
//    }
//
//    public String readLine() {
//        String s = readLine0();
//        while (s.trim().length() == 0)
//            s = readLine0();
//        return s;
//    }
//
//    public String readLine(boolean ignoreEmptyLines) {
//        if (ignoreEmptyLines)
//            return readLine();
//        else
//            return readLine0();
//    }
//
//    public BigInteger readBigInteger() {
//        try {
//            return new BigInteger(readString());
//        } catch (NumberFormatException e) {
//            throw new InputMismatchException();
//        }
//    }
//
//    public char readCharacter() {
//        int c = read();
//        while (isSpaceChar(c))
//            c = read();
//        return (char) c;
//    }
//
//    public double readDouble() {
//        int c = read();
//        while (isSpaceChar(c))
//            c = read();
//        int sgn = 1;
//        if (c == '-') {
//            sgn = -1;
//            c = read();
//        }
//        double res = 0;
//        while (!isSpaceChar(c) && c != '.') {
//            if (c == 'e' || c == 'E')
//                return res * Math.pow(10, readInt());
//            if (c < '0' || c > '9')
//                throw new InputMismatchException();
//            res *= 10;
//            res += c - '0';
//            c = read();
//        }
//        if (c == '.') {
//            c = read();
//            double m = 1;
//            while (!isSpaceChar(c)) {
//                if (c == 'e' || c == 'E')
//                    return res * Math.pow(10, readInt());
//                if (c < '0' || c > '9')
//                    throw new InputMismatchException();
//                m /= 10;
//                res += (c - '0') * m;
//                c = read();
//            }
//        }
//        return res * sgn;
//    }
//
//    public boolean isExhausted() {
//        int value;
//        while (isSpaceChar(value = peek()) && value != -1)
//            read();
//        return value == -1;
//    }
//
//    public String next() {
//        return readString();
//    }
//
//    public SpaceCharFilter getFilter() {
//        return filter;
//    }
//
//    public void setFilter(SpaceCharFilter filter) {
//        this.filter = filter;
//    }
//
//    public interface SpaceCharFilter {
//        public boolean isSpaceChar(int ch);
//    }
//}
//
//class OutputWriter {
//    private final PrintWriter writer;
//
//    public OutputWriter(OutputStream outputStream) {
//        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(
//                outputStream)));
//    }
//
//    public OutputWriter(Writer writer) {
//        this.writer = new PrintWriter(writer);
//    }
//
//    public void print(char[] array) {
//        writer.print(array);
//    }
//
//    public void print(Object... objects) {
//        for (int i = 0; i < objects.length; i++) {
//            if (i != 0)
//                writer.print(' ');
//            writer.print(objects[i]);
//        }
//    }
//
//    public void print(int[] array) {
//        for (int i = 0; i < array.length; i++) {
//            if (i != 0)
//                writer.print(' ');
//            writer.print(array[i]);
//        }
//    }
//
//    public void print(long[] array) {
//        for (int i = 0; i < array.length; i++) {
//            if (i != 0)
//                writer.print(' ');
//            writer.print(array[i]);
//        }
//    }
//
//    public void printLine(int[] array) {
//        print(array);
//        writer.println();
//    }
//
//    public void printLine(long[] array) {
//        print(array);
//        writer.println();
//    }
//
//    public void printLine() {
//        writer.println();
//    }
//
//    public void printLine(Object... objects) {
//        print(objects);
//        writer.println();
//    }
//
//    public void print(char i) {
//        writer.print(i);
//    }
//
//    public void printLine(char i) {
//        writer.println(i);
//    }
//
//    public void printLine(char[] array) {
//        writer.println(array);
//    }
//
//    public void printFormat(String format, Object... objects) {
//        writer.printf(format, objects);
//    }
//
//    public void close() {
//        writer.close();
//    }
//
//    public void flush() {
//        writer.flush();
//    }
//
//    public void print(long i) {
//        writer.print(i);
//    }
//
//    public void printLine(long i) {
//        writer.println(i);
//    }
//
//    public void print(int i) {
//        writer.print(i);
//    }
//
//    public void printLine(int i) {
//        writer.println(i);
//    }
//}
//
//class ArrayUtils {
//
//    public static int[] createOrder(int size) {
//        int[] order = new int[size];
//        for (int i = 0; i < size; i++)
//            order[i] = i;
//        return order;
//    }
//
//    public static int maxPosition(int[] array) {
//        return maxPosition(array, 0, array.length);
//    }
//
//    public static int maxPosition(int[] array, int from, int to) {
//        if (from >= to)
//            return -1;
//        int max = array[from];
//        int result = from;
//        for (int i = from + 1; i < to; i++) {
//            if (array[i] > max) {
//                max = array[i];
//                result = i;
//            }
//        }
//        return result;
//    }
//
//}package companywidetests.walmartlabs;

import java.util.Scanner;

/**
 * Created by hadoop on 27/10/17.
 */
public class HikingSelfies {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int x = sc.nextInt();
        long options = ((1<<n)-1);
        System.out.println(Math.abs(x-options));
    }
}
package companywidetests;

/**
 * Created by hadoop on 27/10/17.
 */
public class test {
}
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Created by hadoop on 4/9/17.
 */
public class Traingle {
    static int minvalue = Integer.MAX_VALUE;

    public static void main(String[] args) {

        ArrayList<List<Integer>> list = new ArrayList<List<Integer>>();
        list.add(Arrays.asList(2));
        list.add(Arrays.asList(3,4));
        list.add(Arrays.asList(6,5,7));
        list.add(Arrays.asList(4,1,8,3));

        int ans = maximumsum(list);
    }

    private static int maximumsum(ArrayList<List<Integer>> list) {
        int n = list.size();
        int [][]sum = new int[n][n];
        for(int i=0;i<n;i++) {
            Arrays.fill(sum[i],Integer.MAX_VALUE);
        }
        for(int i=0;i<n;i++){
            sum[n-1][i] = list.get(n-1).get(i);
        }
        for(int i=n-2;i>=0;i--){
            for(int j=0;j<=i;j++){
                sum[i][j] = Math.min(sum[i+1][j],sum[i+1][j+1])+list.get(i).get(j);
            }
        }
        return sum[0][0];
    }

    private static int search(ArrayList<List<Integer>> triangle){
        if(triangle == null || triangle.size() == 0){
            return 0;
        }
        int n = triangle.size();
        int [][]sum = new int[n][n];
        for(int i=0;i<n;i++) {
            Arrays.fill(sum[i],Integer.MAX_VALUE);
        }
        return searchagain(0,0,n,triangle);
    }

    private static int searchagain(int x, int y, int n, ArrayList<List<Integer>> triangle) {
        if(x == n-1){
            return triangle.get(n-1).get(y);
        }
        return Math.min(searchagain(x+1,y,n,triangle),searchagain(x,y+1,n,triangle)) + triangle.get(x).get(y);
    }

}
package zrzahid;

/**
 * Created by hadoop on 9/9/17.
 */
public class FIzbizz {

    public void fizzbuzz(int x){
        for(int i=1;i<=x;i++){
            if(i %3==0 && i%5==0){
                System.out.println("FizzBuzz");
            }
            else if(i %3 ==0){
                System.out.println("Fizz");
            }
            else if( i %5 ==0){
                System.out.println("buzz");
            }
            else
                System.out.println(i);
        }
    }

}
package zrzahid;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

/**
 * Created by hadoop on 10/9/17.
 */
public class ShortestPath {
    private class Node{
        List<Node> next;

    }
    public List<Node> shortestPath(Node a, Node b){
        if(a == null || b == null) return  null;
        Queue<Node> toVisit = new LinkedList<>();
        HashMap<Node,Node> parent = new HashMap<>();

        toVisit.add(a);
        parent.put(a,null);

        while (!toVisit.isEmpty()){
            Node curr = toVisit.remove();
            if(curr == b){
                break;
            }
            for(Node n:curr.next){
                if(!parent.containsKey(n)) {
                    toVisit.add(n);
                    parent.put(n, curr);
                }
            }
        }
        if(parent.get(b) == null) return null;
        List<Node> out = new LinkedList<>();
        Node curr = b;
        while (curr!=null){
            out.add(0,curr);
            curr = parent.get(curr);
        }
        return out;
    }
}
package zrzahid;

public class Solution {
    public void solveSudoku(char[][] board) {
        if(board == null || board.length == 0)
            return;
        solve(board);
    }
    
    public boolean solve(char[][] board){
        for(int i = 0; i < board.length; i++){
            for(int j = 0; j < board[0].length; j++){
                if(board[i][j] == '.'){
                    for(char c = '1'; c <= '9'; c++){//trial. Try 1 through 9
                        if(isValid(board, i, j, c)){
                            board[i][j] = c; //Put c for this cell
                            
                            if(solve(board))
                                return true; //If it's the solution return true
                            else
                                board[i][j] = '.'; //Otherwise go back
                        }
                    }
                    
                    return false;
                }
            }
        }
        return true;
    }
    
    private boolean isValid(char[][] board, int row, int col, char c){
        for(int i = 0; i < 9; i++) {
            if(board[i][col] != '.' && board[i][col] == c) return false; //check row
            if(board[row][i] != '.' && board[row][i] == c) return false; //check column
            if(board[3 * (row / 3) + i / 3][ 3 * (col / 3) + i % 3] != '.' && 
board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c) return false; //check 3*3 block
        }
        return true;
    }
}
/*


const int MAX = 8;

int ithRowQueen[MAX];
bool visited_col[MAX], diag_right[2*MAX+1], diag_left[2*MAX+1];

int sols = 1;

void Queens8(int r) 	// Recursion guarantee no same rows taken
{
	if(r == 8) //So we reach the end
	{
		// Print
		return;
	}

	for(int c=0; c<8; c++)			// j represent the column
	{
		if(!visited_col[c] && !diag_right[c+r] && !diag_left[MAX+c-r]) 	// Guarantee no repeated cols or diagonals
		{
			ithRowQueen[r] = c;

			visited_col[c] = diag_right[c+r] = diag_left[MAX+c-r] = 1;	// Do
			Queens8(r+1);
			visited_col[c] = diag_right[c+r] = diag_left[MAX+c-r] = 0;	//Undo
		}
	}
 */package zrzahid;

import java.util.*;

/**
 * Created by hadoop on 6/9/17.
 */

// when we use BFS, we need something to tell that node has been visited ,
    // once node is visited once , it wud have shortest distance ......
public class IsNavigable {
    public static void main(String[] args) {
        Set<String> dictionary = new HashSet<>();
        dictionary.add("DOG");
        dictionary.add("COT");
        dictionary.add("COG");
        dictionary.add("FOG");
        dictionary.add("DOT");
        String src = "FOG";
        String dest = "COT";
            boolean ans = isNavigable(src,dest,dictionary);
    }

    private static boolean isNavigable(String src, String dest, Set<String> dictionary) {
        if(src.length()!=dest.length()){
            return false;
        }
        if(src.equals(dest)){
            return true;
        }
        dictionary.remove(src);

        final LinkedList<String> queue = new LinkedList<>();
        queue.add(src);

        while (!queue.isEmpty()){
            String intermediate = queue.poll();
            for( int i=0;i<intermediate.length();i++){
                    char []array = intermediate.toCharArray();
                for(char j='A';j<='Z';j++){
                    array[i] =j;
                    String candidate = new String (array);
                    if(candidate.equals(dest)){
                        return true;
                    }
                    else if (dictionary.contains(candidate)){
                        dictionary.remove(candidate);
                        queue.add(candidate);
                    }
                }
            }
        }
        return false;

    }
    public static List<List<String>> wordLadderAll(String src, String dest, Set<String> dictionary){
        if(src == null|| dest == null){
            return Collections.emptyList();
        }//queue datastructure requeired in BFS
        LinkedList<String> queue = new LinkedList<>();
//path from a node to its parent , we often use this technieque
        Map<String,String> parent = new HashMap<>();
        //level of word appeared in the dag // shorteest path
        Map<String,Integer> shortestPath = new HashMap<>();

        Set<String> reachedLeafPath = new HashSet<>();
        List<List<String>> paths = new ArrayList<>();

        int minPath = Integer.MIN_VALUE;
        queue.add(src);
        shortestPath.put(src,0);

        while (!queue.isEmpty()){
            String intermedite = queue.poll();
            // if reached Ans and here ans length more than
            if(shortestPath.get(intermedite)>minPath){
                continue;
            }

            for(int i=0;i<intermedite.length();i++){
                char [] candidate = intermedite.toCharArray();
                for( char j='A';j<='Z';j++){
                    candidate[i] =j;
                    String candidatestring = new String(candidate);

                    if(shortestPath.get(candidatestring) == null){
                        shortestPath.put(candidatestring,shortestPath.get(intermedite)+1);
                    }

                    if(shortestPath.get(intermedite)+1>shortestPath.get(candidatestring)){
                        continue;
                    }

                    if(candidate.equals(src)){
                        reachedLeafPath.add(intermedite);
                        minPath = Math.min(minPath,shortestPath.get(intermedite)+1);
                    }
                    else if(dictionary.contains(candidatestring)){
                        parent.put(candidatestring,intermedite);
                        shortestPath.put(candidatestring,shortestPath.get(intermedite)+1);
                        queue.add(candidatestring);
                    }
                }

            }

        }

    List<List<String>> allpaths = new ArrayList<>();
    for(String set:reachedLeafPath){
            allpaths.add(getPath(parent,set,src,dest));
    }
    return allpaths;

    }
    private static List<String> getPath (Map<String,String> parentMap,String leaf,String src,String dest){
        List<String> path = new LinkedList<>();
        String node = leaf;
        path.add(0,dest);
        path.add(0,leaf);
        while (parentMap.get(node)!=null && parentMap.get(node)!=src){
            node = parentMap.get(node);
            path.add(0,node);
        }
        path.add(0,src);
        return path;
    }

}
package zrzahid;

/**
 * Created by hadoop on 9/9/17.
 */
public class CoinChange {
    public static void main(String[] args) {

    }
    public int change (int x, int []coins){
        if(x ==0 ) return 0;
        int min = Integer.MAX_VALUE;
        for( int i=0;i<coins.length;i++){
            if(x-coins[i]>=0){
                min = Math.min(min,1+change(x-coins[i],coins));
            }
        }
        return min;
    }
}
package zrzahid;

public class IsBstPossibleFromPreorder {
    public static void main(String args[]){
        int[] preorder = {40, 30, 35, 20, 80};//{6,3,0,5,4,8,7,9};//{3,2,5,1,7};
        System.out.println(isBstPossible(preorder, Integer.MIN_VALUE, Integer.MAX_VALUE, 0, preorder.length-1));
    }

    /*
    li is root of current subtree
    ri is the index of the last element in the current subtree
    min, max range for the elements of current subtree
     */
    private static boolean isBstPossible(int[] preorder, int min, int max, int li, int ri){
        if (li==ri && preorder[li]>min && preorder[li]<max){ // if single node subtree...
            return true;
        }
        if (preorder[li]<=min || preorder[li]>=max ){ // if node value out of range
            return false;
        }
        int lsi = preorder[li+1]<preorder[li]?li+1:-1; // left subtree root index (-1 if no left subtree exits for node li)
        int rsi = findNextHigherElementIndex(preorder, li, ri); // right subtree root index (-1 if no right subtree exists for node li)

        boolean isLeftValid = (lsi==-1 || isBstPossible(preorder, min, preorder[li], lsi, rsi-1>lsi?rsi-1:lsi));
        boolean isRightValid =  (rsi==-1 || isBstPossible(preorder, preorder[li], max, rsi, ri));
        return isLeftValid && isRightValid;
    }

    private static int findNextHigherElementIndex(int[] preorder, int li, int ri){
        int x = -1; // -1 if no higher element on right side of li
        for (int i = li+1; i <= ri ; i++) {
            if (preorder[i]>preorder[li]){
                x = i;
                break;
            }
        }
        return x;
    }
}

/*
The first thing we can consider here that for preorder traversal array,
 if at any Point on right side of array we
 find greater element than current element and
 if any element after that is smaller element,
  we should consider that BST is not possible from that very preorder traversal given.

e.g: arr[] = {40,30,35,20,80,100} not possible to build valid BST.

Explanation:

Here when we start building the tree 40 becomes the root of the BST, Now as we proceed
 30 goes in left subtree and now we find next greater of
 30 which is 35, as we know for any lower or smaller element to be in
 the left subtree of 30 should must have been between 30 and its next greater i.e 35 here. So, as we traverse forward we find
 20 which can't fit in left of 30 as it
  is after the next greater element and certainly not as child of 35 as it will violate the BST property (i.e any right subtree element must have greater value always in comparison to root). Thus,valid BST can't be made.

Now, to solve this we can use stack as we use it to
find the next greater element in an array Code for next greater element.
Here we have to just ensure after having the next greater no element comes smaller than that after.

In the code we initially take root as INT_MIN lowest possible value, If the root is anytime lower than current element we return false. While the current element is greater than the element at the top of stack we pop it and set root as the popped element. And we push the current element into the stack for further comparison.

bool check(int *arr, int n)
{
stack<int> s;
int root=INT_MIN;
for(int i=0;i<n;++i)
{
    if(arr[i]<root)
        return false;

    while(!s.empty() && arr[i]>s.top())
    {
        root=s.top();
        s.pop();
    }

    s.push(arr[i]);
}
return true;
}
 */package zrzahid;

import java.util.Arrays;

/**
 * Created by hadoop on 9/9/17.
 */
public class MinHeap {
    private int capacity = 10;
    private int size = 0;
    int [] items = new int[capacity];
    private int getLeftIndex(int i){ return 2*i+1;}
    private int getRightIndex(int i){return 2*i+2;}
    private int getParentIndex(int i){return (i-1)/2;}
    private int getParent(int i){return items[getParentIndex(i)];}
    private int getLeftChild(int i){return items[getLeftIndex(i)];}
    private int getRightChild(int i){return items[getRightIndex(i)];}

    private boolean hasLeftChild(int i){return getLeftIndex(i)<=size-1;}
    private boolean hasRightChild(int i){return getRightIndex(i)<=size-1;}
    private boolean hasParent(int i){return getParentIndex(i)>=0;}


    private int getSize(){return size;}

    private void ensureCapacity(){
        if(size == capacity){
            items = Arrays.copyOf(items,capacity*2);
            capacity = capacity*2;
        }
    }
    public int peek(){
        if(size == 0) return -1;
        return items[0];
    }
    public int  poll(){
        if(size ==0) return -1;
        int value =  items[0];
        items[0] = items[size-1];
        size = size-1;
        heapifyDown();
        return value;
    }

    private void heapifyDown() {
        int index = 0;
        while (hasLeftChild(index)){
            int smallerChildIndex = getLeftIndex(index);
            if(hasRightChild(index) && getRightChild(index)<getLeftChild(index)){
                smallerChildIndex = getRightIndex(index);
            }

            if(items[smallerChildIndex]<items[index]){
                swap(index,smallerChildIndex);
            }
            else {
                break;
            }
            index = smallerChildIndex;
        }

    }
    private void heapifyUp(){
        int index = size-1;
        while (hasParent(index)){
            if(getParent(index)<items[index]){
                break;
            }
            else{
                swap(getParentIndex(index),index);
                index = getParentIndex(index);
            }

        }

    }

    private void swap(int parentIndex, int index) {
        int temp = items[parentIndex];
        items[parentIndex] = items[index];
        items[index] = temp;
    }

    public void add(int val){
        ensureCapacity();
        items[size] = val;
        size++;
        heapifyUp();
    }


}
/**
 * Created with IntelliJ IDEA.
 * User: Gong Li
 * Date: 5/26/13
 * Time: 12:23 PM
 * Implement a priority queue using a heap
 * The heap is implemented using an array indexed from 1
 */
class PriorityQueueUsingHeap<T extends Comparable<T>> {
    T[] arr;
    int N;

    public static void main(String[] args) {
        PriorityQueueUsingHeap<Integer> pq = new PriorityQueueUsingHeap<Integer>();
        pq.insert(3);
        System.out.println(pq.toString());
        pq.insert(5);
        System.out.println(pq.toString());
        pq.insert(2);
        System.out.println(pq.toString());
        pq.insert(-1);
        System.out.println(pq.toString());
        pq.insert(9);
        System.out.println(pq.toString());
        pq.insert(4);
        System.out.println(pq.toString());

        pq.delMax();
        System.out.println(pq.toString());
        pq.delMax();
        System.out.println(pq.toString());
        pq.delMax();
        System.out.println(pq.toString());
        pq.delMax();
        System.out.println(pq.toString());
        pq.delMax();
        System.out.println(pq.toString());
    }

    public PriorityQueueUsingHeap(){
        arr = (T[]) new Comparable[2];
        N = 0;
    }

    public void insert(T t){
        if (N == arr.length - 1) resize(2*N + 1);
        arr[++N] = t;
        swim(N);
    }

    public T delMax(){
        if (isEmpty()) return null;
        T t= arr[1];
        exch(1,N--);
        arr[N+1] = null;
        sink(1);

        //resize this array
        if (N == (arr.length -1)/4) resize((arr.length-1) / 2 + 1);
        return t;
    }
    //helper methods
    public String toString(){
        StringBuffer sb = new StringBuffer();
        for(int i = 1; i <= N; i ++)
            sb.append(arr[i].toString()+" ");
        return sb.toString();
    }

    private boolean isEmpty(){
        return N == 0;
    }
    private void resize(int capacity){
        T[] copy = (T[]) new Comparable[capacity];
        for(int i = 1; i <= N; i ++ )
            copy[i] = arr[i];
        arr = copy;
    }

    private void swim(int k){
        while(k > 1 && less(k/2, k)){
            exch(k/2,k);
            k = k/2;
        }
    }

    private void sink(int k){
        while (2*k < N){
            int j = 2 * k;
            if(j < N && less(j, j +1)) j = j + 1;
            if(less(j, k)) break;
            exch(k,j);
            k = j;
        }
    }

    private boolean less(int i, int j){
        if (arr[i].compareTo(arr[j]) < 0)
            return true;
        return false;
    }

    private void exch(int i, int j){
        T temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}package zrzahid;

/**
 * Created by hadoop on 9/9/17.
 */
public class NthLastLinkedList {
    public static void main(String[] args) {

    }
    private class Node{
       private  int x ;
       private Node next;
    }
    public Node getNodeNth(Node node, int k){
        Node curr = node;
        Node follower = node;
        for( int i=0;i<k;i++){
            if(curr == null) return null;
            curr = curr.next;
        }
        while (curr.next!=null){
            curr = curr.next;
            follower= follower.next;
        }
        return follower;

    }
    public int ones(int x){
        int sum = 0;
        while(x>0){
            sum = sum + x&1;
        }
        return sum;
    }
}
package zrzahid;

/**
 * Created by hadoop on 7/9/17.
 */
public class PermutationRank {
    public static void main(String[] args) {
        char array[]="DCBA".toCharArray();

        int rank = perrank(array);
        System.out.println("ans"+rank);
    }

    private static int perrank(char[] array) {
        int countelementsmaller[] = countsmaller(array);
        int rank=1;
        for(int i=0;i<array.length;i++){
            rank = rank+ countelementsmaller[i]*factorial(array.length-1-i);
        }
        return rank;
    }

    private static int factorial(int i) {
        if(i==0 )return 1;
        return factorial(i-1)*i;
    }


    private static int[] countsmaller(char[] array) {
        int []smaller = new int[array.length];
        for(int i=0;i<array.length;i++){
            int count=0;
            for(int j=i+1;j<array.length;j++){
                if(array[j]<array[i]){
                    count++;
                }
            }
            smaller[i]=count;
        }
        return smaller;
    }

}
package zrzahid;

/**
 * Created by hadoop on 6/9/17.
 */
public class AVLTree {
    public static void main(String[] args) {

    }
    private Node leftRotate(Node root){
        Node newRoot = root.right;
        root.right = newRoot.left;
        newRoot.left = root;
        root.height = setheight(root);
        root.size = setsize(root);
        newRoot.height = setheight(newRoot);
        newRoot.size = setsize(newRoot);
        //root.height = Math.max(height(root.left),height(root.right))+1;
        //root.size = size(root.left)+size(root.right)+1;
        return newRoot;
    }
    private Node rightRotate(Node root){
        Node newRoot = root.left;
        root.left = newRoot.right;
        newRoot.right = root;
        root.height = setheight(root);
        root.size = setsize(root);
        newRoot.height = setheight(newRoot);
        newRoot.size = setsize(newRoot);
        return newRoot;
    }
    private int setheight(Node root){
        if(root == null){
            return 0;
        }
        return 1 + Math.max(root.left!=null?root.left.height:0,root.right!=null?root.right.height:0);

    }
    private int setsize(Node root){
        if(root == null){
            return 0;
        }
        return 1 + (root.left!=null?root.left.size:0)+(root.right!=null?root.right.size:0);
    }
    private int height(Node root){
        return root!=null?root.size:0;
    }

    public  Node insert(Node root,int data){
        if(root == null){
            return new Node(data);
        }
        if(root.data<data){
            root.right = insert(root.right,data);
        }
        else{
            root.left = insert(root.left,data);

        }
        int balance = balance(root.left,root.right);
        if(balance>1){
            if(height(root.left.left)>height(root.left.right)){
                root = rightRotate(root);
            }
            else {
                root.left = leftRotate(root.left);
                root = rightRotate(root);
            }
        }
        else if(balance<-1){
            if(height(root.right.right)>=height(root.right.left)){
                root = leftRotate(root);
            }
            else {
                root.right = rightRotate(root.right);
                root = leftRotate(root);
            }
        }
        else {
            root.height = setheight(root);
            root.size = setsize(root);
        }
        return root;
    }

    private int balance(Node left, Node right) {
        return height(left)-height(right);
    }

    private class Node{
        int data;
        int height;
        int size;
        Node left;
        Node right;
        Node(int data){
            this.data = data;
            this.size = 1;
            this.height = 1;
        }
    }
}
package zrzahid;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;

/**
 * Created by hadoop on 10/9/17.
 */
public class AutoComplete {
    private class Node{
        String prefix;
        HashMap<Character,Node> children;
        boolean isWord;
        private Node(String prefix){
            this.prefix = prefix;
            this.children = new HashMap<>();
        }

    }
    private Node trie;
    public AutoComplete(String [] dict){
        trie = new Node("");
        for(String s :dict){
            insertWord(s);
        }
    }

    private void insertWord(String s) {
        Node curr= trie;
        for(int i=0;i<s.length();i++){
            if(!curr.children.containsKey(s.charAt(i))){
                curr.children.put(s.charAt(i),new Node(s.substring(0,i+1)));
            }
            curr = curr.children.get(s.charAt(i));
            if(i == s.length()-1){
                curr.isWord = true;
            }
        }
    }

    public List<String> getWordsForPrefixString(String pre){
           List<String> results = new LinkedList<>();
           Node curr = trie;
           for(int i=0;i<pre.length();i++){
               if(curr.children.containsKey(pre.charAt(i))){
                   curr= curr.children.get(pre.charAt(i));
               }
               else {
                   return results;
               }
           }
           findAllWords(curr,results);
            return results;
    }

    private void findAllWords(Node curr, List<String> results) {
         if(curr.isWord){
             results.add(curr.prefix);
             return;
         }
         else {
             for(Node child:curr.children.values()){
                 findAllWords(child,results);
             }
         }
    }
    public static void main(String args[]){
        String [] array = new String[6];
        array[0] = "abc";
        array[1] = "acd";
        array[2] = "bcd";
        array[3] = "def";
        array[4] = "a";
        array[5] = "aba";
        AutoComplete autoComplete = new AutoComplete(array);
        System.out.println(autoComplete.getWordsForPrefixString("ab"));
    }

}
package zrzahid;
//
///**
// * Created by hadoop on 6/9/17.
// */
//public class TreeOperations {
//}
//
//
//class TreeNode {
//    int key;
//    int height;
//    int size;
//    TreeNode left;
//    TreeNode right;
//    TreeNode parent;
//
//    TreeNode(int key){
//        this.key = key;
//        this.size = 1;
//        this.height = 1;
//        this.left = null;
//        this.right = null;
//    }
//
//    public int size(TreeNode node){
//        return node == null ?0:node.size;
//    }
//    public int height(TreeNode node){
//        return node == null?0:node.height;
//    }
//    public TreeNode rotateLeft(TreeNode root){
//        TreeNode newroot = root.right;
//        TreeNode leftSubtree  = newroot.left;
//        root.right = leftSubtree;
//        newroot.left = root;
//        root.size
//        return newroot;
//    }
//}
public class TreeOperations {

    public static long find_Ways(int N)
    {

        int [][] array = new int[N+1][3];
        array[1][0]= 1;
        array[1][2]= 1;

        array[2][0] = array[1][2];
        array[2][2] = array[1][0];
        for( int i=3;i<=N;i++){
            array[i][0]= array[i-2][2] +array[i-1][2];
            array[i][2]= array[i-2][0] +array[i-1][0];
        }
        return array[N][0]+array[N][2];
        /* Your class should be named Solution
		 * Don't write main().
		 * Don't read input, it is passed as function argument.
		 * Return output and don't print it.
	 	 * Taking input and printing output is handled automatically.
		 */

    }

    public static void main(String[] args) {
        System.out.println(find_Ways(4));
    }
}package zrzahid;

/**
 * Created by hadoop on 7/9/17.
 */

public class KnightTourAgain
{
    private static final int N = 8;
    private int soln[][];

    public KnightTourAgain()
    {
        soln = new int[N][N];
    }

    private boolean isSafe(int x, int y)
    {
        if (x >= 0 && x < N && y >= 0 && y < N && soln[x][y] == -1)
            return true;
        return false;
    }

    private void printSolution()
    {
        for (int x = 0; x < N; x++)
        {
            for (int y = 0; y < N; y++)
            {
                System.out.print("  " + soln[x][y]);
            }
            System.out.println();
        }
    }

    private boolean solveKTUtil(int x, int y, int movei, int xMove[],int yMove[])
    {
        int k, next_x, next_y;
        if (movei == N * N)
            return true;

        for (k = 0; k < N; k++)
        {

            next_x = x + xMove[k];
            next_y = y + yMove[k];
            if (isSafe(next_x, next_y))
            {
                soln[next_x][next_y] = movei;
                if (solveKTUtil(next_x, next_y, movei + 1, xMove, yMove))
                    return true;
                else
                    soln[next_x][next_y] = -1;
            }
        }
        return false;
    }

    public boolean solveKnightTour()
    {
        for (int x = 0; x < N; x++)
        {
            for (int y = 0; y < N; y++)
            {
                soln[x][y] = -1;
            }
        }
        int xMove[] = { 2, 1, -1, -2, -2, -1, 1, 2 };
        int yMove[] = { 1, 2, 2, 1, -1, -2, -2, -1 };
        soln[0][0] = 0;
        if (!solveKTUtil(0, 0, 1, xMove, yMove))
        {
            System.out.println("the solution does not exist");
            return false;
        }
        else
        {
            printSolution();
        }
        return true;
    }

    public static void main(String... arg)
    {
        KnightTourAgain knightTour = new KnightTourAgain();
        System.out.println("the solution is");
        knightTour.solveKnightTour();
    }
}package zrzahid;

/**
 * Created by hadoop on 7/9/17.
 */
public class TicTacToe {
    private int []rows;
    private int []cols;
    int diagonal;
    int antidiagonal;
    TicTacToe(int n){
        cols = new int[n];
        rows = new int[n];

    }
    public int move(int row,int col,int player){
        int toAdd = player == 1?1:-1;
        rows[row] = toAdd;
        cols[col] = toAdd;
        if(row == col){
            diagonal+=toAdd;
        }
        if(col == cols.length-1-row){
            antidiagonal += toAdd;
        }

        int size = rows.length;
        if(Math.abs(rows[row]) == size|| Math.abs(cols[col]) == size
                || Math.abs(diagonal) ==size
        || Math.abs(antidiagonal)== size){
            return player;
        }
        return 0;
    }
}
//package zrzahid;
//
//import java.util.HashMap;
//import java.util.Map;
//
///**
// * Created by hadoop on 7/9/17.
// */
//public class TopKWords {
//    public static void main(String[] args) {
//
//    }
//    public String[] topKWords(String stream,int k ){
//        final class WordFreq implements Comparable<WordFreq>{
//            String word;
//            int freq;
//            @Override
//            public int compareTo(WordFreq o) {
//                return this.freq-o.freq;
//            }
//        }
//        Map<String,Integer> map = new HashMap<>();
//    }
//}
package zrzahid;

/**
 * Created by hadoop on 9/9/17.
 */
public class Game {
}

/*


#include <iostream>
#include <cmath>
#include <complex>
#include <cassert>
#include <bits/stdc++.h>
        using namespace std;

        #define all(v)        ((v).begin()), ((v).end())
        #define sz(v)       ((int)((v).size()))
        #define clr(v, d)     memset(v, d, sizeof(v))
        #define repi(i, j, n)     for(int i=(j);i<(int)(n);++i)
        #define repd(i, j, n)     for(int i=(j);i>=(int)(n);--i)
        #define repa(v)       repi(i, 0, sz(v)) repi(j, 0, sz(v[i]))
        #define rep(i, v)     repi(i, 0, sz(v))
        #define lp(i, cnt)      repi(i, 0, cnt)
        #define lpi(i, s, cnt)    repi(i, s, cnt)
        #define P(x)        cout<<#x<<" = { "<<x<<" }\n"
        #define pb          push_back
        #define MP          make_pair

        bool isWinning(int pos) {
        if (pos == 0)
        return false;  // can't move = terminal position

        int moves[3] = { 1, 3, 4 };
        // play optimally: try all against his optimality
        for (int i = 0; i < 3; ++i) {
        if (pos >= moves[i] && !isWinning(pos - moves[i]))
        // opponent will lose from this move
        return true;  // ANY lose = I win
        }
        return false;  // ALL moves make opponent win
        }


        int main() {
        #ifndef ONLINE_JUDGE
        freopen("test.txt", "rt", stdin);
        #endif

        return 0;
        }

 */package zrzahid;

import java.util.HashSet;

public class removeDuplicates
{
    static class node
    {
        int val;
        node next;

        public node(int val)
        {
            this.val = val;
        }
    }
    static void myremoval(node n){
            HashSet<Integer> nodes = new HashSet<>();
            node curr = n;

            node prev = null;
            while (curr!=null){
                if(!nodes.contains(curr.val)){
                    if(prev!=null) {
                        prev.next = curr;
                        System.out.println("prev"+prev.val);
                        System.out.println("cu"+curr.val);
                    }
                    prev = curr;
                    nodes.add(curr.val);
                }
                System.out.println("value of "+curr.val);
                curr = curr.next;
//                System.out.println("value of "+curr.val);
            }
            prev.next = null;

    }

    /* Function to remove duplicates from a
       unsorted linked list */
    static void removeDuplicate(node head)
    {
        // Hash to store seen values
        HashSet<Integer> hs = new HashSet<>();

        /* Pick elements one by one */
        node current = head;
        node prev = null;
        while (current != null)
        {
            int curval = current.val;

            // If current value is seen before
            if (hs.contains(curval)) {
                prev.next = current.next;
            } else {
                hs.add(curval);
                prev = current;
            }
            current = current.next;
        }

    }

    /* Function to print nodes in a given linked list */
    static void printList(node head)
    {
        while (head != null)
        {
            System.out.print(head.val + " ");
            head = head.next;
        }
    }

//    curr = 1
//    prev = 2
//        nexnode = 2
//
//    1 2 1 1
    static void removalDulicates(node n) {
        node curr = n;
        while (curr != null) {
            node nextnode = curr.next;
            node prev = curr;
            while (nextnode != null) {
                if (nextnode.val != curr.val) {
                    prev = nextnode;
                    nextnode = nextnode.next;
                } else {
                    prev.next = nextnode.next;
                    nextnode = nextnode.next;
                }
            }
                curr = curr.next;
        }
    }

    public static void main(String[] args)
    {
        /* The constructed linked list is:
         10->12->11->11->12->11->10*/
        node start = new node(10);
        start.next = new node(10);
        start.next.next = new node(13);
        start.next.next.next = new node(14);
        start.next.next.next.next = new node(12);
        start.next.next.next.next.next = new node(11);
        start.next.next.next.next.next.next = new node(14);

        System.out.println("Linked list before removing duplicates :");
        printList(start);

        removalDulicates(start);
        //removeDuplicate(start);

        System.out.println("\nLinked list after removing duplicates :");
        printList(start);
    }
}
package zrzahid;

import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

/**
 * Created by hadoop on 10/9/17.
 */
public class TopSort {
    public List<Integer> buildOrder(int [][]process){
        Set<Integer> tempMarks = new HashSet<Integer>();
        Set<Integer> permMarks = new HashSet<>();
        List<Integer> result = new LinkedList<>();

        for(int i=0;i<process.length;i++){
            if(!permMarks.contains(i)){
                visit(i,process,tempMarks,permMarks,result);
            }
        }
        return result;
    }
    private void visit(int process, int[][] processes, Set<Integer> tempMarks, Set<Integer> permMarks, List<Integer> result) {
            if(tempMarks.contains(process)){
                throw new RuntimeException();
            }
            if(!permMarks.contains(process)) {
                tempMarks.add(process);

                for (int i : processes[process]) {
                    visit(process, processes, tempMarks, permMarks, result);
                }
                permMarks.add(process);
                tempMarks.remove(process);
                result.add(process);
            }


    }
}
package zrzahid;


import java.util.HashSet;
import java.util.LinkedList;
import java.util.Set;

/**
 * Created by hadoop on 6/9/17.
 */
public class MinPath {
    public static void main(String[] args) {
        TreeNode a = null;
        TreeNode b = null;
        int ans = minpath(a,b);
    }
    private class TreeNode{
        int data;
        TreeNode parent;
        TreeNode left;
        TreeNode right;
    }

    public static int minpath(TreeNode a, TreeNode b){
        int height1 = getHeight(a);
        int height2 = getHeight(b);

        if(height1>height2){
            int temp = height1;
            height1 = height2;
            height2 = temp;
            TreeNode tempagain= a;
            a=b;
            b=tempagain;
        }

        LinkedList<Integer> pathDeeper = new LinkedList<>();
        LinkedList<Integer> pathShallower = new LinkedList<>();

        for( int i=0;i<height2-height1;i++){
            pathDeeper.add(b.data);
            b= b.parent;
        }
        while (a!=null && b!=null){

            pathDeeper.add(a.data);
            pathShallower.addFirst(b.data);
            a = a.parent;
            b= b.parent;
            if(a == b){
                Set<Integer> hashset = new HashSet<>();
                hashset.addAll(pathDeeper);
                hashset.addAll(pathShallower);
                return hashset.size();
            }
        }

        return 0;

    }

    public static int getHeight(TreeNode root){
        int height =0;
        while (root!=null){
            height++;
            root = root.parent;
        }
        return height;
    }
}
package zrzahid;

/**
 * Created by hadoop on 6/9/17.
 */
public class Permutation {
    public static void main(String[] args) {
        int nums[]={1,2,3};
        System.out.println(nextpermutation(nums));
        System.out.println("permutt");
        for( int i=0;i<nums.length;i++) {
            System.out.print(nums[i]);
        }


    }
    public static int[] nextpermutation(int []nums){
        int k=-1;
            for( int i=nums.length-2;i>=0;i--){
                if(nums[i]<nums[i+1]){
                    k =i;
                    break;
                }
            }
            if(k ==-1){
                reverse(nums,0,nums.length-1);
                return nums;
            }
            int index= nums.length-1;
            while (nums[index]<=nums[k]){
                index--;
            }
            swap(nums,index,k);
            System.out.println("k"+k);
            reverse(nums,k+1,nums.length-1);
            return nums;
    }

    private static void swap(int[] nums, int index, int k) {
        int temp= nums[index];
        nums[index] = nums[k];
        nums[k] = temp;
    }
    private static void reverse(int nums[],int i,int j){
        System.out.println("i"+i);
        System.out.println("j"+j);
        while (i<j){
            swap(nums,i,j);
            i++;
            j--;
        }
    }

}
package zrzahid;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;

/**
 * Created by hadoop on 4/9/17.
 */
class BfsTemplate {


    public static void main(String[] args) {

    }
    ArrayList<ArrayList<Integer>>levelOrderTraversalTemplate(TreeNode root){
        ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();
        if( root == null){
            return null;
        }
        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        queue.offer(root);
        TreeNode cousin;
        int targetkey = 4;
        int targetValue = -1;
        int levelvalue=0;
        while(!queue.isEmpty()){
            int size = queue.size();
            ArrayList<Integer> level = new ArrayList<Integer>();
            for(int i=0;i<size;i++){
                TreeNode head = queue.poll();
                level.add(head.data);
                if(head.left!=null){
                    queue.add(head.left);
                }
                if(head.right!=null){
                    queue.add(head.right);
                }
                if(head.data == targetkey){
                    targetValue = levelvalue;
                }
                if(levelvalue == targetValue){
                    cousin = head;
                }
            }
            result.add(level);
            levelvalue++;
        }
        return result;
    }
    private class TreeNode{
        int data;
        TreeNode left;
        TreeNode right;

        public TreeNode(int data) {
            this.data = data;
        }
    }
}
package zrzahid;

import java.util.HashSet;

/**
 * Created by hadoop on 10/9/17.
 */
public class Depulicate {
    private class Node{
        int val;
        Node next;
    }

//    1,2,1,4
//1111;
//    nodes {1,2}
//    curr = 4;
//    prev = 2;
//4 5 5 6 {4,5,}
    public void deduplicate(Node n){
        HashSet<Integer> nodes = new HashSet<>();
        Node curr = n;

        Node prev = null;
        while (curr!=null){
            if(!nodes.contains(curr.val)){
                if(prev!=null) {
                    prev.next = curr;
                }
                prev = curr;
                nodes.add(curr.val);
            }
            curr = curr.next;
        }
    }
}
package zrzahid;

import java.util.Comparator;
import java.util.PriorityQueue;

/**
 * Created by hadoop on 10/9/17.
 */
public class MergeKSorted {

    private class QueueNode implements Comparable<QueueNode> {
        int array,index,value;

        public QueueNode(int array, int index, int value) {
            this.array = array;
            this.index = index;
            this.value = value;
        }

        public int compareTo(QueueNode a){
            return value-a.value;
        }
    }

    public int[] merge(int [][] merge){
        PriorityQueue<QueueNode> pq = new PriorityQueue<>();
        int size=0 ;
        for(int i=0;i<merge.length;i++){
            size = size + merge[i].length;
            if(merge[i].length>0) {
                pq.add(new QueueNode(i, 0, merge[i][0]));
            }
        }
        int [] result = new int[size];
        for(int i=0;!pq.isEmpty();i++){
            QueueNode node = pq.poll();
            result[i] = node.value;
            int newindex = node.index+1;
            if(newindex<merge[node.array].length){
                pq.add(new QueueNode(node.array,newindex,merge[node.array][newindex]));
            }
        }
        return result;
    }
}
package zrzahid;

/**
 * Created by hadoop on 7/9/17.
 */
import java.text.DecimalFormat;

public class KnightTour {

    int[][] solution;
    //int path = 0;

    public KnightTour(int N) {
        solution = new int[N][N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                solution[i][j] = -1;
            }
        }
    }

    public void solve() {
        solution[0][0] = 0;
        if (findPath(0, 0, 1, solution.length)) {
            print();
        } else {
            System.out.println("NO PATH FOUND");
        }
    }

    public boolean findPath(int row, int column, int index, int N) {
        // check if current is not used already
        // mark the current cell is as used
        //solution[row][column] = path++;
        // if (index == 50) {
        if (index == N * N ) {
            // if we are here means we have solved the problem
            return true;
        }
        //System.out.println("index"+index);
        for (int k = 0; k < N; k++)
        {

            int next_x = row + xMove[k];
            int next_y = column + yMove[k];
            if (canMove(next_x, next_y,N))
            {
                solution[next_x][next_y] = index;
                if (findPath(next_x, next_y, index + 1,N))
                    return true;
                else
                    solution[next_x][next_y] = -1;
            }
        }
        return false;
        //System.out.println("path previous"+path);
        //if(path>100) System.exit(1);
        // try to solve the rest of the problem recursively

        // go down and right
        //System.out.println("row"+row);
        //System.out.println("column"+column);
//        if (canMove(row + 2, column + 1, N)) {
//            solution[row+2][column+1] = index;
//            boolean result = findPath(row + 2, column + 1, index + 1, N);
//            if(result) return true;
//            //path--;
//            solution[row+2][column+1]=-1;
//        }
//        if (canMove(row + 2, column - 1, N)) {
//            solution[row+2][column-1] = index;
//            boolean result = findPath(row + 2, column - 1, index + 1, N);
//            if(result) return true;
//            //path--;
//            solution[row+2][column-1]=-1;
//        }
//        if (canMove(row - 2, column + 1, N)) {
//            solution[row-2][column+1] = index;
//            boolean result = findPath(row - 2, column + 1, index + 1, N);
//            if(result) return true;
//            //path--;
//            solution[row-2][column+1]=-1;
//        }
//        if (canMove(row - 2, column - 1, N)) {
//            solution[row-2][column-1] = index;
//            boolean result = findPath(row - 2, column - 1, index + 1, N);
//            if(result) return true;
//            //path--;
//            solution[row-2][column-1]=-1;
//        }
//        if (canMove(row + 1, column + 2, N)) {
//            solution[row+1][column+2] = index;
//            boolean result = findPath(row + 1, column + 2, index + 1, N);
//            if(result) return true;
//           // path--;
//            solution[row+1][column+2]=-1;
//        }
//        if (canMove(row + 1, column - 2, N)) {
//            solution[row+1][column-2] = index;
//            boolean result = findPath(row + 1, column -2, index + 1, N);
//            if(result) return true;
//            //path--;
//            solution[row+1][column-2]=-1;
//        }
//        if (canMove(row - 1, column + 2, N)) {
//            solution[row-1][column+2] = index;
//            boolean result = findPath(row - 1, column + 2, index + 1, N);
//            if(result) return true;
//            //path--;
//            solution[row-1][column+2]=-1;
//        }
//        if (canMove(row - 1, column - 2, N)) {
//            solution[row-1][column-2] = index;
//            boolean result = findPath(row - 1, column - 2, index + 1, N);
//            if(result) return true;
//            //path--;
//            solution[row-1][column-2]=-1;
//        }
//        //System.out.println("path"+path);
//       // System.out.println("not found path for "+row);
//        //System.out.println("column"+column);
//        // go right and down
////        if (canMove(row + 1, column + 2, N)
////                && findPath(row + 1, column + 2, index + 1, N)) {
////            return true;
////        }
////        // go right and up
////        if (canMove(row - 1, column + 2, N)
////                && findPath(row - 1, column + 2, index + 1, N)) {
////            return true;
////        }
////        // go up and right
////        if (canMove(row - 2, column + 1, N)
////                && findPath(row - 2, column + 1, index + 1, N)) {
////            return true;
////        }
////        // go up and left
////        if (canMove(row - 2, column - 1, N)
////                && findPath(row - 2, column - 1, index + 1, N)) {
////            return true;
////        }
////        // go left and up
////        if (canMove(row - 1, column - 2, N)
////                && findPath(row - 1, column - 2, index + 1, N)) {
////            return true;
////        }
////        // go left and down
////        if (canMove(row + 1, column - 2, N)
////                && findPath(row + 1, column - 2, index + 1, N)) {
////            return true;
////        }
////        // go down and left
////        if (canMove(row + 2, column - 1, N)
////                && findPath(row + 2, column - 1, index + 1, N)) {
////            return true;
////        }
//        // if we are here means nothing has worked , backtrack
//        //solution[row][column] = 0;
//        //path--;
//        return false;

    }

    public boolean canMove(int row, int col, int N) {
        if (row >= 0 && col >= 0 && row < N && col < N && solution[row][col] == -1) {
            return true;
        }
        return false;
    }

    public void print() {
        DecimalFormat twodigits = new DecimalFormat("00");
        for (int i = 0; i < solution.length; i++) {
            for (int j = 0; j < solution.length; j++) {
                System.out.print("   " + twodigits.format(solution[i][j]));
            }
            System.out.println();
        }
    }

    public static void main(String[] args) {
        int N = 8;
        KnightTour i = new KnightTour(N);
        i.solve();
    }
    int xMove[] = { 2, 1, -1, -2, -2, -1, 1, 2 };
    int yMove[] = { 1, 2, 2, 1, -1, -2, -2, -1 };

}package zrzahid;

import java.util.Stack;

/**
 * Created by hadoop on 10/9/17.
 */
public class LCA {
    private class Node{
        int val;
        Node left;
        Node right;
    }
    public Node lca(Node tree, Node n1, Node n2) {
        if (n1.equals(n2)) return n1;

        Stack<Node> pathToN1 = pathTo(tree, n1);
        Stack<Node> pathToN2 = pathTo(tree, n2);
        if (pathToN1 == null || pathToN2 == null) return null;

        Node prev = null;
        while (!pathToN1.isEmpty() && !pathToN2.isEmpty()) {
            Node s = pathToN1.pop();
            Node t = pathToN2.pop();
            if (s.equals(t)) prev = s;
            else break;
        }

        return prev;
    }

    public Stack<Node> pathTo(Node tree, Node n) {
        if (tree == null) return null;
        if (tree.equals(n)) {
            Stack<Node> s = new Stack<Node>();
            s.push(tree);
            return s;
        }

        Stack<Node> left = pathTo(tree.left, n);
        Stack<Node> right = pathTo(tree.right, n);

        if (left != null) {
            left.push(tree);
            return left;
        }

        if (right != null) {
            right.push(tree);
            return right;
        }

        return null;
    }
}
import java.io.*;
import java.util.*;


public class TestClass {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter wr = new PrintWriter(System.out);
        int T = Integer.parseInt(br.readLine().trim());
        for(int t_i=0; t_i<T; t_i++)
        {
            String s = br.readLine();
            String out_ = solve(s);
           // System.out.println(out_);
            wr.append(out_);
            wr.flush();
         }
         wr.close();
         br.close();
    }
    static String solve(String toBepalinString){
        int count [] = new int[256];
        for(char x:toBepalinString.toCharArray()){
            count[x-'a']++;
        }
        String returnedAns = new String();
        List<Character> charOddCount = new ArrayList<>();

        for(int i=0;i<256;i++){
            if (count[i]%2 == 1){
                charOddCount.add((char)(i+'a'));
                count[i]--;
                i--;
            }
            else if(count[i] !=0 && count[i]%2 ==0) {
                while (count[i]>0){
                    returnedAns = returnedAns+(char)(i+'a');
                    count[i] = count[i]-2;
                }
            }
        }
        StringBuilder sb =  new StringBuilder(returnedAns);
        if(charOddCount.size()>0) {
            returnedAns = sb.toString() + charOddCount.get(0) + sb.reverse().toString();
        }
        else {
            returnedAns = sb.toString() + sb.reverse().toString();
        }
       // System.out.println(returnedAns);
        return returnedAns;
        // Write your code here
    
    }
}///**
// * Created by hadoop on 18/9/17.
// */
//public class CountSort {
//    void sort(int )
//}
/**
 * Created by hadoop on 3/9/17.
 */
public class MaximumSumPath {
    public static void main(String[] args) {

    }

    ResultType MaxPathSum(TreeNode root){
        if(root == null){
            return new ResultType(0,Integer.MIN_VALUE);
        }
        ResultType left = MaxPathSum(root.left);
        ResultType right = MaxPathSum(root.right);

        int singlePath= Math.max(left.singlePath,right.singlePath)+root.data;
        if(singlePath<0){
            singlePath = 0;
        }
        int maxpath = Math.max(left.maxPath,right.maxPath);
        maxpath = Math.max(maxpath,left.singlePath+right.singlePath+root.data);
        return new ResultType(singlePath,maxpath);
    }

    private class TreeNode{
        int data;
        TreeNode left;
        TreeNode right;
    }
    private class ResultType{
        int singlePath;
        int maxPath;

        public ResultType(int singlePath, int maxPath) {
            this.singlePath = singlePath;
            this.maxPath = maxPath;
        }
    }
}
/**
 * Created by hadoop on 10/10/17.
 */
import java.io.*;
import java.io.PrintWriter;
import java.io.Writer;
import java.util.*;
public class Test {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        InputReader inputReader = new InputReader(System.in);
        in.readInt();
        in.readWord();
        OutputWriter outputWriter = new OutputWriter(System.out);
        String line = in.nextLine();
        out.print(line);
    }
    static class OutputWriter {
        private PrintWriter writer;

        public OutputWriter(Writer writer) {
            this.writer = new PrintWriter(writer);
        }

        public OutputWriter(OutputStream stream) {
            this(new OutputStreamWriter(stream));
        }

        public void print(Object... args) {
            for (Object arg : args) {
                writer.print(arg);
            }
            writer.flush();
        }

        public void printLine(Object... args) {
            print(args);
            writer.println();
        }

        void close() {
            writer.close();
        }

    }

    static class InputReader {
        private BufferedReader reader;
        private StringTokenizer tokenizer;

        public InputReader(Reader reader) {
            this.reader = new BufferedReader(reader);
        }

        public InputReader(InputStream stream) {
            this(new InputStreamReader(stream));
        }

        public String nextLine() {
            try {
                return reader.readLine();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }

        public String readWord() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                tokenizer = new StringTokenizer(nextLine());
            }
            return tokenizer.nextToken();
        }

        public int readInt() {
            return Integer.parseInt(readWord());
        }
    }
}
package SoundarCourse;

import java.util.Arrays;

public class LRS {

    // return the longest common prefix of s and t
    public static String lcp(String s, String t) {
        int n = Math.min(s.length(), t.length());
        for (int i = 0; i < n; i++) {
            if (s.charAt(i) != t.charAt(i))
                return s.substring(0, i);
        }
        return s.substring(0, n);
    }


    // return the longest repeated string in s
    public static String lrs(String s) {

        // form the N suffixes
        int N  = s.length();
        String[] suffixes = new String[N];
        for (int i = 0; i < N; i++) {
            suffixes[i] = s.substring(i, N);
        }
        int lcp[] = new int[N];
        // sort them
        Arrays.sort(suffixes);

        // find longest repeated substring by comparing adjacent sorted suffixes
        String lrs = "";
        int index = 0;
        lcp[index++] = 0;
        for (int i = 0; i < N - 1; i++) {
            String x = lcp(suffixes[i], suffixes[i+1]);
            if (x.length() > lrs.length())
                lrs = x;
        }
        return lrs;
    }



    // read in text, replacing all consecutive whitespace with a single space
    // then compute longest repeated substring
    public static void main(String[] args) {
        String s = "banana";
        s = s.replaceAll("\\s+", " ");
//        StdOut.println("'" + lrs(s) + "'");
    }
}package SoundarCourse;

import java.util.Arrays;

/**
 * Created by hadoop on 16/10/17.
 */

public class Asthon {

    public static String lcp(String s, String t) {
        int n = Math.min(s.length(), t.length());
        for (int i = 0; i < n; i++) {
            if (s.charAt(i) != t.charAt(i))
                return s.substring(0, i);
        }
        return s.substring(0, n);
    }


    public static char lrs(String s) {

        int N  = s.length();
        String[] suffixes = new String[N];
        for (int i = 0; i < N; i++) {
            suffixes[i] = s.substring(i, N);
        }
        String lcp[] = new String[N];
        Arrays.sort(suffixes);

        String lrs = "";
        int index = 0;
        lcp[index++] = "";
        for (int i = 0; i < N - 1; i++) {
            lcp[index++] = lcp(suffixes[i], suffixes[i+1]);
        }
        System.out.println(index);
        int numberofstrings = 0;

        for(int i=0;i<N;i++){

            int diffferentsubstrings =  (suffixes[i].length() *(suffixes[i].length()+1))/2;
            int commonsubstrings = (lcp[i].length()*(lcp[i].length()+1))/2;
            diffferentsubstrings = diffferentsubstrings-commonsubstrings;
            numberofstrings = numberofstrings + diffferentsubstrings;
            if(numberofstrings < 2){
                continue;
            }
            System.out.println("diffferentsubstrings"+diffferentsubstrings);
            numberofstrings = numberofstrings-diffferentsubstrings;
            System.out.println(numberofstrings);
            for(int p=lcp[i].length();p<suffixes[i].length();p++){
                    numberofstrings = numberofstrings+(p+1);
                if(numberofstrings>=2){
                    System.out.println("final"+numberofstrings);
                    System.out.println(suffixes[i]);
                    System.out.println(suffixes[i].charAt((numberofstrings-2)));
                    return suffixes[i].charAt((numberofstrings-2));
                }
            }
        }
        return ' ';
    }


    public static void main(String[] args) {
        String s = "dbac";
        s = s.replaceAll("\\s+", " ");
        lrs(s);
    }
}package SoundarCourse;

import java.util.Scanner;

/**
 * Created by hadoop on 16/10/17.
 */
public class HackerRank {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int nostars = sc.nextInt();
        int views = sc.nextInt();
        int maxBrightness = sc.nextInt();
        Point [] stars= new Point[nostars];
        for(int i=0;i<nostars;i++){
            int x= sc.nextInt();
            int y = sc.nextInt();
            int bright = sc.nextInt();
            stars[i] = new Point(x,y,bright);
        }
        for(int i=0;i<views;i++){

            int ans = 0;
            int time = sc.nextInt();
            int x1 = sc.nextInt();
            int y1 = sc.nextInt();
            int x2 = sc.nextInt();
            int y2 = sc.nextInt();
            Rectangle rectangle = new Rectangle(x1,y1,Math.abs(x2-x1),Math.abs(y2-y1));
            for(int st=0;st<nostars;st++){
                if(rectangle.contains(stars[st].x,stars[st].y)){
                    ans = ans+(stars[st].bright+time)%(maxBrightness+1);
                }
            }
            System.out.println(ans);
        }
    }


    private static class Point{
        int x;
        int y;
        int bright;

        public Point(int x, int y, int bright) {
            this.x = x;
            this.y = y;
            this.bright = bright;
        }
    }
    private static class Rectangle {
        int x;
        int y;
        int width;
        int height;

        public Rectangle(int x, int y, int width, int height) {
            if(width < 0 || height < 0)
                throw new IllegalArgumentException();

            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
        }

        public int getHeight() {
            return height;
        }

        public int getWidth() {
            return width;
        }

        public int getX() {
            return x;
        }

        public int getY() {
            return y;
        }

        public String toString() {
            return "Rectangle[x=" + x + ",y=" + y + ",width=" + width + ",height="
                    + height + "]";
        }
        public boolean contains(int x, int y) {
            return this.x <= x && x <= this.x + width && this.y <= y &&
                    y <= this.y + height;
        }
    }

}
package SystemDesignCodes;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * Created by hadoop on 7/10/17.
 */
public class MiniTwitter {
    public static int  friendshipId;
    public class Tweet{
        public int id;
        public int user_id;
        public String text;
        Tweet(int user_id,String text){
            this.user_id = user_id;
            this.text = text;
        }
    }
    public class FriendShip{
        public int id;
        public int from_user_id;
        public int to_user_id;
        public FriendShip(int id,int from_user_id,int to_user_id){
            this.id = id;
            this.from_user_id = from_user_id;
            this.to_user_id = to_user_id;
        }
    }
    public class  User{
        public  int id;
        public User(int id){
            this.id = id;
        }
    }
    // Tablessss in any database
    ArrayList<User> userTable;
    ArrayList<FriendShip> friendShipTable;
    ArrayList<Tweet> tweetTable;

    public MiniTwitter(){
        userTable = new ArrayList<>();
        friendShipTable = new ArrayList<>();
        tweetTable = new ArrayList<>();
    }

    public List<Tweet> getNewsFeed(int user_id) {
        //1 find all followings
        Set<Integer> followings = new HashSet<>();
        for (FriendShip friendShip : friendShipTable) {
            if (friendShip.from_user_id == user_id) {
                followings.add(friendShip.to_user_id);
            }
        }
        //go through tweet table
        List<Tweet> ret = new ArrayList<>();
        for (Tweet tweet : tweetTable) {
            if (followings.contains(tweet.user_id)) {
                ret.add(tweet);
                if (ret.size() == 10) {
                    return ret;
                }
            }
        }
        return ret;
    }

        public List<Tweet> getTimeLine(int user_id) {

            List<Tweet> ret = new ArrayList<>();
            for (Tweet t : tweetTable) {
                if (t.user_id == user_id) {
                    ret.add(t);
                    if (ret.size() == 10) {
                        return ret;
                    }
                }
            }
            return ret;
        }

        public void follow(int from_user_id,int to_user_id){
        friendShipTable.add(new FriendShip(friendshipId++,from_user_id,to_user_id));
        }

}
package SystemDesignCodes;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Random;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * Implement following interface so that multi-put is atomic.
 * Expect multiple producers and consumers inserting to and extracting from this queue implementation.
 *
 * @author Baofeng Xue at 2016/3/22 21:39.
 *         <p>
 *         threadSafe bounded blocking queue implementation. Expected to be used in a
 *         Producer->Consumer pattern
 */
public interface MultiPutBlockingBoundedQueue<E> {

    /**
     * Sets the capacity of the buffer. Can be called only once. If called more
     * than once or if the passed capacity is <= 0, throw an exception.
     */
    public void init(int capacity) throws Exception;

    /**
     * Get the next item from the queue throws Exception if not initialized
     */
    public E get() throws Exception;

    /**
     * Put the item to the tail of the queue. throws Exception if not
     * initialized
     */
    public void put(E obj) throws Exception;

    /**
     * Put the list of items in an atomic manner. The list can be more than the
     * capacity throws Exception if not initialized
     */
    public void multiput(List<E> objs) throws Exception;

}

class Impl<E> implements MultiPutBlockingBoundedQueue<E> {
    boolean inited;

    List<E> queue;
    Lock lock;
    Condition canPut;
    Condition canGet;
    private int capacity;

    public static void main(String[] args) throws Exception {
        Impl<Integer> impl = new Impl<>();
        impl.init(10);
        Random random = new Random();

        ExecutorService putService = Executors.newFixedThreadPool(10);
        int i = 0;


        while (i < 100) {
            final int finalI = i;
            putService.submit(() -> {
                try {
                    if (finalI % 20 == 0) {
                        ArrayList<Integer> objs = new ArrayList<>();
                        objs.add(random.nextInt());
                        objs.add(random.nextInt());
                        impl.multiput(objs);
                    }

                    impl.get();
                    impl.put(random.nextInt());

                } catch (Exception e) {
                    e.printStackTrace();
                }
            });

            i++;
        }

        putService.shutdown();
        putService.awaitTermination(1, TimeUnit.MINUTES);
    }

    @Override
    public void init(int capacity) throws Exception {
        if (inited || capacity <= 0) throw new RuntimeException();
        lock = new ReentrantLock();
        canPut = lock.newCondition();
        canGet = lock.newCondition();
        queue = new LinkedList<>();
        this.capacity = capacity;
        inited = true;
    }

    @Override
    public E get() throws Exception {
        if (queue == null) throw new RuntimeException();
        lock.lock();
        while (queue.size() == 0) {
            canGet.await();
        }
        E top = queue.get(0);
        queue.remove(0);
        System.out.println("get:" + top + " size:" + queue.size());
        canPut.signal();
        lock.unlock();
        return top;
    }

    @Override
    public void put(E obj) throws Exception {
        if (queue == null) throw new RuntimeException();
        lock.lock();
        while (queue.size() == capacity) {
            canPut.await();
        }
        queue.add(obj);
        System.out.println("put:" + obj + " size:" + queue.size());
        canGet.signal();
        lock.unlock();
    }

    @Override
    public void multiput(List<E> objs) throws Exception {
        if (queue == null) throw new RuntimeException();
        for (E obj : objs) {
            put(obj);
        }
    }
}package SystemDesignCodes;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Created by hadoop on 7/10/17.
 */
public class InvertedIndex {
    class Document {
        public int id;
        public String content;
    }
    Map<String,List<Integer>> getInvertedIndex(List<Document> docs){
        Map<String,List<Integer>> invertedIndex = new HashMap<>();
        if(docs == null){
            return invertedIndex;
        }
        for(Document d :docs){
            String [] words = d.content.split(" ");
            for(String word:words){
                if(isStopWords(word) || word.length() ==0){
                    continue;
                }
                if(!invertedIndex.containsKey(word)){
                    List<Integer> list = new ArrayList<>();
                    invertedIndex.put(word,list);
                }
                invertedIndex.get(word).add(d.id);
            }
        }
        return invertedIndex;
    }

    private boolean isStopWords(String word) {
        if(word.equals("the")){
            return true;
        }
        return false;
    }
}package SystemDesignCodes;

import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

/**
 * Created by hadoop on 8/10/17.
 */
public class SchedularTokenBucket {
    private Semaphore semaphore;
    private int maxPermits;
    private TimeUnit timeUnit;
    private ScheduledExecutorService service;

    public static SchedularTokenBucket create(int permits,TimeUnit timeUnit){
        SchedularTokenBucket schedularTokenBucket = new SchedularTokenBucket(permits,timeUnit);
        schedularTokenBucket.scheduleReplnishment();
        return schedularTokenBucket;
    }

    public SchedularTokenBucket(int maxPermits, TimeUnit timeUnit) {
        this.maxPermits = maxPermits;
        this.timeUnit = timeUnit;
    }
    public boolean aquire(int times) throws Exception{
        if(semaphore.tryAcquire((times))){
            return true;
        }
        return false;

    }

    private void scheduleReplnishment(){
        service = Executors.newScheduledThreadPool(1);
        service.schedule(new Runnable() {
            @Override
            public void run() {
              semaphore.release(maxPermits-semaphore.availablePermits());
            }},1,timeUnit);
    }
}
package SystemDesignCodes;

import java.util.concurrent.*;

/**
 * Created by hadoop on 8/10/17.
 */
public class AlarmClock {
    long initialDelay;
    long delayBetweenRuns;
    long shutDownAfter;
    private ScheduledExecutorService fschedular;
    public static void main(String[] args) {
        AlarmClock clock = new AlarmClock(3,1,20);
        clock.activateAlarmAndThenStop();
    }

    public AlarmClock(long initialDelay, long delayBetweenRuns, long shutDownAfter) {
        this.initialDelay = initialDelay;
        this.delayBetweenRuns = delayBetweenRuns;
        this.shutDownAfter = shutDownAfter;
        fschedular = Executors.newScheduledThreadPool(1);
    }

    public void activateAlarmAndThenStop(){
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
            log("try");
            }
        };
        Runnable stop = new Runnable() {
            @Override
            public void run() {

                fschedular.shutdown();
            }
        };
       ScheduledFuture future =  fschedular.scheduleWithFixedDelay(runnable,initialDelay,delayBetweenRuns, TimeUnit.SECONDS);
       Future objet = fschedular.schedule(stop,shutDownAfter,TimeUnit.SECONDS);
        System.out.println(future.isCancelled());
        System.out.println(objet.isCancelled());
        try {
            System.out.println("blocjed");
            objet.get();
            System.out.println("blocking cal");
            System.out.println(objet.isDone());
            System.out.println(future.isDone());

        }
        catch(Exception e){

        }
    }
    private static void log(String aMsg){
        System.out.println(aMsg);
    }
}
package SystemDesignCodes;

import java.util.Map;
import java.util.TreeMap;
import java.util.SortedMap;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.math.BigInteger;
import java.io.UnsupportedEncodingException;

public class ConsistentHash {
    private static int MAX_REPLICA = 100;
    private SortedMap<BigInteger, String> entries = new TreeMap<>();

    public void put(String node) throws NoSuchAlgorithmException,
                                           UnsupportedEncodingException{
        BigInteger key = hash(node);
        entries.put(key, node);

        for (int i = 0 ; i < MAX_REPLICA ; i++ ) {
            key = hash(node + ":" + i);
            entries.put(key, node);
        }
    }

    private String get(String entry) throws NoSuchAlgorithmException,
                                            UnsupportedEncodingException{
        assert !entries.isEmpty() : "Handle this case properly";

        BigInteger key = hash(entry);

        if (!entries.containsKey(key)) {
            SortedMap<BigInteger, String> tailMap = entries.tailMap(key);
            key = tailMap.isEmpty() ? entries.firstKey() : tailMap.firstKey();
        }

        return entries.get(key);
    }

    private BigInteger hash(String node) throws NoSuchAlgorithmException,
                                                UnsupportedEncodingException {
        MessageDigest md5 = MessageDigest.getInstance("MD5");
        byte[] checksum = md5.digest(node.getBytes("UTF-8"));
        return new BigInteger(1, checksum);
    }

    public static void main(String[] args) throws Exception {
        ConsistentHash s = new ConsistentHash();

        for (char c = 'A' ; c <= 'Z' ; c++) {
            s.put(String.valueOf(c));
        }

        for (int i = 0 ; i < 10 ; i++) {
            System.out.println(s.get("user-id-" + i + "-data"));
        }
        System.out.println("again");
        for (int i = 0 ; i < 10 ; i++) {
            System.out.println(s.get("user-id-" + i + "-data"));
        }
    }
}package SystemDesignCodes;

import java.util.*;

/**
 * Created by hadoop on 7/10/17.
 */
public class Typeahead {
    Set<String> dict ;
    private class TreeNode{
        Set<String> tops;
        Map<Character,TreeNode> neighbors;
        TreeNode(){
            tops = new HashSet<>();
            neighbors = new HashMap<>();
        }
    }
    Typeahead(Set<String> dict){
        this.dict = dict;
    }
    TreeNode root;
    List<String> search(String str){
        TreeNode current = root;
        for(char c:str.toCharArray()){
            current = current.neighbors.get(c);
            if(current == null){
                return new ArrayList<>();
            }
        }
        return new ArrayList<>(current.tops);
    }

    TreeNode buildTreeFromDict(Set<String> dict){
        TreeNode current = new TreeNode();
        for(String word :dict){
            for(int i=0;i<word.length();i++) {
                String subWord = word.substring(i);
                for (char c : subWord.toCharArray()) {
                    if (!current.neighbors.containsKey(c)) {
                        TreeNode node = new TreeNode();
                        current.neighbors.put(c, node);
                    }
                    current.tops.add(subWord);
                    current = current.neighbors.get(c);
                }
            }
        }
        return current;
    }

}
package SystemDesignCodes;

import java.util.HashMap;
import java.util.Map;
import java.util.TreeSet;

/**
 * Created by hadoop on 7/10/17.
 */
public class LfuCache {
    int time = 0;
    int capacity;
    LfuCache(int capacity){
        this.capacity = capacity;
    }
    private class Cache implements Comparable<Cache>{
        int key;
        int value;
        int time;
        int freq;

        public Cache(int key, int value, int time, int freq) {
            this.key = key;
            this.value = value;
            this.time = time;
            this.freq = freq;
        }

        public Cache() {
            super();
        }

        @Override
        public int compareTo(Cache o) {
            if(freq == o.freq){
                return time-o.time;
            }
            return freq-o.freq;
        }

        @Override
        public int hashCode() {
            return super.hashCode();
        }

        @Override
        public boolean equals(Object obj) {
            return key == ((Cache)obj).key;
        }
    }
    Map<Integer,Cache> caches = new HashMap<>();
    TreeSet<Cache> set = new TreeSet<>();
    public int get(int key){
        if(!caches.containsKey(key))
            return Integer.MAX_VALUE;
        time++;
        int value = caches.get(key).value;
        update(key,value);
        return value;
    }

    private void update(int key, int value) {
        // updaet tree set jismein ordering ho raha hai ...
        // update hashmap cache as well
        Cache oldcache = caches.get(key);
        Cache newCache = new Cache(key,value,oldcache.freq+1,time);
        caches.remove(key);
        caches.put(key,newCache);
        set.remove(oldcache); // Use Equal's method to remove entries
        set.add(newCache);
    }
    public void put(int key,int value){
        if(caches.containsKey(key)){
            Cache cache = caches.get(key);
            cache.value = value;
            update(key,value);
        }
        else {
            if(caches.size() > capacity){
               Cache cache =  set.pollFirst();
               caches.remove(cache.key);
            }
            Cache cache = new Cache(key,value,1,time);
            caches.put(key,cache);
            set.add(cache);
        }
    }
}
package SystemDesignCodes;


import java.util.*;

/**
 * Created by hadoop on 7/10/17.
 */
public class MiniCasandra {
    HashMap<String,TreeMap<Integer,String>> store;
    public  MiniCasandra(){
        store = new HashMap<>();
    }

    public void insert(String raw_key,int column_key,String column_value){
        TreeMap<Integer,String> data;
        if(store.containsKey(raw_key)){
            data = store.get(raw_key);
        }
        else {
            data = new TreeMap<>();
        }
        data.put(column_key,column_value);
        store.put(raw_key,data);
    }

    List<Column> query(String raw_key, int column_start, int column_end){
        List<Column> list = new ArrayList<>();
        TreeMap map = store.get(raw_key);
        if(map == null){
            return null;
        }
        NavigableMap<Integer,String> submap = map.subMap(column_start,true,column_end,true);
        for(Map.Entry<Integer,String> entry:submap.entrySet()){
            list.add(new Column(entry.getKey(),entry.getValue()));
        }
        return list;
    }
    private class Column{
        int key;
        String value;
        Column(Integer key,String value){
            this.key = key;
            this.value = value;
        }
    }
}
package SystemDesignCodes;


import java.util.LinkedList;

/**
 * Created_By: stefanie
 * Date: 14-10-23
 * Time: 7:11
 */
import java.util.*;
public class DZ10_BlockingQueue_Synchronized<T>  {
    Boolean pushFlag = true;
    Boolean popFlag = true;
    Integer N;
    Queue<T> queue = new LinkedList<>();
    public DZ10_BlockingQueue_Synchronized(int n) {
        N = n;
    }

    public void push(T item) {
        try {
            synchronized (pushFlag) {
                while(queue.size() >= N){
                    System.out.println("Queue is full");
                    pushFlag.wait();
                }
                queue.add(item);
                popFlag.notifyAll();
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public T pop() {
        try {
            synchronized (popFlag){
                while(queue.size() <= 0) {
                    System.out.println("Queue is empty");
                    popFlag.wait();
                }
                pushFlag.notifyAll();
                return queue.poll();
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
            return null;
        }
    }
    public int size(){
        return queue.size();
    }
}
package SystemDesignCodes;

/**
 * Created_By: stefanie
 * Date: 15-1-20
 * Time: 3:10
 */
public class TQ44_CyclicBuffer<T> {
    T[] buffer;
    int size;
    int begin;
    int end;

    public TQ44_CyclicBuffer(int capacity){
        buffer = (T[]) new Object[capacity];
        begin = 0;
        end = 0;
        size = 0;
    }

    private int next(int index){
        return (index + 1) % buffer.length;
    }

    public void push(T element){
        if(size >= buffer.length) throw new RuntimeException("Buffer is Full");
        buffer[end] = element;
        end = next(end);
        size++;
    }

    public T poll(){
        if(size == 0) throw  new RuntimeException("Buffer is Empty");
        T element = buffer[begin];
        begin = next(begin);
        size--;
        return element;
    }

    public static void main(String[] args){
        TQ44_CyclicBuffer<Integer> buffer = new TQ44_CyclicBuffer(3);
        buffer.push(1);
        buffer.push(2);
        buffer.push(3);
        try{
            buffer.push(4);
        } catch (RuntimeException e){
            System.out.println(e.getMessage());  //Buffer is Full
        }
        System.out.println(buffer.poll());    //1
        buffer.push(4);
        System.out.println(buffer.poll());    //2
        System.out.println(buffer.poll());    //3
        System.out.println(buffer.poll());    //4
        try{
            buffer.poll();
        } catch (RuntimeException e){
            System.out.println(e.getMessage()); //Buffer is Empty
        }
    }
}
package SystemDesignCodes;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Created by hadoop on 7/10/17.
 */
public class HeartBeat {
    Map<String,Integer> slaves;
    int interval;
    HeartBeat(){
        slaves = new HashMap<>();
    }

    public void init(List<String> slaveiplist,int interval){
        if(slaveiplist == null){
            return;
        }
        for(String ip:slaveiplist){
            slaves.put(ip,0); // timestamp
        }
        this.interval = interval; // after which ping happens
    }
    public void ping(int timestamp,String slave_ip){
        slaves.put(slave_ip,timestamp);
    }
    public List<String> getDiedSlaves(int timestamp){
        List<String> ret = new ArrayList<>();
        for(Map.Entry<String,Integer> entry:slaves.entrySet()){
            if(entry.getValue()+ 2*interval >timestamp){
                ret.add(entry.getKey());
            }
        }
        return ret;
    }
}
package SystemDesignCodes;

/**
 * Created by hadoop on 8/10/17.
 */
class HashMapCustom<K,V> {
    private Entry<K,V> [] table;
    int capacity = 4;
    private static class Entry<K,V>{
        K key;
        V value;
        Entry<K,V> next;
        public Entry(K key,V value,Entry<K,V> next){
            this.key = key;
            this.value = value;
            this.next = next;
        }
    }
    public HashMapCustom(){
        table = new Entry[4];

    }
    public void put(K newkey,V newvalue){
        if(newkey == null){
            return;
        }
        int hash= hash(newkey);
        Entry<K,V> newEntry = new Entry<K,V>(newkey,newvalue,null);
        if(table[hash] == null){
            table[hash] = newEntry;
        }
        else {
            Entry<K,V> previous = null;
            Entry<K,V> current = table[hash];
            while (current!=null){
            // also consider case where key is equal
                if(current.key.equals(newkey)){
                    if(previous == null){
                        newEntry.next = current.next;
                        table[hash] = newEntry;
                        return;
                    }
                    else {
                        previous.next = newEntry;
                        newEntry.next = current.next;
                        return;
                    }
                }
                previous =current;
                current = current.next;
            }
            previous.next = newEntry;
        }
    }
    public V getValue(K key){
        int hash = hash(key);
        Entry<K,V> current = table[hash];
        while (current!=null){
            if(current.equals(key)){
                return current.value;
            }
            current = current.next;
        }
        return null;
    }
    public boolean removeKey(K key){
        int hash = hash(key);
        Entry<K,V> current = table[hash];
        Entry<K,V> previous = null;
        while (current!=null){
            if(current.equals(key)){
                if(previous == null){
                    table[hash].next = current.next;
                }
                else {
                    previous.next = current.next;
                }
                return true;
            }
            previous = null;
            current = current.next;
        }
        return false;
    }

    private int hash(K newkey) {
        return (newkey.hashCode())%4;
    }
}package SystemDesignCodes;


import java.util.*;

/**
 * Created by hadoop on 7/10/17.
 */
public class FriendShipService {
    HashMap<Integer,Set<Integer>> followers,followings;

    FriendShipService(){
        followers = new HashMap<>();
        followings = new HashMap<>();
    }
    public List<Integer> getFollowers(int userId){
        if(followers.containsKey(userId)){
            return new ArrayList<>(followers.get(userId));
        }
        return new ArrayList<>();
    }

    public List<Integer> getFollowings(int userId){
        if(followers.containsKey(userId)){
            return new ArrayList<>(followings.get(userId));
        }
        return new ArrayList<>();
    }
    public void follow(int from_user_id,int to_user_id){
        if(!followers.containsKey(from_user_id)){
            TreeSet treeSet = new TreeSet();
            followers.put(from_user_id,treeSet);
        }
        followers.get(from_user_id).add(to_user_id);

        if(!followings.containsKey(to_user_id)){
            TreeSet treeSet = new TreeSet();
            followings.put(to_user_id,treeSet);
        }
        followings.get(to_user_id).add(from_user_id);
    }
}
package SystemDesignCodes;

import java.util.Iterator;

/**
 * Created by hadoop on 7/10/17.
 */
public class WordCount {
    public static class Map {
        public void map(String key,String value,OutputCollector<String,Integer> outputCollector){
            String []words = key.split(" ");
            for(String word:words){
                outputCollector.collect(word,new Integer(1));
            }
        }
    }
    public static class Reduce{
        public void reduce(String key, Iterator<Integer> values,OutputCollector<String,Integer> outputCollector){
            Integer output=0;
            while (values.hasNext()){
                output = output+values.next();
            }
            outputCollector.collect(key,output);
        }
    }
}

class OutputCollector<K,V>{
    public void collect(K key,V value){
        //print collect output
    }
}package SystemDesignCodes;

import java.util.Map;

/**
 * Created by hadoop on 7/10/17.
 */
class BaseGFSClient {
     private Map<String, String> chunk_list;
     public BaseGFSClient() {}
      public String readChunk(String filename, int chunkIndex) {
          // Read a chunk from GFS
          return null;
      }
      public void writeChunk(String filename, int chunkIndex,
                             String content) {
          // Write a chunk to GFS
      }
  }
public class GFS_Client extends BaseGFSClient{
    Map<String,Integer> nameToChunkSize;
    int chunkSize; // 64mb 128 mb
    GFS_Client(int chunkSize){
        this.chunkSize = chunkSize;
    }
    public void writeFile(String filename,String content){
        int partitions = content.length()/chunkSize;
        if(content.length()%chunkSize != 0){
            partitions+=1;
        }
        nameToChunkSize.put(filename,partitions);
        for(int i=0;i<=partitions;i++){
            int startpointer = i*chunkSize;
            int endpointer = Math.min(content.length(),(i+1)*chunkSize);
            writeChunk(filename,i,content.substring(startpointer,endpointer));
        }

    }
    public String readFile(String filename){
        int partitions = nameToChunkSize.get(filename);
        String content = "";
        for(int i=0;i<=partitions;i++){
            content = content +readChunk(filename,i);
        }
        return content;
    }
}
package SystemDesignCodes;

import java.util.Map;
import java.util.NavigableMap;
import java.util.Stack;
import java.util.TreeMap;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * Created by hadoop on 7/10/17.
 */
public class SerializeTrieTree {
    private class TrieNode {
      public NavigableMap<Character, TrieNode> children;
      public TrieNode() {
          children = new TreeMap<Character, TrieNode>();
      }
  }
  public String Serialize(TrieNode node){
        if(node == null){
            return "";
        }
        String s="";
        for(Map.Entry<Character,TrieNode> entry:node.children.entrySet()){
            s = "+"+entry.getKey();
            s = s+ Serialize(entry.getValue());
            s =s +"-";
        }
        return s;
  }
  TrieNode deserialize(TrieNode current,String s, AtomicInteger a){
      if(a.get() == s.length()){
          return null;
      }
      if(s.charAt(a.get()) =='+'){
          current = new TrieNode();
          a.incrementAndGet();
          while (a.get()<s.length()) {
              Character character = s.charAt(a.get());
              a.incrementAndGet();
              current.children.put(character, deserialize(current.children.get(character), s, a));
          }
      }
      else if(s.charAt(a.get()) =='-'){
          a.incrementAndGet();
          return current;
      }
      else {
          return null;
      }
      return current;
  }

  //Stack Version

    public TrieNode deserilaize(String s ){
      int index = 0;
        Stack<TrieNode>stack = new Stack<>();
        TrieNode root = new TrieNode();
        stack.push(root);
        while (index<s.length()){

            if(s.charAt(index) == '+'){
                char c = s.charAt(++index);
                TrieNode node = new TrieNode();
                stack.peek().children.put(c,node);
                // very imp step as think through keep pusing and updaing children
                // post that
                // very nice logic shud be done non recursively
                // clear and simple
                stack.push(node);
            }
            else {
                index++;
                stack.pop();
            }
        }
        return root;
    }
}
package SystemDesignCodes;

import java.util.concurrent.TimeUnit;

/**
 * This is licensed under AGPL 3.0. http://www.gnu.org/licenses/agpl-3.0.html
 * @author Chandra Patni
 */
public class RateLimit {
    int rate;
    String unit;
    TimeUnit limit;
    private long lastCheck;
    private long lastFilled;
    private int allowance;
    boolean conformance;
    String slug;
    String databaseName;

    public RateLimit() {
    }

    public RateLimit(int rate, TimeUnit limit) {
        this.rate = rate;
        this.limit = limit;
        lastFilled = lastCheck = System.currentTimeMillis();
        allowance = rate;
    }


    public int getRate() {
        return rate;
    }

    public TimeUnit getLimit() {
        return limit;
    }

    public long getLastCheck() {
        return lastCheck;
    }

    public int getAllowance() {
        return allowance;
    }

    public boolean record(int messages) {
        long now = System.currentTimeMillis();
        long elapsed = now - lastFilled;

        if(elapsed >= limit.toMillis(1) ) {
            allowance = rate;
            lastFilled = now;
        }
        allowance -= messages;
        lastCheck = now;
        return allowance >= 0;
    }

    @Override
    public String toString() {
        return "RateLimit{" +
                "rate=" + rate +
                ", limit=" + limit +
                '}';
    }
    

    public static void main(String[] args) throws Exception{
        RateLimit rateLimit = new RateLimit(10, TimeUnit.MINUTES);
        System.out.println("RateLimit.main " +rateLimit);
        for (int i = 0; i < 110; i++) {
            System.out.println(i + " " + rateLimit.record(10));
        }

        Thread.sleep(5000L);
        System.out.println("After sleep");
        for (int i = 0; i < 110; i++) {
            System.out.println(i +    " "+ rateLimit.record(1));
        }
    }
}package SystemDesignCodes;

import java.math.BigInteger;
import java.security.MessageDigest;
import java.util.SortedMap;
import java.util.TreeMap;

/**
 * Created by hadoop on 7/10/17.
 */
public class MyConsistentHash {
    private int maxreplica = 3;
    private SortedMap<BigInteger,String> keynodemap = new TreeMap<>();
    public void put(String node) throws Exception{
        BigInteger key = hash(node);
        keynodemap.put(key,node);
        for(int i=0;i<maxreplica;i++){
            key = hash(node+":"+i);
            keynodemap.put(key,node);
        }
    }

    private BigInteger hash(String node) throws Exception {
        MessageDigest messageDigest = MessageDigest.getInstance("MD5");
        byte[] bytearray = messageDigest.digest(node.getBytes());
        BigInteger bigInteger = new BigInteger(bytearray);
        return bigInteger;
    }

    public String get(String entry) throws Exception{
        BigInteger key = hash(entry);
        if(!keynodemap.containsKey(key)){
            SortedMap<BigInteger,String> map = keynodemap.tailMap(key);
            if(map.isEmpty()){
                return keynodemap.get(keynodemap.firstKey());
            }
            return keynodemap.get(map.firstKey());
        }
        return keynodemap.get(key);
    }

    public static void main(String[] args) throws Exception {
        MyConsistentHash consistentHash = new MyConsistentHash();
        consistentHash.put("1.2.3.4");
        consistentHash.put("1.2.3.5");
        consistentHash.put("1.2.3.10");

        System.out.println(consistentHash.get("user1"));
        System.out.println(consistentHash.get("user3"));
        System.out.println(consistentHash.get("user2"));

    }
}

package SystemDesignCodes;

class QueueFullException extends RuntimeException {
     
    public QueueFullException(){
        super();
    }
    
    public QueueFullException(String message){
        super(message);
    }
    
}
 
 class QueueEmptyException extends RuntimeException {
 
    public QueueEmptyException(){
        super();
    }
    
    public QueueEmptyException(String message){
        super(message);
    }
    
}
 
/**
 * Circular Queue- implemented using Queue.
 */
 class CircularQueue<E> {
   
    private E[] circularQueueAr;
    private int maxSize;   //Maximum Size of Circular Queue
   
    private int rear;//elements will be added/queued at rear.
    private int front;   //elements will be removed/dequeued from front      
    private int number; //number of elements currently in Priority Queue
    
     /**
      * Constructor
      */
    public CircularQueue(int maxSize){
        this.maxSize = maxSize;
        circularQueueAr = (E[])new Object[this.maxSize];
        number=0; //Initially number of elements in Circular Queue are 0.
        front=0;  
        rear=0;    
    }
 
 
 
    /**
     * Adds element in Circular Queue(at rear)
     */
    public void enqueue(E item) throws QueueFullException {
        if(isFull()){
         throw new QueueFullException("Circular Queue is full");
        }else{
         circularQueueAr[rear] = item;
         rear = (rear + 1) % circularQueueAr.length;    
         number++; // increase number of elements in Circular queue
        }
    }
 
 
    /**
     * Removes element from Circular Queue(from front)
     */
    public E dequeue() throws QueueEmptyException {
        E deQueuedElement;
        if(isEmpty()){
         throw new QueueEmptyException("Circular Queue is empty");
        }else{
           deQueuedElement = circularQueueAr[front];
         circularQueueAr[front] = null;
         front = (front + 1) % circularQueueAr.length;
            number--; // Reduce number of elements from Circular queue
        }
       return deQueuedElement;
    }
 
    /**
     * Return true if Circular Queue is full.
     */
    public boolean isFull() {     
        return (number==circularQueueAr.length);    
    }
 
 
    /**
     * Return true if Circular Queue is empty.
     */
    public boolean isEmpty() {
        return (number==0);
    }
 
 
}
 
/** CircularQueueExample Main class - Copyright (c), AnkitMittal JavaMadeSoEasy.com */
public class CircularQueueExample {
 
    public static void main(String[] args) {
        CircularQueue<Integer> circularQueue = new CircularQueue<Integer>(5); //Initial size of CircularQueueArray
      
        circularQueue.enqueue(11);
        circularQueue.enqueue(21);
        circularQueue.enqueue(31);
        circularQueue.enqueue(51);
        circularQueue.enqueue(61);
 
        System.out.print("Elements deQueued from circular Queue: ");
        System.out.print(circularQueue.dequeue()+" ");
        System.out.print(circularQueue.dequeue()+" ");
        System.out.print(circularQueue.dequeue()+" ");
        System.out.print(circularQueue.dequeue()+" ");
        System.out.print(circularQueue.dequeue()+" ");
       
    }
    
}
package SystemDesignCodes;

/**
 * Created by hadoop on 8/10/17.
 */
public class FutureUsage {
}
/*
final Future<String> contentsFuture = startDownloading(new URL("http://www.example.com"));
while (!contentsFuture.isDone()) {
    askUserToWait();
    doSomeComputationInTheMeantime();
}
contentsFuture.get();

we can use This as reference for future object
//https://dzone.com/articles/javautilconcurrentfuture


 */package SystemDesignCodes;


import java.util.HashMap;

/**
 * Created by hadoop on 7/10/17.
 */
/*
Design and implement a data structure for Least Recently Used (LRU) cache.
It should support the following operations: get and set.

get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
set(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.

Tags: Design

*/
/*
It looks like we need to do some design, according to (http://www.cnblogs.com/yuzhangcmu/p/4113462.html). Though, the solution's concept is quite similar as attempt1.

1. The design uses HashMap, and 2-way LinkedList. Map<key, LinkNode>
2. Use two dummy node: head and tail. When add/remove nodes, we are add/remove nodes in between head and tail.
	So. head.next is our real 1st element
	andd tail.pre is our real last element

Note:
Be careful: when removing a node due to capacity issue, remember to remove both 1st node(head.next) and the corresponding entry in the map: map.remove(head.next.key)
*/

//Use double linked list to store value.
//Store key in hashmap<key, node> to find node easily
//Functions: insert in front, remove node,
public class LRUCache {
    class DoubleLinkedListNode {
        int key, val;
        DoubleLinkedListNode next,prev;
        public DoubleLinkedListNode(int key, int val){
            this.key = key;
            this.val = val;
            next = null;
            prev = null;
        }
    }
    public int capacity;
    public HashMap<Integer, DoubleLinkedListNode> map;
    public DoubleLinkedListNode head, tail;
    public LRUCache(int capacity) {
        this.capacity = capacity;
        this.map = new HashMap<Integer, DoubleLinkedListNode>();
        this.head = new DoubleLinkedListNode(-1, -1);
        this.tail = new DoubleLinkedListNode(-1, -1);
        head.next = tail;
        head.prev = tail;
        tail.next = head;
        tail.prev = head;
    }

    public int get(int key) {
        if (map.containsKey(key)) {
            DoubleLinkedListNode node = map.get(key);
            moveToHead(node);
            return node.val;
        } else {
            return -1;
        }
    }

    public void set(int key, int value) {
        if (map.containsKey(key)) {
            map.get(key).val = value;
            moveToHead(map.get(key));
        } else {
            DoubleLinkedListNode node = new DoubleLinkedListNode(key, value);
            if (map.size() >= this.capacity) {
                DoubleLinkedListNode rm = tail.prev;
                remove(rm);
                map.remove(rm.key);
            }
            insertHead(node);
            map.put(key, node);
        }
    }

    public void moveToHead(DoubleLinkedListNode node) {
        remove(node);
        insertHead(node);
    }

    //Helper functions
    public void insertHead(DoubleLinkedListNode node) {
        DoubleLinkedListNode next = head.next;
        head.next = node;
        node.prev = head;
        node.next = next;
        next.prev = node;
    }

    public void remove(DoubleLinkedListNode node) {
        DoubleLinkedListNode front = node.prev;
        DoubleLinkedListNode end = node.next;
        front.next = end;
        end.prev = front;
    }
}
//package SystemDesignCodes;50.LFU
//Design and implement a data structure for Least Frequently Used (LFU) cache. It should support the following operations: get and put.
//
//get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
//put(key, value) - Set or insert the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least frequently used item before inserting a new item. For the purpose of this problem, when there is a tie (i.e., two or more keys that have the same frequency), the least recently used key would be evicted.
//
//Follow up:
//Could you do both operations in O(1) time complexity?
//
//Example:
//
//LFUCache cache = new LFUCache( 2 /* capacity */ );
//
//cache.put(1, 1);
//cache.put(2, 2);
//cache.get(1);       // returns 1
//cache.put(3, 3);    // evicts key 2
//cache.get(2);       // returns -1 (not found)
//cache.get(3);       // returns 3.
//cache.put(4, 4);    // evicts key 1.
//cache.get(1);       // returns -1 (not found)
//cache.get(3);       // returns 3
//cache.get(4);       // returns 4
//
//Solution:
//Two HashMaps are used, one to store <key, value> pair, another store the <key, node>.
//I use double linked list to keep the frequent of each key. In each double linked list node, keys with the same count are saved using java built in LinkedHashSet. This can keep the order.
//Every time, one key is referenced, first find the current node corresponding to the key, If the following node exist and the frequent is larger by one, add key to the keys of the following node, else create a new node and add it following the current node.
//All operations are guaranteed to be O(1).
package SystemDesignCodes;

import java.util.*;

public class LFUCache {
    private Node head = null;
    private int cap = 0;
    private HashMap<Integer, Integer> valueHash = null;
    private HashMap<Integer, Node> nodeHash = null;
    
    public LFUCache(int capacity) {
        this.cap = capacity;
        valueHash = new HashMap<Integer, Integer>();
        nodeHash = new HashMap<Integer, Node>();
    }
    
    public int get(int key) {
        if (valueHash.containsKey(key)) {
            increaseCount(key);
            return valueHash.get(key);
        }
        return -1;
    }
    
    public void set(int key, int value) {
        if ( cap == 0 ) return;
        if (valueHash.containsKey(key)) {
            valueHash.put(key, value);
        } else {
            if (valueHash.size() < cap) {
                valueHash.put(key, value);
            } else {
                removeOld();
                valueHash.put(key, value);
            }
            addToHead(key);
        }
        increaseCount(key);
    }
    
    private void addToHead(int key) {
        if (head == null) {
            head = new Node(0);
            head.keys.add(key);
        } else if (head.count > 0) {
            Node node = new Node(0);
            node.keys.add(key);
            node.next = head;
            head.prev = node;
            head = node;
        } else {
            head.keys.add(key);
        }
        nodeHash.put(key, head);      
    }
    
    private void increaseCount(int key) {
        Node node = nodeHash.get(key);
        node.keys.remove(key);
        
        if (node.next == null) {
            node.next = new Node(node.count+1);
            node.next.prev = node;
            node.next.keys.add(key);
        } else if (node.next.count == node.count+1) {
            node.next.keys.add(key);
        } else {
            Node tmp = new Node(node.count+1);
            tmp.keys.add(key);
            tmp.prev = node;
            tmp.next = node.next;
            node.next.prev = tmp;
            node.next = tmp;
        }

        nodeHash.put(key, node.next);
        if (node.keys.size() == 0) remove(node);
    }
    
    private void removeOld() {
        if (head == null) return;
        int old = 0;
        for (int n: head.keys) {
            old = n;
            break;
        }
        head.keys.remove(old);
        if (head.keys.size() == 0) remove(head);
        nodeHash.remove(old);
        valueHash.remove(old);
    }
    
    private void remove(Node node) {
        if (node.prev == null) {
            head = node.next;
        } else {
            node.prev.next = node.next;
        } 
        if (node.next != null) {
            node.next.prev = node.prev;
        }
    }
    
    class Node {
        public int count = 0;
        public LinkedHashSet<Integer> keys = null;
        public Node prev = null, next = null;
        
        public Node(int count) {
            this.count = count;
            keys = new LinkedHashSet<Integer>();
            prev = next = null;
        }
    }
}
package SystemDesignCodes;


import java.util.HashMap;

/**
 * Created by hadoop on 7/10/17.
 */
public class MemCache {
    private class Data{
        int ttl;
        int editTime;
        int value;
        public Data(int value,int ttl,int editTime){
            this.value = value;
            this.ttl = ttl;
            this.editTime = editTime;
        }
    }
    // we need to put value with timestamp and ttl thats all other opertaions are trivial

    // incr,decr
    //
    HashMap<Integer,Data> cache;

    MemCache(){
        cache = new HashMap<>();
    }
    public int get(int currentTime,int key){
        int val= Integer.MAX_VALUE;
        if(!cache.containsKey(key)){
            return -1;
        }
        Data data = cache.get(key);
        if(data.ttl ==0 || data.ttl + data.editTime-1>=currentTime){
            val = data.value;
        }
        else {
            cache.remove(key);
        }
        return val;
    }
    public void set(int currenttime,int key,int ttl,int value){
        cache.put(key,new Data(value,ttl,currenttime));
    }
    public int incr(int currenttime,int key,int delta){
        int val = Integer.MAX_VALUE;
        if(!cache.containsKey(key)){
            return val;
        }
        Data data = cache.get(key);
        if(data.ttl == 0 || data.ttl +data.editTime-1>=currenttime){
            data.value+=delta;
            val = data.value;
            cache.put(key,data);
            return val;
        }
        else {
            cache.remove(key);
        }
        return val;
    }
    public int decr(int currenttime,int key,int delta){
        int value = Integer.MAX_VALUE;
        if(!cache.containsKey(key)){
            return value;
        }
        Data data = cache.get(key);
        if(data.ttl == 0 || data.ttl+data.editTime-1>=currenttime){
            data.value = data.value-delta;
            value = data.value;
            cache.put(key,data);
        }
        else {
            cache.remove(key);
        }
        return value;
    }

}
package SystemDesignCodes;

import java.util.ArrayList;
import java.util.List;
import java.util.Queue;
import java.util.Set;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.locks.ReentrantLock;

/**
 * Created by hadoop on 7/10/17.
 */
public class WebCrawler {
    Set<String> visitedUrls;
    Queue<String> urlPool;

    ReentrantLock lock;
    private static AtomicLong finished = new AtomicLong(0);

    List<String> crawler(String url){
        urlPool.offer(url);
        CrawlerThread [] threads = new CrawlerThread[16];
        for(int i=0;i<16;i++){
            threads[i].start();
        }
        while (!(urlPool.size() == 0 && finished.get() ==0l)){
            continue;
        }
        return new ArrayList<>(visitedUrls);
    }


}
class CrawlerThread extends Thread{
    Set<String> visitedUrls;
    Queue<String> urlPool;
    ReentrantLock lock;
    AtomicLong finished;
    HtmlParser htmlParser = new HtmlParser();

    CrawlerThread(Set<String>visitedUrls,Queue<String>urlPool,ReentrantLock lock,AtomicLong finished){
        this.visitedUrls = visitedUrls;
        this.urlPool = urlPool;
        this.lock = lock;
        this.finished = finished;
    }
    public void run() {
        while (true) { // imp condtion while(true) gets used in many problems
            if(urlPool.size() == 0 && finished.get() ==0l){
                break;
            }
            lock.lock();
            String polledUrl = urlPool.poll();
            if(visitedUrls.contains(polledUrl)){
                continue;
            }
            lock.unlock();
            if(polledUrl!=null){
                finished.incrementAndGet();
                visitedUrls.add(polledUrl);
                // Parsing takes lot of time so doing it outside the lock
                //maintain two sets queue for bfs
                // implementing BFS in each craweler just that multithread
                // so we put while(true) condition and also using lock structure
                // we could have used blocking queue ..
                // to make it simpler we could have used blocking queue
                // basically abstract out the all threading code
                // its simple produicer consumer problem
                // useed reentrant lock becure it can enter again and again
                // many threads using same lock since its the same shared resource
                // can you think of some other logic so that we donot need to use fininshed
                // state variable .. some sort of counter requered shared counter kind of concept
                // when queue size becomes zero then all other threads should not stoppppp
                // since running thread might end up putting
                // even if we had used blocking queue since we required one counter to tell its stopped now
                //almost impossible to solve this problem without finished counter to manage all thread
                // in live state
                List<String> parsedUrls = htmlParser.parsedUrls(polledUrl);

                lock.lock();
                urlPool.addAll(new ArrayList<>(parsedUrls));
                lock.unlock();
                finished.decrementAndGet();
            }
        }

    }
}

class HtmlParser{
    List<String> parsedUrls(String url){
        return new ArrayList<>();
    }
}
package SystemDesignCodes.Threading;

/**
 * Created by hadoop on 8/10/17.
 */
public class AtomicIntegerCustom {
    int currentValue;
    int previosValue;

    AtomicIntegerCustom(){
        currentValue = 0;
    }
    AtomicIntegerCustom(int init){
        this.currentValue = init;
    }
    public synchronized int get(){
        return currentValue;
    }
    public synchronized void set(int value){
        currentValue = value;
    }
    private synchronized int getAndSet(int value){
        previosValue = currentValue;
        currentValue = value;
        return previosValue;
    }
    public synchronized void increment(){
        currentValue++;
    }
}
package SystemDesignCodes.Threading;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
 
public class ReentrantLockTryLockTest {
    public static void main(String[] args) {

        Lock lock = new ReentrantLock();
        MyRunnable myRunnable = new MyRunnable(lock);
        new Thread(myRunnable, "Thread-1").start();
        new Thread(myRunnable, "Thread-2").start();

    }
}

class MyRunnable implements Runnable {

        Lock lock;

        public MyRunnable(Lock lock) {
            this.lock = lock;
        }

        public void run() {

            System.out.println(Thread.currentThread().getName()
                    + " is Waiting to acquire lock");

            if (lock.tryLock()) {
                System.out.println(Thread.currentThread().getName()
                        + " has acquired lock.");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

            } else {
                System.out.println(Thread.currentThread().getName()
                        + " didn't got lock.");

            }

        }
    }
/*OUTPUT
 
Thread-1 is Waiting to acquire lock
Thread-2 is Waiting to acquire lock
Thread-1 has acquired lock.
Thread-2 didn't got lock.
 
*/package SystemDesignCodes.Threading;

/**
 * Created by hadoop on 8/10/17.
 */
public class RentrantLockCustom {
    int lockHoldCount;
    long idOfCurrenThread;
    RentrantLockCustom(){
        lockHoldCount = 0 ;
    }
    public synchronized void lock(){
        if(lockHoldCount == 0){
            lockHoldCount++;
            idOfCurrenThread = Thread.currentThread().getId();
        }
        else if(lockHoldCount>0 && idOfCurrenThread == Thread.currentThread().getId()){
            lockHoldCount++;
        }
        else {
            try{
                wait(); // blocking call until lockholdcount becomes 0
                lockHoldCount = 0;
                idOfCurrenThread = Thread.currentThread().getId();
            }
            catch (Exception e){

            }
        }
    }
    public synchronized void unlock(){

        if(lockHoldCount == 0){
            /// thrwo execption not possinble
        }
        lockHoldCount--;
        if(lockHoldCount == 0){
            this.notifyAll();
        }
    }
    public synchronized boolean tryLock(){
        if(lockHoldCount == 0){
            lock();
            return true;
        }
        else {
            return false;
        }
    }
}
package SystemDesignCodes.Threading;
//CountDownLatch in Java
//1.8
//CountDownLatch is used to make sure that a task waits for other threads before it starts. To understand its application, let us consider a server where the main task can only start when all the required services have started.
//
//Working of CountDownLatch:
//When we create an object of CountDownLatch, we specify the number if threads it should wait for, all such thread are required to do count down by calling CountDownLatch.countDown() once they are completed or ready to the job. As soon as count reaches zero, the waiting task starts running.
//
//Example of CountDownLatch in JAVA:
//
///* Java Program to demonstrate how to use CountDownLatch,
//   Its used when a thread needs to wait for other threads
//   before starting its work. */
import java.util.concurrent.CountDownLatch;
 
public class CountDownLatchDemo
{
    public static void main(String args[]) throws InterruptedException
    {
        // Let us create task that is going to wait for four
        // threads before it starts
        CountDownLatch latch = new CountDownLatch(4);
 
        // Let us create four worker threads and start them.
        Worker first = new Worker(1000, latch, "WORKER-1");
        Worker second = new Worker(2000, latch, "WORKER-2");
        Worker third = new Worker(3000, latch, "WORKER-3");
        Worker fourth = new Worker(4000, latch, "WORKER-4");
        first.start();
        second.start();
        third.start();
        fourth.start();
 
        // The main task waits for four threads
        latch.await();
 
        // Main thread has started
        System.out.println(Thread.currentThread().getName() +
                           " has finished");
    }
}
 
// A class to represent threads for which the main thread
// waits.
class Worker extends Thread
{
    private int delay;
    private CountDownLatch latch;
 
    public Worker(int delay, CountDownLatch latch,
                                     String databaseName)
    {
        super(databaseName);
        this.delay = delay;
        this.latch = latch;
    }
 
    @Override
    public void run()
    {
        try
        {
            Thread.sleep(delay);
            latch.countDown();
            System.out.println(Thread.currentThread().getName()
                               + " finished");
        }
        catch (InterruptedException e)
        {
            e.printStackTrace();
        }
    }
}package SystemDesignCodes.Threading;

/**
 * Created by hadoop on 8/10/17.
 */
public class SemaphoreCustom {
    int permits;
    public SemaphoreCustom(int permits){
        this.permits = permits;
    }
    public synchronized void acquire() throws InterruptedException{
        if(permits>0){
            permits--;
        }
        else {
            this.wait();
            permits--;
        }
    }
    public synchronized void release() throws InterruptedException{
        permits++;
        if(permits>0){
            this.notifyAll();
        }
    }
}
package SystemDesignCodes.Threading.th;

import java.util.LinkedList;
import java.util.List;
 
 
 
 
/**
 * Implementing custom BlockingQueue interface .
 * This BlockingQueue implementation follows FIFO (first-in-first-out).
 * New elements are inserted at the tail of the queue,
 * and removal elements is done at the head of the queue.
 *
 * @author AnkitMittal
 * Copyright (c), AnkitMittal .
 * All Contents are copyrighted and must not be reproduced in any form.
 */
interface BlockingQueueCustom<E> {
 
      /**
       * Inserts the specified element into this queue
       * only if space is available else 
       * waits for space to become available.
       */
      void put(E item)  throws InterruptedException ;
 
 
      /**
       * Retrieves and removes the head of this queue
       * only if elements are available else 
       * waits for element to become available.
       */
      E take()  throws InterruptedException;
}
 
/** Copyright (c), AnkitMittal JavaMadeSoEasy.com */
/**
 * Implementing custom LinkedBlockingQueue class.
 * This BlockingQueue implementation follows FIFO (first-in-first-out).
 * New elements are inserted at the tail of the queue,
 * and removal elements is done at the head of the queue.
 *
 * @author AnkitMittal
 * Copyright (c), AnkitMittal .
 * All Contents are copyrighted and must not be reproduced in any form.
 */
class LinkedBlockingQueueCustom<E> implements BlockingQueueCustom<E>{
 
      private List<E> queue;
      private int  maxSize ; //maximum number of elements queue can hold at a time.
 
      public LinkedBlockingQueueCustom(int maxSize){
     this.maxSize = maxSize;
     queue = new LinkedList<E>();
      }
 
 
      /**
       * Inserts the specified element into this queue
       * only if space is available else 
       * waits for space to become available.
       */
      public synchronized void put(E item)  throws InterruptedException  {
            
               //check space is available or not.
               if (queue.size() == maxSize) {
             this.wait();
               }
               
               //space is available, insert.
         queue.add(item);
         this.notify();
      }
 
 
      /**
       * Retrieves and removes the head of this queue
       * only if elements are available else 
       * waits for element to become available.
       */
      public synchronized E take()  throws InterruptedException{
 
             //waits element is available or not.
        if (queue.size() == 0) {
            this.wait();
        }
 
        //element is available, remove.
        this.notify();
         return queue.remove(0);
      }  
}
 
 
/**
 * Producer Class in java
 */
class Producer implements Runnable {
 
    private final BlockingQueueCustom<Integer> sharedQueue;
 
    public Producer(BlockingQueueCustom<Integer> sharedQueue) {
        this.sharedQueue = sharedQueue;
    }
 
    @Override
    public void run() {
        for(int i=1; i<=10; i++){
         try {
             System.out.println("Produced : " + i);
             //put/produce into sharedQueue.
             sharedQueue.put(i);          
         } catch (InterruptedException ex) {
             
         }
        }
    }
 
}
 
/**
 * Consumer Class in Java
 */
class Consumer implements Runnable{
 
    private BlockingQueueCustom<Integer> sharedQueue;
 
    public Consumer (BlockingQueueCustom<Integer> sharedQueue) {
        this.sharedQueue = sharedQueue;
    }
 
    @Override
    public void run() {
        while(true){
         try {
           //take/consume from sharedQueue.
             System.out.println("CONSUMED : "+ sharedQueue.take());  
         } catch (InterruptedException ex) {
             
         }
        }
    }
 
 
}
 
 
/** Copyright (c), AnkitMittal JavaMadeSoEasy.com */
/**
 * Main class in java
 */
public class ProducerConsumerBlockingQueueCustom {
 
    public static void main(String args[]){
     
     BlockingQueueCustom<Integer> sharedQueue = new LinkedBlockingQueueCustom<Integer>(10); //Creating shared object
    
     Producer producer=new Producer(sharedQueue);
     Consumer consumer=new Consumer(sharedQueue);
    
     Thread producerThread = new Thread(producer, "ProducerThread");
     Thread consumerThread = new Thread(consumer, "ConsumerThread");
     producerThread.start();
     consumerThread.start();
 
    }
 
}
 
/*

Produced : 1
Produced : 2
Produced : 3
CONSUMED : 1
Produced : 4
CONSUMED : 2
Produced : 5
CONSUMED : 3
Produced : 6
CONSUMED : 4
Produced : 7
CONSUMED : 5
Produced : 8
CONSUMED : 6
Produced : 9
CONSUMED : 7
Produced : 10
CONSUMED : 8
CONSUMED : 9
CONSUMED : 10
*///package SystemDesignCodes.Threading.th;
//
//import java.util.concurrent.BlockingQueue;
//import java.util.concurrent.LinkedBlockingQueue;
//
///**
// * Producer Class in java.
// */
//class Producer implements Runnable {
//
//    private final BlockingQueue<Integer> sharedQueue;
//
//    public Producer(BlockingQueue<Integer> sharedQueue) {
//        this.sharedQueue = sharedQueue;
//    }
//
//    @Override
//    public void run() {
//        for(int i=1; i<=10; i++){
//         try {
//             System.out.println("Produced : " + i);
//             //put/produce into sharedQueue.
//             sharedQueue.put(i);
//         } catch (InterruptedException ex) {
//
//         }
//        }
//    }
//
//}
//
///**
// * Consumer Class in java.
// */
//class Consumer implements Runnable{
//
//    private BlockingQueue<Integer> sharedQueue;
//
//    public Consumer (BlockingQueue<Integer> sharedQueue) {
//        this.sharedQueue = sharedQueue;
//    }
//
//    @Override
//    public void run() {
//        while(true){
//         try {
//           //take/consume from sharedQueue.
//             System.out.println("CONSUMED : "+ sharedQueue.take());
//         } catch (InterruptedException ex) {
//
//         }
//        }
//    }
//
//
//}
//
///** Copyright (c), AnkitMittal JavaMadeSoEasy.com */
//public class ProducerConsumerBlockingQueue {
//
//    public static void main(String args[]){
//
//     //Creating shared object
//     BlockingQueue<Integer> sharedQueue = new LinkedBlockingQueue<Integer>();
//
//     Producer producer=new Producer(sharedQueue);
//     Consumer consumer=new Consumer(sharedQueue);
//
//     Thread producerThread = new Thread(producer, "ProducerThread");
//     Thread consumerThread = new Thread(consumer, "ConsumerThread");
//     producerThread.start();
//     consumerThread.start();
//
//    }
//
//}package SystemDesignCodes.Threading;

/**
 * Created by hadoop on 27/10/17.
 */
public class OneOfTheBestLock {
}
///http://dinukaroshan.blogspot.in/2012/10/locking-with-semaphore-example.html
package SystemDesignCodes.Threading;

import java.util.concurrent.Semaphore;

/**
 * Created by hadoop on 8/10/17.
 */
public class SemaphoreUsage {
    static int sharedvariable = 1;
    // only one is allowed to permit the usage
    // zero or less means we need to release first before we aquire
   // static Semaphore semaphore = new Semaphore(1);
    static SemaphoreCustom semaphore = new SemaphoreCustom(1);
    public static void main(String[] args) {
        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    Thread.sleep(5000);
                    semaphore.acquire();
                    for (int i = 0; i < 50; i++) {
                        System.out.println("thread 1"+sharedvariable);
                        sharedvariable++;
                    }
                }
                catch (Exception e){

                }
                finally {
                    try {
                        semaphore.release();
                    }
                    catch (Exception e){

                    }
                }
            }
        });
        Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    semaphore.acquire();
                    System.out.println("thread 2"+sharedvariable);

                    for (int i = 0; i < 50; i++) {
                        sharedvariable--;
                    }
                }
                catch (Exception e){

                }
                finally {
                    try {
                        semaphore.release();
                    }
                    catch (Exception e){

                    }
                }
            }
        });
        thread.start();
        thread1.start();
    }
}
package SystemDesignCodes.Threading.ConcurrencyPractical;

import java.util.Date;
import java.util.concurrent.Semaphore;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class PrintingJob implements Runnable {
    private PrinterQueue printerQueue;
 
    public PrintingJob(PrinterQueue printerQueue) {
        this.printerQueue = printerQueue;
    }
 
    @Override
    public void run() {
        System.out.printf("%s: Going to print a document\n", Thread
                .currentThread().getName());
        printerQueue.printJob(new Object());
    }
}
class PrinterQueue
{
    //This Semaphore will keep track of no. of printers used at any point of time.
    private final Semaphore semaphore;

    //While checking/acquiring a free printer out of three available printers, we will use this lock.
    private final Lock printerLock;

    //This array represents the pool of free printers.
    private boolean freePrinters[];

    public PrinterQueue()
    {
        semaphore = new Semaphore(3);
        freePrinters = new boolean[3];
        for (int i = 0; i < 3; i++) {
            freePrinters[i] = true;
        }
        printerLock = new ReentrantLock();
    }

    public void printJob(Object document)
    {
        try
        {
            //Decrease the semaphore counter to mark a printer busy
            semaphore.acquire();

            //Get the free printer
            int assignedPrinter = getPrinter();

            //Print the job
            Long duration = (long) (Math.random() * 10000);
            System.out.println(Thread.currentThread().getName()
                    + ": Printer " + assignedPrinter
                    + " : Printing a Job during " + (duration / 1000)
                    + " seconds :: Time - " + new Date());
            Thread.sleep(duration);

            //Printing is done; Free the printer to be used by other threads.
            releasePrinter(assignedPrinter);
        }
        catch (InterruptedException e) {
            e.printStackTrace();
        }
        finally {
            System.out.printf("%s: The document has been printed\n", Thread
                    .currentThread().getName());

            //Increase the semaphore counter back
            semaphore.release();
        }
    }

    //Acquire a free printer for printing a job
    private int getPrinter()
    {
        int foundPrinter = -1;
        try {
            //Get a lock here so that only one thread can go beyond this at a time
            printerLock.lock();

            //Check which printer is free
            for (int i = 0; i < freePrinters.length; i++)
            {
                //If free printer found then mark it busy
                if (freePrinters[i])
                {
                    foundPrinter = i;
                    freePrinters[i] = false;
                    break;
                }
            }
        }
        catch (Exception e) {
            e.printStackTrace();
        } finally
        {
            //Allow other threads to check for free priniter
            printerLock.unlock();
        }
        return foundPrinter;
    }

    //Release the printer
    private void releasePrinter(int i) {
        printerLock.lock();
        //Mark the printer free
        freePrinters[i] = true;
        printerLock.unlock();
    }
}package SystemDesignCodes.Threading.ConcurrencyPractical;

import java.util.HashMap;
import java.util.Map;

/**
 * A mock storage to hold the person objects in a map
 * 
 * @author dinuka.arseculeratne
 * 
 */
public class PersonStorage {

	private Map<Integer, Person> personCache = new HashMap<Integer, Person>();

	private int counter = 0;

	/**
	 * This class is made singleton and hence the constructor is made private
	 */
	private PersonStorage() {

	}

	/**
	 * Bill Pugh's way of lazy initializing the singleton instance
	 * 
	 * @author dinuka.arseculeratne
	 * 
	 */
	private static final class SingletonHolder {
		public static final PersonStorage INSTANCE = new PersonStorage();
	}

	/**
	 * Use this method to get a reference to the singleton instance of
	 * {@link PersonStorage}
	 * 
	 * @return the singleton instance
	 */
	public static PersonStorage getInstance() {
		return SingletonHolder.INSTANCE;
	}

	/**
	 * Inserts the person into the map. Note that we use defensive copying so
	 * that even if the client changes the object later on, those changes will
	 * not be reflected in the object within the map
	 * 
	 * @param person
	 *            the instance of {@link Person} to be inserted
	 * @return the key which signifies the location of the person object
	 * @throws InterruptedException
	 */
	public int putPerson(Person person) throws InterruptedException {

		Person copyPerson = person.copyPerson();
		personCache.put(++counter, copyPerson);

		return counter;
	}

	/**
	 * Here as well we use defensive copying so that the value of the object
	 * reference within the map is not passed in to the calling party.
	 * 
	 * @param id
	 *            the id representing the location of the object within the map
	 * @return the instance of the {@link Person} represented by the key passed
	 *         in
	 * @throws InterruptedException
	 */
	public Person retrievePerson(int id) throws InterruptedException {
		PersonLock.getInstance().getReadLock();
		if (!personCache.containsKey(id)) {
			throw new RuntimeException("Key is not found");
		}
		PersonLock.getInstance().releaseReadLock();
		return personCache.get(id).copyPerson();
	}

}
package SystemDesignCodes.Threading.ConcurrencyPractical;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.concurrent.*;

/**
 * Created by hadoop on 27/10/17.
 */
class CallableFuture implements Callable<Integer> {
    Integer number;
    CallableFuture(int number){
        this.number = number;
    }
    @Override
    public Integer call() throws Exception {
        int ans =1;
        while (number>0){
            ans = ans *number;
            number--;
        }
        return ans; // imp as i m returnining ... imp ...
    }
}
class  CallableExample{
    public static void main(String[] args) {
        ThreadPoolExecutor poolOfThreads =(ThreadPoolExecutor) Executors.newFixedThreadPool(5);
        int index = 1;
        Queue<Future<Integer>> futureObjects = new LinkedList<>();
        for(int i=0;i<5;i++){
            Future<Integer> futureObject= poolOfThreads.submit(new CallableFuture(index++));
            futureObjects.add(futureObject);
        }
        while (!futureObjects.isEmpty()){
            try {
                Future<Integer> ans = futureObjects.poll();
                Integer factans = ans.get();
                System.out.println("ans    " + factans);
            }
            catch (Exception e){

            }
        }
    }
}package SystemDesignCodes.Threading.ConcurrencyPractical;

/**
 * Data holding object for a person
 * 
 * @author dinuka.arseculeratne
 * 
 */
public class Person {

	private Long id;

	private String databaseName;

	private String address;

	public Person(Long id, String databaseName, String address) {
		super();
		this.id = id;
		this.databaseName = databaseName;
		this.address = address;
	}

	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public String getName() {
		return databaseName;
	}

	public void setName(String databaseName) {
		this.databaseName = databaseName;
	}

	public String getAddress() {
		return address;
	}

	public void setAddress(String address) {
		this.address = address;
	}

	public Person copyPerson() {
		Person copyPerson = new Person(this.getId(), this.getName(),
				this.getAddress());
		return copyPerson;

	}

	@Override
	public String toString() {
		return "Person [id=" + id + ", databaseName=" + databaseName + ", address=" + address
				+ "]";
	}
	
	
}
package SystemDesignCodes.Threading.ConcurrencyPractical;

/**
 * Created by hadoop on 27/10/17.
 */
public class SemaphoreAndLock {


}

class  Job implements Runnable{
    int id;
    Job(int id){
        this.id = id;
    }
    @Override
    public void run() {
        System.out.println("print this file using printer id"+id) ;
    }
}
package SystemDesignCodes.Threading.ConcurrencyPractical.LocksSemaphore;

import java.util.HashMap;
import java.util.Map;

/**
 * A mock storage to hold the person objects in a map
 * 
 * @author dinuka.arseculeratne
 * 
 */
public class PersonStorage {

	private Map<Integer, Person> personCache = new HashMap<Integer, Person>();

	private int counter = 0;

	/**
	 * This class is made singleton and hence the constructor is made private
	 */
	private PersonStorage() {

	}

	/**
	 * Bill Pugh's way of lazy initializing the singleton instance
	 * 
	 * @author dinuka.arseculeratne
	 * 
	 */
	private static final class SingletonHolder {
		public static final PersonStorage INSTANCE = new PersonStorage();
	}

	/**
	 * Use this method to get a reference to the singleton instance of
	 * {@link PersonStorage}
	 * 
	 * @return the singleton instance
	 */
	public static PersonStorage getInstance() {
		return SingletonHolder.INSTANCE;
	}

	/**
	 * Inserts the person into the map. Note that we use defensive copying so
	 * that even if the client changes the object later on, those changes will
	 * not be reflected in the object within the map
	 * 
	 * @param person
	 *            the instance of {@link Person} to be inserted
	 * @return the key which signifies the location of the person object
	 * @throws InterruptedException
	 */
	public int putPerson(Person person) throws InterruptedException {

		Person copyPerson = person.copyPerson();
		personCache.put(++counter, copyPerson);

		return counter;
	}

	/**
	 * Here as well we use defensive copying so that the value of the object
	 * reference within the map is not passed in to the calling party.
	 * 
	 * @param id
	 *            the id representing the location of the object within the map
	 * @return the instance of the {@link Person} represented by the key passed
	 *         in
	 * @throws InterruptedException
	 */
	public Person retrievePerson(int id) throws InterruptedException {
		PersonLock.getInstance().getReadLock();
		if (!personCache.containsKey(id)) {
			throw new RuntimeException("Key is not found");
		}
		PersonLock.getInstance().releaseReadLock();
		return personCache.get(id).copyPerson();
	}

}
package SystemDesignCodes.Threading.ConcurrencyPractical.LocksSemaphore;

/**
 * Data holding object for a person
 * 
 * @author dinuka.arseculeratne
 * 
 */
public class Person {

	private Long id;

	private String databaseName;

	private String address;

	public Person(Long id, String databaseName, String address) {
		super();
		this.id = id;
		this.databaseName = databaseName;
		this.address = address;
	}

	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public String getName() {
		return databaseName;
	}

	public void setName(String databaseName) {
		this.databaseName = databaseName;
	}

	public String getAddress() {
		return address;
	}

	public void setAddress(String address) {
		this.address = address;
	}

	public Person copyPerson() {
		Person copyPerson = new Person(this.getId(), this.getName(),
				this.getAddress());
		return copyPerson;

	}

	@Override
	public String toString() {
		return "Person [id=" + id + ", databaseName=" + databaseName + ", address=" + address
				+ "]";
	}
	
	
}
package SystemDesignCodes.Threading.ConcurrencyPractical.LocksSemaphore;

import java.util.concurrent.Semaphore;

/**
 * This class will allow thread to acquire and release locks as required
 * 
 * @author dinuka.arseculeratne
 * 
 */
public class PersonLock {

	/**
	 * We do not want multiple lock objects lying around so we make ths class
	 * singleton
	 */
	private PersonLock() {

	}

	/**
	 * Bill Pugh's way of lazy initializing the singleton instance
	 * 
	 * @author dinuka.arseculeratne
	 * 
	 */
	private static class SingletonHolder {
		public static final PersonLock INSTANCE = new PersonLock();
	}

	/**
	 * Use this method to get a reference to the singleton instance of
	 * {@link PersonLock}
	 * 
	 * @return the singleton instance
	 */
	public static PersonLock getInstance() {
		return SingletonHolder.INSTANCE;
	}

	/**
	 * In this sample, we allow only one thread at at time to update the cache
	 * in order to maintain consistency
	 */
	private Semaphore writeLock = new Semaphore(1);

	/**
	 * We allow 10 concurrent threads to access the cache at any given time
	 */
	private Semaphore readLock = new Semaphore(10);

	public void getWriteLock() throws InterruptedException {
		writeLock.acquire();
	}

	public void releaseWriteLock() {
		writeLock.release();
	}

	public void getReadLock() throws InterruptedException {
		readLock.acquire();
	}

	public void releaseReadLock() {
		readLock.release();
	}
}
package SystemDesignCodes.Threading.ConcurrencyPractical.LocksSemaphore.MyOwnImpl;

/**
 * Created by hadoop on 27/10/17.
 */
public class Person {
    Long id;
    String databaseName;
}
package SystemDesignCodes.Threading.ConcurrencyPractical.LocksSemaphore.MyOwnImpl;

import java.util.concurrent.Semaphore;

/**
 * Created by hadoop on 27/10/17.
 */
public class PersonLock {
    PersonLock instance;
    private PersonLock(){

    }
    PersonLock getInstance(){
        if(instance == null){
            synchronized (instance){
                if(instance == null){
                    instance=new PersonLock();
                    return instance;
                }
                return instance;
            }
        }
        else {
            return instance;
        }
    }
    private Semaphore readLock = new Semaphore(10);
    private Semaphore writeLock = new Semaphore(1);

    public void getReadLock() throws Exception{
        readLock.acquire();
    }
    public void getWriteLock() throws Exception{
        writeLock.acquire();
    }
    public void releeaseReadLock() throws Exception{
        readLock.release();
    }
    private void releaseWriteLock(){
        writeLock.release();
    }



}
package SystemDesignCodes.Threading.ConcurrencyPractical.LocksSemaphore;

/**
 * A test class to demonstrate the locking at work
 * 
 * @author dinuka.arseculeratne
 * 
 */
public class TestLock {

	public static void main(String[] args) throws InterruptedException {

		Thread t1 = new Thread(new Runnable() {

			@Override
			public void run() {

				Person p1 = new Person(1L, "Test1", "XYZ");
				try {
					PersonLock.getInstance().getWriteLock();
					PersonStorage.getInstance().putPerson(p1);
				} catch (InterruptedException e) {
					// Exception handling need to be done
					e.printStackTrace();
				} finally {

					PersonLock.getInstance().releaseWriteLock();
				}
			}
		});

		Thread t2 = new Thread(new Runnable() {

			@Override
			public void run() {
				Person p2 = new Person(2L, "Test123", "ABC");

				try {
					PersonStorage.getInstance().putPerson(p2);
				} catch (InterruptedException e) {
					// Exception handling need to be done
				}
			}
		});

		t1.start();
		t2.start();

		System.out.println(PersonStorage.getInstance().retrievePerson(2));
	}
}
package SystemDesignCodes.Threading.ConcurrencyPractical;

import java.util.concurrent.Semaphore;

/**
 * This class will allow thread to acquire and release locks as required
 * 
 * @author dinuka.arseculeratne
 * 
 */
public class PersonLock {

	/**
	 * We do not want multiple lock objects lying around so we make ths class
	 * singleton
	 */
	private PersonLock() {

	}

	/**
	 * Bill Pugh's way of lazy initializing the singleton instance
	 * 
	 * @author dinuka.arseculeratne
	 * 
	 */
	private static class SingletonHolder {
		public static final PersonLock INSTANCE = new PersonLock();
	}

	/**
	 * Use this method to get a reference to the singleton instance of
	 * {@link PersonLock}
	 * 
	 * @return the singleton instance
	 */
	public static PersonLock getInstance() {
		return SingletonHolder.INSTANCE;
	}

	/**
	 * In this sample, we allow only one thread at at time to update the cache
	 * in order to maintain consistency
	 */
	private Semaphore writeLock = new Semaphore(1);

	/**
	 * We allow 10 concurrent threads to access the cache at any given time
	 */
	private Semaphore readLock = new Semaphore(10);

	public void getWriteLock() throws InterruptedException {
		writeLock.acquire();
	}

	public void releaseWriteLock() {
		writeLock.release();
	}

	public void getReadLock() throws InterruptedException {
		readLock.acquire();
	}

	public void releaseReadLock() {
		readLock.release();
	}
}
package SystemDesignCodes.Threading.ConcurrencyPractical;

/**
 * Created by hadoop on 27/10/17.
 */
import java.util.*;
class Producer implements Runnable {
    List<Integer> taskQueue;
    int size ;
    Producer(int size,List<Integer>taskQueue){
        this.size = size;
        this.taskQueue = taskQueue;
    }
    @Override
    public void run() {
        int counter =0;
        while (true){
            produce(counter++);
        }
    }

    private void produce(int i) {
        synchronized (taskQueue){
            while (taskQueue.size() ==size){
                try {
                    taskQueue.wait();
                }
                catch (Exception e){

                }
                // perform task
                taskQueue.add(i);
                taskQueue.notifyAll();
            }
        }
    }
}

class Consumer implements Runnable{
    LinkedList<Integer> taskQueue;
    Consumer(LinkedList<Integer> taskQueue){
        this.taskQueue = taskQueue;
    }
    @Override
    public void run() {
        while (true){
            int consume =consume();
        }
    }

    private int consume() {
        synchronized (taskQueue){
            while (taskQueue.size() ==0){
                try {
                    taskQueue.wait();
                }
                catch (Exception e){

                }
                }
            int itemfetched = taskQueue.getFirst();
            taskQueue.notifyAll();
            return itemfetched;
        }
    }
}
package SystemDesignCodes.Threading.ConcurrencyPractical;

/**
 * Created by hadoop on 27/10/17.
 */
public class LockingTutorial {
    class democlass{
        public synchronized void dosomework(){

        }
        public void dosomeworkagain (){
            synchronized (this){



            }
        }
    }
    static class demostaticlock{
        static Object lock = new Object();
        Object nonstatic = new Object();
        public synchronized static void demo(){

        }
        public static void demostatic(){
            synchronized (lock){

            }
        }

    }
    class waitconstruct{
        Object lock = new Object();
        boolean favourablecondition = false;
        void dosomework(){
            // if my favourable condition is not there i wilsleep
            synchronized (lock) {
                while (!favourablecondition) {
                    try {
                        lock.wait();
                    }
                    catch (Exception e){

                    }
                }
                /// perform what the fuck u want to do
            }



        }


    }
}
package SystemDesignCodes.Threading.ConcurrencyPractical;

import java.net.URL;
import java.net.URLConnection;
import java.util.concurrent.Semaphore;

/**
 * Created by hadoop on 26/10/17.
 */
public class ConnectionLimiter {
    private final Semaphore semaphore;
    ConnectionLimiter(int numberOfRequests){
        semaphore = new Semaphore(numberOfRequests);
    }
    public URLConnection aquire(URL url){
        try {
            semaphore.acquire();
            return url.openConnection();
        }
        catch (Exception e){
            return null;
        }
    }
    public void release(URLConnection urlConnection){
        try{
            // clean up urlconnection resource
        }finally {
            semaphore.release();
        }
    }
}
/*
This is a nice elegant solution to a problem of limited resources. T
he call to acquire() will block until permits are available. T
he beauty of the semaphore is that it hides all the complexity of managing access control, counting permits and, of course, getting the thread-safety right.
As with most methods of locking or synchronization, there are some potential issues.

The number one thing to remember is, always release what you acquire. This is done by using try..finally constructs.

There are other less obvious problems that can befall you when using semaphores. The following class shows a deadlock that only the luckiest of you will avoid. Youll notice that the two threads which acquire the two semaphore permits do so in opposite order. (try..finally is left out for the sake of brevity).
Useful Tricks with Semaphores

One interesting property of Semaphores in Java is that release doesnt have to be called by the same thread as acquire. This means you could have a thread limiter that pools or creates threads based on a semaphore by calling acquire(). Then, the running thread could release its own semaphore permit when it completes. This is a useful property that we dont have with normal mutexes in Java.

Uses

What are some possible uses for counting semaphores? The following come to mind:

Limiting concurrent access to disk (this can kill performance due to competing disk seeks)
Thread creation limiting
JDBC connection pooling / limiting
Network connection throttling
Throttling CPU or memory intensive tasks




Dangers

As with most methods of locking or synchronization, there are some potential issues.

The number one thing to remember is, always release what you acquire. This is done by using try..finally constructs.

There are other less obvious problems that can befall you when using semaphores. The following class shows a deadlock that only the luckiest of you will avoid. Youll notice that the two threads which acquire the two semaphore permits do so in opposite order. (try..finally is left out for the sake of brevity).

public static void main(String[] args) throws Exception {
   Semaphore s1 = new Semaphore(1);
   Semaphore s2 = new Semaphore(1);

   Thread t = new Thread(new DoubleResourceGrabber(s1, s2));
   // now reverse them ... here comes trouble!
   Thread t2 = new Thread(new DoubleResourceGrabber(s2, s1));

   t.start();
   t2.start();

   t.join();
   t2.join();
   System.out.println("We got lucky!");
}

private static class DoubleResourceGrabber implements Runnable {
   private Semaphore first;
   private Semaphore second;

   public DoubleResourceGrabber(Semaphore s1, Semaphore s2) {
       first = s1;
       second = s2;
   }

   public void run() {
       try {
           Thread t = Thread.currentThread();

           first.acquire();
           System.out.println(t + " acquired " + first);

           Thread.sleep(200); // demonstrate deadlock

           second.acquire();
           System.out.println(t + " acquired " + second);

           second.release();
           System.out.println(t + " released " + second);

           first.release();
           System.out.println(t + " released " + first);
       } catch (InterruptedException ex) {
           ex.printStackTrace();
       }
   }
}
If you run this, you will more than likely have a hung process. Issues of lock ordering apply to semaphores as much as regular mutexes or synchronization in Java. In some cases, timeouts (see note on tryAcquire() later in the article) can be used to prevent deadlocks from causing a process to hang up, but typically a deadlock is a symptom of a logic error which can be avoided. If youre unfamiliar with deadlocks, I recommend you read up on them. Wikipedia has a decent article on deadlocks which applies to all languages equally.

The main things that you should be careful of when using semaphores (including binary semaphores, i.e. mutexes) are:

Not releasing after acquire (either missing release call or an exception is thrown and there is no finally block)
Long held semaphores, causing thread starvation
Deadlocks (as seen above)
Useful Tricks with Semaphores

One interesting property of Semaphores in Java is that release doesnt have to be called by the same thread as acquire. This means you could have a thread limiter that pools or creates threads based on a semaphore by calling acquire(). Then, the running thread could release its own semaphore permit when it completes. This is a useful property that we dont have with normal mutexes in Java.

Another trick is to increase the number of permits at runtime. Contrary to what you might guess, the number of permits in a semaphore isnt fixed, and a call to release() will always increment the number of permits, even if no corresponding acquire() call was made. Note that this can also result in bugs if you are incorrectly calling release() when no acquire() was made.

Finally, there are a few useful methods to be familiar with in Javas Semaphore. The method acquireInterruptibly() will acquire a resource, reattempting if it is interrupted. This means no outside handling of InterruptedException. The method tryAcquire() allows us to limit how long we will wait for a permit  we can either return immediately if there is no permit to obtain, or wait a specified timeout. If you somehow have known deadlocks that you cant fix easily or track down, you could help prevent locking up processes by using tryAcquire() with suitable timeouts.
 */package SystemDesignCodes.Threading.ConcurrencyPractical;

/**
 * A test class to demonstrate the locking at work
 * 
 * @author dinuka.arseculeratne
 * 
 */
public class TestLock {

	public static void main(String[] args) throws InterruptedException {

		Thread t1 = new Thread(new Runnable() {

			@Override
			public void run() {

				Person p1 = new Person(1L, "Test1", "XYZ");
				try {
					PersonLock.getInstance().getWriteLock();
					PersonStorage.getInstance().putPerson(p1);
				} catch (InterruptedException e) {
					// Exception handling need to be done
					e.printStackTrace();
				} finally {

					PersonLock.getInstance().releaseWriteLock();
				}
			}
		});

		Thread t2 = new Thread(new Runnable() {

			@Override
			public void run() {
				Person p2 = new Person(2L, "Test123", "ABC");

				try {
					PersonStorage.getInstance().putPerson(p2);
				} catch (InterruptedException e) {
					// Exception handling need to be done
				}
			}
		});

		t1.start();
		t2.start();

		System.out.println(PersonStorage.getInstance().retrievePerson(2));
	}
}
package SystemDesignCodes.Threading;

/**
 * Created by hadoop on 8/10/17.
 */
public class CountDownLatch {

}
package SystemDesignCodes.Threading.th1;

import java.util.LinkedList;
import java.util.List;
 
/**
 * Producer Class.
 */
class Producer implements Runnable {
 
    private List<Integer> sharedQueue;
    private int maxSize=10; //maximum number of products which sharedQueue can hold at a time.
 
    public Producer(List<Integer> sharedQueue) {
        this.sharedQueue = sharedQueue;
    }
 
    @Override
    public void run() {
        for (int i = 1; i <= 10; i++) {  //produce 10 products.
         try {
             produce(i);
         } catch (InterruptedException e) {  e.printStackTrace();   }
        }
}
 
    private void produce(int i) throws InterruptedException {
    
       synchronized (sharedQueue) {
           //if sharedQuey is full wait until consumer consumes.
           while (sharedQueue.size() == maxSize) {
               System.out.println("Queue is full, producerThread is waiting for "
                       + "consumerThread to consume, sharedQueue's size= " + maxSize);
               sharedQueue.wait();
           }

       }
       /* 2 Synchronized blocks have been used means before
        * producer produces by entering below synchronized
        * block consumer can consume.  
        */
      
       //as soon as producer produces (by adding in sharedQueue) it notifies consumerThread.
        synchronized (sharedQueue) {
           System.out.println("Produced : " + i);
           sharedQueue.add(i);
         Thread.sleep((long)(Math.random() * 1000));
         sharedQueue.notify();
        }
    }
}
 
/**
 * Consumer Class.
 */
class Consumer implements Runnable {
    private List<Integer> sharedQueue;
    public Consumer(List<Integer> sharedQueue) {
        this.sharedQueue = sharedQueue;
    }
   
    @Override
    public void run() {
        while (true) {
         try {
             consume();
             Thread.sleep(100);
         } catch (InterruptedException e) {  e.printStackTrace();   }
        }
    }
 
    private void consume() throws InterruptedException {
      
       synchronized (sharedQueue) {
           //if sharedQuey is empty wait until producer produces.
           while (sharedQueue.size() == 0) {
                  System.out.println("Queue is empty, consumerThread is waiting for "
                               + "producerThread to produce, sharedQueue's size= 0");
             sharedQueue.wait();
         }
       }
       
 
       /* 2 Synchronized blocks have been used means before
        * consumer start consuming by entering below synchronized
        * block producer can produce.  
        */
      
        /*If sharedQueue not empty consumer will consume
      * (by removing from sharedQueue) and notify the producerThread.
      */
        synchronized (sharedQueue) {
           Thread.sleep((long)(Math.random() * 2000));
         System.out.println("CONSUMED : "+ sharedQueue.remove(0));
         sharedQueue.notify();
        }
    }
   
}
 
/** Copyright (c), AnkitMittal JavaMadeSoEasy.com */
public class ProducerConsumerWaitNotify {
 
    public static void main(String args[]) {
       List<Integer> sharedQueue = new LinkedList<Integer>(); //Creating shared object
      
       Producer producer=new Producer(sharedQueue);
       Consumer consumer=new Consumer(sharedQueue);
      
        Thread producerThread = new Thread(producer, "ProducerThread");
        Thread consumerThread = new Thread(consumer, "ConsumerThread");
        producerThread.start();
        consumerThread.start();
    }
}package SystemDesignCodes.Threading.semaphore;
public class Job implements Runnable {
	private Printer printer;
	private String jobName;  
	public Job(Printer printer, String jobName) {
		this.printer = printer;
		this.jobName = jobName;
	}
	@Override
	public void run() {
		System.out.println("Job sent to printer:"+ jobName);		
		printer.print(jobName);
	}
}package SystemDesignCodes.Threading.semaphore;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Main {
	public static void main(String[] args) {
		final int threadCount = 5;
		final ExecutorService exService = Executors.newFixedThreadPool(threadCount);
		final Printer printer = new Printer();
		for (int i=1; i<= threadCount; i++) {
			exService.execute(new Job(printer, "Job-"+i));
		}
		exService.shutdown();
	}
}
package SystemDesignCodes.Threading.semaphore;

import java.util.concurrent.Semaphore;

public class Printer {
	   private static final int MAX_PERMIT = 1;
	   private final Semaphore semaphore = new Semaphore(MAX_PERMIT, true);
	   public void print(String jobName) {
	      try {
			semaphore.acquire();
			System.out.println("Printing Job: "+ jobName);				
		    Thread.sleep(2000);
			System.out.println("Finished Job: "+ jobName);	
		  } catch (InterruptedException e) {
			e.printStackTrace();
		  }finally {
		    semaphore.release();
		  }
	   }
}package SystemDesignCodes.Threading.semaphore.countingsemaphore;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Main {
	public static void main(String[] args) {
		final int threadCount = 6;
		final ExecutorService exService = Executors.newFixedThreadPool(threadCount);
		final Library library = new Library();
		for(int i=0; i < threadCount; i++) {
			Reader reader = new Reader(library);
			exService.execute(reader);
		}
		exService.shutdown();
	}
}
package SystemDesignCodes.Threading.semaphore.countingsemaphore;
public class Book {
	private String bookName;
	public Book(String bookName) {
		this.bookName = bookName;
	}
	public void read() {
		System.out.println(bookName + " is being read......");
		try {
			Thread.sleep(2000);
		}catch(InterruptedException e) {
			e.printStackTrace();
		}
	}
	public String getBookName() {
		return bookName;
	}
}
package SystemDesignCodes.Threading.semaphore.countingsemaphore;

import java.util.concurrent.Semaphore;

public class Library {
	   private static final int MAX_PERMIT = 3;
	   private final Semaphore availableBook = new Semaphore(MAX_PERMIT, true);
	   private Book[] books = {new Book("Ramayan"), new Book("Mahabharat"), new Book("Panchtantra")};
	   private boolean[] beingRead = new boolean[MAX_PERMIT];
	   
	   //Book is being issued to reader
	   public Object issueBook() throws InterruptedException {
	     availableBook.acquire();
	     return getNextAvailableBook();
	   }
	   private synchronized Book getNextAvailableBook() {
		 Book book = null;  
	     for (int i = 0; i < MAX_PERMIT; ++i) {
	       if (!beingRead[i]) {
	          beingRead[i] = true;
	          book = books[i];
	          System.out.println(book.getBookName()+" has been issued.");
	          break;
	       }
	     }
	     return book;
	   }
	   //Book is being returned to library
	   public void returnBook(Book book) {
		     if (markAsAvailableBook(book))
		       availableBook.release();
	   }	   
	   private synchronized boolean markAsAvailableBook(Book book) {
		 boolean flag = false;  
	     for (int i = 0; i < MAX_PERMIT; ++i) {
	       if (book == books[i]) {
	          if (beingRead[i]) {
	            beingRead[i] = false;
	            flag = true;
		        System.out.println(book.getBookName()+" has been returned.");
	          } 
	          break;
	       }
	     }
	     return flag;
	   }
}package SystemDesignCodes.Threading.semaphore.countingsemaphore;
public class Reader implements Runnable {
	private Library library;
	public Reader(Library library) {
		this.library = library;
	}
	@Override
	public void run() {
		try {
			Book book = (Book)library.issueBook();
			book.read();
			library.returnBook(book);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
}package SystemDesignCodes.Threading;

/**
 * Created by hadoop on 8/10/17.
 */
public class CountDownLatchCustom {
    private int count;
    public CountDownLatchCustom(int count){
        this.count = count;
    }
    public synchronized void await(){
        if(count>0){
            try {
                wait();
            }
            catch (Exception e){

            }
        }
    }
    public synchronized void countDown(){
        count--;
        if(count == 0){
            notifyAll();
        }
    }
}
package SystemDesignCodes.Threading.ThreadPool;

import java.util.LinkedList;
import java.util.List;

/**
 * Created by hadoop on 8/10/17.
 */


interface BlockingQueue<E>{
    void put(E e);
    E get();
    int size();
}
class LinkedBlockingQueue<E> implements BlockingQueue<E>{
    List<E> list;
    int maxsize;
    LinkedBlockingQueue(int maxsize){
        list = new LinkedList<E>();
        this.maxsize = maxsize;
    }
    @Override
    public synchronized void put(E o) {
        while (list.size() == maxsize){
            try {
                wait();
            }
            catch (Exception e){

            }
        }
        list.add(o);
        notifyAll();
    }

    @Override
    public synchronized E get() {
        while (list.size() == 0){
            try {
                wait();
            }
            catch (Exception e){

            }
        }
        E item = list.get(0);
        list.remove(0);
        this.notifyAll();
        return item;
    }

    @Override
    public int size() {
        return list.size();
    }
}
public class ThreadPool{
    private LinkedBlockingQueue<Runnable> tasks ;

    private volatile boolean  poolShutDown = false;
    public ThreadPool(int sizeofpool){
        tasks = new LinkedBlockingQueue<>(sizeofpool);
        for(int i=0;i<sizeofpool;i++){
            ThreadPoolsThread threadPoolsThread = new ThreadPoolsThread(tasks,this);
            threadPoolsThread.start();
        }
    }
    public synchronized void execute(Runnable task){
        tasks.put(task);
    }

    public boolean isPoolShutDown() {
        return poolShutDown;
    }
    public static void main(String args[]){
        ThreadPool threadPool = new ThreadPool(3);
        Task task = new Task();
        threadPool.execute(task);
    }
}
class ThreadPoolsThread extends Thread{
    LinkedBlockingQueue<Runnable> tasks;
    ThreadPool threadPool;

    public ThreadPoolsThread(LinkedBlockingQueue<Runnable> tasks, ThreadPool threadPool) {
        this.tasks = tasks;
        this.threadPool = threadPool;
    }

    @Override
    public void run() {
        while (true){
            Runnable task = tasks.get();
            task.run();
            if(tasks.size() == 0 && threadPool.isPoolShutDown()){
                break;
            }
        }
    }
}


class Task implements Runnable{
    @Override
    public void run() {
        System.out.println("Lets Do it");
    }
}


//http://www.javamadesoeasy.com/2015/03/implementing-threadpool-using-custom.htmlpackage SystemDesignCodes.Threading;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingDeque;

/**
 * Created by hadoop on 8/10/17.
 */
public class ProducerConsumer {

    public static void main(String[] args) {
        BlockingQueue<Integer> blockingQueue = new LinkedBlockingDeque<>();
        Thread producerThread = new Thread(new Producer(blockingQueue));
        Thread consumerThread = new Thread(new Consumer(blockingQueue));
        producerThread.start();
        consumerThread.start();
    }

}

class Producer implements Runnable{
    private final BlockingQueue<Integer> blockingQueue;
    Producer(BlockingQueue<Integer> blockingQueue){
        this.blockingQueue = blockingQueue;
    }
    public void run(){
        for(int i=0;i<10;i++){
            try {
                blockingQueue.put(i);
            }
            catch (Exception e){

            }
            }
    }
}
class  Consumer implements Runnable{
    private final BlockingQueue<Integer> blockingQueue;
    Consumer(BlockingQueue<Integer> blockingQueue){
        this.blockingQueue = blockingQueue;
    }
    public void run(){
        while (true){
            try {
                blockingQueue.take();
            }
            catch (Exception e){

            }
        }
    }
}package SystemDesignCodes.Threading;

/**
 * Created by hadoop on 8/10/17.
 */
public class LINKNAME {
}

//http://www.javamadesoeasy.com/2015/03/implementing-threadpool-using-custom.htmlpackage SystemDesignCodes.Threading;

import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.BlockingQueue;

/**
 * Created by hadoop on 8/10/17.
 */
public class LinkedBlockingQueueCustom<E> {
    List<E> list;
    int maxsize;
    LinkedBlockingQueueCustom(int maxsize){
        list = new LinkedList<>();
        this.maxsize = maxsize;
    }
    public void put(E e) {
        if(list.size() == maxsize){
            try {
                wait();
            }
            catch (Exception x){

            }
        }

        list.add(e);
        this.notifyAll();
    }

    public E take() throws InterruptedException {
        if(list.size() == 0){
            try{
                wait();
            }
            catch (Exception e){

            }
        }
        E ob =list.get(0);
        this.notifyAll();
        return ob;
    }
}
package SystemDesignCodes.Threading;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
 
public class ReentrantLockTest {
    public static void main(String[] args) {
 
        Lock lock=new ReentrantLock();
        MyRunnable1 myRunnable=new MyRunnable1(lock);
        new Thread(myRunnable,"Thread-1").start();
        new Thread(myRunnable,"Thread-2").start();
        
    }
}
 
 


class MyRunnable1 implements Runnable{
    
    Lock lock;
    public MyRunnable1(Lock lock) {
        this.lock=lock;
    }
    
    public void run(){
        
                  System.out.println(Thread.currentThread().getName()
               +" is Waiting to acquire lock");
 
        
        lock.lock();
        System.out.println();
        System.out.println(Thread.currentThread().getName()
                     +" has called lock(), lockHoldCount=1 ");
        
        
        lock.lock();         
        System.out.println(Thread.currentThread().getName()
                     +" has called lock(), lockHoldCount=2 ");
        
        System.out.println(Thread.currentThread().getName()
                  +" is about to call unlock(), lockHoldCount will become 1 ");
           lock.unlock();    
        
        System.out.println(Thread.currentThread().getName()
                  +" is about to call unlock(), lockHoldCount will become 0 ");
           lock.unlock();    
        
        
        
    }
}
 
/*OUTPUT
 
Thread-2 is Waiting to acquire lock
Thread-1 is Waiting to acquire lock
 
Thread-2 has called lock(), lockHoldCount=1
Thread-2 has called lock(), lockHoldCount=2
Thread-2 is about to call unlock(), lockHoldCount will become 1
Thread-2 is about to call unlock(), lockHoldCount will become 0
 
Thread-1 has called lock(), lockHoldCount=1
Thread-1 has called lock(), lockHoldCount=2
Thread-1 is about to call unlock(), lockHoldCount will become 1
Thread-1 is about to call unlock(), lockHoldCount will become 0
 
*/package SystemDesignCodes.Threading;

import java.io.BufferedReader;
import java.io.FileWriter;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.URL;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;


public class Manager {
    static final int N = 3;
    public static void main(String[] args) throws InterruptedException {
        CountDownLatch start = new CountDownLatch(1);
        CountDownLatch done = new CountDownLatch(N); 
        ExecutorService service = Executors.newFixedThreadPool(N);
        service.execute(new Downloader(start,done,"http://www.google.com","google.txt"));
        service.execute(new Downloader(start,done,"http://www.southwest.com","southwest.txt"));
        service.execute(new Downloader(start,done,"http://www.learnquest.com","learnquest.txt"));
        System.out.println("Manager should give a go signal");
        start.countDown(); // go ahead threads, download stuff
        done.await();
        System.out.println("all tasks done, now do something");
        
    }
   private static class Downloader implements Runnable{
        CountDownLatch start;
        CountDownLatch done ;
        private String site;
        private String file; 
        
        private Downloader(CountDownLatch start, CountDownLatch done, String site,String file) {
            this.start = start;
            this.done = done;
            this.site = site;
            this.file = file;
        }

        @Override
        public void run() {
            try {
                start.await();
                URL url = new URL(site);
                InputStream inputStream = url.openConnection().getInputStream();
                BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
                FileWriter writer = new FileWriter("c:/temp/"+file);
                char[] buffer = new char[8096];
                int counter = -1;
                while((counter = reader.read(buffer)) != -1){
                    writer.write(buffer,0,counter);
                }
                writer.flush();
                writer.close();
                System.out.println("Finished dowloading "+site);
                done.countDown();
            } catch (Exception e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            } 
        }
        
    }
}package SystemDesignCodes;

/**
 * Created by hadoop on 7/10/17.
 */
public class ConsistentHashing {

}
package SystemDesignCodes;

import java.util.HashMap;

/**
 * Created by hadoop on 22/10/17.
 */
public class MyLruCache<K,V> {
    Node<K,V> head;
    Node<K,V> tail;
    int capacity;
    HashMap<K,Node<K,V>> hashMap = new HashMap<>();
    MyLruCache(int capacity){
        head = new Node<K,V>();
        tail = new Node<K,V>();
        this.capacity = capacity;
        head.next = tail;
        tail.previous = head;
        head.previous = tail;
        tail.next = head;
    }

    private class Node<K,V>{
        K key;
        V value;
        Node<K,V> next;
        Node<K,V> previous;
        Node(K key,V value){
            this.key = key;
            this.value = value;
        }
        Node(){

        }
    }

    V get(K key){
        if(hashMap.containsKey(key)){
            Node<K,V> node = hashMap.get(key);
            moveToHead(node);
            return node.value;
        }
        else {
            return null;
        }
    }

    private void moveToHead(Node<K, V> node) {
        remove(node);
        insertAtHead(node);
    }

    private void remove(Node<K, V> node) {
        node.next.previous = node.previous;
        node.previous.next = node.next;
    }
    private void  insertAtHead(Node<K,V> node){
        Node<K,V> oldHead = head.next;
        head.next = node;
        node.next = oldHead;
        oldHead.previous = node;
    }
    void put(K key,V value){
        Node<K,V> node = hashMap.get(key);
        if(node!=null){
            node.value = value;
            moveToHead(node);
            return;
        }
        else {
         // Here movetohead nope inseatd only insert since its the first entrying in this cache
            // move to head required only in get method or in put that particular node already exists ...
            if(hashMap.size()>=capacity){
                // remove  from the tail...
                Node tobeRemoved = tail.previous;
                remove(tobeRemoved);
                hashMap.remove(tobeRemoved.key);
            }

            node = new Node<K,V>(key,value);
            insertAtHead(node);
            hashMap.put(key,node);
            return;
        }

    }

}
package SystemDesignCodes;

import java.util.Date;

/**
 * Created_By: zouzhile
 * Date: 2/21/14
 * Time: 3:24 PM
 *
 * Given a timer time() with nanosecond accuracy and given the interface
 interface RealTimeCounter:
 void increment()
 int getCountInLastSecond()
 int getCountInLastMinute()
 int getCountInLastHour()
 int getCountInLastDay()
 implement the interface. The getCountInLastX functions should return the number of times increment was called in the last X.
 */
public class DZ19_RealTimeCounter {

    static class Timer {

        /*
          timer in nanoseconds accurracy
         */
        public static long time() {
            return new Date().getTime() * 1000;
        }

        /**
         *
         * @param start the start time in nanoseconds
         * @param end  the end time in nanoseconds
         * @return
         */
        public static int diff(long start, long end) {
            return (int) (end - start) / 1000000;
        }
    }

    class CyclicBuffer {

        int[] data = new int[86400]; //86400 second per day
        int endOffset = 0;

        /**
         *
         * @param value current counter value
         * @param seconds how many seconds passed since last append
         */
        public void append(int value, int seconds) {
            for(int i = 1; i <= seconds; i ++) {
                endOffset = (endOffset + i) % data.length;
                data[endOffset] = value;
            }
        }

        public int get(int distanceFromEnd) {
            int offset = (endOffset + data.length - distanceFromEnd) % data.length;
            return (int)data[offset];
        }
    }

    private int counter = 0;
    private long lastIncrementTime = -1;
    private CyclicBuffer buffer = new CyclicBuffer();

    public void increment() {
        long currentTime = Timer.time();

        if(lastIncrementTime < 0)
            lastIncrementTime = currentTime;

        int secondsSinceLastIncrement = Timer.diff(lastIncrementTime, currentTime);
        counter ++;
        buffer.append(counter, secondsSinceLastIncrement);
    }

    public int getCountInLastSecond() {
        return buffer.get(0) - buffer.get(1);
    }

    public int getCountInLastMinute() {
        return buffer.get(0) - buffer.get(60);
    }

    public int getCountInLastHour() {
        return buffer.get(0) - buffer.get(3600);
    }

    public int getCountInLastDay() {
        return buffer.get(0) - buffer.get(86399);
    }

}
package SystemDesignCodes;

import java.util.SortedMap;
import java.util.TreeMap;

/**
 * Created by hadoop on 7/10/17.
 */
// record a hit and provide hits in last 5 minutes
// maintains 300 timestaps of each second in last 5 minutes
    //with treemap its piece of cake
public class WebLogger {
    SortedMap<Integer,Integer> hitMap;
    WebLogger(){
        hitMap = new TreeMap<>();
    }
    public void hit(Integer timestamp){
        // remove all vlaues that are before timestamp-299
        // if we need vlaues from starting use headmap
        // if we need values from ending use tail mao
        hitMap = hitMap.tailMap(timestamp-299);

        if(hitMap.containsKey(timestamp)){
            hitMap.put(timestamp,hitMap.get(timestamp)+1);
            return;
        }
        else {
            hitMap.put(timestamp,1);
        }
        return;
    }
    public void get_hit_count_in_5min(Integer timestamp){
        hitMap = hitMap.tailMap(timestamp-299);
        int count = 0;
        for(int hits:hitMap.values()){
            count = count+hits;
        }
    }

}
class OptimizedWebLogger{
    int count;
    int []hitmap;
    int lasthit; // so that you can update counter with everyhit

    OptimizedWebLogger(){
        count = 0;
        lasthit = -1;
        hitmap = new int[300];
    }

    public void hit(Integer timestamp){
        timeFly(timestamp);
        count++;
        hitmap[timestamp%300]+=1;
        lasthit = timestamp;
    }

    private int getHitsInLast5min(Integer timestamp) {
        timeFly(timestamp);
        return count;
    }

    public void timeFly(Integer timestamp) {
        if (lasthit > 0) {
            if (timestamp - lasthit >= 300) {
                count = 0;
                for (int i = 0; i < 300; i++) {
                    hitmap[i] = 0;
                }
            } else {
                for (int i = lasthit + 1; i <= timestamp; i++) {
                    count = count - hitmap[i % 300];
                    hitmap[i % 300] = 0;
                }
            }
        }
    }
}
//package SystemDesignCodes;
//
///**
// * Created by hadoop on 8/10/17.
// */
//public class LinkedHashMap<K,V> {
//    private Entry<K,V> []table;
//    int capacity = 4;
//    class Entry<K,V>{
//        K key;
//        V value;
//        Entry<K,V> next;
//        Entry<K,V> after;
//        Entry<K,V> before;
//
//        public Entry(K key, V value) {
//            this.key = key;
//            this.value = value;
//        }
//    }
//    Entry<K,V>  head;
//    Entry<K,V> tail;
//    LinkedHashMap(){
//        table = new Entry[capacity];
//    }
//    int hash(K key){
//        return (key.hashCode()%capacity);
//    }
//    public void put(K key, V value){
//
//        if(key == null){
//            return;
//        }
//        int hash = hash(key);
//        Entry<K,V> newEntry = new Entry<>(key,value);
//        mainTainOrderAfterInsert(newEntry);
//
//    }
//
//    private void mainTainOrderAfterInsert(Entry<K, V> newEntry) {
//        if(head == null){
//            head = newEntry;
//            tail = newEntry;
//            return;
//        }
//        else if(tail.key.equals(newEntry.key)){
//            deleteLast();
//            insertAtLast(newEntry);
//        }
//        else if(head.key.equals(newEntry.key)){
//            deleteFirst();
//            insertFirst(newEntry);
//        }
//        else {
//            Entry<K,V> deleteEntry = deleteEntrySpecfic(newEntry);
//            if(deleteEntry == null){
//                insertLast(newEntry);
//            }
//            else {
//                deleteAfter(deleteEntry,newEntry);
//            }
//        }
//    }
//
//    private void deleteLast() {
//        if(head == tail){
//            tail= null;
//            head = null;
//        }
//        if(tail !=null){
//            tail.before.after = tail.after;
//            //tail.after.before = tail.before;
//            tail = tail.before;
//        }
//        // tail = tail.before  ;
//        // tail.after = null;
//    }
//    private void deleteFirst(){
//        if(head == tail){
//            tail = null;
//            head = null;
//        }
//        if(head!=null){
//            head = head.after;
//            head.before = null;
//        }
//    }
//
//}

///*
//package com.ankit;
//
// /**
// * @author AnkitMittal, JavaMadeSoEasy.com
// * Copyright (c), AnkitMittal . All Contents are copyrighted and must not be
// * reproduced in any form.
// * This class provides custom implementation of LinkedHashMap(without using java api's)-
// * which allows us to store data in key-value pair form.
// * It maintains insertion order, uses DoublyLinkedList for doing so.
// * If key which already exists is added again, its value is overridden but
// * insertion order does not change,
// * BUT, if key-value pair is removed and value is again added than insertion order
// * changes(which is quite natural behavior).
// * @param <K>
// * @param <V>
// */
//class LinkedHashMapCustom<K, V> {
//
//    private Entry<K,V>[] table;   //Array of Entry.
//    private int capacity= 4;  //Initial capacity of HashMap
//    private Entry<K,V> header; //head of the doubly linked list.
//    private Entry<K,V> last; //last of the doubly linked list.
//
//    /*
//     * before and after are used for maintaining insertion order.
//     */
//    static class Entry<K, V> {
//        K key;
//        V value;
//        Entry<K,V> next;
//        Entry<K,V> before,after;
//
//        public Entry(K key, V value, Entry<K,V> next){
//            this.key = key;
//            this.value = value;
//            this.next = next;
//        }
//    }
//
//
//    @SuppressWarnings("unchecked")
//    public LinkedHashMapCustom(){
//        table = new Entry[capacity];
//    }
//
//
//
//    /**
//     * Method allows you put key-value pair in LinkedHashMapCustom.
//     * If the map already contains a mapping for the key, the old value is replaced.
//     * Note: method does not allows you to put null key thought it allows null values.
//     * Implementation allows you to put custom objects as a key as well.
//     * Key Features: implementation provides you with following features:-
//     *     >provide complete functionality how to override equals method.
//     *  >provide complete functionality how to override hashCode method.
//     * @param newKey
//     * @param data
//     */
//    public void put(K newKey, V data){
//        if(newKey==null)
//            return;    //does not allow to store null.
//
//        int hash=hash(newKey);
//
//        Entry<K,V> newEntry = new Entry<K,V>(newKey, data, null);
//        maintainOrderAfterInsert(newEntry);
//        if(table[hash] == null){
//            table[hash] = newEntry;
//        }else{
//            Entry<K,V> previous = null;
//            Entry<K,V> current = table[hash];
//            while(current != null){ //we have reached last entry of bucket.
//                if(current.key.equals(newKey)){
//                    if(previous==null){  //node has to be insert on first of bucket.
//                        newEntry.next=current.next;
//                        table[hash]=newEntry;
//                        return;
//                    }
//                    else{
//                        newEntry.next=current.next;
//                        previous.next=newEntry;
//                        return;
//                    }
//                }
//                previous=current;
//                current = current.next;
//            }
//            previous.next = newEntry;
//        }
//    }
//
//
//    /**
//     * below method helps us in ensuring insertion order of LinkedHashMapCustom
//     * after new key-value pair is added.
//     */
//    private void maintainOrderAfterInsert(Entry<K, V> newEntry) {
//
//        if(header==null){
//            header=newEntry;
//            last=newEntry;
//            return;
//        }
//
//        if(header.key.equals(newEntry.key)){
//            deleteFirst();
//            insertFirst(newEntry);
//            return;
//        }
//
//        if(last.key.equals(newEntry.key)){
//            deleteLast();
//            insertLast(newEntry);
//            return;
//        }
//
//        Entry<K, V> beforeDeleteEntry=    deleteSpecificEntry(newEntry);
//        if(beforeDeleteEntry==null){
//            insertLast(newEntry);
//        }
//        else{
//            insertAfter(beforeDeleteEntry,newEntry);
//        }
//
//
//    }
//
//    /**
//     * below method helps us in ensuring insertion order of LinkedHashMapCustom,
//     * after deletion of key-value pair.
//     */
//    private void maintainOrderAfterDeletion(Entry<K, V> deleteEntry) {
//
//        if(header.key.equals(deleteEntry.key)){
//            deleteFirst();
//            return;
//        }
//
//        if(last.key.equals(deleteEntry.key)){
//            deleteLast();
//            return;
//        }
//
//        deleteSpecificEntry(deleteEntry);
//
//    }
//
//    /**
//     * returns entry after which new entry must be added.
//     */
//    private void insertAfter(Entry<K, V> beforeDeleteEntry, Entry<K, V> newEntry) {
//        Entry<K, V> current=header;
//        while(current!=beforeDeleteEntry){
//            current=current.after;  //move to next node.
//        }
//
//        newEntry.after=beforeDeleteEntry.after;
//        beforeDeleteEntry.after.before=newEntry;
//        newEntry.before=beforeDeleteEntry;
//        beforeDeleteEntry.after=newEntry;
//
//    }
//
//
//    /**
//     * deletes entry from first.
//     */
//    private void deleteFirst(){
//
//        if(header==last){ //only one entry found.
//            header=last=null;
//            return;
//        }
//        header=header.after;
//        header.before=null;
//
//    }
//
//    /**
//     * inserts entry at first.
//     */
//    private void insertFirst(Entry<K, V> newEntry){
//
//        if(header==null){ //no entry found
//            header=newEntry;
//            last=newEntry;
//            return;
//        }
//
//        newEntry.after=header;
//        header.before=newEntry;
//        header=newEntry;
//
//    }
//
//    /**
//     * inserts entry at last.
//     */
//    private void insertLast(Entry<K, V> newEntry){
//
//        if(header==null){
//            header=newEntry;
//            last=newEntry;
//            return;
//        }
//        last.after=newEntry;
//        newEntry.before=last;
//        last=newEntry;
//
//    }
//
//    /**
//     * deletes entry from last.
//     */
//    private void deleteLast(){
//
//        if(header==last){
//            header=last=null;
//            return;
//        }
//
//        last=last.before;
//        last.after=null;
//    }
//
//
//    /**
//     * deletes specific entry and returns before entry.
//     */
//    private Entry<K, V> deleteSpecificEntry(Entry<K, V> newEntry){
//
//        Entry<K, V> current=header;
//        while(!current.key.equals(newEntry.key)){
//            if(current.after==null){   //entry not found
//                return null;
//            }
//            current=current.after;  //move to next node.
//        }
//
//        Entry<K, V> beforeDeleteEntry=current.before;
//        current.before.after=current.after;
//        current.after.before=current.before;  //entry deleted
//        return beforeDeleteEntry;
//    }
//
//
//    /**
//     * Method returns value corresponding to key.
//     * @param key
//     */
//    public V get(K key){
//        int hash = hash(key);
//        if(table[hash] == null){
//            return null;
//        }else{
//            Entry<K,V> temp = table[hash];
//            while(temp!= null){
//                if(temp.key.equals(key))
//                    return temp.value;
//                temp = temp.next; //return value corresponding to key.
//            }
//            return null;   //returns null if key is not found.
//        }
//    }
//
//
//    /**
//     * Method removes key-value pair from HashMapCustom.
//     * @param key
//     */
//    public boolean remove(K deleteKey){
//
//        int hash=hash(deleteKey);
//
//        if(table[hash] == null){
//            return false;
//        }else{
//            Entry<K,V> previous = null;
//            Entry<K,V> current = table[hash];
//
//            while(current != null){ //we have reached last entry node of bucket.
//                if(current.key.equals(deleteKey)){
//                    maintainOrderAfterDeletion(current);
//                    if(previous==null){  //delete first entry node.
//                        table[hash]=table[hash].next;
//                        return true;
//                    }
//                    else{
//                        previous.next=current.next;
//                        return true;
//                    }
//                }
//                previous=current;
//                current = current.next;
//            }
//            return false;
//        }
//
//    }
//
//
//    /**
//     * Method displays all key-value pairs present in HashMapCustom.,
//     * insertion order is not guaranteed, for maintaining insertion order
//     * refer linkedHashMapCustom.
//     * @param key
//     */
//    public void display(){
//
//        Entry<K, V> currentEntry=header;
//        while(currentEntry!=null){
//            System.out.print("{"+currentEntry.key+"="+currentEntry.value+"}" +" ");
//            currentEntry=currentEntry.after;
//        }
//
//    }
//    /**
//     * Method implements hashing functionality, which helps in finding the appropriate
//     * bucket location to store our data.
//     * This is very important method, as performance of HashMapCustom is very much
//     * dependent on this method's implementation.
//     * @param key
//     */
//    private int hash(K key){
//        return Math.abs(key.hashCode()) % capacity;
//    }
//
//}
//
//
///** Copyright (c), AnkitMittal  JavaMadeSoEasy.com */
///**
// * Main class- to test HashMap functionality.
// */
//public class LinkedHashMapCustomApp {
//
//    public static void main(String[] args) {
//        LinkedHashMapCustom<Integer, Integer> linkedHashMapCustom = new LinkedHashMapCustom<Integer, Integer>();
//
//        linkedHashMapCustom.put(21, 12);
//        linkedHashMapCustom.put(25, 121);
//        linkedHashMapCustom.put(30, 151);
//        linkedHashMapCustom.put(33, 15);
//        linkedHashMapCustom.put(35, 89);
//
//        System.out.println("Display values corresponding to keys>");
//        System.out.println("value corresponding to key 21="
//                + linkedHashMapCustom.get(21));
//        System.out.println("value corresponding to key 51="
//                + linkedHashMapCustom.get(51));
//
//        System.out.print("Displaying : ");
//        linkedHashMapCustom.display();
//
//        System.out.println("\n\nvalue corresponding to key 21 removed: "
//                + linkedHashMapCustom.remove(21));
//        System.out.println("value corresponding to key 22 removed: "
//                + linkedHashMapCustom.remove(22));
//
//        System.out.print("Displaying : ");
//        linkedHashMapCustom.display();
//
//    }
//}
// */
package SystemDesignCodes;

import java.util.LinkedList;

/**
 * Created by hadoop on 8/10/17.
 */
public class MinimalTokenBucket {
    private long availableTokens;
    private  long perioidMilliSeconds;
    private LinkedList<Issue> issuedTokens = new LinkedList<>();
    public MinimalTokenBucket(long tokens,long perioidMilliSeconds){
        this.availableTokens = tokens;
        this.perioidMilliSeconds = perioidMilliSeconds;
    }
    private class Issue{
        long tokens;
        long timeStampMillis;

        public Issue(long tokens, long timeStampMillis) {
            this.tokens = tokens;
            this.timeStampMillis = timeStampMillis;
        }
    }

    synchronized boolean tryConsume(int numberOfTokens){
        long now = System.currentTimeMillis();
        clearObseleteIssues(now);
        if(availableTokens>=numberOfTokens){
            availableTokens-=numberOfTokens;
            issuedTokens.addLast(new Issue(numberOfTokens,now));
            return true;
        }
        else {
            return false;
        }
    }

    private void clearObseleteIssues(long now) {
        while (!issuedTokens.isEmpty()){
            Issue issue = issuedTokens.getFirst();
            if(now-issue.timeStampMillis >perioidMilliSeconds){
                availableTokens +=issue.tokens;
                issuedTokens.removeFirst();
            }
            else {
                break;
            }
        }
    }

}
//https://github.com/vladimir-bukhtoyarov/bucket4j/blob/2.1/doc-pages/token-bucket-brief-overview.md#example-of-basic-java-token-bucket-implementation
package SystemDesignCodes;


import java.util.Random;

/**
 * Created_By: stefanie
 * Date: 14-10-23
 * Time: 7:10
 */


public class C10_5_ProducerConsumerWithBlockingFixCapacityQueue {
    static class Producer implements Runnable {
        int counter = 0;
        DZ10_BlockingQueue_Synchronized<Message> queue;
        Random random = new Random();
        int id;

        public Producer(int id, DZ10_BlockingQueue_Synchronized<Message> queue) {
            this.id = id;
            this.queue = queue;
        }

        @Override
        public void run() {
            System.out.printf("PRODUCER-%d IS ON\n", this.id);
            while (true) {
                int time = random.nextInt(5) + 1;
                String message = "task " + id + "-" + counter++ + " need " + time + " seconds";
                Message m = new Message(time, message);
                System.out.printf("PRODUCER-%d: generate a message %s\n ", this.id, m.message);
                queue.push(m);
                System.out.printf("PRODUCER-%d: pushed a message %s in queue, current size is %d\n ", this.id, m.message, queue.size());
                try {
                    Thread.currentThread().sleep(5 * 1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }

        public void start(){
            Thread thread = new Thread(this);
            thread.start();
        }
    }

    static class Consumer implements Runnable {
        DZ10_BlockingQueue_Synchronized<Message> queue;
        int id;

        public Consumer(int id, DZ10_BlockingQueue_Synchronized<Message> queue) {
            this.id = id;
            this.queue = queue;
        }

        @Override
        public void run() {
            System.out.println("CONSUMER IS ON");
            while (true) {
                Message m = queue.pop();
                System.out.printf("CONSUMER-%d: handling %s\n", this.id, m.message);
                try {
                    Thread.currentThread().sleep(m.time * 3 * 1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.printf("CONSUMER-%d: finish %s\n", this.id, m.message);
            }
        }

        public void start(){
            Thread thread = new Thread(this);
            thread.start();
        }
    }

    public static void main(String[] args) {
        DZ10_BlockingQueue_Synchronized<Message> queue = new DZ10_BlockingQueue_Synchronized<>(5);
        for(int i = 0; i < 3; i++){
            new Producer(i+1, queue).start();
            try {
                Thread.currentThread().sleep(3 * 1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        for(int i = 0; i < 5; i++){
            new Consumer(i+1, queue).start();
            try {
                Thread.currentThread().sleep(5 * 1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
class Message {
    int time;
    String message;

    Message(int time, String message) {
        this.time = time;
        this.message = message;
    }
}

package SystemDesignCodes;


import java.util.HashMap;
import java.util.Map;

/**
 * Created by hadoop on 7/10/17.
 */
public class TinyUrl {
    public static int count = 0;
    private static Map<String,String> s2l = new HashMap<>();
    private static Map<String,String> l2s = new HashMap<>();
    private static final String prefix = "http://tiny.url/";

    public String longToShort(String url){
        if(l2s.containsKey(url)){
            return l2s.get(url);
        }

        String shortUrl = prefix + hashLong(url);
        return shortUrl;

    }

    private String hashLong(String url) {
        String ret = "";
        int hashcode = url.hashCode();
        while (hashcode>0){
            int indexvalue = hashcode%62;
            hashcode = hashcode/62;
            if(indexvalue>=0 && indexvalue<=9){
                ret = ""+indexvalue+ret;
            }
            else if(indexvalue>=10 && indexvalue<=35){
                ret = ""+(indexvalue-10 +'a') +ret;
            }
            else {
                ret = ""+(indexvalue-36 + 'A') +ret;
            }
        }
        return ret;
    }
}
package SystemDesignCodes;

import java.util.HashMap;
import java.util.Map;

/**
 * Created by hadoop on 7/10/17.
 */
public class LoadBalancer {

    private class Node{
        int id;
        Node next;
        Node prev;
        Node(int id){
            this.id = id;
            prev = null; // Tricky you got confused as what should be the  value
            next = null;
        }
    }
    Node server;
    Map<Integer,Node> servers;
    LoadBalancer (){
        servers = new HashMap<>();
        server = null;
    }
    public void add(int server_id){
        if(servers.containsKey(server_id)){
            return;
        }
        Node newServer= new Node(server_id);
        if(server == null){
            System.out.println("comig here");
            server = newServer;
            server.next = server;
            server.prev = server;
        }
        else {
            newServer.next = server;
            newServer.prev = server.prev;
            server.prev = newServer;
            newServer.prev.next = newServer;
            server = newServer;
        }
    }
    public void remove(int server_id){
        if(!servers.containsKey(server_id)){
            return;
        }

        Node node = servers.get(server_id);
        node.next.prev = node.prev;
        node.prev.next = node.next;
        servers.remove(server_id);
        if(servers.isEmpty()){
            server = null;
        }
    }

    public int pick(){
       int id =  server.id;
       server = server.next;
       return id;
    }

    public static void main(String args[]){
        LoadBalancer loadBalancer = new LoadBalancer();
        loadBalancer.add(1);
        System.out.println(loadBalancer.server);
        loadBalancer.add(2);
        System.out.println(loadBalancer.server);
        loadBalancer.add(3);
        System.out.println(loadBalancer.server);

        Node ser = loadBalancer.server;
        do{
            System.out.println(ser.id);
            ser = ser.next;
        }while (ser!=loadBalancer.server);
    }
}
/**
 * Created by hadoop on 3/9/17.
 */
public class FlattenBinaryTree {


}

class graphdfsbfstemplate{

   /* dfs(){
        Stack st = new Stack();
        st.push(node);
        node.visited = true;
        printnode(node)
        while(!stack.isEMpty){
        // do not remove until you explored all data

        node = stack.peek() only top seeing not removing
        Node chile = getunvisitednode(node);
        if(chile!=null){ // some child node exist in the system
                child.visited = true;
                 stack.push(child)
                 print node(child)
        }
        else{
            remove item from stack
            stack.pop();
        }

        }

    }

    */
   static TreeNode lastVisit = null;
   public static void flatten(TreeNode root){
       if (root == null){
           return;
       }
       TreeNode savedRight = root.right;
       //initialize a new node, and fill the nodes from root
       if (lastVisit != null){
           lastVisit.left = null;//assign null to left
           lastVisit.right = root;//right will be filled with left child tree first
       }

       lastVisit = root;
       /**go to left first and fill it to lastVisit node's right tree
        * and save right child **/
       flatten(root.left);
       flatten(savedRight);
   }
   }
    class TreeNode{
       int data;
       TreeNode left;
       TreeNode right;
   }
import javax.swing.tree.TreeNode;

/**
 * Created by hadoop on 4/9/17.
 */
public class BinaryTreeBalanced {
    public boolean isBalanced(TreeNode root){
        return diffHeight(root)!=-1;
    }

    private int diffHeight(TreeNode root) {
        if(root == null){
            return 0;
        }
        int leftHeight = diffHeight(root.left);
        int rightHeight = diffHeight(root.right);
        if(leftHeight == -1 || rightHeight == -1 || Math.abs(leftHeight-rightHeight)>1){
            return  -1;
        }
        return Math.max(leftHeight,rightHeight)+1;
    }
    private class TreeNode{
        int data;
        TreeNode left;
        TreeNode right;
    }
    public int maxdepth(TreeNode node){
        if(node == null){
            return 0;
        }
        int left = maxdepth(node.left);
        int right = maxdepth(node.right);
        return Math.max(left,right)+1;
    }
}

class IsValidBinarySearchTree{
    boolean firstValue = true;
    private int lastvalue = Integer.MIN_VALUE;

    boolean IsValidBinarySearchTreeHelper(TreeNode node){
        if(node == null)
            return true;

        boolean left = IsValidBinarySearchTreeHelper(node.left);
        if(firstValue){
            lastvalue = node.data;
            firstValue = false;
        }
        else{
            if(node.data<lastvalue){
                return false;
            }
            lastvalue = node.data;
        }
        if(!left){
            return false;
        }
        return IsValidBinarySearchTreeHelper(node.right);

    }


    private class TreeNode{
        int data;
        TreeNode left;
        TreeNode right;
    }

}
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class CompleteClass {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        Task solver = new Task();
        solver.solve(1, in, out);
        out.close();
    }
}

class Task {
    public void solve(int testNumber, InputReader in, OutputWriter out) {
        int friends = in.readInt();
        int frames = in.readInt();

        out.print(Math.abs(((1<<friends)-1) - frames));
    }
}

class Graph {
    public static final int REMOVED_BIT = 0;

    protected int vertexCount;
    protected int edgeCount;

    private int[] firstOutbound;
    private int[] firstInbound;

    private Edge[] edges;
    private int[] nextInbound;
    private int[] nextOutbound;
    private int[] from;
    private int[] to;
    private long[] weight;
    public long[] capacity;
    private int[] reverseEdge;
    private int[] flags;

    public Graph(int vertexCount) {
        this(vertexCount, vertexCount);
    }

    public Graph(int vertexCount, int edgeCapacity) {
        this.vertexCount = vertexCount;
        firstOutbound = new int[vertexCount];
        Arrays.fill(firstOutbound, -1);

        from = new int[edgeCapacity];
        to = new int[edgeCapacity];
        nextOutbound = new int[edgeCapacity];
        flags = new int[edgeCapacity];
    }

    public static Graph createGraph(int vertexCount, int[] from, int[] to) {
        Graph graph = new Graph(vertexCount, from.length);
        for (int i = 0; i < from.length; i++)
            graph.addSimpleEdge(from[i], to[i]);
        return graph;
    }

    public static Graph createWeightedGraph(int vertexCount, int[] from,
                                            int[] to, long[] weight) {
        Graph graph = new Graph(vertexCount, from.length);
        for (int i = 0; i < from.length; i++)
            graph.addWeightedEdge(from[i], to[i], weight[i]);
        return graph;
    }

    public static Graph createFlowGraph(int vertexCount, int[] from, int[] to,
                                        long[] capacity) {
        Graph graph = new Graph(vertexCount, from.length * 2);
        for (int i = 0; i < from.length; i++)
            graph.addFlowEdge(from[i], to[i], capacity[i]);
        return graph;
    }

    public static Graph createFlowWeightedGraph(int vertexCount, int[] from,
                                                int[] to, long[] weight, long[] capacity) {
        Graph graph = new Graph(vertexCount, from.length * 2);
        for (int i = 0; i < from.length; i++)
            graph.addFlowWeightedEdge(from[i], to[i], weight[i], capacity[i]);
        return graph;
    }

    public static Graph createTree(int[] parent) {
        Graph graph = new Graph(parent.length + 1, parent.length);
        for (int i = 0; i < parent.length; i++)
            graph.addSimpleEdge(parent[i], i + 1);
        return graph;
    }

    public int addEdge(int fromID, int toID, long weight, long capacity,
                       int reverseEdge) {
        ensureEdgeCapacity(edgeCount + 1);
        if (firstOutbound[fromID] != -1)
            nextOutbound[edgeCount] = firstOutbound[fromID];
        else
            nextOutbound[edgeCount] = -1;
        firstOutbound[fromID] = edgeCount;
        if (firstInbound != null) {
            if (firstInbound[toID] != -1)
                nextInbound[edgeCount] = firstInbound[toID];
            else
                nextInbound[edgeCount] = -1;
            firstInbound[toID] = edgeCount;
        }
        this.from[edgeCount] = fromID;
        this.to[edgeCount] = toID;
        if (capacity != 0) {
            if (this.capacity == null)
                this.capacity = new long[from.length];
            this.capacity[edgeCount] = capacity;
        }
        if (weight != 0) {
            if (this.weight == null)
                this.weight = new long[from.length];
            this.weight[edgeCount] = weight;
        }
        if (reverseEdge != -1) {
            if (this.reverseEdge == null) {
                this.reverseEdge = new int[from.length];
                Arrays.fill(this.reverseEdge, 0, edgeCount, -1);
            }
            this.reverseEdge[edgeCount] = reverseEdge;
        }
        if (edges != null)
            edges[edgeCount] = createEdge(edgeCount);
        return edgeCount++;
    }

    protected final GraphEdge createEdge(int id) {
        return new GraphEdge(id);
    }

    public final int addFlowWeightedEdge(int from, int to, long weight,
                                         long capacity) {
        if (capacity == 0) {
            return addEdge(from, to, weight, 0, -1);
        } else {
            int lastEdgeCount = edgeCount;
            addEdge(to, from, -weight, 0, lastEdgeCount + entriesPerEdge());
            return addEdge(from, to, weight, capacity, lastEdgeCount);
        }
    }

    protected int entriesPerEdge() {
        return 1;
    }

    public final int addFlowEdge(int from, int to, long capacity) {
        return addFlowWeightedEdge(from, to, 0, capacity);
    }

    public final int addWeightedEdge(int from, int to, long weight) {
        return addFlowWeightedEdge(from, to, weight, 0);
    }

    public final int addSimpleEdge(int from, int to) {
        return addWeightedEdge(from, to, 0);
    }

    public final int vertexCount() {
        return vertexCount;
    }

    public final int edgeCount() {
        return edgeCount;
    }

    protected final int edgeCapacity() {
        return from.length;
    }

    public final Edge edge(int id) {
        initEdges();
        return edges[id];
    }

    public final int firstOutbound(int vertex) {
        int id = firstOutbound[vertex];
        while (id != -1 && isRemoved(id))
            id = nextOutbound[id];
        return id;
    }

    public final int nextOutbound(int id) {
        id = nextOutbound[id];
        while (id != -1 && isRemoved(id))
            id = nextOutbound[id];
        return id;
    }

    public final int firstInbound(int vertex) {
        initInbound();
        int id = firstInbound[vertex];
        while (id != -1 && isRemoved(id))
            id = nextInbound[id];
        return id;
    }

    public final int nextInbound(int id) {
        initInbound();
        id = nextInbound[id];
        while (id != -1 && isRemoved(id))
            id = nextInbound[id];
        return id;
    }

    public final int source(int id) {
        return from[id];
    }

    public final int destination(int id) {
        return to[id];
    }

    public final long weight(int id) {
        if (weight == null)
            return 0;
        return weight[id];
    }

    public final long capacity(int id) {
        if (capacity == null)
            return 0;
        return capacity[id];
    }

    public final long flow(int id) {
        if (reverseEdge == null)
            return 0;
        return capacity[reverseEdge[id]];
    }

    public final void pushFlow(int id, long flow) {
        if (flow == 0)
            return;
        if (flow > 0) {
            if (capacity(id) < flow)
                throw new IllegalArgumentException("Not enough capacity");
        } else {
            if (flow(id) < -flow)
                throw new IllegalArgumentException("Not enough capacity");
        }
        capacity[id] -= flow;
        capacity[reverseEdge[id]] += flow;
    }

    public int transposed(int id) {
        return -1;
    }

    public final int reverse(int id) {
        if (reverseEdge == null)
            return -1;
        return reverseEdge[id];
    }

    public final void addVertices(int count) {
        ensureVertexCapacity(vertexCount + count);
        Arrays.fill(firstOutbound, vertexCount, vertexCount + count, -1);
        if (firstInbound != null)
            Arrays.fill(firstInbound, vertexCount, vertexCount + count, -1);
        vertexCount += count;
    }

    protected final void initEdges() {
        if (edges == null) {
            edges = new Edge[from.length];
            for (int i = 0; i < edgeCount; i++)
                edges[i] = createEdge(i);
        }
    }

    public final void removeVertex(int vertex) {
        int id = firstOutbound[vertex];
        while (id != -1) {
            removeEdge(id);
            id = nextOutbound[id];
        }
        initInbound();
        id = firstInbound[vertex];
        while (id != -1) {
            removeEdge(id);
            id = nextInbound[id];
        }
    }

    private void initInbound() {
        if (firstInbound == null) {
            firstInbound = new int[firstOutbound.length];
            Arrays.fill(firstInbound, 0, vertexCount, -1);
            nextInbound = new int[from.length];
            for (int i = 0; i < edgeCount; i++) {
                nextInbound[i] = firstInbound[to[i]];
                firstInbound[to[i]] = i;
            }
        }
    }

    public final boolean flag(int id, int bit) {
        return (flags[id] >> bit & 1) != 0;
    }

    public final void setFlag(int id, int bit) {
        flags[id] |= 1 << bit;
    }

    public final void removeFlag(int id, int bit) {
        flags[id] &= -1 - (1 << bit);
    }

    public final void removeEdge(int id) {
        setFlag(id, REMOVED_BIT);
    }

    public final void restoreEdge(int id) {
        removeFlag(id, REMOVED_BIT);
    }

    public final boolean isRemoved(int id) {
        return flag(id, REMOVED_BIT);
    }

    public final Iterable<Edge> outbound(final int id) {
        initEdges();
        return new Iterable<Edge>() {
            public Iterator<Edge> iterator() {
                return new EdgeIterator(id, firstOutbound, nextOutbound);
            }
        };
    }

    public final Iterable<Edge> inbound(final int id) {
        initEdges();
        initInbound();
        return new Iterable<Edge>() {
            public Iterator<Edge> iterator() {
                return new EdgeIterator(id, firstInbound, nextInbound);
            }
        };
    }

    protected void ensureEdgeCapacity(int size) {
        if (from.length < size) {
            int newSize = Math.max(size, 2 * from.length);
            if (edges != null)
                edges = resize(edges, newSize);
            from = resize(from, newSize);
            to = resize(to, newSize);
            nextOutbound = resize(nextOutbound, newSize);
            if (nextInbound != null)
                nextInbound = resize(nextInbound, newSize);
            if (weight != null)
                weight = resize(weight, newSize);
            if (capacity != null)
                capacity = resize(capacity, newSize);
            if (reverseEdge != null)
                reverseEdge = resize(reverseEdge, newSize);
            flags = resize(flags, newSize);
        }
    }

    private void ensureVertexCapacity(int size) {
        if (firstOutbound.length < size) {
            int newSize = Math.max(size, 2 * from.length);
            firstOutbound = resize(firstOutbound, newSize);
            if (firstInbound != null)
                firstInbound = resize(firstInbound, newSize);
        }
    }

    protected final int[] resize(int[] array, int size) {
        int[] newArray = new int[size];
        System.arraycopy(array, 0, newArray, 0, array.length);
        return newArray;
    }

    private long[] resize(long[] array, int size) {
        long[] newArray = new long[size];
        System.arraycopy(array, 0, newArray, 0, array.length);
        return newArray;
    }

    private Edge[] resize(Edge[] array, int size) {
        Edge[] newArray = new Edge[size];
        System.arraycopy(array, 0, newArray, 0, array.length);
        return newArray;
    }

    public final boolean isSparse() {
        return vertexCount == 0 || edgeCount * 20 / vertexCount <= vertexCount;
    }

    protected class GraphEdge implements Edge {
        protected int id;

        protected GraphEdge(int id) {
            this.id = id;
        }

        public int getSource() {
            return source(id);
        }

        public int getDestination() {
            return destination(id);
        }

        public long getWeight() {
            return weight(id);
        }

        public long getCapacity() {
            return capacity(id);
        }

        public long getFlow() {
            return flow(id);
        }

        public void pushFlow(long flow) {
            Graph.this.pushFlow(id, flow);
        }

        public boolean getFlag(int bit) {
            return flag(id, bit);
        }

        public void setFlag(int bit) {
            Graph.this.setFlag(id, bit);
        }

        public void removeFlag(int bit) {
            Graph.this.removeFlag(id, bit);
        }

        public int getTransposedID() {
            return transposed(id);
        }

        public Edge getTransposedEdge() {
            int reverseID = getTransposedID();
            if (reverseID == -1)
                return null;
            initEdges();
            return edge(reverseID);
        }

        public int getReverseID() {
            return reverse(id);
        }

        public Edge getReverseEdge() {
            int reverseID = getReverseID();
            if (reverseID == -1)
                return null;
            initEdges();
            return edge(reverseID);
        }

        public int getID() {
            return id;
        }

        public void remove() {
            removeEdge(id);
        }

        public void restore() {
            restoreEdge(id);
        }
    }

    public class EdgeIterator implements Iterator<Edge> {
        private int edgeID;
        private final int[] next;
        private int lastID = -1;

        public EdgeIterator(int id, int[] first, int[] next) {
            this.next = next;
            edgeID = nextEdge(first[id]);
        }

        private int nextEdge(int id) {
            while (id != -1 && isRemoved(id))
                id = next[id];
            return id;
        }

        public boolean hasNext() {
            return edgeID != -1;
        }

        public Edge next() {
            if (edgeID == -1)
                throw new NoSuchElementException();
            lastID = edgeID;
            edgeID = nextEdge(next[lastID]);
            return edges[lastID];
        }

        public void remove() {
            if (lastID == -1)
                throw new IllegalStateException();
            removeEdge(lastID);
            lastID = -1;
        }
    }

}

interface Edge {
    public int getSource();

    public int getDestination();

    public long getWeight();

    public long getCapacity();

    public long getFlow();

    public void pushFlow(long flow);

    public boolean getFlag(int bit);

    public void setFlag(int bit);

    public void removeFlag(int bit);

    public int getTransposedID();

    public Edge getTransposedEdge();

    public int getReverseID();

    public Edge getReverseEdge();

    public int getID();

    public void remove();

    public void restore();
}

class BidirectionalGraph extends Graph {
    public int[] transposedEdge;

    public BidirectionalGraph(int vertexCount) {
        this(vertexCount, vertexCount);
    }

    public BidirectionalGraph(int vertexCount, int edgeCapacity) {
        super(vertexCount, 2 * edgeCapacity);
        transposedEdge = new int[2 * edgeCapacity];
    }

    public static BidirectionalGraph createGraph(int vertexCount, int[] from,
                                                 int[] to) {
        BidirectionalGraph graph = new BidirectionalGraph(vertexCount,
                from.length);
        for (int i = 0; i < from.length; i++)
            graph.addSimpleEdge(from[i], to[i]);
        return graph;
    }

    public static BidirectionalGraph createWeightedGraph(int vertexCount,
                                                         int[] from, int[] to, long[] weight) {
        BidirectionalGraph graph = new BidirectionalGraph(vertexCount,
                from.length);
        for (int i = 0; i < from.length; i++)
            graph.addWeightedEdge(from[i], to[i], weight[i]);
        return graph;
    }

    public static BidirectionalGraph createFlowGraph(int vertexCount,
                                                     int[] from, int[] to, long[] capacity) {
        BidirectionalGraph graph = new BidirectionalGraph(vertexCount,
                from.length * 2);
        for (int i = 0; i < from.length; i++)
            graph.addFlowEdge(from[i], to[i], capacity[i]);
        return graph;
    }

    public static BidirectionalGraph createFlowWeightedGraph(int vertexCount,
                                                             int[] from, int[] to, long[] weight, long[] capacity) {
        BidirectionalGraph graph = new BidirectionalGraph(vertexCount,
                from.length * 2);
        for (int i = 0; i < from.length; i++)
            graph.addFlowWeightedEdge(from[i], to[i], weight[i], capacity[i]);
        return graph;
    }

    @Override
    public int addEdge(int fromID, int toID, long weight, long capacity,
                       int reverseEdge) {
        int lastEdgeCount = edgeCount;
        super.addEdge(fromID, toID, weight, capacity, reverseEdge);
        super.addEdge(toID, fromID, weight, capacity, reverseEdge == -1 ? -1
                : reverseEdge + 1);
        this.transposedEdge[lastEdgeCount] = lastEdgeCount + 1;
        this.transposedEdge[lastEdgeCount + 1] = lastEdgeCount;
        return lastEdgeCount;
    }

    @Override
    protected int entriesPerEdge() {
        return 2;
    }

    @Override
    public final int transposed(int id) {
        return transposedEdge[id];
    }

    @Override
    protected void ensureEdgeCapacity(int size) {
        if (size > edgeCapacity()) {
            super.ensureEdgeCapacity(size);
            transposedEdge = resize(transposedEdge, edgeCapacity());
        }
    }
}

class IOUtils {
    public static long[] readLongArray(InputReader in, int size) {
        long[] array = new long[size];
        for (int i = 0; i < size; i++)
            array[i] = in.readLong();
        return array;
    }

    public static int[] readIntArray(InputReader in, int size) {
        int[] array = new int[size];
        for (int i = 0; i < size; i++)
            array[i] = in.readInt();
        return array;
    }
}

interface Function<A, V> {
    public abstract V value(A argument);
}

class IntegerUtils {

    public static List<Pair<Long, Integer>> factorize(long number) {
        List<Pair<Long, Integer>> result = new ArrayList<Pair<Long, Integer>>();
        for (long i = 2; i * i <= number; i++) {
            if (number % i == 0) {
                int power = 0;
                do {
                    power++;
                    number /= i;
                } while (number % i == 0);
                result.add(Pair.makePair(i, power));
            }
        }
        if (number != 1)
            result.add(Pair.makePair(number, 1));
        return result;
    }

    public static List<Long> getDivisors(long number) {
        List<Pair<Long, Integer>> primeDivisors = factorize(number);
        return getDivisorsImpl(primeDivisors, 0, 1, new ArrayList<Long>());
    }

    private static List<Long> getDivisorsImpl(
            List<Pair<Long, Integer>> primeDivisors, int index, long current,
            List<Long> result) {
        if (index == primeDivisors.size()) {
            result.add(current);
            return result;
        }
        long p = primeDivisors.get(index).first;
        int power = primeDivisors.get(index).second;
        for (int i = 0; i <= power; i++) {
            getDivisorsImpl(primeDivisors, index + 1, current, result);
            current *= p;
        }
        return result;
    }
}

class Pair<U, V> implements Comparable<Pair<U, V>> {
    public final U first;
    public final V second;

    public static <U, V> Pair<U, V> makePair(U first, V second) {
        return new Pair<U, V>(first, second);
    }

    private Pair(U first, V second) {
        this.first = first;
        this.second = second;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;

        Pair pair = (Pair) o;

        return !(first != null ? !first.equals(pair.first) : pair.first != null)
                && !(second != null ? !second.equals(pair.second)
                : pair.second != null);

    }

    @Override
    public int hashCode() {
        int result = first != null ? first.hashCode() : 0;
        result = 31 * result + (second != null ? second.hashCode() : 0);
        return result;
    }

    public Pair<V, U> swap() {
        return makePair(second, first);
    }

    @Override
    public String toString() {
        return "(" + first + "," + second + ")";
    }

    @SuppressWarnings({ "unchecked" })
    public int compareTo(Pair<U, V> o) {
        int value = ((Comparable<U>) first).compareTo(o.first);
        if (value != 0)
            return value;
        return ((Comparable<V>) second).compareTo(o.second);
    }
}

class InputReader {
    private boolean finished = false;

    private InputStream stream;
    private byte[] buf = new byte[1024];
    private int curChar;
    private int numChars;
    private SpaceCharFilter filter;

    public InputReader(InputStream stream) {
        this.stream = stream;
    }

    public int read() {
        if (numChars == -1)
            throw new InputMismatchException();
        if (curChar >= numChars) {
            curChar = 0;
            try {
                numChars = stream.read(buf);
            } catch (IOException e) {
                throw new InputMismatchException();
            }
            if (numChars <= 0)
                return -1;
        }
        return buf[curChar++];
    }

    public int peek() {
        if (numChars == -1)
            return -1;
        if (curChar >= numChars) {
            curChar = 0;
            try {
                numChars = stream.read(buf);
            } catch (IOException e) {
                return -1;
            }
            if (numChars <= 0)
                return -1;
        }
        return buf[curChar];
    }

    public int readInt() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        int res = 0;
        do {
            if (c < '0' || c > '9')
                throw new InputMismatchException();
            res *= 10;
            res += c - '0';
            c = read();
        } while (!isSpaceChar(c));
        return res * sgn;
    }

    public long readLong() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        long res = 0;
        do {
            if (c < '0' || c > '9')
                throw new InputMismatchException();
            res *= 10;
            res += c - '0';
            c = read();
        } while (!isSpaceChar(c));
        return res * sgn;
    }

    public String readString() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        StringBuilder res = new StringBuilder();
        do {
            if (Character.isValidCodePoint(c))
                res.appendCodePoint(c);
            c = read();
        } while (!isSpaceChar(c));
        return res.toString();
    }

    public boolean isSpaceChar(int c) {
        if (filter != null)
            return filter.isSpaceChar(c);
        return isWhitespace(c);
    }

    public static boolean isWhitespace(int c) {
        return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
    }

    private String readLine0() {
        StringBuilder buf = new StringBuilder();
        int c = read();
        while (c != '\n' && c != -1) {
            if (c != '\r')
                buf.appendCodePoint(c);
            c = read();
        }
        return buf.toString();
    }

    public String readLine() {
        String s = readLine0();
        while (s.trim().length() == 0)
            s = readLine0();
        return s;
    }

    public String readLine(boolean ignoreEmptyLines) {
        if (ignoreEmptyLines)
            return readLine();
        else
            return readLine0();
    }

    public BigInteger readBigInteger() {
        try {
            return new BigInteger(readString());
        } catch (NumberFormatException e) {
            throw new InputMismatchException();
        }
    }

    public char readCharacter() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        return (char) c;
    }

    public double readDouble() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        double res = 0;
        while (!isSpaceChar(c) && c != '.') {
            if (c == 'e' || c == 'E')
                return res * Math.pow(10, readInt());
            if (c < '0' || c > '9')
                throw new InputMismatchException();
            res *= 10;
            res += c - '0';
            c = read();
        }
        if (c == '.') {
            c = read();
            double m = 1;
            while (!isSpaceChar(c)) {
                if (c == 'e' || c == 'E')
                    return res * Math.pow(10, readInt());
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                m /= 10;
                res += (c - '0') * m;
                c = read();
            }
        }
        return res * sgn;
    }

    public boolean isExhausted() {
        int value;
        while (isSpaceChar(value = peek()) && value != -1)
            read();
        return value == -1;
    }

    public String next() {
        return readString();
    }

    public SpaceCharFilter getFilter() {
        return filter;
    }

    public void setFilter(SpaceCharFilter filter) {
        this.filter = filter;
    }

    public interface SpaceCharFilter {
        public boolean isSpaceChar(int ch);
    }
}

class OutputWriter {
    private final PrintWriter writer;

    public OutputWriter(OutputStream outputStream) {
        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(
                outputStream)));
    }

    public OutputWriter(Writer writer) {
        this.writer = new PrintWriter(writer);
    }

    public void print(char[] array) {
        writer.print(array);
    }

    public void print(Object... objects) {
        for (int i = 0; i < objects.length; i++) {
            if (i != 0)
                writer.print(' ');
            writer.print(objects[i]);
        }
    }

    public void print(int[] array) {
        for (int i = 0; i < array.length; i++) {
            if (i != 0)
                writer.print(' ');
            writer.print(array[i]);
        }
    }

    public void print(long[] array) {
        for (int i = 0; i < array.length; i++) {
            if (i != 0)
                writer.print(' ');
            writer.print(array[i]);
        }
    }

    public void printLine(int[] array) {
        print(array);
        writer.println();
    }

    public void printLine(long[] array) {
        print(array);
        writer.println();
    }

    public void printLine() {
        writer.println();
    }

    public void printLine(Object... objects) {
        print(objects);
        writer.println();
    }

    public void print(char i) {
        writer.print(i);
    }

    public void printLine(char i) {
        writer.println(i);
    }

    public void printLine(char[] array) {
        writer.println(array);
    }

    public void printFormat(String format, Object... objects) {
        writer.printf(format, objects);
    }

    public void close() {
        writer.close();
    }

    public void flush() {
        writer.flush();
    }

    public void print(long i) {
        writer.print(i);
    }

    public void printLine(long i) {
        writer.println(i);
    }

    public void print(int i) {
        writer.print(i);
    }

    public void printLine(int i) {
        writer.println(i);
    }
}

class ArrayUtils {

    public static int[] createOrder(int size) {
        int[] order = new int[size];
        for (int i = 0; i < size; i++)
            order[i] = i;
        return order;
    }

    public static int maxPosition(int[] array) {
        return maxPosition(array, 0, array.length);
    }

    public static int maxPosition(int[] array, int from, int to) {
        if (from >= to)
            return -1;
        int max = array[from];
        int result = from;
        for (int i = from + 1; i < to; i++) {
            if (array[i] > max) {
                max = array[i];
                result = i;
            }
        }
        return result;
    }

}package codingblocks;

/**
 * Created by hadoop on 30/9/17.
 */
public class BirthDayParadox {
}

/*

Made with by


Made with by

#include <iostream>
using namespace std;


int main() {
    //Compute the number of ppl such that

    float num = 365;
    float denom = 365;

    // p denotes the prob of some ppl having birthday on same date
    float p = 1;

    //n denotes the number of people needed
    int n = 0;

    // p becomes less than 0.5 because we are starting from 1
    while(p>0.5){
        p = p*(num)/denom;
        num--;
        n++;
        cout<<"Probability is "<<p<<" and "<<" no of people are "<<n<<endl;
    }

    return 0;
}

 */
/*
#include <iostream>
using namespace std;

int main() {

        //Numbers from 1 to 49
        //Choose a subset of 6 Numbers

        int a[] = {1,2,4,5,6,7,8,10,12};
        int n = sizeof(a)/sizeof(int);

        for(int i=0;i<n-5;i++){

            for(int j=i+1;j<n-4;j++){

                for(int k=j+1;k<n-3;k++){

                    for(int l=k+1;l<n-2;l++){

                        for(int m = l+1;m<n-1;m++){

                            for(int o= m+1;o<n;o++){

                                cout<<a[i]<<","<<a[j]<<","<<a[k]<<","<<a[l]<<","<<a[m]<<","<<a[o]<<endl;
                            }

                        }

                    }
                }
            }
        }
        return 0;


}

 */package codingblocks;

import java.util.Scanner;

/**
 * Created by hadoop on 5/10/17.
 */
public class Lcm {
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        int a = sc.nextInt();
        int b = sc.nextInt();
        System.out.println(a*b/gcd(a,b));
    }

    private static int gcd(int a, int b) {
        if (a > b) {
            return gcd(b, a);
        }
        if (b % a == 0) {
            return a;
        }
        return gcd(b % a, a);
    }
}package codingblocks;

import java.util.Scanner;

/**
 * Created by hadoop on 5/10/17.
 */
public class Hulk {
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        int test = sc.nextInt();
        while (test-->0){
            int number = sc.nextInt();
            int ans = 0;
            while (number!=0){
                number = number & (number-1);
                ans++;
            }
            System.out.println(ans);
        }
    }
}
package codingblocks;

import java.util.*;

/**
 * Created by hadoop on 5/10/17.
 */
public class Prime {
    static Set<Integer> getprimes(int n){
        Set<Integer> list = new HashSet<>();
        for(int i=2;i<=n;i++){
            list.add(i);
        }
        for(int i=2;i*i<=n;i++){
            for(int j=i*i;j<=n;j=j+i){
                if(list.contains(j)){
                    list.remove(j);
                }
            }
        }
        return list;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int x = scanner.nextInt();

        Object[] array = getprimes(x).toArray();
        int []primearray = new int[array.length];
        int i=0;
        for(int prime :getprimes(x)){
            primearray[i] = prime;
            i++;
        }
        int minprime = mincount(primearray,x);
        System.out.print(minprime);
    }

    private static int mincount(int[] primearray, int x) {
        int []dp = new  int[x+1];
        Arrays.fill(dp,Integer.MAX_VALUE);
        dp[0]=0;
        for(int i=0;i<primearray.length;i++){
            for(int j=primearray[i];j<=x;j++){
                if(primearray[i]<=j && dp[j-primearray[i]]!=Integer.MAX_VALUE && dp[j]>dp[j-primearray[i]]+1){
                    dp[j] = dp[j-primearray[i]]+1;
                }
            }
        }
        return dp[x];
    }
}package codingblocks;

import java.util.Scanner;

/**
 * Created by hadoop on 5/10/17.
 */
public class BaseConversion {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int base1 = sc.nextInt();
        int base2 = sc.nextInt();
        String num = sc.next();
        int numbase1=0;
        for(int i=0;i<num.toCharArray().length;i++){
            numbase1 = numbase1*base1+(num.charAt(i)-'0');
        }
        String numbase2="";
        while (numbase1>0){
            numbase2 = numbase1%base2+numbase2;
            numbase1 = numbase1/base2;
        }
        System.out.println(numbase2);
    }
}
package codingblocks;

import java.math.BigInteger;
import java.util.Scanner;

class Julka {
    
   static void compute(BigInteger n,BigInteger k){
       
       BigInteger x,y;

       
       x = n.subtract(k);
       x = x.divide(BigInteger.valueOf(2));
       
       y = x.add(k);
       
       System.out.println(y);
       System.out.println(x);
      
   }

    


    public static void main(String args[]) {
        BigInteger n,k,ans;
        Scanner sc = new Scanner(System.in);
        
        int test = 10;
        while(test>0){
            n = sc.nextBigInteger();
            k = sc.nextBigInteger();
            compute(n,k);
            test = test-1;
        }
        
        
    }
}package codingblocks;

import java.util.Arrays;
import java.util.Comparator;
import java.util.Scanner;

/**
 * Created by hadoop on 5/10/17.
 */
public class Strings {
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        int test =sc.nextInt();
        String [] array = new String[test];
        int i=0;
        while (test-->0){
            array[i] = sc.next();
            System.out.println(array[i]);
            i++;
        }
        Arrays.sort(array, new Comparator<String>() {
            @Override
            public int compare(String o1, String o2) {
                char a[] = o1.toCharArray();
                char b[] =o2.toCharArray();
                int i=0;
                int j=0;
                while (i<a.length && j<b.length){
                    if(a[i]!=b[j]){
                        return a[i]-b[j];
                    }

                }
                return b.length-a.length;
            }
        });
        for (int k=0;k<array.length;k++) {
            System.out.println(array[k]);
        }
    }
}
package codingblocks;

import java.util.Arrays;
import java.util.Scanner;

/**
 * Created by hadoop on 5/10/17.
 */
public class Ncr {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int k = sc.nextInt();
        int cache [][] = new int[n+1][k+1];
        for(int i=0;i<=n;i++){
            Arrays.fill(cache[i],Integer.MAX_VALUE);
        }
        int value = nckit(n,k);
        System.out.print(value);
    }

    private static int nck(int n, int k,int[][]cache) {
        if(cache[n][k]!=Integer.MAX_VALUE){
            return cache[n][k];
        }
        if(n<k){
            return 0;
        }
        if(n == 0){
            return 0;
        }
        if(k ==0){
            return 1;
        }
        if(n == k){
            return 1;
        }
        if( k ==1){
            return n;
        }
        return cache[n][k]=((nck(n-1,k-1,cache)%1000000007)+ (nck(n-1,k,cache)%1000000007))%1000000007;
    }
    private static int nckit(int n,int k){
        int cache[][] = new int[n+1][k+1];

        for(int j=1;j<=k;j++){
            cache[0][j]=0;
        }
        for(int i=0;i<=n;i++){
            cache[i][0]=1;
        }
        for(int i=1;i<=n;i++){
            for(int j=1;j<=k;j++){
                cache[i][j] = ((cache[i-1][j]%1000000007)+(cache[i-1][j-1]%1000000007))%1000000007;
            }
        }
        return cache[n][k];
    }
}
package codingblocks;

/**
 * Created by hadoop on 30/9/17.
 */
public class BigFactorial {

    void big_factorial(int number){
        int a[] = new int[100];
        a[0] = 1;
        int n = 1; // denotes index before we which we have processed things
        for(int i=2;i<=number;i++){
            n = multiply(a,n,i);
            System.out.println(n);
        }
        System.out.println("ans");
        for(int i=n-1;i>=0;i--){
            System.out.print(a[i]);
        }
    }

    private int multiply(int[] a, int n, int no) {
        int carry = 0;
        for(int i=0;i<n;i++){
            int product = a[i]*no +carry;
            a[i] = product%10;
            carry = product/10;
        }
        while (carry!=0){
            a[n] = carry%10;
            carry= carry/10;
            n++;
        }
        return n;
    }
    public static void main(String args[]){
        BigFactorial bigFactorial = new BigFactorial();
        bigFactorial.big_factorial(10);
    }
}

/*

Made with by


Made with by

#include <iostream>
using namespace std;

void multiply(int *a,int &n,int no){

    // array 1 2 3 0 0 0 0 by number 4
    int carry = 0;

    for(int i=0;i<n;i++){

        int product = a[i]*no + carry;
        a[i] = product%10;
        carry = product/10;
    }

    //Left out carry
    while(carry){
        a[n] = carry%10;
        carry = carry/10;
        n++;
    }


}


void big_factorial(int number){

    //Assuming that ans contains at max 1000 digits, all positions are 0 initially
    int *a = new int[1000]{0};

    a[0] = 1;
    int n = 1; // which denotes the index of the array, before which we have stored some digits

    for(int i=2;i<=number;i++){
        multiply(a,n,i);
    }

    //Print the digits in the reverse order

    for(int i=n-1;i>=0;i--){
        cout<<a[i];
    }
    cout<<endl;
    cout<<n<<" digits "<<endl;
    cout<<endl;

}

int main() {
    big_factorial(100);

}

 */
/*
import java.math.BigInteger;
import java.util.Scanner;

class Julka {

   static void compute(BigInteger n,BigInteger k){

       BigInteger x,y;

       x = n.subtract(k);
       x = x.divide(BigInteger.valueOf(2));

       y = x.add(k);

       System.out.println(y);
       System.out.println(x);

   }




    public static void main(String args[]) {
        BigInteger n,k,ans;
        Scanner sc = new Scanner(System.in);

        int test = 10;
        while(test>0){
            n = sc.nextBigInteger();
            k = sc.nextBigInteger();
            compute(n,k);
            test = test-1;
        }


    }
}
 */package codingblocks;

import java.util.Scanner;

/**
 * Created by hadoop on 5/10/17.
 */
public class Modify {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String s = scanner.next();
        String ans = "";
        for(int i=0;i<s.length();i++){
            if(s.charAt(i)>='5'){
                ans = ans+('9'-s.charAt(i));
            }
            else {
                ans = ans + s.charAt(i);
            }
        }
        System.out.println(ans);
    }
}
////package codingblocks;
////
/////**
//// * Created by hadoop on 5/10/17.
//// */
////public class CodingBlocks {
////}
//#include <iostream>
//#include <vector>
//using namespace std;
//
//        #define ll long long
//        #define MOD 1000000000
//
//        ll k;
//        vector<ll> a,b,c;
//
////Multiply two matrices
//        vector<vector<ll> > multiply(vector<vector<ll> > A,vector<vector<ll> > B ){
//
//        //third matrix mei result store
//        vector<vector<ll> > C(k+1,vector<ll>(k+1));
//
//        for(int i=1;i<=k;i++){
//        for(int j=1;j<=k;j++){
//        for(int x=1;x<=k;x++){
//
//        C[i][j] = (C[i][j] + (A[i][x]*B[x][j])%MOD)%MOD;
//        }
//
//        }
//        }
//
//
//        return C;
//        }
//
//
//        vector<vector<ll> >  pow(vector<vector<ll> > A,ll p){
//
//        //Base case
//        if(p==1){
//        return A;
//        }
//        //Rec Case
//        if(p&1){
//        return multiply(A, pow(A,p-1));
//        }
//        else{
//
//        vector<vector<ll> > X = pow(A,p/2);
//        return multiply(X,X);
//        }
//
//        }
//
//
//        ll compute(ll n){
//        //Base case
//        if(n==0){
//        return 0;
//        }
//
//        //Suppose n<=k
//        if(n<=k){
//        return b[n-1];
//        }
//
//        //Otherwise we use matrix exponentiation, indexing 1 se
//        vector<ll> F1(k+1);
//
//        for(int i=1;i<=k;i++){
//        F1[i] = b[i-1];
//        }
//
//        //2. Transformation matrix
//        vector<vector<ll> > T(k+1,vector<ll>(k+1));
//        // Let init T
//
//        for(int i=1;i<=k;i++){
//        for(int j=1;j<=k;j++){
//
//        if(i<k){
//        if(j==i+1){
//        T[i][j] = 1;
//        }
//        else{
//        T[i][j] = 0;
//        }
//        continue;
//        }
//        //Last Row - store the Coefficients in reverse order
//        T[i][j] = c[k-j];
//
//        }
//
//        }
//
//        // 3. T^n-1
//        T = pow(T,n-1);
//
//        // 4. multiply by F1
//        ll res = 0;
//        for(int i=1;i<=k;i++){
//        res = (res + (T[1][i]*F1[i])%MOD)%MOD;
//        }
//
//        return res;
//
//        }
//
//        int main() {
//
//        ll t,n,num;
//
//        cin>>t;
//        while(t--){
//
//        cin>>k;
//
//        //Init Vector F1
//        for(int i=0;i<k;i++){
//        cin>>num;
//        b.push_back(num);
//        }
//
//        //Coefficients
//        for(int i=0;i<k;i++){
//        cin>>num;
//        c.push_back(num);
//        }
//        // the value of n
//        cin>>n;
//        cout<< compute(n)<<endl;
//
//        b.clear();
//        c.clear();
//        }
//
//        return 0;
//
//        }
package codingblocks;

import java.util.Scanner;

/**
 * Created by hadoop on 5/10/17.
 */
public class Factorial {
    public static void main(String[] args) {
        Scanner sc  = new Scanner(System.in);
        int fact = sc.nextInt();
        int []array = new int[40];
        array[0] =1;
        int n =1;
        for(int i=2;i<=fact;i++){
                n = multiply(array,i,n);
        }
        for (int i=0;i<n;i++){
            System.out.print(array[n-1-i]);
        }
    }

    private static int multiply(int[] array, int i, int n) {
        int carry = 0;
        int index = 0;
        while (index<n){
            int multiply = array[index]*i+carry;
            array[index] = multiply%10;
            carry = multiply/10;
            index++;
        }
        while (carry>0){
            array[index]=carry%10;
            carry = carry/10;
            index++;
        }
        return index;
    }
}
package codingblocks;

import java.util.Deque;
import java.util.LinkedList;
import java.util.Scanner;

/**
 * Created by hadoop on 5/10/17.
 */
public class ImportanceTime {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int number = sc.nextInt();
        int numbertem= number;
        Deque<Integer> dequeex = new LinkedList<>();
        Deque<Integer> dequeid = new LinkedList<>();
        while (numbertem-->0){
            dequeex.addLast(sc.nextInt());
        }
        numbertem = number;
        while (numbertem-->0){
            dequeid.addLast(sc.nextInt());
        }
        int totaltime = 0;
        while (!dequeex.isEmpty()){
            if(dequeex.peekFirst() == dequeid.peekFirst()){
                dequeex.removeFirst();
                dequeid.removeFirst();
            }
            else {
                dequeex.addLast(dequeex.pollFirst());
            }
            totaltime = totaltime+1;
        }
        System.out.println(totaltime);
    }
}
package codingblocks;

/**
 * Created by hadoop on 5/10/17.
 */
public class LinearRecurecnce {
    public static void main(String[] args) {
        //f(i) = f(i-1)+f(i-2) ... so we need first 2 terms if some recursion depedent on last
                //two terms
                  //      T *f1 = f2
                    //            T*f2 = f3
        //T*f3 = f4
        //fn = t*fn-1 =t^n-1 f1
        //t^n-1 can be solved using matrix exponantion
        // k*k --> k^3 logn  time complexity for matrix power somthing
        //
    }
}
package codingblocks;

import java.util.Scanner;

/**
 * Created by hadoop on 4/10/17.
 */
public class UniqueNumber2 {
    public static void main(String args[]){
        Scanner scanner = new Scanner(System.in);
        int ans = 0;
        Integer line = scanner.nextInt();
       // String split[] = line.split(" ");
        int array [] = new int[line];
        int testcase = 0;
        while(line-->0){
            array[testcase] = scanner.nextInt();
            ans = ans ^ array[testcase];
            testcase++;
        }

        int point = ans & -1*ans;
        int num1=0;
        int num2=0;
        for(int i=0;i<=testcase-1;i++){
            if((array[i] & point) !=0){
                num1 = num1 ^ array[i];
            }
            else if((array[i] & point) ==0){
                num2 = num2 ^ array[i];
            }
            else {
                System.out.println("problem cant happen"+array[i]);
                continue;
            }
        }
        if(num1<num2) {
            System.out.print(num1 + " ");
            System.out.print(num2);
        }
        else {
            System.out.print(num2 + " ");
            System.out.print(num1);
        }
    }
}
package codingblocks;

import java.util.Scanner;

/**
 * Created by hadoop on 4/10/17.
 */
public class UNIQUENUMBERIII {
    public static void main(String args[]){
        Scanner sc = new Scanner(System.in);
        int testcase = sc.nextInt();
        int array[] =new int[32];
        while (testcase -->0){
            int number = sc.nextInt();
            int index = 0;
            while (number>0){
                int bit = number&1;
                array[index] += bit;
                number = number/2;
                index++;
            }
        }
        int ans = 0;
        int base = 2;
        for(int i=31;i>=0;i--){
            array[i] = array[i]%3;
            ans = ans*base +array[i];
        }
        System.out.println(ans);
    }
}
package codingblocks;

import java.util.Scanner;

/**
 * Created by hadoop on 5/10/17.
 */
public class EvalFunc {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int test =sc.nextInt();
        int ans = Double.valueOf(4*power(test,3)+5*power(test,2)-6*test+14).intValue();
        System.out.println(ans);
    }
    static int power(int x,int n){

        if(n ==1){
            return x;
        }
        if( n ==0){
            return 1;
        }
        int mid = power(x,n/2);
        if((mid & 1 )==1){
            return  mid * mid *x;
        }
        else
            return mid*mid;
    }
    static int powerhelper(int x,int n){
        if(x<0){
            if((n & 1) ==0){
                return power(-1*x,n);
            }
            else {
                return -1*power(-1*x,n);
            }
        }
        return power(x,n);
    }
}
package CodingNinjas;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.Set;

/**
 * Created by hadoop on 11/10/17.
 */
public class UniqueChars {
    public static void main(String[] args) {
        System.out.println(unique("ababacd"));
    }
    static String unique(String a){
        Set set = new LinkedHashSet();
        for(char var:a.toCharArray()){
            set.add(var);
        }
        Iterator it = set.iterator();
        String returned="";
        while (it.hasNext()){
            returned = returned+it.next();
        }
        return returned;
    }
}
package CodingNinjas;

import java.util.HashSet;
import java.util.Scanner;
import java.util.Set;

/**
 * Created by hadoop on 11/10/17.
 */
public class LongestConsecutiveSequence {
    public static void main(String args[]) {
        System.out.println(methodcall());
    }

    static int methodcall() {
        Scanner sc = new Scanner(System.in);
        int i = sc.nextInt();
        int index = 0;
        int[] array = new int[i];
        Set set = new HashSet<>();
        while (i-- > 0) {
            array[index] = sc.nextInt();
            set.add(array[index]);
            index++;
        }
        int ans = Integer.MIN_VALUE;
        for (int k = 0; k < array.length; k++) {
            if (set.remove(array[k])) {
                int size = 1;
                int val = array[k];
                while (set.remove(val - 1)) {
                    val = val - 1;
                }
                size = size + (array[k] - val);

                val = array[k];

                while (set.remove(val + 1)) {
                    val = val + 1;
                }
                size = size + (val - array[k]);

                ans = Math.max(size, ans);
            }
        }
        return ans;
    }
}
package CodingNinjas;

/**
 * Created by hadoop on 11/10/17.
 */
public class KthLargest {
    public static void main(String args[]){
        int array[] ={4,3,2,5,6,9};

        // min head best solution to find kth largest
        //          PriorityQueue<Integer> pq = new PriorityQueue<>(new Comparator<Integer>() {
//             @Override
//             public int compare(Integer o1, Integer o2) {
//                 return o1-o2;
//             }
//         });
//         for(int i=0;i<nums.length;i++){
//             if(i<k) {
//                 pq.add(nums[i]);
//             }
//             else {
//                 if(nums[i] >pq.peek()){
//                     pq.poll();
//                     pq.add(nums[i]);
//                 }

//             }
//         }
        System.out.println(kthlargest(array,4,0,array.length-1));
        System.out.println(findKthSmallestQuick(0,array.length-1,array,4));
    }
    public static int kthlargest(int []array,int k,int start,int end){

        if(end<start){
            return -1;
        }
        if(start == end){
            return array[start];
        }
        int partition = getpartition(array,k,start,end);
        if(partition-start +1 == k){
            return array[partition];
        }
        if(partition-start+1 >k){
            System.out.println("start"+start);
            System.out.println("partition"+partition);
            return kthlargest(array,k,start,partition-1);
        }
        else {
            return kthlargest(array,k-partition-1+start,partition+1,end);
        }
    }

    private static int getpartition(int[] array, int k, int start, int end) {
        int startindex= start;
        int middle = start;
        int endindex = end;
        int pivot = array[(start+end)/2];
        while (middle<=endindex){
            if(array[middle] == pivot){
                middle++;
            }
            if(array[middle]<pivot){
                swap(array,startindex,middle);
                startindex++;
                middle++;
            }
            if(array[middle]>pivot){
                swap(array,endindex,middle);
                endindex--;
            }
        }
        return startindex;
    }

    private static void swap(int[] array, int startindex, int middle) {
        int temp = array[startindex];
        array[startindex] = array[middle];
        array[middle] = temp;
    }
    static int findKthLargestQuickSelect(int nums[], int k){
        int start = 0;
        int end = nums.length-1;
        k = nums.length-k+1;
        return findKthSmallestQuick(start,end,nums,k);
    }
    static int findKthSmallestQuick(int start, int end, int nums[], int k){
        if(start>end){
            return -1;
        }
        if(start == end){
            return nums[start];
        }
        int index = partitionDutch(nums,start,end);
        if(index +1 -start == k){
            return nums[index];
        }
        else if(index+1-start<k){
            return findKthSmallestQuick(index+1,end,nums,k+start-index-1);
        }
        else {
            return findKthSmallestQuick(start,index-1,nums,k);
        }
    }

    private static int partitionDutch(int []nums,int start,int end) {
        int pivot= nums[start];
        int left = start;
        int right = end;
        int middle = start;
        while (middle<=right){
            if(nums[middle] == pivot){
                middle++;
            }
            else if(nums[middle]<pivot){
                swap(nums,left,middle);
                middle++;
                left++;
            }
            else {
                swap(nums,right,middle);
                right--;
            }
        }
        return left;
    }
}
package CodingNinjas;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Scanner;

/**
 * Created by hadoop on 5/10/17.
 */
public class Lexigraphical {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        List<String> strings = new ArrayList<>();
        for(int i=1;i<=n;i++){
            strings.add(String.valueOf(i));
        }
        Collections.sort(strings);
        for(int i=0;i<strings.size();i++){
            System.out.print(strings.get(i));
            if(i!=strings.size()-1) {
                System.out.println();
            }
        }
    }
}
package templates;

/**
 * Created by hadoop on 23/10/17.
 */
public class PalindromeSubstring {
    String res = "";
    int maxlength ;
    public String longestPalindrome(String s) {
        if (s == null || s.length() == 0) return "";
        if (s.length() == 1) return s;
        maxlength = 0;

        for(int i=0;i<s.length()-1;i++){
            if(s.charAt(i) == s.charAt(i+1)){
                helper(s,i,i+1);
            }
            helper(s,i,i);
        }
        return res;
    }

    private void helper(String s, int i, int j) {
        while (i>=0 && j<s.length() ){
            if(s.charAt(i)!=s.charAt(j)) break;
            i--;
            j++;
        }
        if(j-i+1> maxlength){
            maxlength = j-i+1;
            res = s.substring(i,j+1);
        }
    }

}
package templates;

/**
 * Created by hadoop on 23/10/17.
 */
import java.util.*;
public class Parition {
    void partition(List<Integer> nums,List<Integer> pivots){
        Integer []boundaries = new Integer[pivots.size()];
        Arrays.fill(boundaries,0);
        for(int k=0;k<nums.size();k++){

            for(int i=0;i<pivots.size();i++) {
                if(nums.get(k)<pivots.get(i)){
                    Collections.swap(nums,k,boundaries[pivots.get(i)]);
                }
            }
            for(int i=1;i<pivots.size();i++){
                boundaries[i] = Math.max(boundaries[i],boundaries[i-1]);
            }

        }

    }

}
/*
void partition(vector<int> & nums, vector<int> const & pivots)
{
    vector<int> boundaries(pivots.size());
    for (auto &n : nums)
    {
        for (int i = 0; i < pivots.size(); ++ i)
            if (n < pivots[i])
                swap(n, nums[boundaries[i] ++]);
        for (int i = 1; i < pivots.size(); ++ i)
            boundaries[i] = max(boundaries[i], boundaries[i - 1]);
    }
}
 */package DivideAndConquer;

import java.util.LinkedList;
import java.util.Queue;
import java.util.Stack;

class Node
{
    Node left;
    String data;
    Node right;

    Node(Node left, String data, Node right)
    {
        this.left = left;
        this.right = right;
        this.data = data;
    }

    public String getData()
    {
        return data;
    }
}

class Tree
{
    Node node;

    //insert
    public void insert(String data)
    {
        if(node == null)
            node = new Node(null,data,null);
        else
        {
            Queue<Node> q = new LinkedList<Node>();
            q.add(node);

            while(q.peek() != null)
            {
                Node temp = q.remove();
                if(temp.left == null)
                {
                    temp.left = new Node(null,data,null);
                    break;
                }
                else
                {
                    q.add(temp.left);
                }

                if(temp.right == null)
                {
                    temp.right = new Node(null,data,null);
                    break;
                }
                else
                {
                    q.add(temp.right);
                }
            }
        }
    }

    public void postorder(Node node)
    {
        if(node == null)
            return;
        postorder(node.left);
        postorder(node.right);
        System.out.print(node.getData()+" --> ");
    }

    public void iterative(Node node)
    {
        Stack<Node> s = new Stack<Node>();
        Node lastpost = null;
        while(true)
        {
            while(node != null)
            {
                s.push(node);
                node = node.left;
            }

            if(s.isEmpty())break;
            Node topagain= s.pop();

            if(topagain.right==null || topagain.right == lastpost){
                System.out.print(topagain.getData()+" --> ");
                lastpost = topagain;
                node = null;
            }

            else {
                s.push(topagain);
                s.push(topagain.right);
            }
//            if(topagain<0){
//                s.push(topagain);
//            }
//            else{
//
//            }
//
//
//            if(s.peek().right == null)
//            {
//                node = s.pop();
//                System.out.print(node.getData()+" --> ");
//                if(node == s.peek().right)
//                {
//                    System.out.print(s.peek().getData()+" --> ");
//                    s.pop();
//                }
//            }
//
//            if(s.isEmpty())
//                break;
//
//            if(s.peek() != null)
//            {
//                node = s.peek().right;
//            }
//            else
//            {
//                node = null;
//            }
        }
    }
}

class Main
{
    public static void main(String[] args) 
    {
        Tree t = new Tree();
        t.insert("A");
        t.insert("B");
        t.insert("C");
        t.insert("D");
        t.insert("E");

        t.postorder(t.node);
        System.out.println();

        t.iterative(t.node);
        System.out.println();
    }
}package DivideAndConquer;

/**
 * Created by hadoop on 4/9/17.
 */
public class BinarySearchAlgo {
    public static void main(String[] args) {
        int []array = {2,5,6,8,9,10};
        int low = 0;
        int high = array.length-1;

        int index = BinarySearch(array,low,high,8);
        int indexmid = BinarySearchRecursive(array,low,high,8);
        System.out.println("index"+index);
        System.out.println("indexmid"+indexmid);

    }

    private static int BinarySearch(int[] array, int low, int high, int target) {

        while (low<=high){
            int mid = low + (high - low)/2;
            if(array[mid] == target){
                return mid;
            }
            else if(target<array[mid]){
                high = mid -1;
            }
            else{
                low = mid + 1;
            }
        }
        return  -1;
    }
    private static int BinarySearchRecursive(int []array,int low,int high,int target){
        if(low >high ) return -1;

        int mid = (low + high )/2;

        if(array[mid] == target){
            return mid;
        }
        else if (target<array[mid]){
            return BinarySearchRecursive(array,low,mid-1,target);
        }
        else {
            return BinarySearchRecursive(array,mid+1,high,target);
        }
    }
    private int searchinserty(int array[],int low,int high,int target){

        while(low<high) {
            int mid = low + (high - low) / 2;
            if (array[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
            }
            if(target <= array[low]){
                return low;
            }
            else {
                return low+1;
            }

        }
    private int squareroot(int x){
        if(x == 0) return 0;
        int left = 1;
        int right = x;

        while (left<right){
            int mid = left + (right - left  )/2;

//            if(mid * mid <=x && x <(mid +1)* (mid +1)){
//                return  mid;
//            }

            if(mid * mid <x){
                left = mid+1;
            }
            else{
                right = mid;
            }
        }
        return left;
    }
    private int searchRotatedrray(int array[], int low, int high, int target){
        while (low<high){

            int mid = low + (high-low/2);

            if(array[mid]<array[high]){
                if(array[mid]<target && target<=array[high]){
                    low = mid +1;
                }
                else {
                    high = mid;
                }

            }
            else {

                if(array[low]<=target && target<=array[mid]){
                    high = mid;
                }
                else {
                    low = mid +1;
                }
            }
        }
        if(array[low] == target) return low;
        return -1;
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

import java.util.Stack;

/**
 * Created by hadoop on 21/9/17.
 */
public class evalRPN {

    public int evalRpn(String []tokens){
        Stack<Integer> stack = new Stack<>();
        for(String token:tokens){
            if(isOperator(token)){
                stack.push(compute(token,stack.pop(),stack.pop()));
            }
            else {
                stack.push(Integer.parseInt(token));
            }
        }
        return stack.pop();
    }

    private boolean isOperator(String token) {
        if(token.equals("+") || token.equals("-") || token.equals("*") ||token.equals("/")){
            return true;
        }
        return false;
    }
    private int compute(String operator, int num2, int num1) {
        int result = 0;
        switch (operator.charAt(0)) {
            case '+': result = num1 + num2; break;
            case '-': result = num1 - num2; break;
            case '*': result = num1 * num2; break;
            case '/': result = num1 / num2; break;
        }
        return result;
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

import java.util.PriorityQueue;

/**
 * Created by hadoop on 21/9/17.
 */
public class KsmallestMatrix {
    public int kthSmallest(int[][] matrix, int k) {
        return searchHorizonal(matrix,k);
    }

    private int searchHorizonal(int[][] matrix, int k) {
        PriorityQueue<Cell> minHeap = new PriorityQueue<>();
        for(int i=0;i<matrix.length;i++){
            minHeap.add(new Cell(i,0,matrix[i][0]));
        }
        for(int i=1;i<k;i++){
            Cell ans = minHeap.poll();
            if(ans.column+1<matrix[ans.row].length){
                minHeap.add(new Cell(ans.row,ans.column+1,matrix[ans.row][ans.column+1]));
            }
        }
        return minHeap.poll().value;
    }
    private class Cell implements Comparable<Cell>{
        int row;
        int column;
        int value;
        Cell(int row,int column,int k){
            this.row = row;
            this.column = column;
            this.value = k;
        }
        @Override
        public int compareTo(Cell that){
            return this.value-that.value;
        }
    }
    private int searchVertical(int[][] matrix, int k) {
        PriorityQueue<Cell> pq = new PriorityQueue<>();
        for (int j = 0; j < matrix[0].length; j++) {
            pq.offer(new Cell(0, j, matrix[0][j]));
        }
        Cell cell = null;
        for (int i = 0; i < k; i++) {
            cell = pq.poll();
            if (cell.row + 1 < matrix.length) {
                pq.offer(new Cell(cell.row + 1, cell.column, matrix[cell.row + 1][cell.column]));
            }
        }
        return cell.value;
    }
}package SmallAndAmazingGitBookToGiveYouConfidence;

/**
 * Created by hadoop on 21/9/17.
 */
public class MaxSubArray2 {
    public int maxSub2arrays(int []temp){
        int size = temp.length;
        int []left = new int[size];
        int []right = new int[size];
        int currentSum=0;
        int maxSum = Integer.MIN_VALUE;
        for(int i=0;i<temp.length;i++) {
            currentSum = Math.max(temp[i], currentSum + temp[i]);
            maxSum = Math.max(currentSum, maxSum);
            left[i] = maxSum;
        }
        currentSum = 0;
        maxSum = Integer.MAX_VALUE;
        for(int i=temp.length-1;i>=0;i--){
            currentSum = Math.max(currentSum+temp[i],temp[i]);
            maxSum = Math.max(maxSum,currentSum);
            right[i] = maxSum;
        }
        maxSum = Integer.MIN_VALUE;
        for(int i=0;i<temp.length-1;i++){
            maxSum= Math.max(maxSum,left[i]+right[i+1]);
        }
        return maxSum;
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

/**
 * Created by hadoop on 19/9/17.
 */
public class Divide {
    public static void main(String args[]){

    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

import java.util.Arrays;

public class Solution {
    public static void main(String[] args) {
        Solution solution = new Solution();
        System.out.println(solution.reverseWords("  a   b "));
    }
    public String reverseWords(String s) {
        if(s == null || s.length() ==0){
            return s;
        }
        int start=0;
        while(start<s.length() && s.charAt(start) ==' '){
            start++;
        }
        int end = s.length()-1;
        while(end>=start && s.charAt(end) ==' '){
            end--;
        }
        if(start<=end){
            return reverseHelper(s.substring(start,end+1));
        }
        else{
            return "";
        }
        
    }
        String reverseHelper(String b){
        int firstNonSpaceindex=0;
        char[] a = b.toCharArray();
        for(int i=0;i<a.length;i++){
            if(a[i]==' '){
                reversesubstring(a,firstNonSpaceindex,i-1);
                while (i<a.length && a[i] ==' '){
                    i++;
                }
                firstNonSpaceindex = i;
            }
            if(i ==a.length-1){
                System.out.println("enter");
                reversesubstring(a,firstNonSpaceindex,i);
            }
        }
        reversesubstring(a,0,b.length()-1);
        return String.valueOf(removeExtraSpaces(a));
    }
    private char[] removeExtraSpaces(char []array){
        int start=0;
        for(int i=0;i<array.length;i++){
            if(array[i]!=' '){
                array[start++] = array[i];
            }
            else{
                int j =i;
                while(j<array.length && array[j]==' '){
                    j++;
                }
                array[start++] = ' ';
                i=j-1;
            }
        }

        char []newarray = new char[start];
        for(int i=0;i<start;i++){
            newarray[i] = array[i];
        }
        return newarray;
        //array[start++]='\0';
    }

    private void reversesubstring(char[] a, int isspaceindex, int i) {
        while (isspaceindex<i){
            swap(a,isspaceindex,i);
            isspaceindex++;
            i--;
        }

    }

    private void swap(char[] a, int isspaceindex, int i) {
        char temp = a[isspaceindex];
        a[isspaceindex] = a[i];
        a[i] = temp;
    }
}package SmallAndAmazingGitBookToGiveYouConfidence;

/**
 * Created by hadoop on 22/9/17.
 */
public class SortColorsAgain {
    public void sortColors(int []array){
        int start =0;
        int index =0;
        int end = array.length-1;
        while(index<=end){
            if(array[index] ==0){
                swap(array,start,index);
                start++;
                index++;
            }
            else if(array[index] == 1){
                index++;
            }
            else {
                swap(array,end,index);
                end--;
            }
        }
    }
    private void swap(int[] nums, int index1, int index2) {
        int tmp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = tmp;
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

import java.util.ArrayList;

/**
 * Created by hadoop on 22/9/17.
 */
public class KsumPrintPath {
    public ArrayList<ArrayList<Integer>> ksum2(int []array,int k,int target){

        ArrayList<ArrayList<Integer>> result = new ArrayList<>();
        ArrayList<Integer> path = new ArrayList<>();

        dfshelper(result,path,0,array,target,k);
        return result;
    }

    private void dfshelper(ArrayList<ArrayList<Integer>> result, ArrayList<Integer> path, int index, int array[],int target, int k) {
            if(target<0){
                return;
            }
            if(k<0){
                return;
            }
            if(target == 0 && k ==0 ){
                result.add(new ArrayList<>(path));
                return;
            }
            if(path.size() == array.length){
                if(target == 0 && k ==0){
                    result.add(new ArrayList<>(path));
                }
                return;
            }
            for(int i =index;i<array.length;i++){
                path.add(array[i]);
                target = target -array[i];
                k =k-1;
                dfshelper(result,path,i+1,array,target,k);
                target = target + array[i];
                path.remove(path.size()-1);
                k =k+1;
            }
    }
    public static void main(String args[]){
        KsumPrintPath ksumPrintPath = new KsumPrintPath();
        int []array = {1,2,3,4};
        int k =2;
        int target = 5;
        System.out.println(ksumPrintPath.ksum2(array,k,target));
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Stack;

/**
 * Created by hadoop on 22/9/17.
 */
public class Expression {

    private class Solution {
        /**
         * @param expression: A string array
         * @return: The Polish notation of this expression
         */
        public ArrayList<String> convertToPN(String[] expression) {
            ArrayList<String> result = new ArrayList<>();
            if (expression == null || expression.length == 0) {
                return result;
            }
            Stack<String> opStack = new Stack<>();
            for (int i = expression.length - 1; i >= 0; i--) {
                String token = expression[i];
                if (isNumber(token)) {
                    result.add(token);
                } else if (token.equals("(")) {
                    while (!opStack.peek().equals(")")) {
                        result.add(opStack.pop());
                    }
                    opStack.pop();
                } else if (token.equals(")")) {
                    opStack.push(token);
                } else {
                    while (!opStack.isEmpty() && getPriority(opStack.peek()) > getPriority(token)) {
                        result.add(opStack.pop());
                    }
                    opStack.push(token);
                }
            }
            while (!opStack.isEmpty()) {
                result.add(opStack.pop());
            }
            Collections.reverse(result);
            return result;
        }

        private boolean isNumber(String token) {
            return Character.isDigit(token.charAt(0));
        }

        private int getPriority(String op) {
            if (op.equals(")")) {
                return 0;
            } else if (op.equals("+") || op.equals("-")) {
                return 1;
            } else {
                return 2;
            }
        }
    }
    private class Solution1 {
        /**
         * @param expression: A string array
         * @return: The Reverse Polish notation of this expression
         */
        public ArrayList<String> convertToRPN(String[] expression) {
            ArrayList<String> result = new ArrayList<>();
            if (expression == null || expression.length == 0) {
                return result;
            }
            Stack<String> opStack = new Stack<>();
            for (String token : expression) {
                if (isNumber(token)) {
                    result.add(token);
                } else if (token.equals("(")) {
                    opStack.push(token);
                } else if (token.equals(")")) {
                    while (!opStack.peek().equals("(")) {
                        result.add(opStack.pop());
                    }
                    opStack.pop();
                } else {
                    while (!opStack.isEmpty() && getPriority(opStack.peek()) >= getPriority(token)) {
                        result.add(opStack.pop());
                    }
                    opStack.push(token);
                }
            }
            while (!opStack.isEmpty()) {
                result.add(opStack.pop());
            }
            return result;
        }

        private boolean isNumber(String token) {
            return Character.isDigit(token.charAt(0));
        }

        private int getPriority(String op) {
            if (op.equals("(")) {
                return 0;
            } else if (op.equals("+") || op.equals("-")) {
                return 1;
            } else {
                return 2;
            }
        }
    }
    private class Solution3 {
        private class ExpressionTreeNode{
            String op;
            ExpressionTreeNode left;
            ExpressionTreeNode right;

            public ExpressionTreeNode(String op) {
                this.op = op;
            }
        }
        /**
         * @param expression: A string array
         * @return: The root of expression tree
         */
        public ExpressionTreeNode build(String[] expression) {
            if (expression == null || expression.length == 0) {
                return null;
            }
            Stack<ExpressionTreeNode> numStack = new Stack<>();
            Stack<String> opStack = new Stack<>();
            for (String token : expression) {
                if (isNumber(token)) {
                    numStack.push(new ExpressionTreeNode(token));
                } else if (token.equals("(")) {
                    opStack.push(token);
                } else if (token.equals(")")) {
                    while (!opStack.peek().equals("(")) {
                        numStack.push(buildNode(numStack.pop(), numStack.pop(), opStack.pop()));
                    }
                    opStack.pop();
                } else {
                    while (!opStack.isEmpty() && getPriority(opStack.peek()) >= getPriority(token)) {
                        numStack.push(buildNode(numStack.pop(), numStack.pop(), opStack.pop()));
                    }
                    opStack.push(token);
                }
            }
            while (!opStack.isEmpty()) {
                numStack.push(buildNode(numStack.pop(), numStack.pop(), opStack.pop()));
            }
            return numStack.isEmpty() ? null : numStack.pop();
        }

        private boolean isNumber(String token) {
            return Character.isDigit(token.charAt(0));
        }

        private int getPriority(String op) {
            if (op.equals("(")) {
                return 0;
            } else if (op.equals("+") || op.equals("-")) {
                return 1;
            } else {
                return 2;
            }
        }

        private ExpressionTreeNode buildNode(ExpressionTreeNode node2, ExpressionTreeNode node1, String op) {
            ExpressionTreeNode root = new ExpressionTreeNode(op);
            root.left = node1;
            root.right = node2;
            return root;
        }
    }
    private class Solution4 {
        public int evaluateExpression(String[] expression) {
            if (expression == null || expression.length == 0) {
                return 0;
            }
            Stack<Integer> numStack = new Stack<>();
            Stack<String> opStack = new Stack<>();
            for (String token : expression) {
                if (isNumber(token)) {
                    numStack.push(Integer.valueOf(token));
                } else if (token.equals("(")) {
                    opStack.push(token);
                } else if (token.equals(")")) {
                    while (!opStack.peek().equals("(")) {
                        numStack.push(compute(numStack.pop(), numStack.pop(), opStack.pop()));
                    }
                    opStack.pop();  // pop out "("
                } else {
                    while (!opStack.isEmpty() && getPriority(opStack.peek()) >= getPriority(token)) {
                        numStack.push(compute(numStack.pop(), numStack.pop(), opStack.pop()));
                    }
                    opStack.push(token);
                }
            }
            while (!opStack.isEmpty()) {
                numStack.push(compute(numStack.pop(), numStack.pop(), opStack.pop()));
            }
            return numStack.isEmpty() ? 0 : numStack.pop();
        }

        private boolean isNumber(String token) {
            return Character.isDigit(token.charAt(0));
        }

        private int getPriority(String op) {
            if (op.equals("(")) {
                return 0;
            } else if (op.equals("+") || op.equals("-")) {
                return 1;
            } else {
                return 2;
            }
        }

        private int compute(int num2, int num1, String token) {
            int result;
            if (token.equals("+")) {
                result = num1 + num2;
            } else if (token.equals("-")) {
                result = num1 - num2;
            } else if (token.equals("*")) {
                result = num1 * num2;
            } else {
                result = num1 / num2;
            }
            return result;
        }
    }
}package SmallAndAmazingGitBookToGiveYouConfidence;

/**
 * Created by hadoop on 21/9/17.
 */
public class Candies {
    public int candy(int[] ratings) {
        if (ratings == null || ratings.length == 0) {
            return 0;
        }
        // scan from left to right
        int[] leftCandy = new int[ratings.length];
        leftCandy[0] = 1;
        for (int i = 1; i < ratings.length; i++) {
            if (ratings[i] > ratings[i - 1]) {
                leftCandy[i] = leftCandy[i - 1] + 1;
            } else {
                leftCandy[i] = 1;
            }
        }
        // scan from right to left
        int rightCandy = 1;
        int numCandies = 0;
        for (int i = ratings.length - 1; i >= 0; i--) {
            if (i < ratings.length - 1 && ratings[i] > ratings[i + 1]) {
                rightCandy += 1;
            } else {
                rightCandy = 1;
            }
            numCandies += Math.max(leftCandy[i], rightCandy);
        }
        return numCandies;
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

import java.util.HashMap;
import java.util.Map;

/**
 * @author tusroy
 * Date 06/20/2015
 *  
 * Video link - https://youtu.be/ID00PMy0-vE
 *  
 * Disjoint sets using path compression and union by rank
 * Supports 3 operations
 * 1) makeSet
 * 2) union
 * 3) findSet
 * 
 * For m operations and total n elements time complexity is O(m*f(n)) where f(n) is 
 * very slowly growing function. For most cases f(n) <= 4 so effectively
 * total time will be O(m). Proof in Coreman book.
 */
public class DisjointSet {


    private Map<Long, Node> map = new HashMap<>();

    class Node {
        long data;
        Node parent;
        int rank;
    }

    /**
     * Create a set with only one element.
     */
    public void makeSet(long data) {
        Node node = new Node();
        node.data = data;
        node.parent = node;
        node.rank = 0;
        map.put(data, node);
    }

    /**
     * Combines two sets together to one.
     * Does union by rank
     *
     * @return true if data1 and data2 are in different set before union else false.
     */
    public boolean union(long data1, long data2) {
        Node node1 = map.get(data1);
        Node node2 = map.get(data2);

        Node parent1 = findSet(node1);
        Node parent2 = findSet(node2);

        //if they are part of same set do nothing
        if (parent1.data == parent2.data) {
            return false;
        }

        //else whoever's rank is higher becomes parent of other
        if (parent1.rank >= parent2.rank) {
            //increment rank only if both sets have same rank
            parent1.rank = (parent1.rank == parent2.rank) ? parent1.rank + 1 : parent1.rank;
            parent2.parent = parent1;
        } else {
            parent1.parent = parent2;
        }
        return true;
    }

    /**
     * Finds the representative of this set
     */
    public long findSet(long data) {
        return findSet(map.get(data)).data;
    }

    /**
     * Find the representative recursively and does path
     * compression as well.
     */
    private Node findSet(Node node) {
        Node parent = node.parent;
        if (parent == node) {
            return parent;
        }
        node.parent = findSet(node.parent);
        return node.parent;
    }

    public static void main(String args[]) {
        DisjointSet ds = new DisjointSet();
        ds.makeSet(1);
        ds.makeSet(2);
        ds.makeSet(3);
        ds.makeSet(4);
        ds.makeSet(5);
        ds.makeSet(6);
        ds.makeSet(7);

        ds.union(1, 2);
        ds.union(2, 3);
        ds.union(4, 5);
        ds.union(6, 7);
        ds.union(5, 6);
        ds.union(3, 7);

        System.out.println(ds.findSet(1));
        System.out.println(ds.findSet(2));
        System.out.println(ds.findSet(3));
        System.out.println(ds.findSet(4));
        System.out.println(ds.findSet(5));
        System.out.println(ds.findSet(6));
        System.out.println(ds.findSet(7));
    }
}package SmallAndAmazingGitBookToGiveYouConfidence;

import java.util.Stack;

/**
 * Created by hadoop on 21/9/17.
 */
public class LargestRectangle {
    public int largestRectangle(int []heights){
        if(heights == null || heights.length == 0){
            return 0;
        }
        Stack<Integer> stack = new Stack<>();
        int area = Integer.MIN_VALUE;
        for(int i=0;i<heights.length;i++){
            while (!stack.isEmpty()  && heights[i]<heights[stack.peek()]){
                int localarea = heights[stack.peek()]*(i-stack.pop());
           //     System.out.println("localarea"+localarea);
                area = Math.max(area,localarea);
            }
            stack.push(i);
        }
        while (!stack.isEmpty()){
            int localarea = heights[stack.peek()]*(heights.length-stack.pop());
         //   System.out.println("localarea"+localarea);

            area = Math.max(area,localarea);

        }
        return area;
    }

    public int largestRectangleArea(int[] heights) {
        if (heights == null || heights.length == 0) {
            return 0;
        }

        int maxArea = 0;
        Stack<Integer> indexStack = new Stack<>();
        indexStack.push(-1);
        for (int i = 0; i < heights.length; ++i) {
            while (indexStack.peek() != -1 && heights[i] < heights[indexStack.peek()]) {
                int index = indexStack.pop();
                maxArea = Math.max(maxArea, (i - indexStack.peek() - 1) * heights[index]);
            }
            indexStack.push(i);
        }
        while (indexStack.peek() != -1) {
            int index = indexStack.pop();
            maxArea = Math.max(maxArea,
                    (heights.length - indexStack.peek() - 1) * heights[index]);
        }

        return maxArea;
    }
    public int largestRectangleAreaWorking(int[] heights) {
        if(heights == null || heights.length ==0){
            return 0;
        }
        int area = Integer.MIN_VALUE;
        Stack<Integer> stack = new Stack<Integer>();
        for(int i=0;i<heights.length;i++){
            while (!stack.isEmpty() && heights[i]<heights[stack.peek()]){
                int index = stack.pop();
                if(!stack.isEmpty()){
                    int localarea = heights[index] *(i-stack.peek()-1);
                    area = Math.max(localarea,area);

                }
                else{
                    int localarea = heights[index]*i;
                    area = Math.max(localarea,area);

                }
            }
            stack.push(i);
        }
        while(!stack.isEmpty()){
            int index = stack.pop();
            if(!stack.isEmpty()){
                int localarea = heights[index] *(heights.length-stack.peek()-1);
                area = Math.max(localarea,area);
            }else{
                int localarea = heights[index]*heights.length;
                area = Math.max(localarea,area);
            }
        }
        return area;
    }

    public static void main(String[] args) {
        LargestRectangle largestRectangle = new LargestRectangle();
        int []height = {2,1,5,6,2,3};
        System.out.println(largestRectangle.largestRectangle(height));
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

/**
 * Created by hadoop on 21/9/17.
 */
//dp[k][i+1] = max(dp[k-1][i+1], dp[k][i], max(dp[k-1][j] + prices[i] - prices[j]))  {0 <= j < i}

public class TransactionKAllowed {
    public int maxProfit(int []nums, int k){
        int profit[][] = new int[k+1][nums.length];
        for(int t= 1;t<=k;t++){
            for(int i=0;i<nums.length;i++){
                for(int partition=0;partition<i;partition++) {
                    int transactiondontdo = profit[t-1][i];
                    int alreadydone = 0;
                    if(i>0) {
                         alreadydone = profit[t][i - 1];
                    }
                    int transactiondo = 0;
                    if(nums[i]>nums[partition]) {
                        transactiondo = profit[t - 1][partition] + nums[i] - nums[partition];
                    }
                    int ans = Math.max(alreadydone,Math.max(transactiondo,transactiondontdo));
                    profit[t][i] = Math.max(profit[t][i],ans);
                }
            }
        }
        for(int i=1;i<=k;i++){
            for(int j=0;j<nums.length;j++){
                System.out.print(profit[i][j]);
            }
            System.out.println();
        }
       // System.out.println(profit[1][nums.length-1]);
        return profit[k][nums.length-1];
    }

    public static void main(String[] args) {
        int nums[] = {4, 4, 6, 1, 1, 4, 2, 5};
        int k = 2;
        TransactionKAllowed transactionKAllowed = new TransactionKAllowed();
        System.out.println(transactionKAllowed.maxProfit(nums, 2));
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

/**
 * Created by hadoop on 19/9/17.
 */
public class AutoComplete {
    private class TrieNode {
        String prefix;
        boolean isWord;
        HashMap<Character, TrieNode> hashMap;
        TrieNode(String prefix){
            hashMap = new HashMap<>();
            this.prefix = prefix;
        }
    }
    private TrieNode trieNode;
    public AutoComplete(){
        trieNode = new TrieNode("");
    }

    public void insertWord(String word){
        TrieNode current = trieNode;
        for(int i=0;i<word.length();i++){
            TrieNode children =current.hashMap.get(word.charAt(i));
            if(children == null){
                children = new TrieNode(word.substring(0,i+1));
                current.hashMap.put(word.charAt(i),children);
            }
            current = children;
            if(i == word.length()-1){
                children.isWord = true;
            }
        }
    }
    public void insertShort(String s){
        TrieNode curr = trieNode;
        for(int i=0;i<s.length();i++){
            if(!curr.hashMap.containsKey(s.charAt(i))){
                curr.hashMap.put(s.charAt(i),new TrieNode(s.substring(0,i+1)));
            }
            curr = curr.hashMap.get(s.charAt(i));
            if(i == s.length()-1){
                curr.isWord = true;
            }
        }
    }
    public boolean search(String s){
        if(s == null || s.length() ==0){
            return false;
        }
        TrieNode curr = trieNode;
        for(int i=0;i<s.length();i++){
            if(!curr.hashMap.containsKey(s.charAt(i))){
                return false;
            }
            curr = curr.hashMap.get(s.charAt(i));
            if(curr == null){
                return false;
            }
        }
        return curr.isWord;
    }
    public List<String> getAllWordsForPrefix(String s){
        List<String> results = new ArrayList<>();
        TrieNode curr = trieNode;
        for( int i=0;i<s.length();i++){
            if(curr.hashMap.containsKey(s.charAt(i))){
                curr = curr.hashMap.get(s.charAt(i));
            }
            else {
                return results;
            }
        }
        getAllWords(curr,results);
        return results;
    }
    void getAllWords(TrieNode curr,List<String> results){
        if (curr.isWord == true){
            results.add(curr.prefix);
            return;
        }
        for(TrieNode childrens:curr.hashMap.values()){
            getAllWords(childrens,results);
        }
    }

    public static void main(String[] args) {
        AutoComplete autoComplete = new AutoComplete();
        autoComplete.insertWord("abc");
        autoComplete.insertWord("acd");
        autoComplete.insertWord("bcd");
        autoComplete.insertShort("def");
        autoComplete.insertShort("a");
        autoComplete.insertWord("aba");
        System.out.println(autoComplete.getAllWordsForPrefix("ab"));
        System.out.println(autoComplete.search("ab"));
    }

}package SmallAndAmazingGitBookToGiveYouConfidence;

/**
 * Created by hadoop on 20/9/17.
 */
public class Anagram {
    int ascii = 256;
    boolean anagram(String a, String b){
        int [] count = new int[ascii];
        for(char c:a.toCharArray()){
            count[c]+=1;
        }
        for(char c:b.toCharArray()){
            count[c]-=1;
            if(count[c]<0){
                return false;
            }
        }
        return true;
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

/**
 * Created by hadoop on 21/9/17.
 */
public class MaxSubArray {
    public static void main(String []args) {
    }
    public void kadan(int []temp){
        int maxSum = Integer.MAX_VALUE;
        int curretSum = 0;
        for(int num:temp){
            curretSum = Math.max(curretSum+num,num);
            maxSum = Math.max(curretSum,maxSum);
        }
        System.out.println("Max Sum" +maxSum);
    }

}
package SmallAndAmazingGitBookToGiveYouConfidence;

/**
 * Created by hadoop on 22/9/17.
 */
import java.util.*;
public class Anagrams {
    private class Solution {
        public List<List<String>> groupAnagrams(String[] strs) {
            Map<Integer, List<String>> map = new HashMap<>();
            for (String str : strs) {
                int hashCode = computeHashCode(str);
                List<String> anagramList;
                if (map.containsKey(hashCode)) {
                    anagramList = map.get(hashCode);
                } else {
                    anagramList = new ArrayList<>();
                }
                anagramList.add(str);
                map.put(hashCode, anagramList);
            }
            List<List<String>> result = new ArrayList<>();
            for (List<String> anagramList : map.values()) {
                Collections.sort(anagramList);
                result.add(anagramList);
            }
            return result;
        }

        private int computeHashCode (String str) {
            int[] count = new int[26];
            for (char c: str.toCharArray()) {
                ++count[c - 'a'];
            }
            int hashCode = 17;
            for (int val: count) {
                hashCode = hashCode * 31 + val;
            }
            return hashCode;
            // in java string we use
            //s[0]*31^(n-1) + s[1]*31^(n-2) +  + s[n-1]
            // mind u u r calcultaing hashcode of ocunt array
            //
        }
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

/**
 * Created by hadoop on 19/9/17.nt
 */
public class DivideIntegers {
    int divide(int x,int y){
        if(y ==0){
            return x>0?Integer.MAX_VALUE:Integer.MIN_VALUE;
        }
        if(x ==0){
            return x;
        }
        if(x <0 && y <0){
            return divideHelper(-1*x,-1*y);
        }
        if(x >0 && y >0){
            return divideHelper(x,y);
        }
        return -1 * divideHelper(Math.abs(x),Math.abs(y));
    }

    int divideHelper(int dividend,int divisor){
        int answer=0;
        while (divisor<=dividend){
            int temp = divisor;
            int shift =1;
            while (temp<=dividend) {
                temp = temp << 1;
                shift = shift << 1;
            }
            answer = answer + shift>>1;
            dividend = dividend-temp>>1;
        }
        return answer;
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

import java.util.*;

/**
 * Created by hadoop on 21/9/17.
 */
public class ValidParenthese {
    private static final Map<Character, Character> leftToRightBraces = new HashMap<>();
    private static final Set<Character> leftBracesSet = new HashSet<>();
    private static final Set<Character> rightBracesSet = new HashSet<>();

    static {
        leftToRightBraces.put('(',')');
        leftToRightBraces.put('{','}');
        leftToRightBraces.put('[',']');
        for (char c : new char[] {'(', '[', '{'}) {
            leftBracesSet.add(c);
        }
        for (char c : new char[] {')', ']', '}'}) {
            rightBracesSet.add(c);
        }
    }
    public boolean isValidPranet(String s){
        Stack<Character> stack = new Stack<>();
        for(char c:s.toCharArray()){
            if(leftParen(c)){
                stack.push(c);
            }
            else if(rightPran(c)){
                if(stack.isEmpty() || !isMatch(stack.pop(),c)){
                    return false;
                }
            }
        }
        return stack.isEmpty();
    }

    private boolean isMatch(Character pop, char c) {
        if(leftToRightBraces.containsKey(pop)) {
            return leftToRightBraces.get(pop) == c;
        }
        return false;
    }

    private boolean rightPran(char c) {
        return leftBracesSet.contains(c);
    }

    private boolean leftParen(char c) {
        return rightBracesSet.contains(c);
    }

}
package SmallAndAmazingGitBookToGiveYouConfidence;

/**
 * Created by hadoop on 19/9/17.
 */
public class SubarraySumSlildingWindow {
    void findSubarray(int []num,int n,int sum){
        int windowsum = num[0];
        int low = 0;
        int high =0;
        int count =0;
        while (low<n){
            while(windowsum<sum && high<n) {
                high++;
                windowsum = windowsum + num[high];
            }
            if(windowsum == sum){
                System.out.println(low);
                // since we have incremented high
                System.out.println(high);
                //windowsum = windowsum-num[low];
                //low++;
            }
           // while (windowsum>sum && low<n) {
                windowsum = windowsum - num[low];
                low++;
            //}
        }
    }

    public static void main(String[] args) {
        int []num = {2,6,0,9,7,3,1,4,1,10};
        int sum = 15;
        SubarraySumSlildingWindow subarraySumSlildingWindow = new SubarraySumSlildingWindow();
        subarraySumSlildingWindow.findSubarray(num,num.length-1,15);
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

/**
 * Created by hadoop on 21/9/17.
 */
public class KsumDFS{

    public int ksum(int []array,int k , int target){
        if(k<1||k >array.length){
            return 0;
        }
        return ksumhelper(array,k,target,0);
    }

    private int ksumhelper(int[] array, int k, int target, int index) {
        int totalways = 0;
        if(target<0){
            return 0;
        }
        if(k<0){
            return 0;
        }
        if(k == 0){
            if(target ==0) return 1;
            return 0;
        }
        for(int i=index;i<array.length;i++){
            target = target-array[i];
            totalways +=ksumhelper(array,k-1,target,i+1);
            target = target-array[i];
        }
        return totalways;
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

/**
 * Created by hadoop on 20/9/17.
 */
public class AddBinary {
    String addBinary(String a,String b){
        int index1= a.length()-1;
        int index2 = b.length()-1;

        int carry =0;
        int base = 2;
        String output = "";
        while (index1>=0 || index2 >=0 || carry!=0){
            int num1=0;
            if(index1>=0){
                num1 = a.charAt(index1)-'0';
                index1--;
            }
            int  num2=0;
            if(index2>=0){
                num2 = a.charAt(index2)-'0';
                index2--;
            }
            int sum = num1 + num2 + carry;
            carry = sum/base;
            int value = sum%base;
            output = output+ String.valueOf(value);
        }
        return output;
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Queue;

/**
 * Created by hadoop on 22/9/17.
 */
public class HasRoute {
    HashSet<DirectedGraphNode> hashSet = new HashSet<>();
    public boolean hasRoute(ArrayList<DirectedGraphNode> graph,
                            DirectedGraphNode s, DirectedGraphNode t) {
        return dfsHelper(s,t,graph);
    }

    private boolean dfsHelper(DirectedGraphNode s, DirectedGraphNode t, ArrayList<DirectedGraphNode> graph) {
        if(s == t){
            return true;
        }

        hashSet.add(s);
        for(DirectedGraphNode directedGraphNode :s.neighbor){
            if(!hashSet.contains(directedGraphNode)){
                if(dfsHelper(directedGraphNode,t,graph)){
                    return true;
                }
            }
        }
        return false;
    }

    private class DirectedGraphNode{
        int label;
        ArrayList<DirectedGraphNode> neighbor;
    }
    private boolean bfsHelper(ArrayList<DirectedGraphNode> graphNodes,DirectedGraphNode start,DirectedGraphNode end){

        if(start == end){
            return true;
        }
        HashSet<DirectedGraphNode> bfsSet = new HashSet<>();
        Queue<DirectedGraphNode> bfsQueue = new LinkedList<>();
        bfsQueue.add(start);
        bfsSet.add(start);
        while(!bfsQueue.isEmpty()){
            DirectedGraphNode polled = bfsQueue.poll();
            if(polled == end){
                return true;
            }
            for(DirectedGraphNode node:polled.neighbor){
                if(!bfsSet.contains(node)){
                    bfsSet.add(node);
                    bfsQueue.add(node);
                }
            }
        }
        return false;
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

/**
 * Created by hadoop on 19/9/17.
 */
public class SortColors {
    public static void main(String[] args) {
        int []num = {1,3,4,5,5,6,3};
        SortColors sortColors = new SortColors();
        System.out.println(sortColors.countSort(num,6));
    }
    int [] countSort(int []num,int k){
        int []count = new int[k];
        int []result = new int[num.length];
        for( int i=0;i<num.length;i++){
            count[num[i]-1]++;
        }
        for( int i=1;i<k;i++){
            count[i] = count[i]+count[i-1];
        }

        for(int i=num.length-1;i>=0;i--){
            result[--count[num[i]-1]] = num[i];
        }
        for( int i=0;i<count.length;i++){
            System.out.println(count[i]);
        }
        return result;
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

import java.util.HashMap;
import java.util.Map;

/**
 * Created by hadoop on 20/9/17.
 */
public class RomanToInt {
    Map<Character,Integer> map = new HashMap<>();
    RomanToInt(){
        map.put('I',1);
        map.put('V',5);
        map.put('X',10);
        map.put('L',50);
        map.put('C',100);
    }
    int romantoint(String x){
        int result = 0;
        for(int i=0;i<x.length();i++){
            if(i>0 && map.get(x.charAt(i))>map.get(x.charAt(i-1))){
                result = result + map.get(x.charAt(i))-2*map.get(x.charAt(i-1));
            }
            else {
                result = result + map.get(x.charAt(i));
            }
        }
        return result;
    }
    String inttoroman(int a){
        int array[] = {1000,900,500,400,100,90,50,40,10,9,5,4,1};
        String []roman = {"M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"};
        String output = "";
        while (a!=0){
            for(int i=0;i<array.length;i++){
                int times=a/array[i];
                int remainder = a%array[i];
                for(int k=0;k<times;k++){
                    output = output+roman[i];
                }
                a = remainder;
            }
        }
        return output;
    }

    public static void main(String[] args) {
        RomanToInt romanToInt = new RomanToInt();
        System.out.println(romanToInt.inttoroman(3549));
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

import java.util.HashMap;
import java.util.Map;

/**
 * Created by hadoop on 22/9/17.
 */
public class TwoSum {
    public int[] twoSum(int[] num, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        int index = 0;
        for (int number : num) {
            if (map.containsKey(target - number)) {
                return new int[]{map.get(target - number), index};
            }
            map.put(number, index++);
        }
        return null;
    }


    private class TwoSumDesign {
        HashMap<Integer,Integer> hashMap = new HashMap<>();
        void add(int num){
            if(hashMap.containsKey(num)){
               int count= hashMap.get(num);
               hashMap.put(num,count+1);
            }
            else{
                hashMap.put(num,1);
            }
        }
        public boolean find(int value){
            for(int num:hashMap.keySet()){
                if(hashMap.containsKey(value-num)){
                    if(value == num){
                        if(hashMap.get(num)>1) {
                            return true;
                        }
                        return false;
                    }
                    return true;
                }
            }
            return false;
        }
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

import java.util.ArrayList;
import java.util.List;

/**
 * Created by hadoop on 23/9/17.
 */
public class PrintNumbers {

    List<Integer> nnumbers(int n){
        List<Integer> ans = new ArrayList<Integer>();
        nnumbersHelper(ans,n,0);
        System.out.println("ans"+ans);
        return ans;
    }

    private void nnumbersHelper(List<Integer> ans, int n, int num) {
        if(n==0){
            if(num!=0){
                ans.add(num);
            }
            return;
        }

        for(int i=0;i<=9;i++){
            n=n-1;
            int oldnum = num;
            num = num*10 +i;
            nnumbersHelper(ans,n,num);
            n = n+1;
            num = oldnum;
        }
    }

    public static void main(String[] args) {
        PrintNumbers printNumbers = new PrintNumbers();
        printNumbers.nnumbers(2);
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

/**
 * Created by hadoop on 22/9/17.
 */
public class LongestConsecutiveMatrix2 {
    public static int DIRS[][]={{1,0},{-1,0},{0,1},{0,-1}};
    private int [][]cache;
    int maxlenth = Integer.MIN_VALUE;
    public int longestIncreasingContinuous(int [][]matrix){
        boolean [][]visited = new boolean[matrix.length][matrix[0].length];
        for(int i=0;i<matrix.length;i++){
            for(int j=0;j<matrix[0].length;j++){
                visited[i][j] = true;
                maxlenth = Math.max(maxlenth,dfs(i,j,visited,matrix));
                visited[i][j] = false;
            }
        }
        return maxlenth;
    }

    private int dfs(int i, int j, boolean[][] visited,int [][]matrix) {

        int maxlength = 1;

        for (int k = 0; k < DIRS.length; k++) {
            if(isValid(i+DIRS[k][0],j+DIRS[k][1],matrix,matrix[i][j])){
                    visited[i+DIRS[k][0]][j+DIRS[k][1]] = true;
                    maxlength = Math.max(maxlength,1 + dfs(i+DIRS[k][0],j+DIRS[k][1],visited,matrix));
                    visited[i+DIRS[k][0]][j+DIRS[k][1]] = false;
                }
        }
        return maxlength;

    }

    private boolean isValid(int row, int column, int [][]matrix,int matrixvalue) {
        if(row<0 || column<0 || row>=matrix.length ||column>=matrix[0].length || matrix[row][column] <matrixvalue){
            return false;
        }
        return true;
    }
    public static void main(String []args) {
        int[][] matrix = {{1, 2, 3, 4, 5},
                {16, 17, 24, 23, 6},
                {15, 18, 25, 22, 7},
                {14, 19, 20, 21, 8},
                {13, 12, 11, 10, 9}};
        LongestConsecutiveMatrix2  longestConsecutiveMatrix2 = new LongestConsecutiveMatrix2();
        System.out.println(longestConsecutiveMatrix2.longestIncreasingContinuous(matrix));
        System.out.println("LOngest");
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

import java.util.ArrayList;
import java.util.List;

/**
 * Created by hadoop on 21/9/17.
 */
public class MaxSumSubarrayK {

    public int maxSubArray(ArrayList<Integer> list ,int k){

        int [][]sum = new int[k+1][list.size()+1];
        for(int i=1;i<=k;i++){
            for(int j=i-1;j<list.size();j++){
                int currentSum=0;
                int max = Integer.MIN_VALUE;
                for(int partition = j;partition>=i;partition--){
                    currentSum = Math.max(currentSum+list.get(partition),list.get(partition));
                    max = Math.max(max,currentSum);
                    sum[i][j] = Math.max(sum[i][j],sum[i-1][partition-1] +max);
                }
            }
        }
        return sum[k][list.size()-1];

    }
    public static void main(String args[]){
        ArrayList<Integer> list = new ArrayList<>();
        list.add(-1);
        list.add(4);
        list.add(-2);
        list.add(3);
        list.add(-2);
        list.add(3);
        MaxSumSubarrayK maxSumSubarrayK = new MaxSumSubarrayK();
        System.out.println(maxSumSubarrayK.maxSubArray(list,2));
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;

public class HashMapCustom<K, V> {

    private int ENTRYSET_ARRAY_SIZE = 256;
    @SuppressWarnings("unchecked")
    private EntrySet<K, V>[] entrySetArray = new EntrySet[ENTRYSET_ARRAY_SIZE];

    public void put(K key, V value) {
        // create hash from the key and do modulo
        // over the length of the entry set array size
        int hashCode = getHashFromKey(key);
        EntrySet<K, V> entrySet = new EntrySet<K, V>(key, value);

        // If the entry is free we store the entrySet in the free array position
        if (entrySetArray[hashCode] == null) {
            entrySetArray[hashCode] = entrySet;
            return;
        }

        // we have a "collision" so we have to append the entrySet to the linkedList
        // we go to the end of the linkedList and then we append the new entrySet there
        EntrySet<K, V> currentEntrySet = entrySetArray[hashCode];
        while (currentEntrySet.next() != null) {
            currentEntrySet = currentEntrySet.next();
        }
        currentEntrySet.setNext(entrySet);
    }

    public V get(K key) throws Exception {
        int hashCode = getHashFromKey(key);
        EntrySet<K, V> entrySet = entrySetArray[hashCode];

        // We need to iterate over the linkedList and see which one is
        // the hash of our key
        while (entrySet != null) {
            if (entrySet.getKey().equals(key)) {
                return entrySet.getValue();
            }
            entrySet = entrySet.next();
        }

        throw new Exception(String.format("Key %s does not exist", key.toString()));
    }

    protected int getHashFromKey(K key) {
        return Math.abs(key.hashCode() % ENTRYSET_ARRAY_SIZE);
    }

    public Set<K> keySet(){
        Set<K> keys = new HashSet<K>();
        for(int i = 0; i < ENTRYSET_ARRAY_SIZE; i++){
            EntrySet<K, V> entry = entrySetArray[i];
            while(entry != null){
                keys.add(entry.getKey());
                entry = entry.next();
            }
        }
        return keys;
    }
}

class EntrySet<K, V> {
    private K key;
    private V value;
    private EntrySet<K, V> next;

    public EntrySet(K key, V value) {
        this.key = key;
        this.value = value;
    }

    public K getKey() {
        return key;
    }

    public V getValue() {
        return value;
    }

    public EntrySet<K, V> next() {
        return next;
    }

    public void setNext(EntrySet<K,V> next){
        this.next = next;
    }
}
// class HashMap<K,V>
//{
//    private double loadFactor = 0.75;
//    private Entry[] table;
//    private int elemCount;;
//
//    public static class Entry
//    {
//        K key;
//        V value;
//        Entry<K,V> next;
////contructors, getters and setters below
//...
//    }
//    /**
//     * Insert your super-mega-hash-function below :)
//     */
//    static int hash(int h)
//    {
//        h ^= (h >>> 20) ^ (h >>> 12);
//        return h ^ (h >>> 7) ^ (h >>> 4);
//    }
//
//    public void put(K key, V value)
//    {
//        if (elemCount>table.length*loadFactor) resize();//resize the table, if elements> above len*loadfactor
//
//        int index = hash(key.hashCode())%table.length;
//        if (table[index]==null) table[index] = new Entry(key,value);
//        else
//        {
//            Entry cur = table[index];
//            while(true)
//            {
//                if (cur.getKey().equals(key))
//                {
//                    cur.setValue(value);
//                    break;
//                }
//                if (cur.next()==null) break;
//                cur = cur.next();// end and the element does not exist in table!
//            }
//
//            cur.setNext(new Entry(key,value));//add it to end of table
//        }
//    }
//
//    public V get(K key)
//    {
//        int index = hash(key.hashCode())%table.length;
//        if (table[index]==null) return null;//if value at index==null, return null
//        else
//        {
//            Entry cur = table[index];
//            while(true)
//            {
//                if (cur.getKey().equals(key))// check if it exists in table
//                {
//                    return cur.getValue();
//                }
//                if (cur.next()==null)
//                    break;
//                cur = cur.next();
//            }
//            return null;// not in map!
//        }
//    }
//
//    public void resize()// resize the table by creating a new table of length=1.5* old table length
////instantiate new table
////copy all elements from old table to new table and return it
//    {
//        int newSize = table.length*1.5;
//        Entry[] newTable = new Entry[newSize];
//        for (int i=0; i<table.length; i++)
//            newTable[i]=table[i];
//        table = newTable;
//    }
////contructors, getters and setters below
//...
//}




//    public V put(K key, V value){
//        if(key == null)
//            return putForNullKey(value);
//        int hash = hash(key.hashCode());
//        int i = indexFor(hash, table.length);
//        for(Entry<K, V> e = table[i]; e != null; e = e.next){
//            Object k;
//            // Collision
//            if(e.hash == hash && K == e.key || key.equals(k)){
//                V oldValue = e.value;
//                e.value = value;
//                e.recordAccess(this);
//                return oldValue;
//            }
//        }
//        modCount++;
//        addEntry(hash, key, value, i);
//        return null;
//    }

//import static java.util.Collections.*;
//
//        import java.util.Collection;
//        import java.util.HashMap;
//        import java.util.Map;
//        import java.util.Set;
//        import java.util.concurrent.TimeUnit;

/**
 * A hash map that expires and removes items if they are older than a given
 * time-to-live.
 * <p>
 * The expiry is a passive process, items aren't removed until they are
 * retrieved and deemed to be expired by {@link #get(Object)}.
 */
//class TtlHashMap<K, V> implements Map<K, V> {
//
//    private final HashMap<K, V> store = new HashMap<>();
//    private final HashMap<K, Long> timestamps = new HashMap<>();
//    private final long ttl;
//
//    public TtlHashMap(TimeUnit ttlUnit, long ttlValue) {
//        this.ttl = ttlUnit.toNanos(ttlValue);
//    }
//
//    @Override
//    public V get(K key) {
//        V value = this.store.get(key);
//
//        if (value != null && expired(key, value)) {
//            store.remove(key);
//            timestamps.remove(key);
//            return null;
//        } else {
//            return value;
//        }
//    }
//
//    private boolean expired(Object key, V value) {
//        return (System.nanoTime() - timestamps.get(key)) > this.ttl;
//    }
//
//    @Override
//    public V put(K key, V value) {
//        timestamps.put(key, System.nanoTime());
//        return store.put(key, value);
//    }
//
//    @Override
//    public int size() {
//        return store.size();
//    }
//
//    @Override
//    public boolean isEmpty() {
//        return store.isEmpty();
//    }
//
//    @Override
//    public boolean containsKey(Object key) {
//        return store.containsKey(key);
//    }
//
//    @Override
//    public boolean containsValue(Object value) {
//        return store.containsValue(value);
//    }
//
//    @Override
//    public V remove(Object key) {
//        timestamps.remove(key);
//        return store.remove(key);
//    }
//
//    @Override
//    public void putAll(Map<? extends K, ? extends V> m) {
//        for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {
//            this.put(e.getKey(), e.getValue());
//        }
//    }
//
//    @Override
//    public void clear() {
//        timestamps.clear();
//        store.clear();
//    }
//
//    @Override
//    public Set<K> keySet() {
//        clearExpired();
//        return unmodifiableSet(store.keySet());
//    }
//
//    @Override
//    public Collection<V> values() {
//        clearExpired();
//        return unmodifiableCollection(store.values());
//    }
//
//    @Override
//    public Set<java.util.Map.Entry<K, V>> entrySet() {
//        clearExpired();
//        return unmodifiableSet(store.entrySet());
//    }
//
//    private void clearExpired() {
//        for (K k : store.keySet()) {
//            this.get(k);
//        }
//    }
//
//}
//https://howtodoinjava.com/core-java/collections/how-hashmap-works-in-java/
//http://www.javamadesoeasy.com/2015/04/concurrenthashmap-in-java.html

//
//public class HashMap<K,V>
//{
//    private double loadFactor = 0.75;
//    private Entry[] table;
//    private int elemCount;;
//
//    public static class Entry
//    {
//        K key;
//        V value;
//        Entry<K,V> next;
////contructors, getters and setters below
//...
//    }
//    /**
//     * Insert your super-mega-hash-function below :)
//     */
//    static int hash(int h)
//    {
//        h ^= (h >>> 20) ^ (h >>> 12);
//        return h ^ (h >>> 7) ^ (h >>> 4);
//    }
//
//    public void put(K key, V value)
//    {
//        if (elemCount>table.length*loadFactor) resize();//resize the table, if elements> above len*loadfactor
//
//        int index = hash(key.hashCode())%table.length;
//        if (table[index]==null) table[index] = new Entry(key,value);
//        else
//        {
//            Entry cur = table[index];
//            while(true)
//            {
//                if (cur.getKey().equals(key))
//                {
//                    cur.setValue(value);
//                    break;
//                }
//                if (cur.next()==null) break;
//                cur = cur.next();// end and the element does not exist in table!
//            }
//
//            cur.setNext(new Entry(key,value));//add it to end of table
//        }
//    }
//
//    public V get(K key)
//    {
//        int index = hash(key.hashCode())%table.length;
//        if (table[index]==null) return null;//if value at index==null, return null
//        else
//        {
//            Entry cur = table[index];
//            while(true)
//            {
//                if (cur.getKey().equals(key))// check if it exists in table
//                {
//                    return cur.getValue();
//                }
//                if (cur.next()==null)
//                    break;
//                cur = cur.next();
//            }
//            return null;// not in map!
//        }
//    }
//
//    public void resize()// resize the table by creating a new table of length=1.5* old table length
////instantiate new table
////copy all elements from old table to new table and return it
//    {
//        int newSize = table.length*1.5;
//        Entry[] newTable = new Entry[newSize];
//        for (int i=0; i<table.length; i++)
//            newTable[i]=table[i];
//        table = newTable;
//    }
////contructors, getters and setters below
//...
//}package SmallAndAmazingGitBookToGiveYouConfidence;

/**
 * Created by hadoop on 20/9/17.
 */
public class ShortestDistance {
    public int shortestDistance(String []words,String word1,String word2){
        int index1 = -1;
        int index2 = -1;
        int mindiff = Integer.MAX_VALUE;
        for(int i=0;i<words.length;i++){
            if(words[i].equalsIgnoreCase(word1)){
                if(index2!=-1 && word1.equals(word2)){
                    if(mindiff >Math.abs(index1-index2)){
                        mindiff = Math.abs(i-index1);
                    }
                }
                index1 =i;
            }
            else if(words[i].equalsIgnoreCase(word2)){
                index2 = i;
            }

            if(index1!=-1 && index2!=-1){
               if(mindiff >Math.abs(index1-index2)){
                   mindiff = Math.abs(index1-index2);
               }
            }
        }
        return mindiff;
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

/**
 * Created by hadoop on 21/9/17.
 */
public class InterLeaved {
    boolean interleaved(String s1,String s2,String s3){
        int len1 = s2.length();
        int len2 = s3.length();
        int len3 = s3.length();
        boolean [][]valid = new boolean[len1+1][len2+1];
        valid[0][0] = true;


        for( int i=1;i<=len1;i++){
            valid[i][0] = valid[i-1][0] && s1.charAt(i-1) == s2.charAt(i-1);
        }
        for( int i=1;i<=len1;i++){
            valid[0][i] = valid[0][i-1] && s1.charAt(i-1) == s3.charAt(i-1);
        }
        for(int i=1;i<=len1;i++){
            for(int j=1;j<=len2;j++){
                valid[i][j] = (valid[i-1][j] && s2.charAt(i-1) ==s1.charAt(i+j-1)) || (valid
                [i][j-1] && s3.charAt(j-1) == s1.charAt(i+j-1));
            }
        }
        return valid[len1][len2];
    }

    public static void main(String[] args) {
        InterLeaved interLeaved = new InterLeaved();
        System.out.println(interLeaved.interleaved("rajat","ra","jt"));
    }

}
package SmallAndAmazingGitBookToGiveYouConfidence;

import static java.util.Collections.*;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;

/**
 * A hash map that expires and removes items if they are older than a given
 * time-to-live.
 * <p>
 * The expiry is a passive process, items aren't removed until they are
 * retrieved and deemed to be expired by {@link #get(Object)}.
 */
public class TtlHashMap<K, V> implements Map<K, V> {

    private final HashMap<K, V> store = new HashMap<>();
    private final HashMap<K, Long> timestamps = new HashMap<>();
    private final long ttl;

    public TtlHashMap(TimeUnit ttlUnit, long ttlValue) {
        this.ttl = ttlUnit.toNanos(ttlValue);
    }

    @Override
    public V get(Object key) {
        V value = this.store.get(key);

        if (value != null && expired(key, value)) {
            store.remove(key);
            timestamps.remove(key);
            return null;
        } else {
            return value;
        }
    }

    private boolean expired(Object key, V value) {
        return (System.nanoTime() - timestamps.get(key)) > this.ttl;
    }

    @Override
    public V put(K key, V value) {
        timestamps.put(key, System.nanoTime());
        return store.put(key, value);
    }

    @Override
    public int size() {
        return store.size();
    }

    @Override
    public boolean isEmpty() {
        return store.isEmpty();
    }

    @Override
    public boolean containsKey(Object key) {
        return store.containsKey(key);
    }

    @Override
    public boolean containsValue(Object value) {
        return store.containsValue(value);
    }

    @Override
    public V remove(Object key) {
        timestamps.remove(key);
        return store.remove(key);
    }

    @Override
    public void putAll(Map<? extends K, ? extends V> m) {
        for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {
            this.put(e.getKey(), e.getValue());
        }
    }

    @Override
    public void clear() {
        timestamps.clear();
        store.clear();
    }

    @Override
    public Set<K> keySet() {
        clearExpired();
        return unmodifiableSet(store.keySet());
    }

    @Override
    public Collection<V> values() {
        clearExpired();
        return unmodifiableCollection(store.values());
    }

    @Override
    public Set<java.util.Map.Entry<K, V>> entrySet() {
        clearExpired();
        return unmodifiableSet(store.entrySet());
    }

    private void clearExpired() {
        for (K k : store.keySet()) {
            this.get(k);
        }
    }

}package SmallAndAmazingGitBookToGiveYouConfidence;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Created by hadoop on 19/9/17.
 */
public class WeakConnectedComponents {
    DisjointSet disjointSet = new DisjointSet();

    public List<List<Integer>> connectedSet2(ArrayList<DirectedGraphNode> nodes) {
        List<List<Integer>> result = new ArrayList<>();
        for(DirectedGraphNode node:nodes){
            disjointSet.makeSet(node.label);
        }

        for(DirectedGraphNode parent:nodes){
            for(DirectedGraphNode child:parent.neighbors){
                disjointSet.union(parent.label,child.label);
            }
        }
        Map<Long,List<Long>> list = new HashMap<>();
        for(DirectedGraphNode node:nodes){
            long parent = disjointSet.findSet(node.label);
            if(list.containsKey(parent)){
                list.get(parent).add(node.label);
            }
            else {
                List <Long> list1 = new ArrayList<>();
                list1.add(node.label);
                list.put(parent,list1);
            }
        }
        for(List l:list.values()){
            result.add(l);
        }
    return result;
    }
    private  class DirectedGraphNode {
        long label;
        ArrayList<DirectedGraphNode> neighbors;

        DirectedGraphNode(int x) {
            label = x;
            neighbors = new ArrayList<DirectedGraphNode>();
        }
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

/**
 * Created by hadoop on 23/9/17.
 */
public class SegmentTree {

    private class SegmentTreeNode{
        int start;
        int end;
        int max;
        SegmentTreeNode left;
        SegmentTreeNode right;
        public SegmentTreeNode(int start,int end){
            this.start=start;
            this.end= end;
        }
        public SegmentTreeNode(int start,int end,int max){
            this.start = start;
            this.end = end;
            this.max = max;
        }
    }
    SegmentTreeNode build(int start,int end){
        if(start>end){
            return null;
        }
        if(start == end){
            return new SegmentTreeNode(start,start);
        }
        int mid = (start+end)/2;
        SegmentTreeNode root = new SegmentTreeNode(start,end);
        root.left = build(start,mid);
        root.right = build(mid+1,end);
        return root;
    }

    SegmentTreeNode build(int []a,int start,int end){
        if(start >end){
            return null;
        }
        if(start == end){
            return new SegmentTreeNode(start,end,a[start]);
        }
        Integer leftMax = Integer.MIN_VALUE;
        Integer rightMax = Integer.MIN_VALUE;
        SegmentTreeNode root = new SegmentTreeNode(start,end,0);
        int mid = (start+end)/2;
        root.left = build(a,start,mid);
        root.right = build(a,mid+1,end);
        if(root.left!=null){
            leftMax = root.left.max;
        }
        if(root.right!=null){
            rightMax = root.right.max;
        }
        Integer rootMaxValue = Math.max(leftMax,rightMax);
        root.max = rootMaxValue;
        return root;
    }

    Integer  query(SegmentTreeNode root,int start,int end){
        if(start>end){
            return -1;
        }
        if(root.start == root.end){
            return root.max;
        }
        if(root.start == start && root.end ==end){
            return root.max;
        }
        int mid = (root.start + root.end) /2;
        if(end<=mid){
            return query(root.left,start,end);
        }
        else if(start>=mid+1){
            return query(root.right,start,end);
        }
        else {
            int leftans = query(root.left,start,mid);
            int rightans = query(root.right,mid+1,end);
            return Math.max(leftans,rightans);
        }
    }
}package SmallAndAmazingGitBookToGiveYouConfidence;

import java.util.TreeSet;

/**
 * Created by hadoop on 21/9/17.
 */
public class ContainsDuplicate3 {
    boolean containsNearbyAlmostDuplicate(int []nums,int k,int t){
        final TreeSet<Integer> values = new TreeSet<>();
        for(int i=0;i<nums.length;i++){
            Integer potentialNum = values.ceiling(nums[i] - t);

            if (potentialNum != null && potentialNum <= (long)nums[i] + t) {
                return true;
            }
//            Integer floorCheck = values.floor(nums[i]+t); // floor means neeche
 //           Integer ceilCheck = values.ceiling(nums[i]-t);// ceil means upar ...
            values.add(nums[i]);
            if(i>=t){
                values.remove(nums[i-t]);
            }
        }
        return false;
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

/**
 * Created by hadoop on 19/9/17.
 */
public class MergeInterval {
    List<Interval> mergeIntervals(List<Interval> intervals){
        List<Interval> result = new ArrayList<>();
        if(intervals == null || intervals.size()==0){
            return result;
        }
        //Sort based on start time
        Collections.sort(intervals, new Comparator<Interval>() {
            @Override
            public int compare(Interval o1, Interval o2) {
                if(o1.start == o2.start){
                    return o1.end-o2.start;
                }
                return o1.start-o2.start;
            }
        });
        Interval mergedInterval = intervals.get(0);
        for(int index=1;index<intervals.size();index++){
            Interval interval = intervals.get(index);

            if(mergedInterval.end>=interval.start){
                if(mergedInterval.end<=interval.end){
                    mergedInterval.end = interval.end;
                }
            }
            else {
                result.add(mergedInterval);
                mergedInterval = interval;
            }
        }
        result.add(mergedInterval);
        return result;
    }
    private class Interval{
        int start;
        int end;
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

import java.util.Arrays;

/**
 * Created by hadoop on 22/9/17.
 */
public class SmallestDifference {
    public int smallestDiff(int []a,int []b){
        Arrays.sort(a);
        Arrays.sort(b);
        int index1=0;
        int index2=0;
        int mindiff = Integer.MAX_VALUE;
        while (index1<a.length && index2 <b.length){
            mindiff = Math.min(mindiff,Math.abs(a[index1]-b[index2]));
            if(mindiff ==0){
                return 0;
            }
            if(a[index1]<b[index2]){
                index1++;
            }
            else {
                index2++;
            }
        }
        return mindiff;
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

/**
 * Created by hadoop on 21/9/17.
 */
public class ReverseString2 {
    public static void main(String args[]){
        ReverseString2 reverseString2 = new ReverseString2();
        String a = "rahat is goog";
        char[] array = a.toCharArray();
        reverseString2.reverseWords(array);
        for(int i=0;i<array.length;i++){
            System.out.println(array[i]);
        }
    }
    void reverseWords(char [] words){
        int start=0;
        for(int i=0;i<words.length;i++){
            if(words[i] == ' '){
                reverseWordsHelper(words,start,i-1);
                start = i+1;
            }
            if(i == words.length -1){
                reverseWordsHelper(words,start,i);
            }
        }
        reverseWordsHelper(words,0,words.length-1);
    }

    private void reverseWordsHelper(char[] words, int start, int end) {
        while (start<end){
            char temp  = words[start];
            words[start] = words[end];
            words[end] = temp;
            start++;
            end--;
        }
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

/**
 * Created by hadoop on 22/9/17.
 */
public class SubarraySimple {
    public ArrayList<Integer> subarraySum(int[] nums,int sum) {
        HashMap<Integer,Integer> index = new HashMap<>();
        index.put(0,-1);
        int currsum = 0;
        for(int i =0;i<nums.length;i++){
            currsum = currsum + nums[i];
            if(index.containsKey(currsum-sum)){
                ArrayList<Integer> list = new ArrayList<>();
                list.add(index.get(currsum-sum)+1);
                list.add(i);
                return list;
            }
            index.put(currsum,i);
        }
        return null;
    }
}package SmallAndAmazingGitBookToGiveYouConfidence;

/**
 * Created by hadoop on 19/9/17.
 */
public class ReverseIngeter {
    public static void main(String[] args) {

    }
    public  int reverse(int n){
        int result = 0;
        while (n>0){
            if(result> Integer.MAX_VALUE/10){
                return 0;
            }
            result = result*10 + n%10;
            n = n/10;
        }
        return result;
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

import java.util.Stack;


/**
 * Created by hadoop on 22/9/17.
 */
public class ExpressionEval {
    public int expression(String []expression){
        Stack<String> opStack = new Stack<>();
        Stack<Integer> computeStack = new Stack<>();
        
        for(String token:expression){
            if(isNumberToken(token)){
                computeStack.push(Integer.parseInt(token));
                continue;
            }
            if(token.equals("(")){
                opStack.push(token);
            }
            if(token.equals(")")){
                while (!opStack.isEmpty() && opStack.peek()!="("){
                    computeStack.push(compute(opStack.pop(),computeStack.pop(),computeStack.pop()));
                }
            }
            else {
                while (!opStack.isEmpty() && getPriorityToken(token)<=getPriorityToken(opStack.peek())){
                    computeStack.push(compute(opStack.pop(),computeStack.pop(),computeStack.pop()));
                }
            }
        }
        while (!computeStack.isEmpty()){
            computeStack.push(compute(opStack.pop(),computeStack.pop(),computeStack.pop()));
        }
        return computeStack.pop();
    }

    private int compute(String token, Integer num2, Integer num1) {
        int result;
        if (token.equals("+")) {
            result = num1 + num2;
        } else if (token.equals("-")) {
            result = num1 - num2;
        } else if (token.equals("*")) {
            result = num1 * num2;
        } else {
            result = num1 / num2;
        }
        return result;
    }

    int getPriorityToken(String op){

            if (op.equals("(")) {
                return 0;
            } else if (op.equals("+") || op.equals("-")) {
                return 1;
            } else {
                return 2;
            }
    }

    private boolean isNumberToken(String token) {
        return Character.isDigit(token.charAt(0));
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

import java.util.HashSet;
import java.util.PriorityQueue;
import java.util.Set;

/**
 * Created by hadoop on 21/9/17.
 */
public class UglyNumbers {
    int [] ugly(int n){
        int []ulgly = new int[n+1];
        ulgly[1] = 2;
        int i2 = 1;
        int  i5 = 1;
        int i7 = 1;
        for (int i=2;i<=n;i++){
            ulgly[i] = Math.min(Math.min(ulgly[i2]*2,ulgly[i5]*2),ulgly[i7]*7);
            if(ulgly[i] == ulgly[i2]*2){
                i2 = i2+1;
            }
            if(ulgly[i] == ulgly[i5]*5){
                i5 = i5+1;
            }
            if(ulgly[i] == ulgly[i7]*7){
                i7 = i7+1;
            }
        }
        return ulgly;
    }
    int []uglyNUmberUsingPq(int n){
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        Set<Integer> set = new HashSet<>();
        int []factors = {2,3,5};
        pq.add(1);
        set.add(1);
        int []ugly = new int[n+1];
        ugly[1] = 1;
        for(int i=1;i<=n;i++){
            int number = pq.poll();
            ugly[i] = number;
            for(int factor:factors){
                int numbertoinsert = factor*number;
                if(!set.contains(numbertoinsert)){
                    set.add(numbertoinsert);
                    pq.add(numbertoinsert);
                }
            }
        }
        return ugly;
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

import java.util.ArrayList;
import java.util.List;

/**
 * Created by hadoop on 19/9/17.
 */
public class ConnectedComponents {
    DisjointSet disJoint = new DisjointSet();
    public static int[][]DIRS = {{1,0},{0,1},{0,-1},{-1,0}};
    List<Integer> numIslands(int n,int m,Point []operatos){
        List<Integer> result = new ArrayList<>();
        boolean [][] islands = new boolean[n][m];
        int count =0;
        for(Point p:operatos){
            if(!islands[p.x][p.y]){
                islands[p.x][p.y]=true;
                int id = getId(n,p.x,p.y);
                disJoint.makeSet(id);
                long root = disJoint.findSet(id);
                for(int i=0;i<4;i++){
                    int newx = p.x+DIRS[i][0];
                    int newy = p.y +DIRS[i][1];
                    if(!isValid(newx,newy,n,m) && islands[newx][newy])continue;
                    long newRoot = disJoint.findSet(getId(n,newx,newy));
                    if(root!=newRoot){
                        count--;
                        disJoint.union(root,newRoot);
                    }
                }
            }
            result.add(count);
        }
        return result;
    }

    private boolean isValid(int newx, int newy,int n,int m) {
        if(newx>=0 && newx<n && newy>0 && newy <m){
            return true;
        }
        return false;
    }

    private int getId(int m,int x, int y) {
        return x*m+y;
    }

    private class Point{
        int x;
        int y;
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

import java.util.Stack;

/**
 * Created by hadoop on 19/9/17.
 */
public class StackMin {
    Stack<Integer> stack = new Stack<>();
    Stack<Integer> minstack = new Stack<>();

    void push(Integer x){
        stack.push(x);
        if(minstack.isEmpty() || x>=minstack.peek()){
            minstack.push(x);
        }
    }
    Integer pop(){
        int value = stack.pop();
        if(value == minstack.peek()){
            minstack.pop();
        }
        return value;
    }
    Integer top(){
        return stack.peek();
    }
    Integer getMin(){
        if(!minstack.isEmpty()) {
            return minstack.peek();
        }
        return -1;
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.PriorityQueue;

/**
 * Created by hadoop on 21/9/17.
 */
public class SlidingWindowMedian {

    List<Integer> slidingWindow(int []num, int k){
        ArrayList<Integer> list = new ArrayList<>();
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return Integer.compare(o2,o1);
            }
        });
        for(int i=0;i<num.length;i++){
            // add the number
            if(maxHeap.isEmpty() || num[i]<maxHeap.peek()){
                maxHeap.add(num[i]);
            }
            else {
                minHeap.add(num[i]);
            }
            // remove the number
            // remove element ffrom window
            if(i>=k){
                if(num[i-k]>maxHeap.peek()){
                    minHeap.remove(num[i-k]);
                }
                else {
                    maxHeap.remove(num[i-k]);
                }
            }
            // rebalance the number
            if(maxHeap.size()-minHeap.size() >=2){
                minHeap.add(maxHeap.poll());
            }
            if(minHeap.size() -maxHeap.size() >=1){
                maxHeap.add(minHeap.poll());
            }
            //find the peek
            if( i>=k-1 ){
                list.add(maxHeap.peek());
                System.out.println(maxHeap.peek());
            }
        }
        return list;
    }
    double[] setMedian(int []array){
        PriorityQueue<Integer> loweres = new PriorityQueue<>(new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
               return  -1*o1.compareTo(o2);
            }
        });
        PriorityQueue<Integer> higher = new PriorityQueue<>();
        double[] median = new double[array.length];
        for( int i=0;i<array.length;i++){
            // here no removal only addition ...
            addNumber(array[i],loweres,higher);
            balace(loweres,higher);
            median[i] = getMedian(loweres,higher);
        }
        return median;
    }

    private double getMedian(PriorityQueue<Integer> loweres, PriorityQueue<Integer> higher) {
            if(loweres.size() == higher.size()){
                return (loweres.peek() + higher.peek())/2;
            }
            return loweres.peek();
    }

    private void balace(PriorityQueue<Integer> maxheapOfLowersNumbers, PriorityQueue<Integer> minHeapOfHigherNumbers) {
        if(maxheapOfLowersNumbers.size()-minHeapOfHigherNumbers.size()>=2){
            minHeapOfHigherNumbers.add(maxheapOfLowersNumbers.poll());
        }
        if(minHeapOfHigherNumbers.size()-maxheapOfLowersNumbers.size()>=1){
            maxheapOfLowersNumbers.add(minHeapOfHigherNumbers.poll());
        }
    }

    private void addNumber(int i, PriorityQueue<Integer> loweres, PriorityQueue<Integer> higher) {
            if(loweres.isEmpty() || i<loweres.peek()){
                loweres.add(i);
            }
            else{
                higher.add(i);
            }
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

import java.util.ArrayList;
import java.util.List;

/**
 * Created by hadoop on 19/9/17.
 */
public class GrayCode {
    public static void main(String[] args) {
        GrayCode grayCode = new GrayCode();
        System.out.println(grayCode.grayCode(3));
    }
    List<Integer> grayCode(int n){
        List<Integer> result = new ArrayList<>();
        result.add(0);
        for(int i=1;i<=n;i++){
            // fetch the last indexed value it is in order since Arraylist ..
            int size = result.size()-1;
            while (size>=0){
                result.add(result.get(size) | 1<<i-1);
                size--;
            }
        }
        System.out.println(result);
        return result;
    }

}
package SmallAndAmazingGitBookToGiveYouConfidence;

/**
 * Created by hadoop on 19/9/17.
 */
public class DigitsCount {
    public long digitsCount(int k,int n){
        long result = 0;
        for(int base = 1;base<=n;base= base*10){
            int highernumber = n/base;
            int lowernumber = n%base;
            System.out.println(lowernumber);
            System.out.println(highernumber);
            if(highernumber % 10 >k){
                result = result + (highernumber/10+1)*base;
            }
            else {
                result = result + (highernumber/10)*base;
            }
            if(highernumber%10 == k){
                result = result + (lowernumber + 1);
            }
        }
        return result;
    }

    public static void main(String[] args) {
        DigitsCount digitsCount = new DigitsCount();
        System.out.println(digitsCount.digitsCount(1,1410065408));
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

/**
 * Created by hadoop on 21/9/17.
 */
public class Kadans {

    public static void main(String []args){
        Kadans kadans = new Kadans();
        int []temp = new int[]{-1,-3,-4,5,6};
        kadans.kadanemin(temp);
    }

    public static void kadanemin(int []temp){
            int currentMin =0;
            int globalMin = Integer.MAX_VALUE;
            int globalLeft = 0;
            int globalRight = 0;
            int localleft = 0;
            for(int i=0;i<temp.length;i++){
                currentMin = currentMin + temp[i];
                if(currentMin>0){
                    currentMin = 0;
                    localleft = i+1;
                }
                if(currentMin<globalMin){
                    globalMin = currentMin;
                    globalLeft = localleft;
                    globalRight = i;
                }
            }
        System.out.println("Globalmin"+globalMin);
        System.out.println("Globalleft"+globalLeft);
        System.out.println("GlobalRight"+globalRight);
    }
    public static void kadanonedim( int [] temp){
        int max = Integer.MIN_VALUE;
        int startcolumn = -1;
        int startcolumntemp = 0;
        int endcolumn = -1;
        int maxsofar=0;

        for( int i=0;i<temp.length;i++){
            maxsofar = maxsofar +temp[i];
            if(maxsofar<0){
                maxsofar=0;
                startcolumntemp = i+1;
            }
            if(maxsofar>max){
                max = maxsofar;
                endcolumn = i;
                startcolumn = startcolumntemp;
            }
        }
//        return new kadane(startcolumn,endcolumn,max);
    }
}


package SmallAndAmazingGitBookToGiveYouConfidence;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Queue;

/**
 * Created by hadoop on 22/9/17.
 */
public class TopSort {
    public ArrayList<DirectedGraphNode> topSort(ArrayList<DirectedGraphNode> graph){
            ArrayList<DirectedGraphNode> result = new ArrayList<DirectedGraphNode>();
            //init
            HashMap<DirectedGraphNode,Integer> inDegreeMap = new HashMap<>();
            for(DirectedGraphNode node:graph){
                inDegreeMap.put(node,0);
            }
            //count indegree
            for(DirectedGraphNode directedGraphNode :graph){
                for(DirectedGraphNode neighbournode:directedGraphNode.neighbours){
                    inDegreeMap.put(neighbournode,inDegreeMap.get(neighbournode)+1);
                }
            }
            //Get 0 ingress node
        Queue<DirectedGraphNode> queue = new LinkedList<>();
        Queue<DirectedGraphNode> anotherqueue = new LinkedList<>();

        for(DirectedGraphNode directedGraphNode:graph){
                if(inDegreeMap.get(directedGraphNode) ==0){
                    queue.add(directedGraphNode);
                    result.add(directedGraphNode);
                }
            }

        for(HashMap.Entry<DirectedGraphNode,Integer> entry:inDegreeMap.entrySet()){
                if(entry.getValue() ==0){
                    anotherqueue.add(entry.getKey());
                }
        }
        while (!queue.isEmpty()){
                DirectedGraphNode zeroIndegreeNode =queue.poll();
                for(DirectedGraphNode directedGraphNode:zeroIndegreeNode.neighbours){
                    inDegreeMap.put(directedGraphNode,inDegreeMap.get(directedGraphNode)-1);
                    if(inDegreeMap.get(directedGraphNode) == 0){
                        queue.add(directedGraphNode);
                        result.add(directedGraphNode);
                    }
                }
        }

        return result;
    }
    private class DirectedGraphNode{
        int labelNode;
        ArrayList<DirectedGraphNode> neighbours;
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

import java.util.HashMap;
import java.util.Map;
import java.util.Stack;

/**
 * Created by hadoop on 21/9/17.
 */
public class ReverseString3 {
    public static void main(String args[]){

    }
    public static String reverseString(String s){
        Map<Integer,String> punctuationMap = new HashMap<>();
        Stack<String> wordStack = new Stack<>();
        int start =0;
        int end = 0;
        int wordcount = 0;
        while(end <s.length()){
            start = end;
            while(start<s.length() && s.charAt(start) == ' '){
                start++;
            }
            end = start;
            while (end<s.length() && Character.isLetter(s.charAt(end))){
                end++;
            }
            wordcount++;
            if(Character.isLetter(s.charAt(end-1))){
                wordStack.push(s.substring(start,end));
            }
            else{
                punctuationMap.put(wordcount,s.substring(start,end));
            }
        }
        StringBuilder builder = new StringBuilder();
        for(int i=1;i<=wordcount;i++){
            if(punctuationMap.containsKey(i)){
                builder.append(punctuationMap.get(i));
            }
            else {
                builder.append(" "+wordStack.pop());
            }
        }
        return builder.toString().trim();
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

import java.util.Stack;

/**
 * Created by hadoop on 21/9/17.
 */
public class DeleteDigits {
    public String DeleteDigits(String A, int k) {
        Stack<Integer> stack = new Stack<>();
        for (char c : A.toCharArray()) {
            int num = c - '0';
            while (k > 0 && !stack.isEmpty() && num < stack.peek()) {
                stack.pop();
                k--;
            }
            stack.push(num);
        }
        while (k > 0) {
            stack.pop();
            k--;
        }
        // construct result
        StringBuilder sb = new StringBuilder();
        while (!stack.isEmpty()) {
            sb.append(stack.pop());
        }
        String result = sb.reverse().toString();
        // skip leading 0
        int start = 0;
        while (result.charAt(start) == '0') {
            start++;
        }
        // handle special case
        if (start == result.length()) {
            return "0";
        }
        return result.substring(start);
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

import java.util.Stack;

/**
 * Created by hadoop on 19/9/17.
 */
public class Myqueue {
    private Stack<Integer> inStack = new Stack<>();
    private Stack<Integer> outStack = new Stack<>();

    public void push(int x){
        inStack.push(x);
    }
    public int pop(){
        if(outStack.isEmpty()){
            while (!inStack.isEmpty()) {
                outStack.push(inStack.pop());
            }
        }
        return outStack.pop();
    }
    public boolean isEmpty(){
        if(inStack.isEmpty() && outStack.isEmpty()){
            return true;
        }
        else {
            return false;
        }
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

/**
 * Created by hadoop on 19/9/17.
 */
public class SubarraySum0 {
    public ArrayList<Integer> subarraySum(int []nums){
        ArrayList<Integer> result = new ArrayList<>();
        Map<Integer,Integer> map = new HashMap<>();
        map.put(0,-1);
        int sum =0;
        for(int i=0;i<nums.length;i++){
            sum = sum + nums[i];
            // to check sum s
            // check for sum-s in hashmap

            if(map.containsKey(sum)){
                int startIndex = map.get(sum)+1;
                int endIndex = i;
                result.add(startIndex);
                result.add(endIndex);
                return result;
            }
            map.put(sum,i);
        }
        return result;
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

/**
 * Created by hadoop on 20/9/17.
 */
public class ReverseString {
    public static void main(String[] args) {
        ReverseString reverseString = new ReverseString();
        System.out.println(reverseString.reverseString("rajat"));
        System.out.print(reverseString.reverseWords("rajat is good"));
    }

    public String reverseWords(String s){
        if( s== null){
            return s;
        }
        StringBuilder stringBuilder = new StringBuilder();
        int start =0;
        while (start<s.length() && s.charAt(start) == ' '){
            start++;
        }

        for( int end =start;end<s.length();end++){
            if(s.charAt(end) == ' '){
                stringBuilder.append(reverseString(s.substring(start,end))).append(' ');
                while (end<s.length() && s.charAt(end)==' '){
                    end++;
                }
                start = end;
            }
            if(end == s.length()-1) {
                stringBuilder.append(reverseString(s.substring(start, end+1)));
            }
        }
        String returnedString = stringBuilder.toString();
        return reverseString(returnedString);
    }

    private String reverseString(String returnedString) {
        char []array = returnedString.toCharArray();
        int start=0;
        int end = returnedString.length()-1;
        while (start<end){
            char temp = array[start];
            array[start] = array[end];
            array[end] = temp;
            start++;
            end--;
        }
        return String.valueOf(array);
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

/**
 * Created by hadoop on 21/9/17.
 */
public class PeakElement {
    int findPeak(int  []nums){
        int start=0;
        int end = nums.length-1;
        while (start<end){
            int mid = start + end-start/2;
            if(nums[mid] <nums[mid+1]){
                start= mid+1;
            }
            else {
                end = mid;
            }
        }
        return start;
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

import java.util.ArrayList;

/**
 * Created by hadoop on 21/9/17.
 */
public class MaxSubarray3 {
    public int maxSubArray(ArrayList<Integer> num){
        int len = num.size();
        int leftmax[]= new int[len];
        int leftmin[] = new int[len];

        int rightmax[] = new int[len];
        int rightmin[] = new int[len];
        int currentMax = 0;
        int currentMin = 0;
        for(int i=0;i<len;i++){
            currentMax = Math.max(currentMax+num.get(i),num.get(i));
            currentMin = Math.min(currentMin+num.get(i),num.get(i));
            if(i==0){
                leftmax[i] = currentMax;
                leftmin[i] = currentMin;
            }
            leftmax[i] = Math.max(leftmax[i-1],currentMax);
            leftmin[i] = Math.min(leftmin[i-1],currentMin);
        }

        return 0;
    }
    public int maxDiffSubArrays(ArrayList<Integer> nums) {
        int len = nums.size();
        int[] leftMax = new int[len];
        int[] leftMin = new int[len];
        int curMaxSum = 0;
        int curMinSum = 0;
        // scan from left to right
        for (int i = 0; i < len; i++) {
            curMaxSum = Math.max(curMaxSum + nums.get(i), nums.get(i));
            curMinSum = Math.min(curMinSum + nums.get(i), nums.get(i));
            if (i == 0) {
                leftMax[i] = curMaxSum;
                leftMin[i] = curMinSum;
            } else {
                leftMax[i] = Math.max(leftMax[i - 1], curMaxSum);
                leftMin[i] = Math.min(leftMin[i - 1], curMinSum);
            }
        }
        // scan from right to left
        curMaxSum = 0;
        curMinSum = 0;
        int rightMax = 0;
        int rightMin = 0;
        int maxDiff = 0;
        for (int i = len - 1; i > 0; i--) {
            curMaxSum = Math.max(curMaxSum + nums.get(i), nums.get(i));
            curMinSum = Math.min(curMinSum + nums.get(i), nums.get(i));
            if (i == len - 1) {
                rightMax = curMaxSum;
                rightMin = curMinSum;
            } else {
                rightMax = Math.max(rightMax, curMaxSum);
                rightMin = Math.min(rightMin, curMinSum);
            }
            maxDiff = Math.max(
                    maxDiff,
                    Math.max(
                            Math.abs(leftMax[i - 1] - rightMin),
                            Math.abs(rightMax - leftMin[i - 1])));
        }
        return maxDiff;
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

/**
 * Created by hadoop on 20/9/17.
 */
public class ReverseWords {
    String reverse(String b){
        int firstNonSpaceindex=0;
        char[] a = b.toCharArray();
        for(int i=0;i<a.length;i++){
            if(a[i]==' '){
                reversesubstring(a,firstNonSpaceindex,i-1);
                while (i<a.length && a[i] ==' '){
                    i++;
                }
                firstNonSpaceindex = i;
            }
            System.out.println("index is"+i);
            if(i ==a.length-1){
                reversesubstring(a,firstNonSpaceindex,i);
            }
        }
        reversesubstring(a,0,b.length()-1);
        return String.valueOf(a);
    }

    private void reversesubstring(char[] a, int isspaceindex, int i) {
        while (isspaceindex<i){
            swap(a,isspaceindex,i);
            isspaceindex++;
            i--;
        }

    }

    private void swap(char[] a, int isspaceindex, int i) {
        char temp = a[isspaceindex];
        a[isspaceindex] = a[i];
        a[i] = temp;

    }

    public static void main(String[] args) {
        ReverseWords reverseWords = new ReverseWords();
        System.out.println(reverseWords.reverse("rajat is good"));
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

/**
 * Created by hadoop on 21/9/17.
 */
public class LongestIncreasingDecreasing {
    public static int maxIncreasingLength(int []nums){
        int []leftIncreasing = new int[nums.length];
        leftIncreasing[0] = 1;
        for(int i=1;i<nums.length;i++){
            if(nums[i]>=nums[i-1]){
                leftIncreasing[i] = Math.max(leftIncreasing[i-1],leftIncreasing[i-1]+1);
            }
            else {
                leftIncreasing[i] = 1;
            }
        }
        int []rightIncreasing = new int[nums.length];
        for(int i=nums.length-2;i>=0;i--){
            if(nums[i]>=nums[i+1]){
                rightIncreasing[i] = Math.max(rightIncreasing[i+1],rightIncreasing[i+1]+1);
            }
            else {
                rightIncreasing[i] = 1;
            }
        }
        int ans =1;
        for(int i=0;i<nums.length;i++){
            ans = Math.max(ans,Math.max(leftIncreasing[i],rightIncreasing[i]));
        }
        System.out.println("ans"+ans);
        return ans;
    }

    public static void main(String[] args) {
        int []nums ={5, 4, 2, 1, 3};
        System.out.println(maxIncreasingLength(nums));
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

/**
 * Created by hadoop on 19/9/17.
 */
public class SingletonEagerRelyOnJvm {
    private static SingletonEagerRelyOnJvm singletonEagerRelyOnJvm = new SingletonEagerRelyOnJvm();
    private SingletonEagerRelyOnJvm(){

    }
    SingletonEagerRelyOnJvm getSingletonEagerRelyOnJvm(){
        return singletonEagerRelyOnJvm;
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

import java.util.HashMap;

/**
 * Created by hadoop on 19/9/17.
 */
public class DisJointSetImpl {
    HashMap<Character,Node> rootMap = new HashMap<Character, Node>();
    private class Node{
        Node parent;
        int rank;
        Character data;
    }
    public void makeSet(Character data){
        Node node = new Node();
        node.parent = node;
        node.rank = 0;
        node.data = data;
        rootMap.put(data,node);
    }
    public boolean unionSet(Character data1,Character data2){
        Node node1 = rootMap.get(data1);
        Node node2 = rootMap.get(data2);

        Node parent1 = findSet(node1);
        Node parent2 = findSet(node2);
        if(parent1 == parent2){
            return false;
        }
        if(parent1.rank <parent2.rank){
            parent1.parent = parent2;
        }
        else if(parent1.rank>parent2.rank){
            parent2.parent = parent1;
        }
        else {
            parent1.rank = parent1.rank+1;
            parent2.parent = parent1;
        }
        return true;

    }
    public Node findSet(Node node){
        Node parent = node.parent;
        if(parent!=node){
            node.parent = findSet(parent);
        }
        return parent;
    }
    public Character findSet(Character character){
        if(rootMap.containsKey(character)) {
            return findSet(rootMap.get(character)).data;
        }
        return null;
    }

    public static void main(String[] args) {
        DisJointSetImpl disJointSet = new DisJointSetImpl();

        DisjointSet ds = new DisjointSet();
        ds.makeSet(1);
        ds.makeSet(2);
        ds.makeSet(3);
        ds.makeSet(4);
        ds.makeSet(5);
        ds.makeSet(6);
        ds.makeSet(7);

        ds.union(1, 2);
        ds.union(2, 3);
        ds.union(4, 5);
        ds.union(6, 7);
        ds.union(5, 6);
        ds.union(3, 7);

        System.out.println(ds.findSet(1));
        System.out.println(ds.findSet(2));
        System.out.println(ds.findSet(3));
        System.out.println(ds.findSet(4));
        System.out.println(ds.findSet(5));
        System.out.println(ds.findSet(6));
        System.out.println(ds.findSet(7));
        disJointSet.makeSet('a');
        disJointSet.makeSet('b');disJointSet.makeSet('c');disJointSet.makeSet('d');disJointSet.makeSet('e');
        disJointSet.makeSet('f');disJointSet.makeSet('g');
        disJointSet.unionSet('a','b');
        disJointSet.unionSet('b','c');
        disJointSet.unionSet('d','e');
        disJointSet.unionSet('f','g');
        System.out.println(disJointSet.findSet('e'));
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

import java.util.HashSet;
import java.util.Set;

/**
 * Created by hadoop on 22/9/17.
 */
public class CotainsDup {
    public boolean containsDup(int []nums){
        Set<Integer> hashSet = new HashSet<>();
        for(int num:nums){
            if(hashSet.contains(num)){
                return true;
            }
            hashSet.add(num);
        }
        return false;
    }
    public boolean containDupInRange(int [] nums,int k){
        Set<Integer> hashset = new HashSet<>();
        for(int i=0;i<nums.length;i++){
            if(hashset.contains(nums[i])){
                return true;
            }
            if(i>=k){
                hashset.remove(nums[i-k]);
            }
            hashset.add(nums[i]);
        }
        return false;
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

/**
 * Created by hadoop on 20/9/17.
 */
public class Palindrome {
    public boolean isPalndrome(String a){
        int start =0;
        int end = a.length()-1;
        while (start<end){
            while (start<end && Character.isSpaceChar(a.charAt(start))){
                start++;
            }
            while (start<end && Character.isSpaceChar(a.charAt(end))){
                end--;
            }
            if(a.charAt(start) != a.charAt(end)){
                return false;
            }
            start++;
            end--;
        }
        return true;
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

/**
 * Created by hadoop on 20/9/17.
 */
public class AddOne {
    public  int[] plusOne(int []num){
        int carry = 1;
        int []temp = new int[num.length+1];
        for(int i=num.length-1;i>=0;i--){
            int sum = num[i] + carry;
            int value = sum%10;
            temp[i+1] = value;
            carry = sum/10;
        }
        if(carry == 1){
            temp[0] = 1;
            return temp;
        }
        for(int i=0;i<num.length;i++){
            temp[i] = temp[i+1];
        }
        return temp;
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

/**
 * Created by hadoop on 20/9/17.
 */
public class AddLists {
    int base = 10;
    private class ListNode{
        int val;
        ListNode next;
        ListNode(int val){
            this.val = val;
        }
    }
    ListNode addLists(ListNode a,ListNode b){
        int carry=0;
        ListNode dummy = new ListNode(-1);
        ListNode tail = dummy;
        while (a!=null && b!=null){
            int sum = carry + a.val + b.val;
                carry = sum/base;
                int nodevalue = sum%base;
                tail.next = new ListNode(nodevalue);
                tail = tail.next;
                a = a.next;
                b = b.next;
        }
        while (a!=null){
            int sum = carry+a.val;
            carry = sum/base;
            int nodevalue = sum%base;
            tail.next = new ListNode(nodevalue);
            tail = tail.next;
            a = a.next;
        }

        while (b!=null){
            int sum = carry+b.val;
            carry = sum/base;
            int nodevalue = sum%base;
            tail.next = new ListNode(nodevalue);
            tail = tail.next;
            b = b.next;
        }
        if(carry!=0){
            tail.next = new ListNode(carry);
            tail = tail.next;
        }
        return dummy.next;
    }
    public static void main(String args[]){
        AddLists addLists = new AddLists();
        //addLists.addLists();
    }
    public ListNode shortListNode(ListNode a,ListNode b){
        ListNode dummy = new ListNode(-1);
        ListNode tail = dummy;
        int carry =0;
        while(a!=null || b!=null || carry!=0){
            int num1=0;
            if(a!=null){
                num1 = a.val;
                a = a.next;
            }
            int num2 = 0;
            if(b!=null){
                num2 = b.val;
                b = b.next;
            }
            carry = carry + num1+num2;
            tail.next = new ListNode(carry%base);
            carry = carry/base;
            tail = tail.next;
        }
        return dummy.next;
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

import java.util.HashMap;
import java.util.Map;

/**
 * Created by hadoop on 19/9/17.
 */
public class DisJoint {
    private Map<Long,Node> map = new HashMap<>();
    private class Node{
        long data;
        Node parent;
        int rank;
    }
    public void makeSet(long data){
        Node node = new Node();
        node.data = data;
        node.rank = 0;
        node.parent=node;
        map.put(data,node);
    }
    public boolean union(long data1,long data2){
        Node node1 = map.get(data1);
        Node node2 = map.get(data2);

        Node parent1 = findSet(node1);
        Node parent2 = findSet(node2);
        if(parent1 == parent2){
            return false;
        }

        if(parent1.rank<parent2.rank){
            parent1.parent=parent2;
        }
        else if(parent2.rank>parent1.rank){
            parent2.parent = parent1;
        }
        else {
            parent2.parent = parent1;
            parent1.rank = parent1.rank+1;
        }
        return true;

    }

    private Node findSet(Node node1) {
        if(node1 == null){
            return null;
        }
        if(node1.parent!=node1) {
            node1.parent = findSet(node1.parent);
        }
        return node1;
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

/**
 * Created by hadoop on 20/9/17.
 */
public class StrStr {
    int strStr(String source,String target){

        for(int start=0;start<=source.length()-target.length();start++){
            int lengthMatched = 0;
            while (lengthMatched<target.length() && source.toCharArray()[start+lengthMatched]==target.toCharArray()[lengthMatched]){
                lengthMatched++;
            }
            if(lengthMatched == target.length()){
                return start;
            }
        }
        return -1;
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

import java.util.ArrayList;
import java.util.List;

/**
 * Created by hadoop on 20/9/17.
 */
public class SubarraySumClosestToZero {
    List<Integer> subarrayCloses(int nums[]){
        List<Integer> list = new ArrayList<>();
        Pair [] pairs = new Pair[nums.length+1];
        pairs[0] = new Pair(0,-1);
        int currsum = 0;
        int mindiff= Integer.MAX_VALUE;
        int minindex = 0;
        for( int i=1;i<=nums.length;i++){
            currsum = currsum + nums[i-1];
            pairs[i] = new Pair(currsum,i);
        }
        for( int i=1;i<=nums.length;i++){
            int diff = pairs[i].sum-pairs[i-1].sum;
            if(diff<mindiff){
                mindiff = diff;
                minindex = i-1;
            }
        }
        if(pairs[minindex].index <pairs[minindex+1].index){
            list.add(pairs[minindex].index);
            list.add(pairs[minindex+1].index);
        }
        else {
            list.add(pairs[minindex+1].index);
            list.add(pairs[minindex].index);
        }
        return list;
    }
    private class Pair implements Comparable<Pair>{
        int sum;
        int index;
        Pair(int sum,int index){
            this.sum = sum;
            this.index = index;
        }
        @Override
        public int compareTo(Pair that){
            return this.sum-that.sum;
        }
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

/**
 * Created by hadoop on 22/9/17.
 */
import java.util.*;
public class WordsDistanceIndexing {
    private Map<String, List<Integer>> wordIndexMap = new HashMap<>();

    public WordsDistanceIndexing(String[] words) {
        for (int i = 0; i < words.length; i++) {
            if (wordIndexMap.containsKey(words[i])) {
                wordIndexMap.get(words[i]).add(i);
            } else {
                List<Integer> list = new ArrayList<>();
                list.add(i);
                wordIndexMap.put(words[i], list);
            }
        }
    }

    public int shortest(String word1, String word2) {
        if (word1.equals(word2)) {
            return 0;
        }
        List<Integer> indexList1 = wordIndexMap.get(word1);
        List<Integer> indexList2 = wordIndexMap.get(word2);
        int index1 = 0;
        int index2 = 0;
        int mindistance = Integer.MAX_VALUE;
        while (index1 < indexList1.size() && index2 < indexList2.size()) {
            mindistance = Math.min(mindistance, indexList1.get(index1) - indexList2.get(index2));
            if (indexList1.get(index1) < indexList2.get(index2)) {
                index1++;
            } else {
                index2++;
            }
        }
        return mindistance;
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

import java.util.HashMap;

/**
 * Created by hadoop on 19/9/17.
 */
public class PermutationIndex{
    public static void main(String[] args) {
        PermutationIndex permutationIndex = new PermutationIndex();
        System.out.println(permutationIndex.index(new int[]{2,2,1,1}));
    }
    public int index(int []a){
        if(a == null || a.length ==0){
            return 0;
        }
        int ans =1;
        HashMap<Integer,Integer> cout = new HashMap<>();
        for( int i=0;i<a.length;i++){
            int smaller=0;
            cout.clear();
            cout.put(a[i],1);
            for(int j=i+1;j<a.length;j++){
                if(cout.containsKey(a[j])){
                    cout.put(a[j],cout.get(a[j])+1);
                }
                else {
                    cout.put(a[j],1);
                }
                if(a[j]<a[i]){
                    smaller++;
                }
            }
            System.out.println(cout);
            System.out.println("count"+getDupFactor(cout));
            ans = ans+(smaller*factorial(a.length-i-1))/getDupFactor(cout);
        }
        return ans;
    }

    private int getDupFactor(HashMap<Integer, Integer> cout) {
        int rank=1;
        for(int a:cout.values()){
            rank = rank *factorial(a);
        }
        return rank;
    }

    private int factorial(int i) {
        if(i ==0){
            return 1;
        }
        if(i ==1){
            return 1;
        }
        return i*factorial(i-1);
    }

}
package SmallAndAmazingGitBookToGiveYouConfidence;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Created by hadoop on 22/9/17.
 */
public class Twosum3sum4sum {
    public int[] twoSum(int []numbers,int target){
        int start =0;
        int end = numbers.length-1;
        while(start<end){
            int sum = numbers[start]+numbers[end];
            if(sum>target){
                end--;
            }
            else if(sum<target){
                start++;
            }
            else {
                return new int []{start+1,end+1};
            }
        }
        return null;
    }
    //sum to zero all tripelest
    List<List<Integer>> threeSum(int []number){
        List<List<Integer>> list = new ArrayList<>();
        Arrays.sort(number);
        for(int i=0;i<number.length-2;i++){
            if(i>0 && number[i] == number[i-1])
                continue;
            int start = i+1;
            int end = number.length-1;
            while (start<end){
                while (start>i+1 && number[start] == number[start-1]){
                    start++;
                }
                while (end<number.length-2 && number[end] == number[end+1]){
                    end--;
                }
                if(start<end){
                    int sum = number[i]+number[start]+number[end];
                    if(sum<0){
                        start++;
                    }
                    else if(sum>0){
                        end--;
                    }
                    else {
                        List<Integer> trip = new ArrayList<>();
                        trip.add(number[i]);
                        trip.add(number[start]);
                        trip.add(number[end]);
                        list.add(trip);
                    }
                }

            }
        }
        return list;
    }
    public List<List<Integer>> threeSumWorking(int[] numbers) {
        List<List<Integer>> result = new ArrayList<>();
        if (numbers == null || numbers.length < 3) {
            return result;
        }
        Arrays.sort(numbers);
        int len = numbers.length;
        for (int i = 0; i < len - 2; i++) {
            if (i > 0 && numbers[i] == numbers[i - 1]) {  /* avoid duplicates */
                continue;
            }
            int start = i + 1;
            int end = len - 1;
            while (start < end) {
        /* avoid duplicates */
                if (start > i + 1 && numbers[start] == numbers[start - 1]) {
                    start++;
                } else if (end < len - 1 && numbers[end] == numbers[end + 1]) {
                    end--;
                } else {
                    int sum = numbers[i] + numbers[start] + numbers[end];  /* may overflow */
                    if (sum < 0) {
                        start++;
                    } else if (sum > 0) {
                        end--;
                    } else {
                        result.add(Arrays.asList(numbers[i], numbers[start++], numbers[end--]));
                    }
                }
            }
        }
        return result;
    }
   int threeSumTOtalTriplets(int []number,int k){
        int target =0;
        List<List<Integer>> list = new ArrayList<>();
        Arrays.sort(number);
        for(int i=0;i<number.length-2;i++){
            if(i>0 && number[i] == number[i-1])
                continue;
            int start = i+1;
            int end = number.length-1;
            while (start<end){
                while (start>i+1 && number[start] == number[start-1]){
                    start++;
                }
                while (end<number.length-2 && number[end] == number[end+1]){
                    end--;
                }
                if(start<end){
                    int sum = number[i]+number[start]+number[end];
                    if(sum<k){
                        target = target + end-start;
                        start++;
                    }
                    else if(sum>k){
                        end--;
                    }
                    else {
                        List<Integer> trip = new ArrayList<>();
                        trip.add(number[i]);
                        trip.add(number[start]);
                        trip.add(number[end]);
                        list.add(trip);
                    }
                }

            }
        }
        return target;
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

/**
 * Created by hadoop on 19/9/17.
 */
public class SingletonLazyApproach {
    private static SingletonLazyApproach singletonLazyApproach ;
    private static Object lock = new Object();

    private SingletonLazyApproach(){
    }
    public static SingletonLazyApproach getSingletonLazyApproach(){

        if(singletonLazyApproach == null){
            synchronized (lock){
                if(singletonLazyApproach == null){
                    singletonLazyApproach = new SingletonLazyApproach();
                }
            }
        }
        return singletonLazyApproach;
    }

}
package SmallAndAmazingGitBookToGiveYouConfidence;

/**
 * Created by hadoop on 21/9/17.
 */
public class ReadNchars {
    public int read(char []answer,int n){
        char [] buffer = new char[4];
        int totalCharsRead = 0;
        boolean isEof = false;
        while (!isEof && totalCharsRead<n){
            int charsRead = read4(buffer);
            if(charsRead<4){
                isEof= true;
            }
            int tobeCopied;
            if(totalCharsRead +1 + charsRead >n){
                tobeCopied= n-totalCharsRead-1;
            }
            else {
                tobeCopied = charsRead;
            }
            for(int i=0;i<tobeCopied;i++){
                answer[totalCharsRead+i] = buffer[i];
            }
            totalCharsRead +=tobeCopied;
        }
        return totalCharsRead;
    }

    private int read4(char[] buffer) {
        return 3;
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

import java.util.Deque;
import java.util.LinkedList;

/**
 * Created by hadoop on 22/9/17.
 */
public class SimplyPath {
    public String simplyPath(String a){
        Deque<String> deque = new LinkedList<>();
        String []tokens = a.split("/");
        for(String token:tokens){
            if(token.equals("..")){
                deque.removeLast();
            }
            // if valid token add it to queue
            else if(!token.equals(".") && !token.equals("")){
                deque.addLast(token);
            }
        }
        StringBuilder stringBuilder = new StringBuilder();
        while (!deque.isEmpty()) {
            stringBuilder.append("/");
            stringBuilder.append(deque.removeFirst());
        }
        return stringBuilder.length()>0?stringBuilder.toString():stringBuilder.append("/").toString();
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

/**
 * Created by hadoop on 21/9/17.
 */
public class BestTimeToBuySell {
    public int timeToBuy(int []nums){
        int []leftProfit = new int[nums.length];
        int minprice = nums[0];
        for(int i=1;i<nums.length;i++){
            leftProfit[i] = Math.max(leftProfit[i-1],nums[i]-minprice);
            minprice = Math.min(minprice,nums[i]);
        }
        int []rightprofit = new int[nums.length];
        int maxprice = nums[nums.length-1];
        for(int i=nums.length-2;i>=0;i--){
            rightprofit[i] = Math.max(rightprofit[i+1],maxprice-nums[i]);
            maxprice = Math.max(maxprice,nums[i]);
        }
        int ans=Integer.MIN_VALUE;

        for(int i=0;i<nums.length;i++){
            ans = Math.max(ans,leftProfit[i]+rightprofit[i]);
        }
        return ans;
    }
    public int maxProfitUnllimitedTransactions(int[] prices) {
        if (prices == null) {
            return 0;
        }
        int profit = 0;
        for (int i = 1; i < prices.length; i++) {
            if (prices[i] > prices[i - 1]) {
                profit += prices[i] - prices[i - 1];
            }
        }
        return profit;
    }

    public int maxProfitOnTransaction(int[] prices) {
        if (prices == null || prices.length <= 1) {
            return 0;
        }

        int minPrice = prices[0];
        int maxProfit = 0;
        for (int i = 1; i < prices.length; ++i) {
            maxProfit = Math.max(maxProfit, prices[i] - minPrice);
            minPrice = Math.min(minPrice, prices[i]);
        }
        return maxProfit;
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

/**
 * Created by hadoop on 21/9/17.
 */
public class KsumDP {
    int ksumtotal(int []num,int k ,int target){
        if(k<1 || k >num.length){
            return 0;
        }
        int count [][][] = new int[k+1][num.length][target+1];
        int newarray [][][] = new int[k+1][num.length][target+1];


        for(int i=0;i<num.length;i++){
            for(int j=0;j<=i;j++){
                if(num[j]<=target){
                    count[1][i][num[j]]++;
                }
            }
        }
        for (int i=0;i<num.length;i++){
            for(int j=0;j<=target;j++){
                System.out.print(count[1][i][j]);
            }
            System.out.println();
        }
        System.out.println("END");

        for (int i = 1; i <= num.length; i++) {
            if (num[i - 1] <= target) {
                for (int j = i-1; j <= num.length-1; j++) {
                    newarray[1][j][num[i - 1]]++;
                }
            }
        }
        for (int i=0;i<num.length;i++){
            for(int j=0;j<=target;j++){
                System.out.print(newarray[1][i][j]);
            }
            System.out.println();
        }

        for(int i=2;i<=k;i++){
            for(int j=i-1;j<num.length;j++){
                for(int l=1;l<=target;l++){
                    count[i][j][l] +=count[i][j-1][l];
                    if(num[j]<=l){
                        count[i][j][l] +=count[i-1][j-1][l-num[j]];

                    }
                }
            }
        }
        return count[k][num.length-1][target];
    }

    public static void main(String[] args) {
        KsumDP ksumDP = new KsumDP();
        int []num = {1,2,3,4};
        int target = 5;
        int k =2;
        System.out.println(ksumDP.ksumtotal(num,2,5));
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

/**
 * Created by hadoop on 22/9/17.
 */
public class QueenSolutionBest {
    private class Solution {
        private boolean[] colConflict;
        private boolean[] diagConflict;
        private boolean[] revDiagConflict;
        private int numSolutions;

        public int totalNQueens(int n) {
            colConflict = new boolean[n];
            diagConflict = new boolean[2 * n];
            revDiagConflict = new boolean[2 * n];
            numSolutions = 0;
            dfs(n, new int[n], 0);
            return numSolutions;
        }

        private void dfs(int n, int[] colPos, int row) {
            if (row == n) {
                numSolutions++;
                return;
            }
            for (int col = 0; col < n; col++) {
                if (isConflict(n, row, col)) {
                    continue;
                }
                setConflict(n, row, col, true);
                colPos[row] = col;
                dfs(n, colPos, row + 1);
                setConflict(n, row, col, false);
            }
        }

        private boolean isConflict(int n, int row, int col) {
            if (colConflict[col] || diagConflict[row - col + n] ||
                    revDiagConflict[row + col]) {
                return true;
            }
            return false;
        }

        private void setConflict(int n, int row, int col, boolean conflict) {
            colConflict[col] = conflict;
            diagConflict[row - col + n] = conflict;
            revDiagConflict[row + col] = conflict;
        }
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

import java.util.ArrayList;
import java.util.List;

import static java.lang.Math.sqrt;

/**
 * Created by hadoop on 22/9/17.
 */
public class FactorCombination {
    List<List<Integer>> factorCombinations(int n){
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> path = new ArrayList<>();

        factorCombinationsHelper(result,path,n,2);
        return result;
    }

    private void factorCombinationsHelper(List<List<Integer>> result, List<Integer> path, int n,int start) {
        System.out.println("path "+ path+" start "+start +" n "+n);
        if(n == 1){
            result.add(new ArrayList<>(path));
            return;
        }
        int maxfactor = Math.max(2,(int)sqrt(n));
        System.out.println("maxfactor"+maxfactor);
        for(int factor=start;factor<=maxfactor;factor++){
            System.out.println("n value before "+n);
            System.out.println("factor"+factor);
            System.out.println("n value after"+n);
            if((n % factor) == 0){
                System.out.println("entering here "+"n "+n +" factor "+factor);
                n= n/factor;
                path.add(factor);
                factorCombinationsHelper(result,path,n,factor);
                n = n*factor;
                path.remove(path.size()-1);
            }
        }
    }

    public static void main(String[] args) {
        FactorCombination factorCombination = new FactorCombination();
        System.out.println(factorCombination.factorCombinations(12));
    }
    private  class Solution {
        private List<List<Integer>> result;
        public List<List<Integer>> getFactors(int n) {
            result = new ArrayList<>();
            if (n <= 1) {
                return result;
            }
            dfs(new ArrayList<>(), n, 2);
            return result;
        }

        private void dfs(List<Integer> path, int n, int start) {
            if (n == 1) {
                if (path.size() > 1) {
                    result.add(new ArrayList<>(path));
                }
                return;
            }
            int maxFactor = Math.max(2, (int)Math.sqrt(n));
            for (int factor = start; factor <= maxFactor; factor++) {
                if (n % factor == 0) {
                    path.add(factor);
                    dfs(path, n / factor, factor);
                    path.remove(path.size() - 1);
                }
            }
        }
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

import java.util.HashSet;

/**
 * Created by hadoop on 22/9/17.
 */
public class HappyNumber {
    public boolean isHappyNumber(int n){
        int temp =n;
        HashSet<Integer> hashset = new HashSet<>();
        while (true){
            int sum = 0;
            while (temp!=0){
                sum = sum + (temp%10 )* (temp%10);
                temp = temp/10;
            }
            if(sum == 1){
                return true;
            }
            if(hashset.contains(sum)){
                return false;
            }
            hashset.add(sum);
            temp = sum;
        }
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

/**
 * Created by hadoop on 21/9/17.
 */
public class FenceColorDFS {
    int numberofcolors = 3;
    private int mincost = Integer.MAX_VALUE;
    public int mincost(int [][]costs){
        dfs(costs,0,0,-1);
        return mincost;
    }

    private void dfs(int[][] costs, int index, int totalcost, int prevcolor) {
        if(index == costs.length){
            mincost = Math.min(mincost,totalcost);
            return;
        }
        else{
            for(int color = 0;color<numberofcolors;color++){
                if(color == prevcolor){
                    continue;
                }
                totalcost = totalcost + costs[index][color];
                dfs(costs,index+1,totalcost,color);
                totalcost = totalcost -costs[index][color];
            }
        }
    }
}
package SmallAndAmazingGitBookToGiveYouConfidence;

import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.PriorityQueue;

/**
 * Created by hadoop on 21/9/17.
 */
public class Airplanes {
    private Comparator<Interval> startTimeComp = new Comparator<Interval>() {
        @Override
        public int compare(Interval o1, Interval o2) {
            return o1.start-o2.start;
        }
    };
    int count(List<Interval> airplanes){
        int ans=0;
        Collections.sort(airplanes,startTimeComp);
        PriorityQueue<Integer> endTimeQueue = new PriorityQueue<>();
        for(Interval interval:airplanes){
            while (!endTimeQueue.isEmpty() && interval.start>=endTimeQueue.peek()){
                endTimeQueue.poll();
            }
            endTimeQueue.add(interval.end);
            ans = Math.max(ans,endTimeQueue.size());
        }
        return ans;
    }

    private class Interval {
        int start;
        int end;
    }
}
import java.util.Collections;
import java.util.PriorityQueue;

/**
 * Created by hadoop on 5/9/17.
 */
class MedianFinder {
    PriorityQueue<Integer> maxHeap;
    PriorityQueue<Integer> minHeap;

    /** initialize your data structure here. */
    public MedianFinder() {
        maxHeap = new PriorityQueue<Integer>(Collections.<Integer>reverseOrder());
        //maxheap has lower set of numbers

        minHeap = new PriorityQueue<>();
    }

    // add to max heap and then min heap
    public void addNum(int num) {
        maxHeap.offer(num);
        minHeap.offer(maxHeap.poll());
        if(maxHeap.size()<minHeap.size()){
            maxHeap.offer(minHeap.poll());
        }
    }

    public double findMedian() {
        if(maxHeap.size() == minHeap.size()){
            System.out.println("coming here since equal");
            System.out.println(maxHeap.peek());
            System.out.println(minHeap.peek());
            return ((double)(maxHeap.peek()+minHeap.peek()))/2;
        }
        System.out.println("coming here" +maxHeap.size());
        System.out.println("coming here" +minHeap.size());

        return maxHeap.peek();
    }
    public static void main(String args[]){
        MedianFinder medianFinder = new MedianFinder();
        medianFinder.addNum(1);
        medianFinder.addNum(2);
        System.out.println("mediain"+medianFinder.findMedian());
    }
}package Gitbooks.Chapter2;

/**
 * Created by hadoop on 16/9/17.
 */
public class Divide {

    int divide(int dividend,int divisor){
        int a = dividend;
        int b = divisor;

        int result = 0;
        while(a>=b){
            int shift =1;
            int temp = b;
            while(a>temp){
                temp=temp<<1;
                shift= shift<<1;
                System.out.println("shift"+shift);
            }
            if(a == temp ){
                return result + shift;
            }
            shift = shift>>1;
            System.out.println("shift"+shift);

            temp = temp>>1;
            result = result + shift;
            a= a-temp;
        }
        System.out.println("rema"+a);
        return result;
    }

    public static void main(String[] args) {
        Divide divide = new Divide();
        System.out.println(divide.divide(10,9));
    }
}
package Gitbooks.Chapter2;

class Solution {
    public static void main(String[] args) {
        Solution solution = new Solution();
        int nums []= {2,1};
        int k =1;
        System.out.println("ans"+solution.findKthLargest(nums,k));
    }
    public int findKthLargest(int[] nums, int k) {
        //         Arrays.sort(nums);
        // int length = nums.length;
        // return nums[length-k];
        //         PriorityQueue<Integer> pq = new PriorityQueue<>(new Comparator<Integer>() {
        //     @Override
        //     public int compare(Integer o1, Integer o2) {
        //         return o2-o1;
        //     }
        // });
        // for(int num:nums){
        //     pq.add(num);
        // }
        // int ans=Integer.MAX_VALUE ;
        // while (k-->0){
        //     ans = pq.poll();
        // }
        // return ans;
        
//          PriorityQueue<Integer> pq = new PriorityQueue<>(new Comparator<Integer>() {
//             @Override
//             public int compare(Integer o1, Integer o2) {
//                 return o1-o2;
//             }
//         });
//         for(int i=0;i<nums.length;i++){
//             if(i<k) {
//                 pq.add(nums[i]);
//             }
//             else {
//                 if(nums[i] >pq.peek()){
//                     pq.poll();
//                     pq.add(nums[i]);
//                 }
                
//             }
//         }
    
//         return pq.peek();
        return findKthLargestQuickSelect(nums,k);
    }
    
    int findKthLargestQuickSelect(int nums[], int k){
        int start = 0;
        int end = nums.length-1;
        k = nums.length-k+1;
        return findKthSmallestQuick(start,end,nums,k);
    }
    int findKthSmallestQuick(int start, int end, int nums[], int k){
        if(start>=end){
            return nums[start];
        }
        int index = partitionDutch(start,end,k,nums);
        if(index +1 == k){
            return nums[index];
        }
        else if(k<index+1){
            return findKthSmallestQuick(start,index-1,nums,k-index-1);
        }
        else {
            return findKthSmallestQuick(index+1,end,nums,k);
        }
    }

    private int partitionDutch(int start, int end, int k,int []nums) {
        int pivot= (start+end)/2;
        int left = start;
        int right = end;
        int middle = start;
        while (middle<=right){
            if(nums[middle] == nums[pivot]){
                middle++;
            }
            else if(nums[middle]<nums[pivot]){
                swap(nums,left,middle);
                middle++;
                left++;
            }
            else {
                swap(nums,right,middle);
                right--;
            }
        }
        return left;
    }

    private void swap(int[] nums, int left, int right) {
        int temp = nums[left];
        nums[left] = nums[right];
        nums[right] = temp;
    }
}package Gitbooks.Chapter2;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;

/**
 * Created by hadoop on 17/9/17.
 */


public class Solution1 {
    public static void main(String[] args) {
        int []nums = {2,1};
        int []nums1 = {2,1};
        int []nums2 = {2,1};
        int []nums3 = {2,1};


        Solution1 solution1 = new Solution1();
        System.out.println(solution1.partition(nums3,0,nums3.length-1));
        System.out.println(nums3[0]);
        System.out.println(nums3[1]);
        System.out.println("end");
        //nums = original;
        System.out.println(solution1.partitionDutch(nums,0,nums.length-1));
        System.out.println(nums[0]);
        System.out.println(nums[1]);
        System.out.println("end");

        System.out.println(solution1.partitionmine(nums1,0,nums1.length-1));

        System.out.println(nums1[0]);
        System.out.println(nums1[1]);
        System.out.println("end");

        System.out.println(solution1.partitionTwoPointerTechnique(nums2,0,nums2.length-1));
        System.out.println(nums2[0]);
        System.out.println(nums2[1]);
        System.out.println("end");


    }
    public int findKthLargest(int[] nums, int k) {
        //         Arrays.sort(nums);
        // int length = nums.length;
        // return nums[length-k];
        //         PriorityQueue<Integer> pq = new PriorityQueue<>(new Comparator<Integer>() {
        //     @Override
        //     public int compare(Integer o1, Integer o2) {
        //         return o2-o1;
        //     }
        // });
        // for(int num:nums){
        //     pq.add(num);
        // }
        // int ans=Integer.MAX_VALUE ;
        // while (k-->0){
        //     ans = pq.poll();
        // }
        // return ans;

//          PriorityQueue<Integer> pq = new PriorityQueue<>(new Comparator<Integer>() {
//             @Override
//             public int compare(Integer o1, Integer o2) {
//                 return o1-o2;
//             }
//         });
//         for(int i=0;i<nums.length;i++){
//             if(i<k) {
//                 pq.add(nums[i]);
//             }
//             else {
//                 if(nums[i] >pq.peek()){
//                     pq.poll();
//                     pq.add(nums[i]);
//                 }

//             }
//         }

//         return pq.peek();
        return findKthLargestQuickSelect(nums,k);
        //return kthLargestElement(k,nums);
    }




    int findKthLargestQuickSelect(int nums[], int k){
        int start = 0;
        int end = nums.length-1;
        k = nums.length-k+1;
        return findKthSmallestQuick(start,end,nums,k);
    }
    int findKthSmallestQuick(int start, int end, int nums[], int k){
        if(start>end){
            return -1;
        }
        if(start == end){
            return nums[start];
        }
        int index = partitionDutch(nums,start,end);
        if(index +1 -start == k){
            return nums[index];
        }
        else if(index+1-start<k){
            return findKthSmallestQuick(index+1,end,nums,k+start-index-1);
        }
        else {
            return findKthSmallestQuick(start,index-1,nums,k);
        }
    }

    private int partitionDutch(int []nums,int start,int end) {
        int pivot= nums[start];
        int left = start;
        int right = end;
        int middle = start;
        while (middle<=right){
            if(nums[middle] == pivot){
                middle++;
            }
            else if(nums[middle]<pivot){
                swap(nums,left,middle);
                middle++;
                left++;
            }
            else {
                swap(nums,right,middle);
                right--;
            }
        }
        return left;
    }

    private void swap(int[] nums, int left, int right) {
        int temp = nums[left];
        nums[left] = nums[right];
        nums[right] = temp;
    }
    public int kthLargestElement(int k, int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        if (k <= 0) {
            return 0;
        }
        return helper(nums, 0, nums.length - 1, nums.length - k + 1);

    }
    public int helper(int[] nums, int l, int r, int k) {
        if (l == r) {
            return nums[l];
        }
        int position = partition(nums, l, r);
        if (position + 1 == k) {
            return nums[position];
        } else if (position + 1 < k) {
            return helper(nums, position + 1, r, k);
        }  else {
            return helper(nums, l, position - 1, k);
        }
    }
    public int partition(int[] nums, int l, int r) {
        // pivot
        int left = l, right = r;
        int pivot = nums[left];

        // partition
        while (left < right) {
            while (left < right && nums[right] >= pivot) {
                right--;
            }
            nums[left] = nums[right];
            while (left < right && nums[left] <= pivot) {
                left++;
            }
            nums[right] = nums[left];
        }

        // pivot
        nums[left] = pivot;
        return left;//return where is the pivot; its position
    }
    private  int partitionmine (int array[],int start ,int end){
        int i = start -1 ;
        int j = start;

        int pivot = array[start];
        if(start == end ){
            return start;
        }
        while(j<= end){
            if(array[j]<pivot){
                i = i+1;
                swap(array, i, j);
                j = j+1;
            }
            else if(array[j] == pivot){
                j++;
            }
            else if(array[j] >pivot){
                swap(array, j, end);
                end = end -1;
            }
        }
        if(i == start -1) {
            return i + 1;
        }
        else{
            return i;
        }
        //return end;
    }
    private int partitionTwoPointerTechnique(int array[],int left,int right){
        int pivot = array[left];

        int leftPointer = left;
        for(int i=left+1;i<=right;i++){
            if(array[i]<pivot){
                swap(array,++leftPointer,i);
            }
        }
        System.out.println("pointer"+array[leftPointer]);
        swap(array,leftPointer,left);
        System.out.println("pointer"+array[leftPointer]);

        return leftPointer;
    }
    private int partitionTwoPointer(int input[],int low,int high) {

        int i = low;
        for (int j = low + 1; j <= high; j++)
            if (input[j]<input[low] && ++i != j) swap(input, i, j);
        if (low != i) swap(input, low, i);
        return i;
    }
    void partition(List<Integer> nums, List<Integer> pivots){
        Integer []boundaries = new Integer[pivots.size()];
        Arrays.fill(boundaries,0);
        for(int k=0;k<nums.size();k++){

            for(int i=0;i<pivots.size();i++) {
                if(nums.get(k)<pivots.get(i)){
                    Collections.swap(nums,k,boundaries[pivots.get(i)]);
                }
            }
            for(int i=1;i<pivots.size();i++){
                boundaries[i] = Math.max(boundaries[i],boundaries[i-1]);
            }

        }

    }


}package Gitbooks.Chapter2;

/**
 * Created by hadoop on 15/9/17.
 */
public class Power2Recuresive {
    public static void main(String[] args) {
        double x= 4.0;
        int n = 2;
        double ans ;
        boolean isNegative = false;
        if(n<0){
            isNegative = true;
            n = -1*n;
        }
        if(x<0 && (n & 1)==1){
            ans = -1*helper(-1*x,n);
        }
        if(x<0 && (n & 1) == 0){
            ans = helper(-1*x,n);
        }
        if(n ==0 || x ==1){
            ans = 1;
        }
        if(isNegative){
          ans = 1/helper(x,n);
        }
        else {
            ans = helper(x,n);
        }

    }

    static double helper(double x,int n){
        //x>0 , n>0
        if(n == 1){
            return x;
        }
        if(n ==0 ){
            return 1;
        }
        double ans = ((n & 1 ) == 1) ? helper(x*x,n/2):helper(x*x,n/2)*x;
        return ans;
    }

    static double power(int x,int n){

        double ans;
        boolean isNegative = false;
        if(n <0){
            n = n*-1;
            isNegative = true;
        }
        if(x<0 && (n & 1)==0){
            ans = helper(x*-1,n);
        }
        if(x<0 && (n & 1) ==1){
            ans = -1 *helper(x*-1,n);
        }
        if(x ==0 || x ==1){
            return x;
        }
        if(n ==0){
            return 1;
        }
        ans = helper(x,n);
        if(isNegative) return (double)(1/ans);
        return ans;
    }

}
package Gitbooks.Chapter2;

import java.util.ArrayList;
import java.util.List;

/**
 * Created by hadoop on 17/9/17.
 */
public class RotateString {
    public void rotateString(char[] str, int offset) {
        List<Integer> list = new ArrayList<>();
        list.toArray();
        // write your code here
        reverse(str,0,str.length-1);
        reverse(str,0,offset-1);
        reverse(str,offset,str.length-1);
    }
    public static void reverse(char []array,int start,int end){
        while(start<end){
            swap(array,start,end);
            start++;
            end--;
        }
    }
    public static void swap(char []array,int a,int b){
        char temp = array[a];
        array[a] = array[b];
        array[b] = temp;
    }

}
package Gitbooks.Chapter2;

/**
 * Created by hadoop on 18/9/17.
 */
public class BinarySearch {
    public int search(int[] nums, int target) {
        return searchRotatedrray(nums,0,nums.length-1,target);

    }
    private int searchRotatedrray(int array[], int low, int high, int target){
        if(array == null || array.length == 0) return -1;
        while (low<high){

            int mid = low + (high-low)/2;

            if(array[mid]<array[high]){
                if(array[mid]<target && target<=array[high]){
                    low = mid +1;
                }
                else {
                    high = mid;
                }

            }
            else {

                if(array[low]<=target && target<=array[mid]){
                    high = mid;
                }
                else {
                    low = mid +1;
                }
            }
        }
        if(array[low] == target) return low;
        return -1;
    }
}
package Gitbooks.Chapter2;

/**
 * Created by hadoop on 18/9/17.
 */
public class MatrixSearch {
    public static void main(String[] args) {
        MatrixSearch matrixSearch = new MatrixSearch();
        int [][]matrix = new int[1][1];
        matrix[0][0] = 1;
        int target = 1;
        System.out.println(matrixSearch.searchMatrix(matrix,target));
    }
        public boolean searchMatrix(int[][] matrix, int target) {

            // lets try to find row;
            int start = 0;
            int end = matrix.length - 1;
            while (start < end) {
                int mid = start + (end - start) / 2;
                if (target <= matrix[mid][0]) {
                    end = mid;
                } else {
                    start = mid + 1;
                }
            }
            int row = -1;
            if(start == 0) {
                row = start;
            }
            else {
                row = start-1;
            }

            // lets try find column
            start = 0;
            end = matrix[row].length - 1;
            while (start < end) {
                int mid = start + (end - start) / 2;
                if (matrix[row][mid] >= target) {
                    end = mid;
                } else {
                    start = mid + 1;
                }
            }
            System.out.println("row" + row);
            System.out.println("start" + start);
            System.out.println("matrix" + matrix[row][start]);
            if (matrix[row][start] == target) {
                return true;
            }
            return false;
        }
}
package Gitbooks.Chapter2;

/**
 * Created by hadoop on 15/9/17.
 */
public class SquareRoot {
    public static void main(String[] args) {
        System.out.println();
        SquareRoot squareRoot = new SquareRoot();
        System.out.println("x"+squareRoot.mysquareagain(2147395599));
    }
    double mysquare(int x){
        double start =1;
        double end = x;
        while (start<end){
            double mid = start + (end-start)/2;
            if(Math.abs(mid * mid -x)<0.000001){
                return mid;
            }
            if(mid*mid>x){
                end = mid;
            }
            else {
                start = mid +1;
            }
        }
//        if(Math.abs(start*start-x)<0.000001){
//            return start;
//        }
        return start;
    }
    int mysquareagain(int x){
        if(x ==0 )return 0;
        int start =1;
        int end = x;
        while (start<end){
            System.out.println("start "+start);
            System.out.println("end "+end);
            int mid = start + (end-start)/2;
            System.out.println("mid "+mid);
            System.out.println("mid * mid"+mid*mid);
            if(mid>=x/mid){
                end = mid;
            }
            else {
                start = mid+1;
            }
        }

        if(start * start >x )return start-1;
        //if(start*start<x)return start;
//        if(Math.abs(start*start-x)<0.000001){
//            return start;
//        }
        // if((int)start*(int)start >x) return (int)start -1;
        // if((start+1)*(start+1)<x) return start+1;
        return start;
    }

    int workingmysquare(int x){
        if(x ==0 )return 0;
        int start =1;
        int end = x;
        while (start<end){
            int mid = start + (end-start)/2;
            if(mid>=x/mid){
                end = mid;
            }
            else {
                start = mid+1;
            }
        }
        if(start  >x/start )return start-1;
        return start;
    }
}
package Gitbooks.Chapter2;

/**
 * Created by hadoop on 15/9/17.
 */
public class Power2 {
    public static void main(String[] args) {
        int x = 5;
        int n = 10;
        double a = 34.00515;
        int b=        -3;
        Power2 power2 = new Power2();
        System.out.println(power2.myPow(a,b));
        // 5^10 = 5^5 * 5^5 => 5^5 => 5^2 * 5 5^2 >=>5 ^2 => s
    }

    int power(int x,int n) {
        int power = n;
        int ans = 1;
        while (power >= 1) {
            if ((power & 1) == 1) {
                ans = ans * x;
            }
            ans = ans * ans;
            power = power>>1;
        }
        return ans;
    }
    public double myPow(double x, int n) {
        double ans = x;
        boolean isnegative = false;
        if(n<0){
            isnegative = true;
            n = n*-1;
        }
        int power = n;


        while (power > 1) {
            if ((power & 1) == 1) {
                System.out.println("here ans1"+ans);
                ans = !isnegative?ans * x:(double)((ans)*(double)(1/x));
                System.out.println("here ans2"+ans);

            }
            if(power == 1){
                return ans;
            }
            System.out.println("here ans3"+ans);

            ans = !isnegative?ans * ans:(double)(1/(ans*ans));
            System.out.println("here ans4"+ans);

            power = power>>1;
        }
        return ans;

    }

}
package Gitbooks.Chapter2;

import java.util.Arrays;
import java.util.Comparator;
import java.util.PriorityQueue;
import java.util.Random;

/**
 * Created by hadoop on 16/9/17.
 */
public class KthLargest {
    public static void main(String[] args) {

        KthLargest kthLargest = new KthLargest();
        int nums[] =
                {7,6,5,4,3,2,1};
              int k =2;
        System.out.println("ans"+kthLargest.findKthLargestQuickSelect(nums,k));
    }
    public  int kth1sst(int []nums,int k){
        Arrays.sort(nums);
        int length = nums.length;
        return nums[length-k];
    }
    public int findKthLargest(int []nums,int k){
        PriorityQueue<Integer> pq = new PriorityQueue<>(new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o2-o1;
            }
        });
        for(int num:nums){
            pq.add(num);
        }
        int ans=Integer.MAX_VALUE ;
        while (k-->0){
            ans = pq.poll();
        }
        return ans;
    }
    public int findKthLargestAgain(int []nums,int k){
        PriorityQueue<Integer> pq = new PriorityQueue<>(new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o1-o2;
            }
        });
        for(int i=0;i<nums.length;i++){
            if(i<k) {
                pq.add(nums[i]);
            }
            else {
                if(nums[i] >pq.peek()){
                    pq.poll();
                    pq.add(nums[i]);
                }

            }
        }
        return pq.peek();


        // Max heap
        //         Arrays.sort(nums);
        // int length = nums.length;
        // return nums[length-k];
        //         PriorityQueue<Integer> pq = new PriorityQueue<>(new Comparator<Integer>() {
        //     @Override
        //     public int compare(Integer o1, Integer o2) {
        //         return o2-o1;
        //     }
        // });
        // for(int num:nums){
        //     pq.add(num);
        // }
        // int ans=Integer.MAX_VALUE ;
        // while (k-->0){
        //     ans = pq.poll();
        // }
        // return ans;
    }
    int findKthLargestQuickSelect(int nums[], int k){
        int start = 0;
        int end = nums.length-1;
        k = nums.length-k+1;
        return findKthSmallestQuick(start,end,nums,k);
    }
    int findKthSmallestQuick(int start, int end, int nums[], int k){

        if(start>=end){
            return nums[start];
        }

       // int index = partitionDutch(start,end,k,nums);
        int index = partitionagainagain(nums,start,end);
        System.out.println("index after partition is "+index);
        if(index+1 == k){
            return nums[index+1];
        }
        else if(index+1<k){
            System.out.println("index"+index);
            System.out.println("end"+end);
            System.out.println("k-index"+(k-index-1));
            return findKthSmallestQuick(start,index-1,nums,k-index-1);
        }
        else {
            return findKthSmallestQuick(index+1,end,nums,k);
        }
    }

    private int partitionDutch(int start, int end, int k,int []nums) {
        Random random = new Random();
        System.out.println("end"+end);
        System.out.println("start"+start);
        System.out.println("k is"+k);
        //int pivot= random.nextInt(end-start)+start;
        int pivot= (start+end)/2;
        int left = start;
        int right = end;
        int middle = start;
        while (middle<=right){
            if(nums[middle] == nums[pivot]){
                middle++;
            }
            else if(nums[middle]<nums[pivot]){
                swap(nums,left,middle);
                middle++;
                left++;
            }
            else {
                swap(nums,right,middle);
                right--;
            }
        }
        return left;
    }

    private static void swap(int[] nums, int left, int right) {
        int temp = nums[left];
        nums[left] = nums[right];
        nums[right] = temp;
    }
    private static int partitionagainagain (int array[],int start ,int end){
        int i = start -1 ;
        int j = start;
        System.out.println("start"+start);
        System.out.println("end"+end);

        int pivot = array[(start + end)/2];
        if(start == end ){
            return start;
        }
        while(j<= end){
            if(array[j]<pivot){
                i = i+1;
                swap(array, i, j);
                j = j+1;
            }
            else if(array[j] == pivot){
                j++;
            }
            else if(array[j] >pivot){
                swap(array, j, end);
                end = end -1;
            }
        }
        if(i == start -1) {
            return i + 1;
        }
        else
        {
            return i;
        }
        //return end;
    }
}
package Gitbooks.Chapter2;

/**
 * Created by hadoop on 16/9/17.
 */
public class Bs {
    public int findDuplicate(int[] nums) {
        int start = 0;
        int end = nums.length-1;
        while(start<end){
            int mid = start + (end-start)/2;
            if(mid+1<=nums[mid]){
                start = mid +1;
            }
            else{
                end = mid;
            }
        }
        return nums[start];
    }

    public static void main(String[] args) {
        Bs bs = new Bs();
        int nums [] = {1,2,3,3};
        System.out.println(bs.findDuplicate(nums));
    }
}
package Gitbooks.Chapter2;

/**
 * Created by hadoop on 17/9/17.
 */
public class MedianSortedArrays {
    public static void main(String[] args) {
        MedianSortedArrays medianSortedArrays = new MedianSortedArrays();
        int [] nums1 = {1,2};
        int [] nums2 = {3,4};
        System.out.println("ans"+medianSortedArrays.findMedian(nums1,nums2));

    }
    public  double findMedian(int []nums1,int [] nums2){
        int m = nums1.length;
        int n = nums2.length;
        int total = m + n;
        if(m>n){
            return findMedian(nums2,nums1);
        }
        if(total%2 ==0){
            return (findMedianHelper(nums1,nums2,0,m-1,0,n-1,(m+n)/2)+
                    findMedianHelper(nums1,nums2,0,m-1,0,n-1,(m+n)/2+1))/2;
        }
        else {
            return findMedianHelper(nums1,nums2,0,m-1,0,n-1,(m+n)/2+1);
        }
    }
    int findMedianHelper(int []nums1,int nums2[],int onestart,int oneend,int secondstart,int secondend,int k){
        int m = oneend-onestart+1;
        int n = secondend-secondstart+1;
        System.out.println("m"+m);
        System.out.println("n"+n);
        System.out.println("k"+k);
        if(m==0){
            return nums2[secondstart+k-1];
        }
        if(n ==0){
            System.out.println("k"+k);
            return nums1[onestart+k-1];
        }
        if(k==1){
            return Math.min(nums1[onestart],nums2[secondstart]);
        }
        if(k==0){
            return -1;
        }
        int midFirstLength = Math.min(k/2,m);
        int midSecondLength = k-midFirstLength;
        System.out.println("mid length"+midFirstLength);
        System.out.println("mid length2"+midSecondLength);
        if(nums1[onestart+midFirstLength-1]<nums2[secondstart+midSecondLength-1]){
            findMedianHelper(nums1,nums2,onestart+midFirstLength,oneend,secondstart,secondstart+midSecondLength,k-midFirstLength);
        }
        else if(nums1[onestart+midFirstLength-1]>nums2[secondstart+midSecondLength-1]){
            findMedianHelper(nums1,nums2,onestart,onestart+midFirstLength,secondstart+midSecondLength,secondend,k-midSecondLength);
        }
        else{
            return nums1[onestart+midFirstLength-1];
        }
        return -1;
    }
}
package Gitbooks.Chapter2;

/**
 * Created by hadoop on 15/9/17.
 */
public class FastPower {
    public int fastPower(int a, int b, int n) {
        // write your code here
        if(n ==1){
            return a%b;
        }
        if(n ==0){
            return 1;
        }
        int x = fastPower(a,b,n/2);
        int ans = ((x%b)*(x%b))%b;
        if((n & 1) ==1){
            ans = ((ans%b)*(a%b))%b;
        }
        return ans;
    }
}


package Gitbooks;

import java.util.ArrayList;
import java.util.List;

/**
 * Created by hadoop on 13/9/17.
 */
public class Parenthesis {
    public static void main(String[] args) {
        Parenthesis parenthesis = new Parenthesis();
        int n = 2;
        System.out.println(parenthesis.generateParenthesis(0,n-1));
    }

    List<String> generateParenthesis(int start,int end) {
        List<String> strings = new ArrayList<>();
        if(start>end){
            strings.add("");
            return strings;
        }
        if(start == end){
            strings.add("()");
            return strings;
        }
        else {
            for(int i=start;i<=end;i++) {
                List<String> leftStrings = generateParenthesis(start,i-1);
                List<String> rightStrings = generateParenthesis(i+1,end);
                System.out.println("leftstrings"+leftStrings);
                System.out.println("right"+rightStrings);
                for(String left:leftStrings){
                    for(String right:rightStrings){
                        strings.add("("+left+")"+right);
                    }
                }
            }

        }
        return strings;
    }

}package Gitbooks;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

/**
 * Created by hadoop on 15/9/17.
 */
public class LetterCombinations {
    public static void main(String[] args) {
        LetterCombinations letterCombinations = new LetterCombinations();
        System.out.println(letterCombinations.letterCombinations("23"));
    }
    public List<String> letterCombinations(String digits) {
        HashMap<Integer, List<Character>> hashMap = new HashMap<>();
        hashMap.put(1, new ArrayList<>());
        hashMap.put(2, new ArrayList<>());
        hashMap.put(3, new ArrayList<>());
        hashMap.put(4, new ArrayList<>());
        hashMap.put(5, new ArrayList<>());
        hashMap.put(6, new ArrayList<>());
        hashMap.put(7, new ArrayList<>());
        hashMap.put(8, new ArrayList<>());
        hashMap.put(9, new ArrayList<>());
        hashMap.get(1);
        int index = 2;
        int charone = 0;
        for (char i = 0; i <= 25; i++) {
            char tobeAdded = (char) ('a' + i);
            charone++;
            if (index != 7 && index != 9 && charone == 4) {
                index = index + 1;
                charone = 1;
            }
            if ((index == 7) && charone == 5) {
                index = index + 1;
                charone = 1;
            }
            hashMap.get(index).add(tobeAdded);
        }
        System.out.println(hashMap);
        List<String> result = new ArrayList<>();
        List<String> path = new ArrayList<>();
        helper(0,result,path,digits,hashMap);
        return result;
    }

    private void helper(int i, List<String> result, List<String> path, String digits, HashMap<Integer, List<Character>> hashMap) {
            if(i == digits.length()){
                String ans = new String();
                for(String a:path){
                    ans = ans+a;
                }
                result.add(ans);
                return;
            }
            for(Character c:hashMap.get(digits.charAt(i)-'0')){
                path.add(String.valueOf(c));
                helper(i+1,result,path,digits,hashMap);
                path.remove(path.size()-1);
            }
    }
}
package Gitbooks;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;

/**
 * Created by hadoop on 15/9/17.
 */
public class Anagrams {
    public static void main(String[] args) {
        String anagrams[]={"eat", "tea", "tan", "ate", "nat", "bat"};
        List<List<String>> answer = new ArrayList<>();
        result(answer,anagrams);
        System.out.println(answer);
    }

    private static void result(List<List<String>> answer, String[] anagrams) {
        HashMap<String,List<String>> hashMap = new HashMap<>();
        for(String a:anagrams){
            char [] array = a.toCharArray();
            Arrays.sort(array);
            if(!hashMap.containsKey(String.valueOf(array))){
                hashMap.put(String.valueOf(array),new ArrayList<>());
            }
            hashMap.get(String.valueOf(array)).add(a);
        }
        answer.addAll(hashMap.values());
    }
    private static void resultagain(List<List<String>> ans,String [] anagrams){
        HashMap<Integer,List<String>> hashMap = new HashMap<>();
        for(String a:anagrams){
            int count []= new int[26];
            count = getCountArray(count,a.toCharArray());
            Integer hascode = gethashcode(count);
            if(!hashMap.containsKey(hascode)){
                hashMap.put(hascode,new ArrayList<>());
            }
            hashMap.get(hascode).add(a);
        }
        hashMap.values();

    }

    private static int gethashcode(int[] count) {
        int hash = 0;
        int a = 31;
        for(int ch:count){
            hash = hash*a + ch;
        }
        return hash;
    }

    private static int[] getCountArray(int[] count, char[] chars) {
        for(int i=0;i<chars.length;i++){
            count[chars[i]-'a']++;
        }
        return count;
    }
}
package Gitbooks;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Created by hadoop on 12/9/17.
 */
public class Permutations {
    public static void main(String[] args) {
        Permutations permutations = new Permutations();
        int nums[] = {2,1,2,3};
        Arrays.sort(nums);
        permutations.permute(nums);
    }

    List<List<Integer>> permute(int [] nums){
        boolean [] visited = new boolean[nums.length];

        List<Integer> path = new ArrayList<>();
        List<List<Integer>> result = new ArrayList<>();
        helper(nums,path,result,visited);
        System.out.println(result);
        return result;
    }

    private void helper(int[] nums, List<Integer> path, List<List<Integer>> result, boolean[] visited) {
        if(path.size() == nums.length){
            result.add(new ArrayList<>(path));
        }
        for(int i=0;i<nums.length;i++){
            if(visited[i]) continue;
            //if(i>0 && nums[i] == nums[i-1] ) continue;
            visited[i] = true;
            path.add(nums[i]);
            helper(nums,path,result,visited);
            visited[i]= false;
            path.remove(path.size()-1);
            while (i < nums.length - 1 && nums[i] == nums[i + 1]) i++;
        }
    }
}
package Gitbooks;

import java.util.ArrayList;
import java.util.List;

/**
 * Created by hadoop on 12/9/17.
 */
public class PermutationSequence {
    public static void main(String[] args) {
        PermutationSequence permutationSequence = new PermutationSequence();
        System.out.println(permutationSequence.getPermutationSequence(3,1));
    }
    String getPermutationSequence(int n,int k){
        List<Integer> integerList = new ArrayList<>();
        for( int i=1;i<=n;i++){
            integerList.add(i);
        }
        int [] fact = new int[n];
        fact[0]=1;
        for( int i=1;i<fact.length;i++){
            fact[i] = fact[i-1]*i;
        }
        String out="";
        for (int i=n;i>0;i--){
            System.out.println("k "+k);
            System.out.println("fac "+fact[i-1]);
            int index = k/fact[i-1];
            System.out.println("index"+(index));
            System.out.println("size"+integerList.size());
            out=out+ integerList.get((index-1));
            integerList.remove(index-1);
            k = k%fact[i-1];
            if(k ==0){
                for(int num:integerList){
                    out = out +num;
                }
                return out;
            }
        }
        return out;
    }
}
package Gitbooks;

import java.util.List;

/**
 * Created by hadoop on 13/9/17.
 */
public class PathSum {
    private class TreeNode{
        int val;
        TreeNode left;
        TreeNode right;
    }
    public boolean hasPathSum(TreeNode root,int sum){
        if(root == null){
            return false;
        }
        if(root.left == null && root.right ==null && sum == 0){
            return true;
        }
        sum = sum-root.val ;
        boolean leftans = hasPathSum(root.left,sum);
        boolean rightans = hasPathSum(root.right,sum);
        sum = sum + root.val;
        return leftans || rightans;
    }
    public boolean hasPathSumPath(TreeNode root, int sum, List<Integer>path, List<List<Integer>> result){
        if(root == null){
            return false;
        }
        sum = sum-root.val ;
        path.add(root.val);
        if(root.left == null && root.right ==null && sum == 0){
            return true;
        }
        boolean leftans = hasPathSum(root.left,sum);
        boolean rightans = hasPathSum(root.right,sum);
        sum = sum + root.val;
        path.remove(path.size()-1);
        return leftans || rightans;
    }
    public int countPath(TreeNode root,int sum){

        if(root == null)
            return 0;
        return pathFromRoot(root,sum) +countPath(root.left,sum)+countPath(root.right,sum);


    }
    int pathFromRoot(TreeNode root,int sum){
        if(root == null) return 0;
        sum = sum -root.val;
        int count = 0;
        if(root.left == null && root.right == null && sum ==0){
            count++;
        }
        count += pathFromRoot(root.left,sum);
        count += pathFromRoot(root.right,sum);
        return count;
    }
}
package Gitbooks;

import java.util.ArrayList;
import java.util.List;

/**
 * Created by hadoop on 14/9/17.
 */
public class WordAbbre {
    public static void main(String args[]){
        String word = "word";
        List<String> stringList = new ArrayList<>();
        int depth = 0;
        int count = 0;
        helper(word,depth,"",count,stringList);
        System.out.println(stringList);
    }

    private static void helper(String word, int depth, String s, int count, List<String> stringList) {
        if(depth == word.length()){
            if(count>0){
                s=s+count;
            }
            stringList.add(s);
            return;
        }
        else{
            helper(word,depth+1,s,count+1,stringList);
            if(count>0)s=s+count;
            helper(word,depth+1,s=s+word.toCharArray()[depth],0,stringList);
        }
    }
}
package Gitbooks;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Created by hadoop on 12/9/17.
 */
public class CombinationSum {
    public static void main(String[] args) {
        int nums [] = {10, 1, 2, 7, 6, 1, 5};
        int target = 8;
        CombinationSum combinationSum = new CombinationSum();
     //   System.out.println(combinationSum.combinationSum(nums,target));
      //  System.out.println(combinationSum.combination5(4,2));
        System.out.println(combinationSum.findSubsequences(new int []{4, 6, 7, 7}));
    }

    List<List<Integer>> combinationSum(int []nums, int target){
        Arrays.sort(nums);
        List<Integer> path = new ArrayList<>();
        List<List<Integer>> list = new ArrayList<>();
        helper(nums,path,list,0,target);
        return list;
    }

    private void helper(int[] nums, List<Integer> path, List<List<Integer>> list, int index, int target) {
        if(target<0) return ;
        if(target == 0){
            list.add(new ArrayList<>(path));
            return;
        }
        for(int i=index;i<nums.length;i++){
            path.add(nums[i]);
            helper(nums,path,list,i+1,target-nums[i]);
            path.remove(path.size()-1);
            while (i<nums.length-1 && nums[i] == nums[i+1])i++;
        }
    }
    List<List<Integer>> combination5(int n,int k ){
        List<Integer> path = new ArrayList<>();
        List<List<Integer>> result = new ArrayList<>();
        helperCombination5(n,k,path,result,1);
        return result;
    }

    private void helperCombination5(int n, int k, List<Integer> path, List<List<Integer>> result, int i) {
        if(path.size() == k ){
            result.add(new ArrayList<>(path));
            return;
        }
        for(int index = i;index<=n;index++){
            path.add(index);
            helperCombination5(n,k,path,result,index+1);
            path.remove(path.size()-1);
        }
    }
    public List<List<Integer>> findSubsequences(int[] nums) {
        List<Integer> path = new ArrayList<>();
        List<List<Integer>> result = new ArrayList<>();
        helperAgain(nums,0,path,result);
        return result;
    }

    private void helperAgain(int[] nums, int i, List<Integer> path, List<List<Integer>> result) {
        if(path.size()>=2){
            result.add(new ArrayList<>(path));
        }
        for( int index = i;index<nums.length;index++){
            System.out.println("check" +index);
            if (path.size()==0|| path.get(path.size()-1)<=nums[index]){
                path.add(nums[index]);
                helperAgain(nums,index+1,path,result);
                path.remove(path.size()-1);
            }
        }
    }
}
package Gitbooks;

/**
 * Created by hadoop on 14/9/17.
 */
public class Sudoku {
    public static void main(String args[]){

    }
    public boolean validSudoku(char [][]board){
        for(int i=0;i<board.length;i++){
            for(int j=0;j<board[0].length;j++){
                if(board[i][j]!='.'){
                    return false;
                }
                for(char c='1';c<='9';c++){
                    if(valid(i,j,board,c)){
                        board[i][j] = c;
                        if(validSudoku(board))
                            return true;
                        board[i][j] = '.';
                    }
                }
            }
        }
        return true;
    }

    private boolean valid(int i, int j, char[][] board, char c) {
        if(board[i][j] !='.') return false;
        for( int k=0;k<9;i++){
            if( board[k][j] ==c) return false;
            if( board[i][k] == c) return false;
        }
        for( int k=0;k<3;k++){
            for(int l=0;l<3;l++){
                if(board[3*(i/3) +k][3*(j/3)+l] == c){
                    return false;
                }
            }
        }
        return true;
    }
}
package Gitbooks;

import java.util.ArrayList;
import java.util.List;

/**
 * Created by hadoop on 13/9/17.
 */
public class Queens {
    static int counter = 0;

    public static void main(String[] args) {
        int n;
        n = 4;

        char[][] board = new char[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                board[i][j] = '.';
            }
        }
        List<List<String>> result = new ArrayList<>();

        Queens queens = new Queens();
        queens.solveQueen(board,0,result,n);
        System.out.println(result);
    }
    void solveQueen(char[][] board, int index, List<List<String>> result,int size){
        if(index == size){
        //    System.out.println("coming here");
            ArrayList<String>list = new ArrayList<>();
            for(int i=0;i<4;i++) {
          //      System.out.println("ans"+String.valueOf(board[i]));
                list.add(String.valueOf(board[i]));
            }
            result.add(new ArrayList<>(list));
            return ;
        }
        //System.out.println("index out"+index);
        for(int col=0;col<size;col++){
            //System.out.println("index in"+index);

            if(valid(index,col,board)){
                //System.out.println("index"+index);
                //System.out.println("ans here");

                board[index][col] ='a';
                if(index ==1 && col ==3){
                    System.out.println("special case");
                    for(int s=0;s<4;s++) {
                        System.out.println(String.valueOf(board[s]));
                        //list.add(String.valueOf(board[i]));
                    }
                    System.out.println("end");

                }
                if(index ==2 && col ==0){
                    System.out.println("special case new again");
                    for(int s=0;s<4;s++) {
                        System.out.println(String.valueOf(board[s]));
                        //list.add(String.valueOf(board[i]));
                    }
                    System.out.println("end");

                }
                //System.out.println("call");
                solveQueen(board,index+1,result,size);
                board[index][col] ='.';
            }
        }
    }

    private boolean valid(int index, int col,char[][] board) {


            for(int  i=0;i<index;i++){
                if(board[i][col] =='a'){
                       // if(index ==3) {
                            //for(int s=0;s<4;s++) {
                                      //System.out.println(String.valueOf(board[s]));
                                //list.add(String.valueOf(board[i]));
                          //  }
                            System.out.println("colmatched" + i);
                        //}
                        return false;
                }
            }

            for(int j=0;j<board.length;j++){
                if(board[index][j] =='a'){
                    if(index == 7 && col == 5) {
                        System.out.println("row");
                    }
                    return false;
                }
            }
            for(int i=0;i<index;i++) {
                for (int j = 0; j < board.length; j++) {
                    if(board[i][j]=='a') {
                        if(j>col) {
                            if (i + j == index + col) {
                                System.out.println("right");
                                return false;

                            }
                        }
                        if(j<col){
                        if (Math.abs(i - j) == Math.abs(index - col)) {
                            System.out.println("left" + i + " " + j);
                            return false;
                        }
                        }

                    }
                }
            }

        return true;
    }
    private boolean validagain(int index, int col,char[][] board) {

        for(int  i=0;i<index;i++){
            if(board[i][col] =='a'){
                return false;
            }
        }
        int row = index;
        int column = col;

        while (row>=0 && column>=0){
            if(board[row][column] =='a'){
                return false;
            }
            row--;
            column--;
        }
        row = index;
        column = col;
        while (row>=0 && column<=board.length-1){
            if(board[row][column] =='a'){
                return false;
            }
            row--;
            column++;
        }
        //  }
        return true;
    }
}
package Gitbooks;

/**
 * Created by hadoop on 12/9/17.
 */
public class NextPermutation {
    public static void main(String args[]){
        NextPermutation nextPermutation = new NextPermutation();
        int nums []= {6,8,7,4,3,2};
        nextPermutation.nextPermutation(nums);
        nextPermutation.previousPermutation(nums);
        for( Integer i :nums){
            System.out.print(i);
        }
    }
    public void nextPermutation(int [] nums){
        for(int i=nums.length-2;i>=0;i--) {
            if (nums[i] < nums[i + 1]) {
                int j;
                for(j=nums.length-1;j>i;j--){
                    if(nums[j]>nums[i]){
                        break;
                    }
                }
                swap(nums,i,j);
                reverse(nums,i+1,nums.length-1);
                return;
            }
        }
    }

    private void reverse(int[] nums, int start, int end) {
        while (start<end){
            swap(nums,start,end);
            start++;
            end--;
        }
    }
    private void swap(int []nums,int i,int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
    private void previousPermutation(int [] nums){
        for( int i = nums.length-2;i>=0;i--){
            if(nums[i]>nums[i+1]){
                int j;
                for(j = nums.length-1;j>i;j--){
                    if(nums[j]<nums[i]){
                        break;
                    }
                }
                swap(nums,i,j);
                reverse(nums,i+1,nums.length-1);
                return;
            }

        }
    }

}
package Gitbooks;

import java.util.ArrayList;
import java.util.List;

/**
 * Created by hadoop on 15/9/17.
 */
public class RestoreIpAddress {
    public static void main(String[] args) {

        List<String> result = new ArrayList<>();
        List<String> path = new ArrayList<>();
        String s="255255255255";
        helper(0,result,path,s);
        System.out.println(result);
    }

    private static void helper(int index, List<String> result, List<String> path, String s) {

        if(index == s.length()){
            if(path.size() ==4) {
                String ans = new String();
                for (String a : path) {
                    ans = ans + "." + a;
                }
                result.add(ans.substring(1));
                return;
            }
            return;
        }
        for( int i=index;i<s.length() && i<index+3;i++){
            if(isvalid(s.substring(index,i+1))){
                path.add(s.substring(index,i+1));
                helper(i+1,result,path,s);
                path.remove(path.size()-1);
            }
        }


    }

    private static boolean isvalid(String substring) {
        if(substring.startsWith("0"))
            return substring.equalsIgnoreCase("0");
        int value = Integer.parseInt(substring);
        if(value >255)return false;
        return true;
    }

}
package Gitbooks;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Created by hadoop on 12/9/17.
 */
public class BfsTemplate {
    public static void main(String args[]){
        BfsTemplate bfsTemplate = new BfsTemplate();
        int nums []={1,1,2,1,3};
        Arrays.sort(nums);
        System.out.println(bfsTemplate.subsets(nums));
        System.out.println(bfsTemplate.subsetsWithDup(nums));
    }

    public List<List<Integer>> subsets(int [] nums){
        List<Integer> list = new ArrayList<>();
        List<List<Integer>> ans = new ArrayList<>();
        return helper(0,list,ans,nums);
    }

    List<List<Integer>> helper(int index,List<Integer> ans, List<List<Integer>> result,int [] nums){

        result.add(new ArrayList<>(ans));
        for(int i=index;i<nums.length;i++){

            if(i-1>=index && nums[i] == nums[i-1] ) continue;
            ans.add(nums[i]);
            helper(i+1,ans,result,nums);
            ans.remove(ans.size()-1);
        }
        return result;
    }
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        List<Integer> path = new ArrayList<Integer>();
        List<List<Integer>> rst = new ArrayList(path);
        if (nums == null || nums.length == 0) {
            return rst;
        }

        Arrays.sort(nums);
        helper(nums, path, 0, rst);

        return rst;
    }

    private void helper(int[] nums, List<Integer> path, int pos, List<List<Integer>> rst) {
        rst.add(new ArrayList(path));

        for (int i = pos; i < nums.length; i++) {
            path.add(nums[i]);
            helper(nums, path, i + 1, rst);
            path.remove(path.size() - 1);
            while (i < nums.length - 1 && nums[i] == nums[i + 1]) i++;
        }
    }
}
package Gitbooks;

import java.util.ArrayList;
import java.util.List;

/**
 * Created by hadoop on 12/9/17.
 */
public class CombinationSum3 {
    public static void main(String[] args) {
        CombinationSum3 combinationSum3 = new CombinationSum3();
        System.out.println(combinationSum3.cominationsum3(3,9));
        System.out.println("ans"+combinationSum3.combinationSum4(new int[]{1, 2, 3},4));

    }
    List<List<Integer>> cominationsum3(int k , int n){
        List<Integer> path = new ArrayList<>();
        List<List<Integer>> result = new ArrayList<>();
        helper(path,result,1,n,k);
        return result;
    }

    private void helper(List<Integer> path, List<List<Integer>> result, int index, int n, int k) {
    if(n<0 || k<0){
        return;
    }
    if(n ==0 && k ==0 ){
        result.add(new ArrayList<>(path));
        return;
    }

    for(int i= index;i<=9;i++){
        path.add(i);
        helper(path,result,i+1,n-i,k-1);
        path.remove(path.size()-1);
    }
    }
    public int combinationSum4(int nums[],int target){
        int cache[] = new int[target+1];
        cache[0]= 1;
        for(int i=0;i<=target;i++){
            for (int j=0;j<nums.length;j++){
                if(nums[j]<=i){
                    cache[i] = cache[i]+cache[i-nums[j]];
                }
            }
        }
        return cache[target];
    }
}
package Gitbooks;

import java.util.ArrayList;
import java.util.List;

/**
 * Created by hadoop on 15/9/17.
 */
public class BinaryWatch {
    public static void main(String args[]){
        List<String> stringList = new ArrayList<>();
        int []nums1= {8,4,2,1};
        int []nums2 = {32,16,8,4,2,1};
        int n = 3;
        List<Integer> list1 = new ArrayList<>();
        List<Integer> result = new ArrayList<>();
        int k =n;
        //getnumbers(k,nums1,list1,result,0,0);
        //System.out.println(result);
        for( int i=1;i<=n;i++){
            ArrayList<Integer> left = new ArrayList<>();
            getnumbers(i,nums1,list1,left,0,0);
            System.out.println(left);
            ArrayList<Integer> right = new ArrayList<>();
            getnumbers(n-i,nums2,list1,right,0,0);
            System.out.println(right);
            System.out.println("end");
        }
    }

    private static void getnumbers(int k, int[] nums1, List list1,List result,int index,Integer sum) {
        if(list1.size() == k ){
            result.add(sum);
            return;
        }
        for(int i=index;i<nums1.length;i++){
            sum = sum + nums1[i];
            list1.add(nums1[i]);
            getnumbers(k,nums1,list1,result,i+1,sum);
            list1.remove(list1.size()-1);
            sum = sum - nums1[i];
        }
    }
}
package Gitbooks;

import java.util.ArrayList;
import java.util.List;

/**
 * Created by hadoop on 15/9/17.
 */
public class PanlindromePartitioning {
    public static void main(String[] args) {

    }
    public List<List<String>> solution(String a){
        List<List<String>> result = new ArrayList<>();
        List<String> path = new ArrayList<>();
        helper(0,result,path,a);
        return result;
    }

    private void helper(int index, List<List<String>> result, List<String> path, String a) {
            if(index == a.length()){
                result.add(new ArrayList<>(path));
                return;
            }
            for( int i=index;i<a.length();i++){
                if(validpalndromde(index,i,a)){
                    path.add(a.substring(index,i+1));
                    helper(index+1,result,path,a);
                    path.remove(path.size()-1);
                }

            }

    }

    private boolean validpalndromde(int start, int end,String s) {
        while (start<end){
            if(s.charAt(start) ==s.charAt(end)){
                start++;
                end--;
            }
            else {
                return false;
            }
        }
        return true;
    }
}
package Gitbooks;

import java.util.HashSet;
import java.util.Set;

/**
 * Created by hadoop on 14/9/17.
 */
public class PossibleSolutionsQueen {
    Set<Integer> sameColumn = new HashSet<>();
    Set<Integer> leftDiagonal = new HashSet<>();
    Set<Integer> rightDiagonal = new HashSet<>();
    int n=4;
    public static void main(String args[]){
        PossibleSolutionsQueen possibleSolutionsQueen = new PossibleSolutionsQueen();
        System.out.println("ans"+possibleSolutionsQueen.queen(0,4));
    }
    int queen(int row,int size){

        if(row ==size ){
            return 1;
        }
        int count = 0;
        for(int col = 0;col<size;col++){
            if(valid(row,col)){
                setMove(row,col);
                count+= queen(row+1,size);
                unsetMove(row,col);
            }
        }
        return count;
    }

    private void unsetMove(int row, int col) {
        sameColumn.remove(col);
        leftDiagonal.remove(row-col+n);
        rightDiagonal.remove(row+col);
    }

    private void setMove(int row, int col) {
        sameColumn.add(col);
        leftDiagonal.add(row-col+n);
        rightDiagonal.add(row+col);
    }

    private boolean valid(int row, int col) {
        if(sameColumn.contains(col)) return  false;
        if(leftDiagonal.contains(row-col+n)) return false;
        if(rightDiagonal.contains(row+col)) return false;
        return true;
    }
}
package BasicAlgorithms.Recursion;

/**
 * Created by hadoop on 24/10/17.
 */
public class NumMatrix {
    TreeNode root;
    public NumMatrix(int[][] matrix) {
        if (matrix.length == 0) {
            root = null;
        } else {
            root = buildTree(matrix, 0, 0, matrix.length-1, matrix[0].length-1);
        }
    }

    public void update(int row, int col, int val) {
        update(root, row, col, val);
    }

    private void update(TreeNode root, int row, int col, int val) {
        if (root.row1 == root.row2 && root.row1 == row && root.col1 == root.col2 && root.col1 == col) {
            root.sum = val;
            return;
        }
        int rowMid = (root.row1 + root.row2) / 2;
        int colMid = (root.col1 + root.col2) / 2;
        TreeNode next;
        if(row<=rowMid && col<=colMid) {
            update(root.c1,row,col,val);
        }
        if(row>rowMid && col<=colMid){
            update(root.c2,row,col,val);
        }
        if(row<=rowMid && col>colMid) {
            update(root.c3,row,col,val);
        }
        if(row>rowMid && col>colMid) {
            update(root.c4,row,col,val);
        }
        root.sum = root.c1.sum + root.c2.sum +root.c3.sum + root.c4.sum;
        return;

//        if (row <= rowMid) {
//            if (col <= colMid) {
//                next = root.c1;
//            } else {
//                next = root.c2;
//            }
//        } else {
//            if (col <= colMid) {
//                next = root.c3;
//            } else {
//                next = root.c4;
//            }
//        }
//        root.sum -= next.sum;
//        update(next, row, col, val);
//        root.sum += next.sum;
    }

    public int sumRegion(int row1, int col1, int row2, int col2) {
        return sumRegion(root, row1, col1, row2, col2);
    }

    private int sumRegion(TreeNode root, int row1, int col1, int row2, int col2) {
        if (root.row1 == row1 && root.col1 == col1 && root.row2 == row2 && root.col2 == col2)
            return root.sum;
        int rowMid = (root.row1 + root.row2) / 2;
        int colMid = (root.col1 + root.col2) / 2;
        int leftquatersum = 0;
        int leftbottomquatersum =0;
        int rightquatersum = 0;
        int rightbottomquatersum = 0;
        if(row1<=rowMid && col1<=colMid){
            leftquatersum = sumRegion(root.c1,row1,col1,Math.min(row2,rowMid),Math.min(col2,colMid));
        }
        if(row2>rowMid && col1<=colMid){
            leftbottomquatersum = sumRegion(root.c2,Math.max(row1,rowMid+1),col1,row2,Math.min(col2,colMid));
        }
        if(row1<=rowMid && col2>colMid){
            rightquatersum = sumRegion(root.c3,row1,Math.max(colMid+1,col1),Math.min(row2,rowMid),col2);
        }
        if(row2>rowMid && col2>colMid){
            rightbottomquatersum = sumRegion(root.c4,Math.max(rowMid+1,row1),Math.max(colMid+1,col1),row2,col2);
        }
        return leftquatersum+ leftbottomquatersum + rightquatersum + rightbottomquatersum;
//        if (rowMid >= row2) {
//            if (colMid >= col2) {
//                return sumRegion(root.c1, row1, col1, row2, col2);
//            } else if (colMid + 1 <= col1) {
//                return sumRegion(root.c2, row1, col1, row2, col2);
//            } else {
//                return sumRegion(root.c1, row1, col1, row2, colMid) + sumRegion(root.c2, row1, colMid+1, row2, col2);
//            }
//        } else if (rowMid + 1 <= row1) {
//            if (colMid >= col2) {
//                return sumRegion(root.c3, row1, col1, row2, col2);
//            } else if (colMid + 1 <= col1) {
//                return sumRegion(root.c4, row1, col1, row2, col2);
//            } else {
//                return sumRegion(root.c3, row1, col1, row2, colMid) + sumRegion(root.c4, row1, colMid+1, row2, col2);
//            }
//        } else {
//            if (colMid >= col2) {
//                return sumRegion(root.c1, row1, col1, rowMid, col2) + sumRegion(root.c3, rowMid+1, col1, row2, col2);
//            } else if (colMid + 1 <= col1) {
//                return sumRegion(root.c2, row1, col1, rowMid, col2) + sumRegion(root.c4, rowMid+1, col1, row2, col2);
//            } else {
//                return sumRegion(root.c1, row1, col1, rowMid, colMid) + sumRegion(root.c2, row1, colMid+1, rowMid, col2) + sumRegion(root.c3, rowMid+1, col1, row2, colMid) + sumRegion(root.c4, rowMid+1, colMid+1, row2, col2);
//            }
//        }
    }

    private TreeNode buildTree(int[][] matrix, int row1, int col1, int row2, int col2) {
        if (row2 < row1 || col2 < col1)
            return null;
        TreeNode node = new TreeNode(row1, col1, row2, col2);
        if (row1 == row2 && col1 == col2) {
            node.sum = matrix[row1][col1];
            return node;
        }
        int rowMid = (row1 + row2) / 2;
        int colMid = (col1 + col2) / 2;
        node.c1 = buildTree(matrix, row1, col1, rowMid, colMid);
        node.c2 = buildTree(matrix, row1, colMid+1, rowMid, col2);
        node.c3 = buildTree(matrix, rowMid+1, col1, row2, colMid);
        node.c4 = buildTree(matrix, rowMid+1, colMid+1, row2, col2);
        node.sum += node.c1 != null ? node.c1.sum : 0;
        node.sum += node.c2 != null ? node.c2.sum : 0;
        node.sum += node.c3 != null ? node.c3.sum : 0;
        node.sum += node.c4 != null ? node.c4.sum : 0;
        return node;
    }

    public class TreeNode {
        int row1, row2, col1, col2, sum;
        TreeNode c1, c2, c3, c4;
        public TreeNode (int row1, int col1, int row2, int col2) {
            this.row1 = row1;
            this.col1 = col1;
            this.row2 = row2;
            this.col2 = col2;
            this.sum = 0;
        }
    }
}
package BasicAlgorithms.Heap;

/**
 * Created by hadoop on 22/10/17.
 */
public class CompareToGyan {
}


/*


 if i return negatvie value ffrom compare to function means push me to elft ....
 if i return positive value from compare means push me to right ....


 this.key-object.key .... if current is smaller means nagetive lvaue will get pushed to left
 hence normal sorting
 objecy.key-this.key .. if current is smaller means positve value .. will get pushed to right
 desc sorting ..
 if curren it bigger then it will get pushed to left ...

 */package BasicAlgorithms.Heap;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.TreeMap;
/**A city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are given the locations and height of all the buildings as shown on a cityscape photo (Figure A), write a program to output the skyline formed by these buildings collectively (Figure B).
 *
 * The geometric information of each building is represented by a triplet of integers [Li, Ri, Hi], where Li and Ri are the x coordinates of the left and right edge of the ith building, respectively, and Hi is its height. It is guaranteed that 0  Li, Ri  INT_MAX, 0 < Hi  INT_MAX, and Ri - Li > 0. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.

 For instance, the dimensions of all buildings in Figure A are recorded as: [ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] .

 The output is a list of "key points" (red dots in Figure B) in the format of [ [x1,y1], [x2, y2], [x3, y3], ... ] that uniquely defines a skyline. A key point is the left endpoint of a horizontal line segment. Note that the last key point, where the rightmost building ends, is merely used to mark the termination of the skyline, and always has zero height. Also, the ground in between any two adjacent buildings should be considered part of the skyline contour.

 For instance, the skyline in Figure B should be represented as:[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ].

 Notes:

 The number of buildings in any input list is guaranteed to be in the range [0, 10000].
 The input list is already sorted in ascending order by the left x position Li.
 The output list must be sorted by the x position.
 There must be no consecutive horizontal lines of equal height in the output skyline. For instance, [...[2 3], [4 5], [7 5], [11 5], [12 7]...] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: [...[2 3], [4 5], [12 7], ...]*/

/**This video is super clear and helpful: https://www.youtube.com/watch?v=GSBLe8cKu0s

 Algorithm:
First observation: all the points in the final result come from the four angles that each building has
Scan through the horizontal lines
Use a PriorityQueue to hold each building, and make the PriorityQueue to sort on the height of the buildings
whenever we encounter the start of a building, we push it into the PriorityQueue, whenever we finished scanning that building, we remove it from the PriorityQueue
Also, in the scan process, well keep updating the maxHeight in the PriorityQueue if we find a new maxHeight which means the building will be overshadowed by the new higher one
 

Three edge cases (see the graph illustration in the above video at 1218):
when two buildings have the same start point, the one with higher height shows up in the final result
when two buildings have the same end point, the one with higher height shows up in the final result
when the start point of one building is is also the end point of another building, the one with higher height shows up in the final result
 

 We use TreeMap over a normal PriorityQueue:
For the sake of efficiency (better time complexity), well use TreeMap which supports O(logn) for remove() operation, this is the reason we choose TreeMap over a normal PriorityQueue in Java (PriorityQueue supports add() and getMaxVal() in both O(logn) time, however, for remove(), it does NOT.)
But TreeMap in Java supports all the three operations in O(logn) time.*/

public class _218 {

    class BuildingPoint implements Comparable<BuildingPoint> {
        int x;
        boolean isStart;
        int h;

        public BuildingPoint(int x, boolean isStart, int h) {
            this.x = x;
            this.h = h;
            this.isStart = isStart;
        }

        @Override
        public int compareTo(BuildingPoint o) {
            if (this.x != o.x) {
                return this.x - o.x;
            } else {
                if (this.isStart && o.isStart) {
                    return o.h - this.h;
                    // cosnder higher value first
                } else if (this.isStart && !o.isStart) {
                    // if i m starting and some else if ending
                    // then please consider me first ... not ending value
                    return -this.h - o.h;
                } else if (!this.isStart && !o.isStart) {
                    // consider smaller value first
                    return this.h - o.h;
                } else {
                    // if i m ending and some one else is starting then consider me last please
                    return this.h + o.h;
                }
            }
        }
    }

    public List<int[]> getSkyline(int[][] buildings) {
        BuildingPoint[] bps = new BuildingPoint[buildings.length * 2];
        int index = 0;
        for (int[] building : buildings) {
            BuildingPoint bp1 = new BuildingPoint(building[0], true, building[2]);
            BuildingPoint bp2 = new BuildingPoint(building[1], false, building[2]);
            bps[index++] = bp1;
            bps[index++] = bp2;
        }

        //this is one key step:
        Arrays.sort(bps);

        List<int[]> result = new ArrayList();
        TreeMap<Integer, Integer> treeMap = new TreeMap();
        treeMap.put(0, 1);
        int prevMaxH = 0;
        for (BuildingPoint bp : bps) {
            //if it's a starting point, we'll add it into the final result
            if (bp.isStart) {
                if (treeMap.containsKey(bp.h)) {
                    treeMap.put(bp.h, treeMap.get(bp.h) + 1);
                } else {
                    treeMap.put(bp.h, 1);
                }
            } else if (!bp.isStart) {
                //if it's an ending point, we'll decrement/remove this entry
                if (treeMap.containsKey(bp.h) && treeMap.get(bp.h) > 1) {
                    treeMap.put(bp.h, treeMap.get(bp.h) - 1);
                } else {
                    treeMap.remove(bp.h);
                }
            }

            int currMaxH = treeMap.lastKey();
            if (currMaxH != prevMaxH) {
                result.add(new int[]{bp.x, currMaxH});
                prevMaxH = currMaxH;
            }

        }

        return result;
    }

}
package BasicAlgorithms.BfsDfs;

import BasicAlgorithms.utils.ConsoleWriter;

import java.util.LinkedList;

/**
 * Created by hadoop on 25/10/17.
 */
public class Maze {
    int xdir []= {1,0,-1,0};
    int ydir [] = {0,1,0,-1};
    int m;
    int n;
    public boolean hasPath(int[][] maze, int[] start, int[] destination) {
         m = maze.length;
         n = maze[0].length;
        boolean visited [][] = new boolean[maze.length][maze[0].length];
        LinkedList<Integer> queue = new LinkedList<>();
        queue.add(start[0]*n+start[1]);
        visited[start[0]][start[1]] = true;
        int counter=0;
        while (!queue.isEmpty()){
            counter++;
            Integer polled = queue.poll();
            int x= polled/n;
            int y = polled%n;
            if(x == destination[0] && y == destination[1]){
                return true;
            }
            System.out.println("x "+x);
            System.out.println("y "+y);
            for(int i=0;i<4;i++){
                counter++;
                //System.out.println("entry");
                //System.out.println();
                int []directions = getNextValid(x,y,xdir[i],ydir[i],visited,maze);
                if(counter>1000){
                    System.exit(1);
                }
                if(directions!=null) {
                    ConsoleWriter.printIntArray(directions);
                }
                if(directions !=null) {
                    if (!visited[directions[0]][directions[1]]) {
                        visited[directions[0]][directions[1]] = true;
                        queue.add(directions[0] * n + directions[1]);
                    }
                }
            }
            if(counter>1000){
                System.exit(1);
            }
        }
        return false;
    }

    private int[] getNextValid(int x, int y, int xdir, int ydir, boolean[][] visited, int[][] maze) {
        int savex = x;
        int savey = y;
        int count = 0;
        System.out.println("here");
        while (isValid(x+xdir,y+ydir) && maze[x+xdir][y+ydir] !=1){
            x = x + xdir;
            y = y +ydir;
            System.out.println(x);
            System.out.println(y);
            count++;
            if(count>1000){
                System.exit(1);
            }
        }
        if(savex == x && savey == y){
            return null;
        }
        return new int[]{x,y};
    }

    private boolean isValid(int newx, int newy) {
        if (newx >= 0 && newx < m && newy >= 0 && newy < n) {
            return true;
        }
        return false;
    }

    public static void main(String[] args) {
        Maze maze = new Maze();
        int matrix[][] ={{0,0,1,0,0},{0,0,0,0,0},{0,0,0,1,0},{1,1,0,1,1},{0,0,0,0,0}};
        System.out.println(maze.hasPath(matrix,new int[]{0,4},new int[]{4,4}));
    }
}package BasicAlgorithms.BfsDfs;

import BasicAlgorithms.utils.ConsoleWriter;

import java.util.LinkedList;
import java.util.Queue;

/**
 * Created by hadoop on 21/10/17.
 */
// Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

// Example 1:

// 11110
// 11010
// 11000
// 00000
// Answer: 1

// Example 2:

// 11000
// 11000
// 00100
// 00011
// Answer: 3
public class NumberOfIslands {
    int xdir[] = {1, 0, -1, 0};
    int ydir[] = {0, 1, 0, -1};
    int m;
    int n;

    public int numIslands(int[][] grid) {
        int number = 0;
        m = grid.length;
        n = grid[0].length;
        boolean[][] visited = new boolean[m][n];
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (grid[i][j] == 1 && !visited[i][j]) {
                    visited[i][j] = true;
                    dfsApply(grid, i, j, visited);
                    number++;
                }
            }
        }
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                System.out.print(" "+visited[i][j]);
            }
            System.out.println();
        }

        return number;
    }

    private void dfsApply(int[][] grid, int x, int y, boolean[][] visited) {

        int m = grid.length;
        int n = grid[0].length;

        for (int k = 0; k < 4; k++) {
            int newx = x + xdir[k];
            int newy = y + ydir[k];
            if (isValid(newx, newy) && !visited[newx][newy] && grid[newx][newy] ==1) {
                visited[newx][newy] = true;
                dfsApply(grid, newx, newy, visited);
            }
        }
    }

    private boolean isValid(int newx, int newy) {
        if (newx >= 0 && newx < m && newy >= 0 && newy < n) {
            return true;
        }
        return false;
    }

    public static void main(String[] args) {
        int[][] array = {
                {1,1,1,1,0},
                {1,1,0,1,0},
                {1,1,0,0,0},
                {0,0,0,0,0}
        };
        int [][]array2 = {
                {1,1,0,0,0},
                {1,1,0,0,0},
                {0,0,1,0,0},
                {0,0,0,1,1}
        };
        NumberOfIslands numberOfIslands = new NumberOfIslands();
        System.out.println(numberOfIslands.numIslands(array2));
        System.out.println(numberOfIslands.numIslandsBfs(array2));
    }
    public int numIslandsBfs(int[][] grid) {
            int numberOfComponenets =0;
            m = grid.length;
            n = grid[0].length;
            boolean [][] visited = new boolean[m][n];
            for(int i=0;i<m;i++){
                for(int j=0;j<n;j++){
                    if(!visited[i][j] && grid[i][j] == 1){
                        bfsApply(grid,i,j,visited);
                        numberOfComponenets++;
                    }
                }
            }
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                System.out.print(" "+visited[i][j]);
            }
            System.out.println();
        }
        return numberOfComponenets;
    }

    private void bfsApply(int[][] grid, int i, int j, boolean[][] visited) {
        Queue<Integer> queue = new LinkedList<>();
        queue.add(i*n+j);
        visited[i][j] = true;

        while (!queue.isEmpty()){
            int polled = queue.poll();
            int x = polled/n;
            int y = polled%n;

            for(int k=0;k<4;k++){
                int newx = x + xdir[k];
                int newy = y + ydir[k];

                if(isValid(newx,newy) && !visited[newx][newy] && grid[newx][newy] == 1){
                    queue.add(newx*n+newy);
                    visited[newx][newy] = true;
                }
            }
        }
    }

}
package BasicAlgorithms.BfsDfs;
import java.util.*;

/**
 * Created by hadoop on 21/10/17.
 */
public class RemoveInvalidPrenthsis {
    public List<String> removeInvalidParentheses(String s) {
        List<String> list = new ArrayList<>();
        // Some times u need to create state on the fly
        // here is one of the example//
        // u just cant make state beforehand to process
        // word ladder problem was one of the xample
        // Make state on the fly ............
        Set<String> visited = new HashSet<>();
        Queue<String> queue = new LinkedList<>();

        queue.add(s);
        visited.add(s);
        HashMap<String,Integer> distance = new HashMap<>();
        distance.put(s,0);
        int mindis = Integer.MAX_VALUE;
        List<String> ans = new LinkedList<>();
        while (!queue.isEmpty()){
            String polled = queue.poll();
            int dist = distance.get(s);
            if(isValid(polled)){
                mindis = dist;
                ans.add(polled);
            }
            List<String> states = getStates(polled);
            for(String v:states){
                if(!visited.contains(v) && dist+1 <mindis){
                    visited.add(v);
                    queue.add(v);
                    distance.put(v,dist+1);
                }
            }
        }
        return ans;
    }

    private boolean isValid(String polled) {
        Stack<Character> stack= new Stack<>();
        for(char c:polled.toCharArray()){
            if(c == '('){
                stack.push(c);
            }
            else {
                if(stack.isEmpty()){
                    return false;
                }
                if (stack.peek() == '('){
                    stack.pop();
                }
                else {
                    return false;
                }
            }
        }
        return stack.size()==0;
    }

    private List<String> getStates(String polled) {
        List<String> states = new ArrayList<>();

        for(int i=1;i<polled.length();i++){
            if(!(polled.charAt(i) !='(' && polled.charAt(i) != ')')){
                states.add(polled.substring(0,i) +polled.substring(i+1));
            }
        }
        return states;
    }

    public static void main(String[] args) {
        RemoveInvalidPrenthsis removeInvalidPrenthsis = new RemoveInvalidPrenthsis();
        System.out.println(removeInvalidPrenthsis.removeInvalidParentheses("()())()"));
    }
}package BasicAlgorithms.BfsDfs;

/**
 * Created by hadoop on 24/10/17.
 */
public class MaxAreaOfIsland {
    public static int maxAreaOfIsland(int[][] grid) {
        if (grid == null || grid.length == 0) return 0;

        int row = grid.length;
        int col = grid[0].length;

        boolean[][] visited = new boolean[row][col];

        int max = 0;
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                if (grid[i][j] == 1 && !visited[i][j]) {
                    int area = dfs(i, j, grid, visited);
                    max = Math.max(max, area);
                }
            }
        }
        return max;
    }

    private static int dfs(int row, int col, int[][] grid, boolean[][] visited) {
        if (row >= 0 && row < grid.length && col >= 0 && col < grid[0].length && !visited[row][col] && grid[row][col] == 1) {
            visited[row][col] = true;
            int res1 = dfs(row + 1, col, grid, visited);
            int res2 = dfs(row, col + 1, grid, visited);
            int res3 = dfs(row - 1, col, grid, visited);
            int res4 = dfs(row, col - 1, grid, visited);
            return res1 + res2 + res3 + res4 + 1;
        }
        return 0;
    }
}
package BasicAlgorithms.BfsDfs;

/**
 * Created by hadoop on 25/10/17.
 */
public class PrioCheck {
}
package BasicAlgorithms.BfsDfs;
import java.util.*;

/**
 * Created by hadoop on 22/10/17.
 */
public class SurroundedRegions {
    public void solve(char[][] board) {
        int[] shift = {0, 1, 0, -1, 0};
        if (board == null || board.length == 0) {
            return;
        }
        int m = board.length;
        int n = board[0].length;
        for (int i = 0; i < n; i++) {
            fill(board, 0, i, shift);
            fill(board, m - 1, i, shift);
        }

        for (int i = 0; i < m; i++) {
            fill(board, i, 0, shift);
            fill(board, i, n - 1, shift);
        }

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (board[i][j] == 'O') {
                    board[i][j] = 'X';
                } else if (board[i][j] == '*') {
                    board[i][j] = 'O';
                }
            }
        }
    }

    public void fill(char[][] board, int i, int j, int[] shift) {
        if (board[i][j] == 'X') {
            return;
        }
        board[i][j] = '*';
        Queue<Integer> queue = new LinkedList<>();
        int m = board.length;
        int n = board[0].length;
        int index = i * n + j;
        queue.offer(index);
        while (!queue.isEmpty()) {
            int code = queue.poll();
            int x = code / n;
            int y = code % n;
            for (int k = 0; k < 4; k++) {
                int nextRow = x + shift[k];
                int nextCol = y + shift[k + 1];
                if (nextRow >= 0 && nextCol >= 0 && nextRow < m && nextCol < n && board[nextRow][nextCol] == 'O') {
                    board[nextRow][nextCol] = '*';
                    queue.offer(nextRow * n + nextCol);
                }
            }
        }
    }
}
package BasicAlgorithms.BfsDfs;
// You are given a m x n 2D grid initialized with these three possible values.

// -1 - A wall or an obstacle.
// 0 - A gate.
// INF - Infinity means an empty room. We use the value 231 - 1 = 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647.
// Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF.

// For example, given the 2D grid:
// INF  -1  0  INF
// INF INF INF  -1
// INF  -1 INF  -1
//   0  -1 INF INF
// After running your function, the 2D grid should be:
//   3  -1   0   1
//   2   2   1  -1
//   1  -1   2  -1
//   0  -1   3   4

// thats amaazing solution ... with DFS usual though ptocess is BFS but think outside the box

// idea is to start DFS from gate .... and u will see result
// we can do with BFS as well but we need to map row and column to one number ..
// also need to keep track of distance

import BasicAlgorithms.utils.ConsoleWriter;

import java.util.*;

/**
 * Created by hadoop on 21/10/17.
 */
public class WallAndGates {

    int[] xdir = {1, 0, -1, 0};
    int[] ydir = {0, 1, 0, -1};
    int m;
    int n;
    private static int INF = Integer.MAX_VALUE;

    public void wallsAndGates(int[][] rooms) {
        m = rooms.length;
        n = rooms[0].length;
        for (int i = 0; i < rooms.length; i++) {
            for (int j = 0; j < rooms[0].length; j++) {
                if (rooms[i][j] == 0) {
                    dfs(rooms, i, j, 0);
                }
            }
        }
      //  dfs(rooms,0,2,0);
    }

    private void dfs(int[][] rooms, int x, int y, int d) {

        // here do u think it wil go in infitine loop ..

        for (int k = 0; k < 4; k++) {
            int newx = x + xdir[k];
            int newy = y + ydir[k];
            if (isValid(newx, newy) && rooms[newx][newy]!=-1) {
                if (rooms[newx][newy] > d + 1) {
                    rooms[newx][newy] = d+1;
                    dfs(rooms, newx, newy, d + 1);
                }
            }
        }
    }


    private boolean isValid(int newx, int newy) {
        if (newx >= 0 && newx < m && newy >= 0 && newy < n ) {
            return true;
        }
        return false;
    }
    public void wallsAndGatesBfs(int[][] rooms) {
        // Its BFS from multiple sources at same time dude
        List<Integer> list = new ArrayList<Integer>();
        for(int i=0;i<rooms.length;i++){
            for(int j=0;j<rooms[0].length;j++){
                if(rooms[i][j] ==0){
                    list.add(i*rooms[0].length+j);
                }
            }
        }
        bfsFromMultipleSources(list,rooms);
    }

    private void bfsFromMultipleSources(List<Integer> list, int[][] rooms) {
        Queue<Integer> queue = new LinkedList<>();
        HashMap<Integer,Integer> distance = new HashMap<>();
        for(int i=0;i<rooms.length;i++){
            for(int j=0;j<rooms[0].length;j++){
                distance.put(i*rooms[0].length+j,INF);
            }
        }
        for(Integer source:list){
            distance.put(source,0);
            queue.add(source);
        }
        m = rooms.length;
        n = rooms[0].length;

        boolean visited[][] = new boolean[rooms.length][rooms[0].length];
        while(!queue.isEmpty()){
            int popped = queue.poll();
            int x = popped/rooms[0].length;
            int y = popped%rooms[0].length;
            for(int k=0;k<4;k++){
                int newx = x+xdir[k];
                int newy = y+ydir[k];
                System.out.println(newx);
                System.out.println(newy);
                System.out.println(isValid(newx,newy));
              //  System.out.println(rooms[newx][newy]!=-1);
               // System.out.println(visited[newx][newy]);
                if(isValid(newx,newy) && rooms[newx][newy]!=-1 && !visited[newx][newy]  && distance.get(newx*rooms[0].length +newy)>(distance.get(x*rooms[0].length+y)+1)){
                    System.out.println("entry here");
                    int v = newx*rooms[0].length+newy;
                    distance.put(v,distance.get(popped)+1);
                    visited[newx][newy] = true;
                    rooms[newx][newy] = distance.get(popped)+1;
                    queue.add(v);
                }
            }

        }
    }

    public static void main(String[] args) {
        int rooms[][] = {{INF, -1, 0, INF},
                {INF, INF, INF, -1},
                {INF, -1, INF, -1},
                {0, -1, INF, INF}};

        WallAndGates wallAndGates = new WallAndGates();
        wallAndGates.wallsAndGates(rooms);
        //wallAndGates.wallsAndGatesBfs(rooms);
        ConsoleWriter.printIntArray(rooms);

    }
}
//3	-1	0	1
//        2	2	1	-1
//        1	-1	2	-1
//        0	-1	3	4package BasicAlgorithms.BfsDfs;

import BasicAlgorithms.utils.ConsoleWriter;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.Queue;

/**
 * Created by hadoop on 21/10/17.
 */
	/*
				Shortest Distance from All Buildings
				You want to build a house on an empty land which reaches all buildings in the shortest amount of distance. You are given a 2D grid of values 0, 1 or 2, where:

				Each 0 marks an empty land which you can pass by freely.
				Each 1 marks a building which you cannot pass through.
				Each 2 marks an obstacle which you cannot pass through.
				The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.

				For example, given three buildings at (0,0), (0,4), (2,2), and an obstacle at (0,2):

				1 - 0 - 2 - 0 - 1
				|   |   |   |   |
				0 - 0 - 0 - 0 - 0
				|   |   |   |   |
				0 - 0 - 1 - 0 - 0
				The point (1,2) is an ideal empty land to build a house, as the total travel distance of 3+3+1=7 is minimal. So return 7.

				Note:
				There will be at least one building. If it is not possible to build such house according to the above rules, return -1.
			*/
public class ShortestDistanceFromBuildings {
    int m;
    int n;
    int xdir []={1,0,-1,0};
    int ydir []={0,1,0,-1};
    public int shortestDistance(int[][] grid) {
        // very difficult to apply DFS hence chose BFS ..
        m = grid.length;
        n = grid[0].length;
        int distance [][] = new int[m][n];
        int isReachable [][] = new  int[m][n];
        int numberOfBuildings= 0;

        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j] == 1){
                    numberOfBuildings++;
                    boolean [][]visited = new boolean[m][n];
                    applyBfs(grid,distance,visited,isReachable,i,j);
                }
            }
        }
        int mindis = Integer.MAX_VALUE;
        int x= -1;
        int y = -1;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(mindis>distance[i][j] && isReachable[i][j] ==numberOfBuildings){
                    mindis = distance[i][j];
                    x = i;
                    y = j;
                }
            }
        }
        ConsoleWriter.printIntArray(distance);
        System.out.println();
        ConsoleWriter.printIntArray(isReachable);
        System.out.println(x);
        System.out.println(y);
        return mindis;
    }

    private void applyBfs(int[][] grid, int[][] distanceMatrix, boolean[][] visited,int[][] isRechable, int x, int y) {
        visited[x][y] = true;
        Queue<Integer> queue = new LinkedList<>();
        queue.add(x*n+y);
        HashMap<Integer,Integer>  distance = new HashMap<>();
        distance.put(x*n+y,0);

        while (!queue.isEmpty()){
            int polled = queue.poll();
            x = polled/n;
            y = polled%n;
            int dis = distance.get(polled);
            for(int k=0;k<4;k++){
                int newx = x+xdir[k];
                int newy = y +ydir[k];
                if(isValid(newx,newy) && !visited[newx][newy] && grid[newx][newy]!=2 && grid[newx][newy]!=1){
                    visited[newx][newy] = true;
                    distanceMatrix[newx][newy] += dis+1;
                    distance.put(newx*n+newy,dis+1);
                    isRechable[newx][newy]++;
                    queue.add(newx*n+newy);
                }
            }
        }
    }
    private boolean isValid(int newx, int newy) {
        if (newx >= 0 && newx < m && newy >= 0 && newy < n) {
            return true;
        }
        return false;
    }
    public static void main(String args[]){
        ShortestDistanceFromBuildings shortestDistanceFromBuildings = new ShortestDistanceFromBuildings();
        int [][]grid ={{1,0,2,0,1},
                        {0,0,0,0,0},
                        {0,0,1,0,0}
                    };
        System.out.println(shortestDistanceFromBuildings.shortestDistance(grid));
    }
}package BasicAlgorithms.Trie;

import java.util.*;

/**
 * Created by hadoop on 13/10/17.
 */
public class AutoComplete {
     TrieNode root;
    public AutoComplete(){
        root = new TrieNode("");
    }

    public void insertWord(String word){
        TrieNode current = root;
        for(int i=0;i<word.length();i++){
            TrieNode children =current.children.get(word.charAt(i));
            if(children == null){
                children = new TrieNode(word.substring(0,i+1));
                current.children.put(word.charAt(i),children);
            }
            current = children;
            if(i == word.length()-1){
                children.isWord = true;
            }
        }
    }
    public void insertShort(String s){
        TrieNode curr = root;
        for(int i=0;i<s.length();i++){
            if(!curr.children.containsKey(s.charAt(i))){
                curr.children.put(s.charAt(i),new TrieNode(s.substring(0,i+1)));
            }
            curr = curr.children.get(s.charAt(i));
            if(i == s.length()-1){
                curr.isWord = true;
            }
        }
    }
    public boolean search(String s){
        if(s == null || s.length() ==0){
            return false;
        }
        TrieNode curr = root;
        for(int i=0;i<s.length();i++){
            if(!curr.children.containsKey(s.charAt(i))){
                return false;
            }
            curr = curr.children.get(s.charAt(i));
            if(curr == null){
                return false;
            }
        }
        return curr.isWord;
    }
    public List<String> getAllWordsForPrefix(String s){
        List<String> results = new ArrayList<>();
        TrieNode curr = root;
        for( int i=0;i<s.length();i++){
            if(curr.children.containsKey(s.charAt(i))){
                curr = curr.children.get(s.charAt(i));
            }
            else {
                return results;
            }
        }
        getAllWords(curr,results);
        return results;
    }
    void getAllWords(TrieNode curr,List<String> results){
        if (curr.isWord == true){
            results.add(curr.prefix);
            return;
        }
        for(TrieNode childrens:curr.children.values()){
            getAllWords(childrens,results);
        }
    }

    public static void main(String[] args) {
        AutoComplete autoComplete = new AutoComplete();
        autoComplete.insertWord("abc");
        autoComplete.insertWord("acd");
        autoComplete.insertWord("bcd");
        autoComplete.insertShort("def");
        autoComplete.insertShort("a");
        autoComplete.insertWord("aba");
        System.out.println(autoComplete.getAllWordsForPrefix("ab"));
        System.out.println(autoComplete.search("ab"));
    }

}
class TrieNode {
    String prefix;
    boolean isWord;
    HashMap<Character, TrieNode> children;
    TrieNode(String prefix){
        children = new HashMap<>();
        this.prefix = prefix;
    }
}package BasicAlgorithms.Trie;

import java.util.ArrayList;
import java.util.List;

/**
 * Created by hadoop on 13/10/17.
 */
public class FindWords {
    int dirx[]={1,-1,0,0};
    int diry[]={0,0,1,-1};
        public List<String> findWords(char[][] board, String[] words) {
        AutoComplete autoComplete = new AutoComplete();
        for(String word:words) {
            autoComplete.insertWord(word);
        }

        List<String> foundWords = new ArrayList<>();
        findWordsAgain(board,foundWords,autoComplete);
        return foundWords;
    }

    private void findWordsAgain(char[][] board, List<String> foundWords, AutoComplete autoComplete) {
        int r = board.length;
        int c = board[0].length;
        boolean [][]visited = new boolean[r][c];
        for(int i=0;i<r;i++){
            for(int j =0;j<c;j++){
                visited[i][j] = true;
                dfsHelper(i,j,autoComplete.root,foundWords,board,visited);
                visited = new boolean[r][c];
            }
        }
    }

    private void dfsHelper(int i, int j, TrieNode current, List<String> foundWords, char[][] board, boolean[][] visited) {

        char c = board[i][j];
        System.out.println("char =>" +c);
        if(!current.children.containsKey(c)){
            return;
        }
        current = current.children.get(c);
        if(current.isWord){
            if(!foundWords.contains(current.prefix)){
                foundWords.add(current.prefix);
            }
        }
        for(int k=0;k<4;k++){
            int newi = i+dirx[k];
            int newj = j+ diry[k];
            if(!isValid(newi,newj,board.length,board[0].length) ){
                continue;
            }
            if(visited[newi][newj]){
                continue;
            }
            visited[newi][newj] = true;
            dfsHelper(newi,newj,current,foundWords,board,visited);
            visited[newi][newj] = false;
        }

    }

    private boolean isValid(int newi, int newj,int r,int c) {
        if(newi>=0 && newi<r && newj>=0 && newj<c){
            return true;
        }
        return false;
    }
    public static void main(String args[]){
        FindWords findWords = new FindWords();
        char [][]board = {
                {'o', 'a', 'a', 'n'},
                {'e', 't', 'a', 'e'},
                {'i', 'h', 'k', 'r'},
                {'i', 'f', 'l', 'v'}
        };
        char [][]board1 = {
                {'a', 'b'},
                {'c', 'd'}
        };

        String []words = {"eat","oath"};
        String words1[] ={"cdba"};
        System.out.println(findWords.findWords(board1,words1));
    }
}package BasicAlgorithms.Trie;

/**
 * Created by hadoop on 22/10/17.
 */
public class FindWord {
    int xdir[]={1,0,-1,0};
    int ydir[]={0,1,0,-1};
    int m;
    int n;
    public boolean exist(char[][] board, String word) {
        m = board.length;
        n = board[0].length;
        if(m == 0 || n ==0){
            return false;
        }
        for(int i=0;i<board.length;i++){
            for(int j=0;j<board[0].length;j++){
                if(board[i][j] == word.charAt(0)){
                    boolean [][] visited = new boolean[board.length][board[0].length];
                    visited[i][j] = true;
                    if(dfsApply(board,i,j,0,visited,word)){
                        return true;
                    }
                }
            }
        }
        return false;
    }

    private boolean dfsApply(char[][] board, int x, int y, int d, boolean[][] visited,String word) {
        if(d == word.length()-1){
            return true;
        }
        for(int k=0;k<4;k++){
            int newx = x+xdir[k];
            int newy = y+ydir[k];
            System.out.println("newx"+newx);
            System.out.println("newy"+newy);
            if(isValid(newx,newy)) {
                System.out.println(visited[newx][newy]);
            }
            if(isValid(newx,newy) && !visited[newx][newy] && board[newx][newy] == word.charAt(d+1)){
                visited[newx][newy] = true;
                if(dfsApply(board,newx,newy,d+1,visited,word) == true){
                    return true;
                }
                visited[newx][newy] = false;
            }
        }
        return false;
    }

    private boolean isValid(int newx, int newy) {
        if (newx >= 0 && newx < m && newy >= 0 && newy < n ) {
            return true;
        }
        return false;
    }

    public static void main(String[] args) {
        char [][]board = {{'A','B','C','E'},
                        {'S','F','C','S'},
                {'A','D','E','E'}};
        String word = "ABCCED";
        char [][]board1 = {{'a','a'}};
        String word1 ="aaa";
        FindWord findWord = new FindWord();
        System.out.println(findWord.exist(board1,word1));
    }
}
package BasicAlgorithms.Math;

/**
 * @author Baofeng Xue at 2016/4/3 16:59.
 */
public class PrintFactors {

    public static void main(String[] args) {
        printFactors(12, "", 12);
        printFactors(24, "", 24);
        printFactors(30, "", 30);
    }

    public static void printFactors(int product, String carryString, int minFactor) {
        for (int factor1 = product / 2; factor1 >= 2; factor1--) {

            if (product % factor1 != 0) {
                continue;
            }

            if (factor1 > minFactor) {
                continue;
            }

            int factor2 = product / factor1;

            if (factor2 <= minFactor && factor1 <= minFactor && factor2 <= factor1) {
                System.out.println(carryString + factor1 + "*" + factor2);
            }

            printFactors(factor2, carryString + factor1 + "*", Math.min(factor2, factor1));
        }
    }
}package BasicAlgorithms.Math;

public class Prime {

    public static void main(String[] args) {
        long begin = System.currentTimeMillis();
        System.out.println(begin);
        runEratosthenesSieve(100000000);
        System.out.println();
        System.out.println(System.currentTimeMillis() - begin);
    }

    public static void runEratosthenesSieve(int upperBound) {

        int upperBoundSquareRoot = (int) Math.sqrt(upperBound);

        boolean[] isComposite = new boolean[upperBound + 1];

        for (int m = 2; m <= upperBoundSquareRoot; m++) {
            if (!isComposite[m]) {
                System.out.print(m + " ");
                for (int k = m * m; k <= upperBound; k += m)
                    isComposite[k] = true;
            }
        }

        for (int m = upperBoundSquareRoot; m <= upperBound; m++)
            if (!isComposite[m])
                System.out.print(m + " ");

    }
}
package BasicAlgorithms.Math;

import java.util.HashMap;
import java.util.HashSet;

/**
 * Created by hadoop on 24/10/17.
 */
public class DivideRec {
    public String fractionToDecimal(int num, int den) {
//        if (num == 0) {
//            return "0";
//        }
//        StringBuilder ans = new StringBuilder("");
//        // "+" or "-"
//        ans.append(((num > 0) ^ (den > 0)) ? "-" : "");
//        long numerator = Math.abs((long)num);
//        long denominator = Math.abs((long)den);
//        ans.append(numerator/denominator);
//        numerator = numerator%denominator;
//        if(numerator == 0){
//            return ans.toString();
//        }
//        ans.append(".");
//        HashMap<Long,Long> hashset = new HashMap<>();
//        hashset.put(numerator,(long)ans.length());
//        while (numerator != 0) {
//            numerator *= 10;
//            numerator %= den;
//            if (hashset.containsKey(numerator)) {
//                int index = hashset.get(numerator).intValue();
//                ans.insert(index, "(");
//                ans.append(")");
//                break;
//            }
//            else {
//                ans.append(numerator / den);
//                hashset.put(numerator, (long)ans.length());
//            }
//        }
//        return ans.toString();
        return null;

    }
    public static void main(String args[]){
        DivideRec divideRec = new DivideRec();
      //  System.out.println(divideRec.fractionToDecimal(1,3));
    }
    private class Solution {
        public String fractionToDecimal(int numerator, int denominator) {
            if (numerator == 0) {
                return "0";
            }
            StringBuilder res = new StringBuilder();
            // "+" or "-"
            res.append(((numerator > 0) ^ (denominator > 0)) ? "-" : "");
            long num = Math.abs((long)numerator);
            long den = Math.abs((long)denominator);

            // integral part
            res.append(num / den);
            num %= den;
            if (num == 0) {
                return res.toString();
            }

            // fractional part
            res.append(".");
            HashMap<Long, Integer> map = new HashMap<Long, Integer>();
            map.put(num, res.length());
            while (num != 0) {
                num *= 10;
                res.append(num / den);
                num %= den;
                if (map.containsKey(num)) {
                    int index = map.get(num);
                    res.insert(index, "(");
                    res.append(")");
                    break;
                }
                else {
                    map.put(num, res.length());
                }
            }
            return res.toString();
        }
    }
}package BasicAlgorithms.Math;

import java.util.Arrays;

/**
 * @author Baofeng Xue at 2016/3/22 21:11.
 */
public class Triangle {

    public static void main(String[] args) {

        Triangle triangle = new Triangle();
        System.out.println(Arrays.toString(triangle.getTriangleSides(new int[]{6, 4, 5})));
        System.out.println(Arrays.toString(triangle.getTriangleSides(new int[]{10, 2, 7})));
        System.out.println(Arrays.toString(triangle.getTriangleSides(new int[]{1, 2, 3, 4})));
    }

    /**
     * Three segments of lengths A, B, C form a triangle iff
     * <p>
     * A + B > C
     * B + C > A
     * A + C > B
     * <p>
     * e.g.
     * 6, 4, 5 can form a triangle
     * 10, 2, 7 can't
     * <p>
     * Given a list of segments lengths algorithm should find at least one triplet of segments that form a triangle (if any).
     * <p>
     * Method should return an array of either:
     * - 3 elements: segments that form a triangle (i.e. satisfy the condition above)
     * - empty array if there are no such segments
     */
    int[] getTriangleSides(int[] segments) {

        int[] result = {};

        if (segments == null || segments.length < 3) return result;

        Arrays.sort(segments);

        for (int i = 0; i < segments.length - 2; i++) {
            int a = segments[i];
            int b = segments[i + 1];
            int c = segments[i + 2];
            if (a + b > c) {
                result = new int[3];
                result[0] = a;
                result[1] = b;
                result[2] = c;
                return result;
            }
        }
        return result;
    }
}package BasicAlgorithms.String;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Created by hadoop on 15/10/17.
 */
public class TextJustification {
    public List<String> fullJustify(String[] words, int maxWidth) {
        List<String> list = new ArrayList<>();
        if(words == null || words.length ==0){
            return list;
        }
        int start=0;
        int end=0;
        boolean newline  = true;
        int currentlen =0;
        int currentcount =0;
        int counter = 0;
        if(maxWidth == 0){
            list.addAll(Arrays.asList(words));
            return list;
        }
        boolean lastlineadded = false;
        while (end<words.length){
            System.out.println("end"+end);
            if(newline){
                currentcount=1;
                currentlen =words[end].length();
                System.out.println("lenn"+currentlen);
                System.out.println("counn"+currentcount);
            }
            else {
                currentlen+=words[end].length();
                currentcount++;
                System.out.println("len"+currentlen);
                System.out.println("coun"+currentcount);
            }
            if(currentlen+currentcount-1>maxWidth){

                    System.out.println("start"+start);
                    System.out.println("end"+end);
                    list.add(prettybetween(words, start, end - 1, currentlen - words[end].length(), maxWidth));
                    start = end;
                    newline = true;

            }
            else if(currentlen+currentcount-1==maxWidth){
                System.out.println("enterting");
                list.add(prettybetween(words, start, end, currentlen, maxWidth));
                start = end+1 ;
                end = end +1;
                if(end>=words.length){
                    lastlineadded = true;
                }
                newline = true;
            }
            else {
                end++;
                newline = false;
            }
            counter++;
            if(counter>50){
                System.exit(1);
            }
        }
        if(!lastlineadded) {
            list.add(prettylast(words, start, end - 1, currentlen, maxWidth));
        }
        return list;
    }

    private String prettybetween(String[] words, int start, int end, int length, int maxWidth) {
            int numberwords = end-start+1;
            String result = "";
            int i=0;
            int freespace = maxWidth - length;
            if(numberwords == 1){
                return words[start]+addspacenew(maxWidth-words[start].length());
            }
            int slots = numberwords-1;
            int each = freespace/slots;
            int remaininginleft = freespace%slots;
            while (i<numberwords-1){
                result = result + words[start+i];
                if(i<remaininginleft){
                    result = result +" ";
                }
                result = result+ addspacenew(each);
                i++;
            }
            result  = result + words[end];
            return result;
    }
    private String prettylast(String[] words, int start, int end, int length, int maxWidth) {
        int numberwords = end-start+1;
        String result = "";
        int i=0;
        int freespaceintheend = maxWidth - length -numberwords+1;
        while (i<numberwords-1){
            result = result + words[start+i];
            result = result +" ";
            i++;
        }
        result  = result + words[end];
        result = result + addspacenew(freespaceintheend);
        return result;
    }
    private String addspacenew(int wid){
        String space = "";
        for(int i=0;i<wid;i++){
            space = space+" ";
        }
        return space;
    }
    public static void main(String args[]){
        TextJustification textJustification = new TextJustification();
        String[] words = new String[]{"This", "is", "an", "example", "of", "text", "justification."};
        int l=3;
        int L = 16;
        String word[] ={"a","b","c","d","e"};
        List<String> list = textJustification.fullJustify(word,l);
        System.out.println(list);
    }
}package BasicAlgorithms.String;

public class KMP {

	public static void main(String[] args) {

		// Step 1 (pre processing): computing the LPS - longest proper prefix
        // which is also a suffix
		// step 2 (processing):

		String text = "AAABBCCAAABAB";
		String pattern = "AAA";

		int n = text.length();
		int m = pattern.length();

		int[] LPS = new int[m];

		int i = 0; // text pointer
		int j = 0; // pattern pointer

		computeLongestProperPrefixSuffix(pattern, m, LPS);

		while (i < n) {

			if (text.charAt(i) == pattern.charAt(j)) {
				i++;
				j++;

			}

			if (j == m) {
				System.out.println("Pattern is Matched!! at position "+(i-j));
				j = LPS[j - 1];
			}

			else if (i < n && text.charAt(i) != pattern.charAt(j)) {

				if (j == 0)
					i++;
				else
					j = LPS[j - 1];

			}
		}

		// TODO Auto-generated method stub

	}

	public static void computeLongestProperPrefixSuffix(String pattern, int m, int[] LPS) {
		int i = 1;

		int len = 0;

		LPS[0] = 0;

		while (i < m) {

			if (pattern.charAt(i) == pattern.charAt(len)) {
				len++;
				LPS[i] = len;
				i++;
			} else {
				if (len != 0)
					len = LPS[len - 1];
				else
					LPS[i] = 0;
				i++;
			}

		}
		

		// prefix table

		// proper prefix: all combinations without including the combination
		// which is containing the last character of
		// the pattern e.g abcde have these proper prefix: a, ab, abc, abcd

		// proper suffic: all combinations without including the combination
		// which is containing the first character of
		// the pattern e.g abcde have these proper suffix: e, de, cde, bcde

		// so, the longest proper prefix equal to the longest proper suffix = ?
	}
}package BasicAlgorithms.String;

public class Solution extends Reader4 {
    /**
     * @param buf Destination buffer
     * @param n   Maximum number of characters to read
     * @return    The number of characters read
     */
    int offset = 0;
    int buffersize=0;
    public int read(char[] buf, int n) {
        int totalbytes = 0;
        boolean eofile = false;
        char []buffer = new char[4];
        int bytesread =0;
        while (!eofile && totalbytes<n){
            if(buffersize == 0){
                bytesread = read4(buffer);
                if(bytesread<4){
                    eofile = true;
                }
            }
            int remainingbytestoread= n-totalbytes;
            for(int i=0;i<Math.min(remainingbytestoread,bytesread);i++){
                buf[totalbytes++] = buffer[offset+i];
            }
            offset = (offset + Math.min(remainingbytestoread,bytesread))%4;
            buffersize = buffersize - Math.min(remainingbytestoread,bytesread);
        }
        
        return totalbytes;
    }
}
class Reader4 {
    int read4(char[] buf) {
        return 4;
    }
}package BasicAlgorithms.String;

/**
 * Created by hadoop on 14/10/17.
 */
public class CountAndSay {
    public String countAndSay(int n) {
        if(n==0){
            return "";
        }
        String res = "1";

        for(int i=1;i<n;i++){
            String temp="";
            int count = 1;
            for(int j=1;j<res.length();j++){
                if(res.charAt(j) == res.charAt(j-1)){
                    count++;
                }
                else {
                    temp = temp+count;
                    temp = temp + res.charAt(j-1);
                    count =1;
                }
            }
            temp = temp+count;
            temp = temp+res.charAt(res.length()-1);
            res = temp;
        }
        return res;
    }

    public static void main(String[] args) {
        CountAndSay countAndSay = new CountAndSay();
        countAndSay.countAndSay(5);
    }
}
package BasicAlgorithms.String;

/**
 * Created by hadoop on 14/10/17.
 */
public class LongestPalindrome {
    int max = 1;
    int low = 0;
    public String longestPalindrome(String s) {
        if(s == null || s.length() == 0){
            return "";
        }
        if(s.length() == 1){
            return s;
        }
        for (int i=0;i<s.length();i++){
            extendPalindrome(s,i,i+1);
            extendPalindrome(s,i,i);
        }
        return s.substring(low,max+low);
    }

    private void extendPalindrome(String s, int i, int j) {
        int locallow = i;
        int locallength = 0;
        while (i>=0 && j<s.length()&& s.charAt(i) == s.charAt(j)){
            System.out.print(" "+s.charAt(i));
            System.out.print(" "+s.charAt(j));
            System.out.print(" "+i);
            System.out.print(" "+j);
            System.out.println();
            locallow = i;
            locallength = j-i+1;
            i--;
            j++;
        }

        if(max<locallength){
            System.out.println(i);
            System.out.println(j);
            max = locallength;
            low = locallow;
        }
    }

    public static void main(String[] args) {
        String a = "babad";
        LongestPalindrome longestPalindrome = new LongestPalindrome();
        System.out.println(longestPalindrome.longestPalindrome(a));
    }
}package BasicAlgorithms.String;

import java.util.HashMap;

/**
 * Created by hadoop on 14/10/17.
 */
public class PermutationPalindrome {
    public boolean canPermutePalindrome(String s) {
        int i=0;
        int j = s.length()-1;
        HashMap<Character,Integer> hashMap= new HashMap<>();
        for(char c:s.toCharArray()){
            if(hashMap.containsKey(c)){
                hashMap.remove(c);
            }
            else {
                hashMap.put(c,1);
            }
        }
        return hashMap.size()<=1;
    }
}package BasicAlgorithms.String;

/**
 * Created by hadoop on 24/10/17.
 */
import java.util.*;
public class LongestWord {
    public String findLongestWord(String s, List<String> d) {
        Collections.sort(d, new Comparator<String>() {
            @Override
            public int compare(String o1, String o2) {
                return o2.length() - o1.length();
            }
        });
        int j =-1;
        for (String dict : d) {
            j=0;
            for (int i = 0; i < s.length() && j < dict.length(); i++) {
                if (s.charAt(i) == dict.charAt(j)) {
                    j++;
                }
            }
            if (j == dict.length()) {
                return dict;
            }
        }
        return null;
    }
}
package BasicAlgorithms.String;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

/**
 * Created by hadoop on 23/10/17.
 */
public class Anagrams {
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> list = new ArrayList<>();
        StringBuilder sb = new StringBuilder();
        for(int i=0;i<=s.length()-p.length();i++){
            if(i<p.length()-1){
                sb.append(s.charAt(i));
                continue;
            }
            if(i>p.length()-1){
                sb.deleteCharAt(i-p.length());
            }
            sb.append(s.charAt(i));
            if(isAnagram(sb.toString(),p)){
               list.add(i);
            }
        }
        return list;
    }

    public boolean isAnagram(String s, String t) {
        HashMap<Character,Integer> hashMap = new HashMap<>();
        int counter=0;
        for(int i=0;i<s.length();i++){
            if(!hashMap.containsKey(s.charAt(i))){
                hashMap.put(s.charAt(i),1);
                counter++;
            }
            else {
                hashMap.put(s.charAt(i),hashMap.get(s.charAt(i))+1);
                counter++;
            }
        }
        for(int i=0;i<t.length();i++){
            if(hashMap.containsKey(t.charAt(i))){
                System.out.println(hashMap);
                int freq = hashMap.get(t.charAt(i));
                freq = freq-1;
                System.out.println("t.charat"+t.charAt(i));
                System.out.println("frq"+freq);
                if(freq == 0){
                    hashMap.remove(t.charAt(i));
                }
                else {
                    hashMap.put(t.charAt(i),freq);
                }
                counter--;
            }
            else {
                return false;
            }
        }
        System.out.println(counter);
        return counter ==0;
    }
}package BasicAlgorithms.String;

import java.util.*;

/**
 * Created by hadoop on 14/10/17.
 */
public class PalindromePermutations {
    public List<String>generatePalindromes(String s){
        // check if possible to generate palindrome
        List<String> res = new ArrayList<>();
        HashMap<Character,Integer> hashMap = new HashMap<>();
        for(char c:s.toCharArray()){
            if(!hashMap.containsKey(c)){
                hashMap.put(c,1);
            }
            else {
                hashMap.put(c,hashMap.get(c)+1);
            }
        }

        char []array = s.toCharArray();
        char []permuteArray;
        if(array.length %2 ==1){
            permuteArray = new char[array.length/2];
        }
        else {
            permuteArray = new char[array.length/2];
        }
        Character mid = null;
        int y=0;
        System.out.println("permuse"+permuteArray.length);
        for(Map.Entry<Character,Integer> entry: hashMap.entrySet()){
            if(entry.getValue()%2 == 1 && mid == null){
                mid = entry.getKey();
            }
            else if(entry.getValue()%2 == 1 && mid != null) {
                return res;
            }
            for(int x=0;x<(entry.getValue()/2);x++){
                System.out.println("y "+y);
                permuteArray[y++]= entry.getKey();
            }
        }
        System.out.println("len "+permuteArray.length);
        for(char a:permuteArray){
            System.out.print(a);
        }
        System.out.println();
        Arrays.sort(permuteArray);
        List<Character> path = new ArrayList<>();
        boolean visited[] = new boolean[permuteArray.length];
        permutations(path,visited,permuteArray,res,mid);
        return res;
    }

    private void permutations(List<Character> path, boolean[] visited, char[] permuteArray, List<String> res,Character mid) {
        if(path.size() == permuteArray.length){
            StringBuilder sb = new StringBuilder();
            for(Character c:path){
                sb.append(c);
            }
            String firstHalf = sb.toString();
            String reverse = sb.reverse().toString();
            if(mid == null){
                res.add(firstHalf+reverse);
            }
            else {
                res.add(firstHalf+mid+reverse);
            }
            return;
        }
        for(int k=0;k<permuteArray.length;k++){
            if(visited[k]) continue;
                visited[k] = true;
                path.add(permuteArray[k]);
                permutations(path, visited, permuteArray, res, mid);
                visited[k] = false;
                path.remove(path.size() - 1);
                while (k < permuteArray.length - 1 && permuteArray[k] == permuteArray[k + 1]) {
                    k++;
                }
            }
        }
    public static void main(String args[]){
        PalindromePermutations palindromePermutations = new PalindromePermutations();
        List<Character> list = new ArrayList<>();
        List<String> res = new ArrayList<>();
        char []permuteArray = {'a','b','c'};
        Character mid = 'f';
        boolean visited[] = new boolean[3];

        palindromePermutations.permutations(list,visited,permuteArray,res,mid);
        System.out.println(res);
        System.out.println(palindromePermutations.generatePalindromes("aaaaa"));
    }
}
package BasicAlgorithms.String;

import java.util.HashMap;

/**
 * Created by hadoop on 15/10/17.
 */
public class MinWindowString {
    public String minWindow(String s, String t) {

        int start=0;
        int end = 0;
        HashMap<Character,Integer>shortMap = new HashMap<>();
        int counter=0;
        for(char c:t.toCharArray()){
            if(shortMap.containsKey(c)){
                shortMap.put(c,shortMap.get(c)+1);
                counter++;
            }
            else {
                counter++;
                shortMap.put(c,1);
            }
        }
        String ans = new String();
        int i=0;
        int j=0;
        int leng =Integer.MAX_VALUE;

        HashMap<Character,Integer> longMap = new HashMap<>();
        int totalcount=0;
        while (end<s.length()){
            if(!shortMap.containsKey(s.charAt(end))){
                end++;
                continue;
            }
            if(!longMap.containsKey(s.charAt(end))){
                longMap.put(s.charAt(end),1);
            }
            else {
                longMap.put(s.charAt(end),longMap.get(s.charAt(end))+1);
            }
            if(longMap.get(s.charAt(end))<=shortMap.get(s.charAt(end))){
                counter--;
            }

            // we have found solution ... now trying to optimse
            while (counter<=0){
                if(end-start+1<leng){
                    i = start;
                    j = end;
                    leng = end-start+1;
                    System.out.println("ans"+leng);
                }
                Integer frq = longMap.get(s.charAt(start));
                if(frq == null){
                    start++;
                    continue;
                }
                if(frq>shortMap.get(s.charAt(start))){
                }
                else {
                    counter++;
                }
                frq--;
                if(frq == 0) {
                    longMap.remove(s.charAt(start));
                }
                else {
                    longMap.put(s.charAt(start),frq);
                }
                start++;
            }

            end++;
        }
        return s.substring(i,j+1);
    }
    public static void main(String args[]){
        MinWindowString minWindowString = new MinWindowString();
        System.out.println(minWindowString.minWindow("ADOBECODEBANC","ABC"));
    }
}package BasicAlgorithms.String;

/**
 * Created by hadoop on 14/10/17.
 */
public class CompareStrings {
    public boolean compareStrings(String A, String B) {
        int []count = new int[256];
        for(char c:A.toCharArray()){
            count[c]++;
        }
        int totalelement=0;
        for(char d:B.toCharArray()){
            if(count[d]>0){
                count[d]--;
                totalelement++;
            }
        }
        if(totalelement == B.length()){
            return true;
        }
        return false;
    }
}package BasicAlgorithms.String;

import java.util.*;
/**
 * Created by hadoop on 16/10/17.
 */
public class WordLadders {

    Map<String,List<String>> map;
    List<List<String>> results;
    public List<List<String>> findLadders(String start, String end, List<String> dict) {
        results = new ArrayList<>();
        if(dict.size() == 0){
            return results;
        }
        Queue<String> queue = new ArrayDeque<>();
        queue.add(start);
        map = new HashMap<>();
        Map<String,Integer> ladder = new HashMap<>();
        for(String string:dict){
            ladder.put(string,Integer.MAX_VALUE);
        }
        ladder.put(start,0);
        dict.add(end);
        Integer min = Integer.MAX_VALUE;
        // BFS DIJKSTTA
        while (!queue.isEmpty()){
            String word = queue.poll();
            int step = ladder.get(word)+1;
            if(step>min){
                break;
            }
            for(int i=0;i<word.length();i++){
                StringBuilder sb = new StringBuilder(word);
                for(char a='a';a<='z';a++){
                    sb.setCharAt(i,a);
                    String newword = sb.toString();
                    if(ladder.containsKey(newword)){
                        int dis = ladder.get(newword);
                        if(dis<step){
                            continue;
                        }
                        else if(dis>step){
                            ladder.put(newword,step);
                            queue.add(newword);
                        }
                        else {
                            // do nothing just update path as we are going down
                        }

                        // Adding only smallest equal path // avioded longes path
                        //with continue written above
                        if(map.containsKey(newword)){
                            map.get(newword).add(word);
                        }
                        else {
                            map.put(newword,new LinkedList<>(Arrays.asList(new String []{word})));
                        }

                        if(newword.equals(end)){
                            min = step;
                        }

                    }
                }
            }
        }
        LinkedList<String> result = new LinkedList<>();
        //result.add(end);
        backTrace(end, start, result);
        return results;

    }

    private void backTrace(String end, String start, LinkedList<String> result) {
        if(end.equals(start)){
            result.add(0,start);
            results.add(new ArrayList<>(result));
            result.remove(0);
            return;
        }
        else {
            if(map.get(end)!=null) {
                for (String recu : map.get(end)) {
                    result.add(0, recu);
                    backTrace(recu, start, result);
                    result.remove(0);
                }
            }
        }

    }
}
package BasicAlgorithms.String;

/**
 * Created by hadoop on 13/10/17.
 */
public class AddBinary {
    public String addBinary(String a, String b) {
            if(a == null || a.length() == 0){
                return b;
            }
            if( b  == null || b.length() == 0){
                return a;
            }
            int i = a.length()-1;
            int j = b.length()-1;
            String ans="";
            int carry = 0;
            while (i>=0 || j>=0 || carry>0) {
                int avalue =0;
                if(i>=0){
                    avalue = a.charAt(i)-'0';
                }
                int bvalue = 0;
                if(j>=0){
                    bvalue = b.charAt(i)-'0';
                }
                int sum = avalue +bvalue+ carry;
                ans = sum % 2 + ans;
                carry = sum / 2;
            }
            return ans;
    }
}package BasicAlgorithms.String;

/**
 * Created by hadoop on 14/10/17.
 */
public class LongestCommonPrefix {
    public String longestCommonPrefix(String[] strs) {
        String firstString = strs[0];

        for(int i=0;i<firstString.length();i++){
            for(int j=1;j<strs.length;j++){
                if(strs[j].length()<i+1){
                    return firstString.substring(0,i);
                }
                if(strs[j].charAt(i)!=firstString.charAt(i)){
                    return firstString.substring(0,i);
                }
            }
        }
        return null;
    }
}package BasicAlgorithms.String;

/**
 * Created by hadoop on 14/10/17.
 */
public class RotateArray {
    public void rotateString(char[] str, int offset) {
        int length = str.length;
        offset = offset%length;
        int cycles = gcd(length,offset);
        int loops = length/offset +1;
        for(int i=0;i<cycles;i++){
            int tempindex = i;
            char tempvalue = str[i];
            while (true){
                int pos = (tempindex-offset+str.length)%str.length;
                if(pos == i){
                    break;
                }
                str[tempindex] = str[pos];
                tempindex = pos;
            }
            str[tempindex] = tempvalue;
        }
        }

    private int gcd(int length, int offset) {
        if(offset>length){
            return gcd(offset,length);
        }
        if(length%offset == 0){
            return offset;
        }
        return gcd(offset,length%offset);
    }

    public static void main(String[] args) {
        char a[]={'a','b','c','d','e','f'};
        RotateArray rotateArray = new RotateArray();
        rotateArray.rotateString(a,1);
        System.out.println(String.valueOf(a));
    }
}package BasicAlgorithms.String;

import java.util.Comparator;
import java.util.HashMap;
import java.util.Map;
import java.util.PriorityQueue;

/**
 * Created by hadoop on 21/10/17.
 */
public class TopK {
    private class Node {
        String str;
        Integer freq;

        Node(String str, Integer freq) {
            this.str = str;
            this.freq = freq;
        }

        public String[] topKFrequentWords(String[] words, int k) {
            String[] rst = new String[k];
// better method wud be creating min heap
            HashMap<String,Node> hashMap = new HashMap<>();
            PriorityQueue<Node> priorityQueue = new PriorityQueue<>(new Comparator<Node>() {
                @Override
                public int compare(Node o1, Node o2) {
                    return o2.freq-o1.freq;
                }
            });
            for(String word:words){
                if(!hashMap.containsKey(word)){
                    hashMap.put(word,new Node(word,0));
                }
                hashMap.get(word).freq = hashMap.get(word).freq +1;
            }

            for(Map.Entry<String,Node> entry:hashMap.entrySet()){
                priorityQueue.add(entry.getValue());
            }
            for(int i=0;i<k;i++){
                rst[i] = priorityQueue.poll().str;
            }
            return rst;
        }
        public String[] topKFrequentWordsMinHeap(String[] words, int k) {
            String[] rst = new String[k];
// better method wud be creating min heap
            HashMap<String,Node> hashMap = new HashMap<>();
            PriorityQueue<Node> priorityQueue = new PriorityQueue<>();
            for(String word:words){
                if(!hashMap.containsKey(word)){
                    hashMap.put(word,new Node(word,0));
                }
                hashMap.get(word).freq = hashMap.get(word).freq +1;
                if(priorityQueue.peek().freq<hashMap.get(word).freq){
                    priorityQueue.poll();
                    priorityQueue.add(hashMap.get(word));
                }
            }
      //      for(Map.Entry<String,Node> entry:hashMap.entrySet()){
        //        priorityQueue.add(entry.getValue());
       //     }
            for(int i=0;i<k;i++){
                rst[i] = priorityQueue.poll().str;
            }
            return rst;
        }
    }
}
package BasicAlgorithms.String;

/**
 * Created by hadoop on 14/10/17.
 */
public class LongestCommonString {
    public int longestCommonSubstring(String A, String B) {
        int [][]a = new int[A.length()+1][B.length()+1];
        for(int i=0;i<=A.length();i++){
            for(int j=0;i<=B.length();j++){
                if(i== 0 || j ==0){
                    a[i][j] = 0;
                    continue;
                }
                if(A.charAt(i-1)==B.charAt(j-1)){
                    a[i][j] = a[i-1][j-1]+1;
                }
                else {
                    a[i][j] = 0;
                }
            }
        }
        return a[A.length()][B.length()];
    }
}package BasicAlgorithms.String;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

/**
 * Created by hadoop on 14/10/17.
 */
public class GroupAnagrams {
    public List<List<String>> groupAnagrams(String[] strs) {
        HashMap<Integer, List<String>> hashMap = new HashMap<>();
        for (String word : strs) {
            int hashCode = getHashCode(word);
            if (!hashMap.containsKey(hashCode)) {
                hashMap.put(hashCode, new ArrayList<>());
            }
            hashMap.get(hashCode).add(word);
        }
        List<List<String>> result = new ArrayList<>();
        result.addAll(hashMap.values());
        return result;
    }
    int getHashCode(String word){
        int []hashing = new int[26];
        generatecount(hashing,word);
        int seed = 31;
        int hashcode = 0;
        for(int x:hashing){
            hashcode = hashcode*31 + x;
        }
            return hashcode;
        }

    private void generatecount(int[] hashing, String word) {
        for(char a:word.toCharArray()){
            hashing[a-'a']++;
        }
    }
}package BasicAlgorithms.String;

import java.util.*;

/**
 * Created by hadoop on 15/10/17.
 */
public class RemoveDuplicates {
    public String removeDuplicateLetters(String s) {

        HashMap<Character,Integer> hashMap = new HashMap<>();
        for(int i=0;i<s.length();i++){
            if(!hashMap.containsKey(s.charAt(i))){
                hashMap.put(s.charAt(i),1);
            }
            else {
                hashMap.put(s.charAt(i),hashMap.get(s.charAt(i))+1);
            }
        }
        int end =0;
        List<Character> list = new LinkedList<>();
        while (end<s.length()){
            char c= s.charAt(end);
            int freq = hashMap.get(s.charAt(end));
            freq = freq -1;
            if(freq == 0){
                hashMap.remove(s.charAt(end));
            }
            hashMap.put(s.charAt(end),freq);
            end++;
            if(list.contains(c))continue;
            while (!list.isEmpty() && c<list.get(list.size()-1) && hashMap.get(list.get(list.size()-1))>0){
                list.remove(list.size()-1);
            }
                list.add(c);
        }
        String ans = "";
        for(Character c:list) {
            ans = ans + c;
        }
        return ans;
    }
    public static void main(String ar[]){
        RemoveDuplicates removeDuplicates = new RemoveDuplicates();
        System.out.println(removeDuplicates.removeDuplicateLetters("cbacdcbc"));
    }
}package BasicAlgorithms.String;

/**
 * Created by hadoop on 24/10/17.
 */
public class Atoi {
    public int myAtoi(String str){
        int index = 0;
        str = str.trim();
        if( str == null || str.length() ==0){
            return 0;
        }
        int sign=1;
        if(str.charAt(index) =='-'){
            sign = -1;
            index++;
        }
        else if(str.charAt(index) =='+'){
            sign =1;
            index++;
        }
        long result=0;
        for(int i=index;i<str.length();i++){
            if(str.charAt(i) > '9' || str.charAt(i) < '0'){
                break;
            }
            result = result*10 + str.charAt(i)-'0';
            if(result>Integer.MAX_VALUE){
                break;
            }
        }
        if(sign == 1){
            if(sign*result>=Integer.MAX_VALUE){
                return Integer.MAX_VALUE;
            }
        }
        if(sign == -1){
            if(sign*result<=Integer.MIN_VALUE){
                return Integer.MIN_VALUE;
            }
        }
        return (int)result*sign;
    }
}
package BasicAlgorithms.String;

/**
 *
 * Created by hadoop on 14/10/17.
 */
public class LengthOfLast {
    public static void main(String arhs[]) {

    }

    public int lengthOfLastWord(String s) {
        int end = s.length()-1;
        while (end>=0  && s.charAt(end)==' ')
            end--;
        int start=end;
        while (start>=0 && s.charAt(start)!=' '){
            start--;
        }
        return  s.substring(start+1,end+1).length();
    }
}package BasicAlgorithms.String;

import java.util.HashSet;
import java.util.Iterator;

/**
 * Created by hadoop on 14/10/17.
 */
public class LongestConsecutiveSequence {

    public int longestConsecutive(int[] nums) {
        HashSet<Integer> set = new HashSet<>();
        for(int num:nums){
            set.add(num);
        }
        Iterator<Integer> it = set.iterator();
        int maxsize = 0;
        for(int i=0;i<nums.length;i++) {
            if (set.remove(nums[i])) {
                int elem = nums[i];
                int leftsize = 0;
                int rightsize = 0;
                int leftreduce = elem - 1;
                int rightreduce = elem + 1;
                while (set.remove(leftreduce)) {
                    leftreduce--;
                    leftsize++;
                }
                while (set.remove(rightreduce)) {
                    rightreduce++;
                    rightsize++;
                }
                maxsize = Math.max(maxsize, leftsize + rightsize + 1);
            }
        }
        return maxsize;
    }
    public static void main(String args[]){
        LongestConsecutiveSequence lsc = new LongestConsecutiveSequence();
        int num[]={1,2,3,4};
        System.out.println(lsc.longestConsecutive(num));
    }
}package BasicAlgorithms.String;

/**
 * Created by hadoop on 15/10/17.
 */
public class EditDistance {
    public int minDistance(String word1, String word2) {
        int [][]dp = new int[word1.length()+1][word2.length()+1];

        dp[0][0] = 0;
        for(int i=0;i<=word1.length();i++){
            for(int j=0;j<=word2.length();j++){
                if(i==0 ){
                    dp[i][j] = j;
                }
                else if(j==0){
                    dp[i][j] = i;
                }
                else if(i==0 && j==0){
                    dp[0][0] = 0;
                }
                else {
                    if(word1.charAt(i-1) == word2.charAt(j-1)){
                        dp[i][j] = dp[i-1][j-1];
                    }
                    else {
                        System.out.println();
                        int replace = 1+dp[i-1][j-1];
                        int delete = 1 + dp[i][j-1]; // delete in i
                        int add = 1 + dp[i-1][j]; // delete in j
                        System.out.println(replace);
                        System.out.println(delete);
                        System.out.println(add);
                        dp[i][j]  = Math.min(Math.min(replace,delete),add);
                    }
                }
            }
        }
        return dp[word1.length()][word2.length()];
    }
    public static void main(String args[]){
        EditDistance editDistance = new EditDistance();
        System.out.println(editDistance.minDistance("a","b"));
    }
}package BasicAlgorithms.String;

/**
 * Created by hadoop on 13/10/17.
 */
public class FlipGame2 {
    public boolean canWin(String s) {
        if(s == null || s.length() ==0){
            return false;
        }
        for(int i=0;i<s.length()-1;i++){
            if(s.charAt(i) == '+' && s.charAt(i+1)=='+'){
                String updatedString = s.substring(0,i)+"--"+s.substring(i+2);
                if(!canWin(updatedString)){
                    return true;
                }
            }
        }
        return false;
    }
}
package BasicAlgorithms.String;

/**
 * Created by hadoop on 15/10/17.
 */
public class ReadNSize extends Read4{
    public int read(char[] buf, int n) {
        int totalbytes = 0;
        boolean eofile = false;
        char []buffer = new char[4];
        while (!eofile && totalbytes<n){
            int bytesread = read4(buffer);
            if(bytesread<4){
                eofile = true;
            }
            int remainingbytestoread= n-totalbytes;
            for(int i=0;i<Math.min(remainingbytestoread,bytesread);i++){
                buf[totalbytes++] = buffer[i];
            }
        }
        return totalbytes;
    }
}
class Read4{
    int read4(char[]buffer){
        return 4;
    }
}package BasicAlgorithms.String;

/**
 * Created by hadoop on 14/10/17.
 */
public class CompareVersions {
    public int compareVersion(String version1, String version2) {
        String []v1 = version1.split("\\.");
        String []v2 = version2.split("\\.");
        int i = 0;
        int j = 0;
        while (i<v1.length || j<v2.length){
            int a= 0;
            if(i<v1.length){
                a = Integer.parseInt(v1[i]);
            }
            int b= 0;
            if(j<v2.length){
                b = Integer.parseInt(v2[j]);
            }
            System.out.println("a"+a);
            System.out.println("b"+b);
            if(a<b){
                return -1;
            }
            if(a>b){
                return 1;
            }
            System.out.println("a"+a);
            System.out.println("b"+b);
            i++;
            j++;
        }
        return 0;
    }

    public static void main(String[] args) {
        CompareVersions compareVersions = new CompareVersions();
        System.out.println(compareVersions.compareVersion("1.0","1"));
    }
}//package BasicAlgorithms.String;
//
///**
// * Created by hadoop on 13/10/17.
// */
//public class CompareVersion {
//    public int compareVersion(String version1, String version2) {
//        String a[] = version1.split("\\.");
//        String b[] = version2.split("\\.");
//        System.out.println(a.length);
//        System.out.println(b.length);
//        if(a.length ==1 && b.length ==1){
//            int x  =Integer.parseInt(version1);
//            int  y = Integer.parseInt(version2);
//            System.out.println("x"+x);
//            System.out.println("y"+y);
//            if(x<y){
//                return -1;
//            }
//            else if(x>y) {
//                return 1;
//            }
//            else {
//                return 0;
//            }
//        }
//        if(a.length ==1){
//            int x = Integer.parseInt(version1);
//            int y = Integer.parseInt(b[0]);
//            if(x<y){
//                return -1;
//            }
//            else if(x>y) {
//                return 1;
//            }
//            else {
//                return -1;
//            }
//        }
//        if(b.length ==1){
//            int x = Integer.parseInt(a[0]);
//            int y = Integer.parseInt(version2);
//            if(x<y){
//                return -1;
//            }
//            else if(x>y) {
//                return 1;
//            }
//            else {
//                return 1;
//            }
//        }
//        int i=0;
//        int j=0;
//        while (i<a.length &&j<b.length){
//            int first = Integer.parseInt(a[i]);
//            int second = Integer.parseInt(b[j]);
//            if(first<second){
//                return -1;
//            }
//            if(first>second){
//                return 1;
//            }
//            i++;
//            j++;
//        }
//        if(i == a.length && b.length ==j){
//            return 0;
//        }
//        if(i == a.length){
//            return -1;
//        }
//        else {
//            return 1;
//        }
//    }
//
//    public static void main(String[] args) {
//        CompareVersion compareVersion = new CompareVersion();
//        System.out.println(compareVersion.compareVersion("01","1"));
//    }
//}package BasicAlgorithms.String;
import java.util.*;

/**
 * Created by hadoop on 16/10/17.
 */

public class Minw {
    public String minWindow(String s, String t) {
        int start=0;
        int end = 0;
        HashMap<Character,Integer>shortMap = new HashMap<>();
        int counter=0;
        for(char c:t.toCharArray()){
            if(shortMap.containsKey(c)){
                shortMap.put(c,shortMap.get(c)+1);
                counter++;
            }
            else {
                counter++;
                shortMap.put(c,1);
            }
        }
        System.out.println(shortMap);
        String ans = new String();
        int i=0;
        int j=0;
        int leng =Integer.MAX_VALUE;
        HashMap<Character,Integer> longMap = new HashMap<>();
        int totalcount=0;
        while (end<s.length()){
            if(!shortMap.containsKey(s.charAt(end))){
                end++;
                continue;
            }
            if(!longMap.containsKey(s.charAt(end))){
                longMap.put(s.charAt(end),1);
            }
            else {
                longMap.put(s.charAt(end),longMap.get(s.charAt(end))+1);
            }
            if(longMap.get(s.charAt(end))<=shortMap.get(s.charAt(end))){
                counter--;
            }
            System.out.println(longMap);
            System.out.println(counter);
            // we have found solution ... now trying to optimse
            while (counter<=0){
                if(end-start+1<leng){
                    i = start;
                    j = end;
                    leng = end-start+1;
                    System.out.println(i);
                    System.out.println(j);
                    ans = s.substring(i,j+1);
                }
                Integer frq = longMap.get(s.charAt(start));
                if(frq == null){
                    start++;
                    continue;
                }
                if(frq>shortMap.get(s.charAt(start))){
                }
                else {
                    counter++;
                }
                frq--;
                if(frq == 0) {
                    longMap.remove(s.charAt(start));
                }
                else {
                    longMap.put(s.charAt(start),frq);
                }
                start++;
            }
            end++;
        }
        return ans;
    }

    public static void main(String[] args) {
        Minw minw = new Minw();
        System.out.println(minw.minWindow("a","aa"));
    }
}package BasicAlgorithms.String;

/**
 * Created by hadoop on 15/10/17.
 */
public class OneEditDistanace {
    public boolean isOneEditDistance(String s, String t) {
        if(s.length()>t.length()){
            return isOneEditDistance(t,s);
        }
        if(s.length() == t.length()){
            int count = 0;
            for(int i=0;i<s.length();i++){
                if(s.charAt(i)!=t.charAt(i)){
                    count++;
                }
            }
            if(count>1){
                return false;
            }
        }
        else if(t.length()-s.length() ==1){
            int i=0;
            for(i=0;i<s.length();i++){
                if(s.charAt(i)!=t.charAt(i)){
                    break;
                }
            }
            for(int k=i;k<s.length();k++){
                if(s.charAt(k)!=t.charAt(k+1)){
                    return false;
                }
            }
            return true;
        }
            return false;
    }
}package BasicAlgorithms.String;

/**
 * Created by hadoop on 11/11/17.
 */
public class ShortestString {
}
/*

Shortest Superstring Problem
4.6

Given a set of n strings arr[], find the smallest string that contains each string in the given set as substring. We may assume that no string in arr[] is substring of another string.

Examples:

Input:  arr[] = {"geeks", "quiz", "for"}
Output: geeksquizfor

Input:  arr[] = {"catg", "ctaagt", "gcta", "ttca", "atgcatc"}
Output: gctaagttcatgcatc

Shortest Superstring Greedy Approximate Algorithm
Shortest Superstring Problem is a NP Hard problem. A solution that always finds shortest superstring takes exponential time. Below is an Approximate Greedy algorithm.

Let arr[] be given set of strings.

1) Create an auxiliary array of strings, temp[].  Copy contents
   of arr[] to temp[]

2) While temp[] contains more than one strings
     a) Find the most overlapping string pair in temp[]. Let this
        pair be 'a' and 'b'.
     b) Replace 'a' and 'b' with the string obtained after combining
        them.

3) The only string left in temp[] is the result, return it.

Two strings are overlapping if prefix of one string is same suffix of other string or vice verse. The maximum overlap mean length of the matching prefix and suffix is maximum.

Working of above Algorithm:

arr[] = {"catgc", "ctaagt", "gcta", "ttca", "atgcatc"}
Initialize:
temp[] = {"catgc", "ctaagt", "gcta", "ttca", "atgcatc"}

The most overlapping strings are "catgc" and "atgcatc"
(Suffix of length 4 of "catgc" is same as prefix of "atgcatc")
Replace two strings with "catgcatc", we get
temp[] = {"catgcatc", "ctaagt", "gcta", "ttca"}

The most overlapping strings are "ctaagt" and "gcta"
(Prefix of length 3 of "ctaagt" is same as suffix of "gcta")
Replace two strings with "gctaagt", we get
temp[] = {"catgcatc", "gctaagt", "ttca"}

The most overlapping strings are "catgcatc" and "ttca"
(Prefix of length 2 of "catgcatc" as suffix of "ttca")
Replace two strings with "ttcatgcatc", we get
temp[] = {"ttcatgcatc", "gctaagt"}

Now there are only two strings in temp[], after combing
the two in optimal way, we get tem[] = {"gctaagttcatgcatc"}

Since temp[] has only one string now, return it.

Below is C++ implementation of above algorithm.
// C++ program to find shortest superstring using Greedy
// Approximate Algorithm
#include <bits/stdc++.h>
using namespace std;

// Utility function to calculate minimum of two numbers
int min(int a, int b)
{
    return (a < b) ? a : b;
}

// Function to calculate maximum overlap in two given strings
int findOverlappingPair(string str1, string str2, string &str)
{
    // max will store maximum overlap i.e maximum
    // length of the matching prefix and suffix
    int max = INT_MIN;
    int len1 = str1.length();
    int len2 = str2.length();

    // check suffix of str1 matches with prefix of str2
    for (int i = 1; i <= min(len1, len2); i++)
    {
        // compare last i characters in str1 with first i
        // characters in str2
        if (str1.compare(len1-i, i, str2, 0, i) == 0)
        {
            if (max < i)
            {
                //update max and str
                max = i;
                str = str1 + str2.substr(i);
            }
        }
    }

    // check prefix of str1 matches with suffix of str2
    for (int i = 1; i <= min(len1, len2); i++)
    {
        // compare first i characters in str1 with last i
        // characters in str2
        if (str1.compare(0, i, str2, len2-i, i) == 0)
        {
            if (max < i)
            {
                //update max and str
                max = i;
                str = str2 + str1.substr(i);
            }
        }
    }

    return max;
}

// Function to calculate smallest string that contains
// each string in the given set as substring.
string findShortestSuperstring(string arr[], int len)
{
    // run len-1 times to consider every pair
    while(len != 1)
    {
        int max = INT_MIN;  // to store  maximum overlap
        int l, r;   // to store array index of strings
        // involved in maximum overlap
        string resStr;  // to store resultant string after
        // maximum overlap

        for (int i = 0; i < len; i++)
        {
            for (int j = i + 1; j < len; j++)
            {
                string str;

                // res will store maximum length of the matching
                // prefix and suffix str is passed by reference and
                // will store the resultant string after maximum
                // overlap of arr[i] and arr[j], if any.
                int res = findOverlappingPair(arr[i], arr[j], str);

                // check for maximum overlap
                if (max < res)
                {
                    max = res;
                    resStr.assign(str);
                    l = i, r = j;
                }
            }
        }

        len--;  //ignore last element in next cycle

        // if no overlap, append arr[len] to arr[0]
        if (max == INT_MIN)
            arr[0] += arr[len];
        else
        {
            arr[l] = resStr;   // copy resultant string to index l
            arr[r] = arr[len];  // copy string at last index to index r
        }
    }
    return arr[0];
}

// Driver program
int main()
{
    string arr[] = {"catgc", "ctaagt", "gcta", "ttca", "atgcatc"};
    int len = sizeof(arr)/sizeof(arr[0]);

    cout << "The Shortest Superstring is "
         << findShortestSuperstring(arr, len);

    return 0;
}
// This code is contributed by Aditya Goel
 */package BasicAlgorithms.String;

import java.util.Stack;

/**
 * Created by hadoop on 14/10/17.
 */
public class LongestValidSubstring {
    public int longestValidParentheses(String s) {
        if(s == null || s.length() == 0){
            return 0;
        }
        int start = 0;
        int maxlength = 0;
        Stack<Integer> stack = new Stack<>();
        for(int i=0;i<s.length();i++){
            if(s.charAt(i) == '('){
                stack.push(i);
            }
            else {
                if(stack.isEmpty()){
                    start = i+1;
                }
                else {
                    int element = stack.pop();
                    if(stack.isEmpty()){
                        maxlength = Math.max(maxlength,i-start+1);
                    }
                    else {
                        maxlength = Math.max(maxlength,i-stack.peek());
                    }

                }

            }
        }
        return maxlength;
    }
    public static void main(String args[]){

    }
}package BasicAlgorithms.String;
import com.sun.jmx.remote.internal.ArrayQueue;

import java.util.*;

/**
 * Created by hadoop on 16/10/17.
 */
public class WordLadder {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        LinkedList<String> queue = new LinkedList<>();
        HashMap<String,Integer> distance = new HashMap<>();
        //Set<String> visited = new HashSet<>();
        //int infinity = Integer.MAX_VALUE;
        distance.put(beginWord,1);
        queue.add(beginWord);
        wordList.remove(beginWord);
        while (!queue.isEmpty()){
            String v = queue.poll();
            List<String> neighbours = getAdj(v,wordList);
            for(String w:neighbours){
                int parentdis = distance.get(v)+1;
                Integer child = distance.get(w);
                if(child!=null && child <=parentdis){
                    continue;
                }
                if(wordList.contains(w)){
                    distance.put(w,distance.get(v)+1);
                    queue.add(w);
                    wordList.remove(w);
                    if(w.equals(endWord)){
                        return distance.get(w);
                    }
                }
            }
        }
        return 0;
    }

    private List<String> getAdj(String polled, List<String> wordList) {
        List<String> list = new ArrayList<>();
        char []array = polled.toCharArray();
        for(int i=0;i<array.length;i++){
            for(char a='a';a<='z';a++){
                char save = array[i];
                array[i] = a;
                String changed = String.valueOf(array);
                if(wordList.contains(changed)){
                    list.add(changed);
                }
                array[i]= save;
            }
        }
        return list;
    }
    public static void main(String args[]){
            WordLadder wordLadder = new WordLadder();
            List<String> a = new ArrayList();
            wordLadder.getAdj("rajat",a);


        String begin= "sand";
        String end  = "acne";
        String words[]= {"slit","bunk","wars","ping","viva","wynn","wows","irks","gang","pool","mock","fort","heel","send","ship","cols","alec","foal","nabs","gaze","giza","mays","dogs","karo","cums","jedi","webb","lend","mire","jose","catt","grow","toss","magi","leis","bead","kara","hoof","than","ires","baas","vein","kari","riga","oars","gags","thug","yawn","wive","view","germ","flab","july","tuck","rory","bean","feed","rhee","jeez","gobs","lath","desk","yoko","cute","zeus","thus","dims","link","dirt","mara","disc","limy","lewd","maud","duly","elsa","hart","rays","rues","camp","lack","okra","tome","math","plug","monk","orly","friz","hogs","yoda","poop","tick","plod","cloy","pees","imps","lead","pope","mall","frey","been","plea","poll","male","teak","soho","glob","bell","mary","hail","scan","yips","like","mull","kory","odor","byte","kaye","word","honk","asks","slid","hopi","toke","gore","flew","tins","mown","oise","hall","vega","sing","fool","boat","bobs","lain","soft","hard","rots","sees","apex","chan","told","woos","unit","scow","gilt","beef","jars","tyre","imus","neon","soap","dabs","rein","ovid","hose","husk","loll","asia","cope","tail","hazy","clad","lash","sags","moll","eddy","fuel","lift","flog","land","sigh","saks","sail","hook","visa","tier","maws","roeg","gila","eyes","noah","hypo","tore","eggs","rove","chap","room","wait","lurk","race","host","dada","lola","gabs","sobs","joel","keck","axed","mead","gust","laid",
                "ends","oort","nose","peer"
                ,"kept","abet","iran","mick","dead","hags","tens","gown","sick","odis",
                "miro","bill","fawn","sumo","kilt","huge","ores","oran","flag","tost","seth"
                ,"sift","poet","reds","pips","cape","togo","wale","limn","toll","ploy",
                "inns","snag","hoes","jerk","flux","fido","zane","arab","gamy","raze",
                "lank","hurt","rail","hind","hoot","dogy","away","pest","hoed","pose","lose"
                ,"pole","alva","dino","kind","clan","dips","soup","veto","edna","damp","gush","amen","wits","pubs","fuzz","cash","pine","trod","gunk","nude","lost","rite","cory","walt","mica","cart","avow","wind","book","leon","life","bang","draw","leek","skis","dram","ripe","mine","urea","tiff","over","gale","weir","defy","norm","tull","whiz","gill","ward","crag","when","mill","firs","sans","flue","reid","ekes","jain","mutt","hems","laps","piss","pall","rowe","prey","cull","knew","size","wets","hurl","wont","suva","girt","prys","prow","warn","naps","gong","thru","livy","boar","sade","amok","vice","slat","emir","jade","karl","loyd","cerf","bess","loss","rums","lats","bode","subs","muss","maim","kits","thin","york","punt","gays","alpo","aids","drag","eras","mats","pyre","clot","step","oath","lout","wary","carp","hums","tang","pout","whip","fled","omar","such","kano","jake","stan","loop","fuss","mini","byrd","exit","fizz","lire","emil","prop","noes","awed","gift","soli","sale","gage","orin","slur","limp","saar","arks","mast","gnat","port","into","geed","pave","awls","cent","cunt","full","dint","hank","mate","coin","tars","scud","veer","coax","bops","uris","loom","shod","crib","lids","drys","fish","edit","dick","erna","else","hahs","alga","moho","wire","fora","tums","ruth","bets","duns","mold","mush","swop","ruby","bolt","nave","kite","ahem","brad","tern","nips","whew","bait","ooze","gino","yuck","drum","shoe","lobe","dusk","cult","paws","anew","dado","nook","half","lams","rich","cato","java","kemp","vain","fees","sham","auks","gish","fire","elam","salt","sour","loth","whit","yogi","shes","scam","yous","lucy","inez","geld","whig","thee","kelp","loaf","harm","tomb","ever","airs","page","laud","stun","paid","goop","cobs","judy","grab","doha","crew","item","fogs","tong","blip","vest","bran","wend","bawl","feel","jets","mixt","tell","dire","devi","milo","deng","yews","weak","mark","doug","fare","rigs","poke","hies","sian","suez","quip","kens","lass","zips","elva","brat","cosy","teri","hull","spun","russ","pupa","weed","pulp","main","grim","hone","cord","barf","olav","gaps","rote","wilt","lars","roll","balm","jana","give","eire","faun","suck","kegs","nita","weer","tush","spry","loge","nays","heir","dope","roar","peep","nags","ates","bane","seas","sign","fred","they","lien","kiev","fops","said","lawn","lind","miff","mass","trig","sins","furl","ruin","sent","cray","maya","clog","puns","silk","axis","grog","jots","dyer","mope","rand","vend","keen","chou","dose","rain","eats","sped","maui","evan","time","todd","skit","lief","sops","outs","moot","faze","biro","gook","fill","oval","skew","veil","born","slob","hyde","twin","eloy","beat","ergs","sure","kobe","eggo","hens","jive","flax","mons","dunk","yest","begs","dial","lodz","burp","pile","much","dock","rene","sago","racy","have","yalu","glow","move","peps","hods","kins","salk","hand","cons","dare","myra","sega","type","mari","pelt","hula","gulf","jugs","flay","fest","spat","toms","zeno","taps","deny","swag","afro","baud","jabs","smut","egos","lara","toes","song","fray","luis","brut","olen","mere","ruff","slum","glad","buds","silt","rued","gelt","hive","teem","ides","sink","ands","wisp","omen","lyre","yuks","curb","loam","darn","liar","pugs","pane","carl","sang","scar","zeds","claw","berg","hits","mile","lite","khan","erik","slug","loon","dena","ruse","talk","tusk","gaol","tads","beds","sock","howe","gave","snob","ahab","part","meir","jell","stir","tels","spit","hash","omit","jinx","lyra","puck","laue","beep","eros","owed","cede","brew","slue","mitt","jest","lynx","wads","gena","dank","volt","gray","pony","veld","bask","fens","argo","work","taxi","afar","boon","lube","pass","lazy","mist","blot","mach","poky","rams","sits","rend","dome","pray","duck","hers","lure","keep","gory","chat","runt","jams","lays","posy","bats","hoff","rock","keri","raul","yves","lama","ramp","vote","jody","pock","gist","sass","iago","coos","rank","lowe","vows","koch","taco","jinn","juno","rape","band","aces","goal","huck","lila","tuft","swan","blab","leda","gems","hide","tack","porn","scum","frat","plum","duds","shad","arms","pare","chin","gain","knee","foot","line","dove","vera","jays","fund","reno","skid","boys","corn","gwyn","sash","weld","ruiz","dior","jess","leaf","pars","cote","zing","scat","nice","dart","only","owls","hike","trey","whys","ding","klan","ross","barb","ants","lean","dopy","hock","tour","grip","aldo","whim","prom","rear","dins","duff","dell","loch","lava","sung","yank","thar","curl","venn","blow","pomp","heat","trap","dali","nets","seen","gash","twig","dads","emmy","rhea","navy","haws","mite","bows","alas","ives","play","soon","doll","chum","ajar","foam","call","puke","kris","wily","came","ales","reef","raid","diet","prod","prut","loot","soar","coed","celt","seam","dray","lump","jags","nods","sole","kink","peso","howl","cost","tsar","uric","sore","woes","sewn","sake","cask","caps","burl","tame","bulk","neva","from","meet","webs","spar","fuck","buoy","wept","west","dual","pica","sold","seed","gads","riff","neck","deed","rudy","drop","vale","flit","romp","peak","jape","jews","fain","dens","hugo","elba","mink","town","clam","feud","fern","dung","newt","mime","deem","inti","gigs","sosa","lope","lard","cara","smug","lego","flex","doth","paar","moon","wren","tale","kant","eels","muck","toga","zens","lops","duet","coil","gall","teal","glib","muir","ails","boer","them","rake","conn","neat","frog","trip","coma","must","mono","lira","craw","sled","wear","toby","reel","hips","nate","pump","mont","died","moss","lair","jibe","oils","pied","hobs","cads","haze","muse","cogs","figs","cues","roes","whet","boru","cozy","amos","tans","news","hake","cots","boas","tutu","wavy","pipe","typo","albs","boom","dyke","wail","woke","ware","rita","fail","slab","owes","jane","rack","hell","lags","mend","mask","hume","wane","acne","team","holy","runs","exes","dole","trim","zola","trek","puma","wacs","veep","yaps","sums","lush","tubs","most","witt","bong","rule","hear","awry","sots","nils","bash","gasp","inch","pens","fies","juts","pate","vine","zulu","this","bare","veal","josh","reek","ours","cowl","club","farm","teat","coat","dish","fore","weft","exam","vlad","floe","beak","lane","ella","warp","goth","ming","pits","rent","tito","wish","amps","says","hawk","ways","punk","nark","cagy","east","paul","bose","solo","teed","text","hews","snip","lips","emit","orgy","icon","tuna","soul","kurd","clod","calk","aunt","bake","copy","acid","duse","kiln","spec","fans","bani","irma","pads","batu","logo","pack","oder","atop","funk","gide","bede","bibs","taut","guns","dana","puff","lyme","flat","lake","june","sets","gull","hops","earn","clip","fell","kama","seal","diaz","cite","chew","cuba","bury","yard","bank","byes","apia","cree","nosh","judo","walk","tape","taro","boot","cods","lade","cong","deft","slim","jeri","rile","park","aeon","fact","slow","goff","cane","earp","tart","does","acts","hope","cant","buts","shin","dude","ergo","mode","gene","lept","chen","beta","eden","pang","saab","fang","whir","cove","perk","fads","rugs","herb","putt","nous","vane","corm","stay","bids","vela","roof","isms","sics","gone","swum","wiry","cram","rink","pert","heap","sikh","dais","cell","peel","nuke","buss","rasp","none","slut","bent","dams","serb","dork","bays","kale","cora","wake","welt","rind","trot","sloe","pity","rout","eves","fats","furs","pogo","beth","hued","edam","iamb","glee","lute","keel","airy","easy","tire","rube","bogy","sine","chop","rood","elbe","mike","garb","jill","gaul","chit","dons","bars","ride","beck","toad","make","head","suds","pike","snot","swat","peed","same","gaza","lent","gait","gael","elks","hang","nerf","rosy","shut","glop","pain","dion","deaf","hero","doer","wost","wage","wash","pats","narc","ions","dice","quay","vied","eons","case","pour","urns","reva","rags","aden","bone","rang","aura","iraq","toot","rome","hals","megs","pond","john","yeps","pawl","warm","bird","tint","jowl","gibe","come","hold","pail","wipe","bike","rips","eery","kent","hims","inks","fink","mott","ices","macy","serf","keys","tarp","cops","sods","feet","tear","benz","buys","colo","boil","sews","enos","watt","pull","brag","cork","save","mint","feat","jamb","rubs","roxy","toys","nosy","yowl","tamp","lobs","foul","doom","sown","pigs","hemp","fame","boor","cube","tops","loco","lads","eyre","alta","aged","flop","pram","lesa","sawn","plow","aral","load","lied","pled","boob","bert","rows","zits","rick","hint","dido","fist","marc","wuss","node","smog","nora","shim","glut","bale","perl","what","tort","meek","brie","bind","cake","psst","dour","jove","tree","chip","stud","thou","mobs","sows","opts","diva","perm","wise","cuds","sols","alan","mild","pure","gail","wins","offs","nile","yelp","minn","tors","tran","homy","sadr","erse","nero","scab","finn","mich","turd","then","poem","noun","oxus","brow","door","saws","eben","wart","wand","rosa","left","lina","cabs","rapt","olin","suet","kalb","mans","dawn","riel","temp","chug","peal","drew","null","hath","many","took","fond","gate","sate","leak","zany","vans","mart","hess","home","long","dirk","bile","lace","moog","axes","zone","fork","duct","rico","rife","deep","tiny","hugh","bilk","waft","swig","pans","with","kern","busy","film","lulu","king","lord","veda","tray","legs","soot","ells","wasp","hunt","earl","ouch","diem","yell","pegs","blvd","polk","soda","zorn","liza","slop","week","kill","rusk","eric","sump","haul","rims","crop","blob","face","bins","read","care","pele","ritz","beau","golf","drip","dike","stab","jibs","hove","junk","hoax","tats","fief","quad","peat","ream","hats","root","flak","grit","clap","pugh","bosh","lock","mute","crow","iced","lisa","bela","fems","oxes","vies","gybe","huff","bull","cuss","sunk","pups","fobs","turf","sect","atom","debt","sane","writ","anon","mayo","aria","seer","thor","brim","gawk","jack","jazz","menu","yolk","surf","libs","lets","bans","toil","open","aced","poor","mess","wham","fran","gina","dote","love","mood","pale","reps","ines","shot","alar","twit","site","dill","yoga","sear","vamp","abel","lieu","cuff","orbs","rose","tank","gape","guam","adar","vole","your","dean","dear","hebe","crab","hump","mole","vase","rode","dash","sera","balk","lela","inca","gaea","bush","loud","pies","aide","blew","mien","side","kerr","ring","tess","prep","rant","lugs","hobo","joke","odds","yule","aida","true","pone","lode","nona","weep","coda","elmo","skim","wink","bras","pier","bung","pets","tabs","ryan","jock","body","sofa","joey","zion","mace","kick","vile","leno","bali","fart","that","redo","ills","jogs","pent","drub","slaw","tide","lena","seep","gyps","wave","amid","fear","ties","flan","wimp","kali","shun","crap","sage","rune","logs","cain","digs","abut","obit","paps","rids","fair","hack","huns","road","caws","curt","jute","fisk","fowl","duty","holt","miss","rude","vito","baal","ural","mann","mind","belt","clem","last","musk","roam","abed","days","bore","fuze","fall","pict","dump","dies","fiat","vent","pork","eyed","docs","rive","spas","rope","ariz","tout","game","jump","blur","anti","lisp","turn","sand","food","moos","hoop","saul","arch","fury","rise","diss","hubs","burs","grid","ilks","suns","flea","soil","lung","want","nola","fins","thud","kidd","juan","heps","nape","rash","burt","bump","tots","brit","mums","bole","shah","tees","skip","limb","umps","ache","arcs","raft","halo","luce","bahs","leta","conk","duos","siva","went","peek","sulk","reap","free","dubs","lang","toto","hasp","ball","rats","nair","myst","wang","snug","nash","laos","ante","opal","tina","pore","bite","haas","myth","yugo","foci","dent","bade","pear","mods","auto","shop","etch","lyly","curs","aron","slew","tyro","sack","wade","clio","gyro","butt","icky","char","itch","halt","gals","yang","tend","pact","bees","suit","puny","hows","nina","brno","oops","lick","sons","kilo","bust","nome","mona","dull","join","hour","papa","stag","bern","wove","lull","slip","laze","roil","alto","bath","buck","alma","anus","evil","dumb","oreo","rare","near","cure","isis","hill","kyle","pace","comb","nits","flip","clop","mort","thea","wall","kiel","judd","coop","dave","very","amie","blah","flub","talc","bold","fogy","idea","prof","horn","shoo","aped","pins","helm","wees","beer","womb","clue","alba","aloe","fine","bard","limo","shaw","pint","swim","dust","indy","hale","cats","troy","wens","luke","vern","deli","both","brig","daub","sara","sued","bier","noel","olga","dupe","look","pisa","knox","murk","dame","matt","gold","jame","toge","luck","peck","tass","calf","pill","wore","wadi","thur","parr","maul","tzar","ones","lees","dark","fake","bast","zoom","here","moro","wine","bums","cows","jean","palm","fume","plop","help","tuba","leap","cans","back","avid","lice","lust","polo","dory","stew","kate","rama","coke","bled","mugs","ajax","arts","drug","pena","cody","hole","sean","deck","guts","kong","bate","pitt","como","lyle","siam","rook","baby","jigs","bret","bark","lori","reba","sups","made","buzz","gnaw","alps","clay","post","viol","dina","card","lana","doff","yups","tons","live","kids","pair","yawl","databaseName","oven","sirs","gyms","prig","down","leos","noon","nibs","cook","safe","cobb","raja","awes","sari","nerd","fold","lots","pete","deal","bias","zeal","girl","rage","cool","gout","whey","soak","thaw","bear","wing","nagy","well","oink","sven","kurt","etna","held","wood","high","feta","twee","ford","cave","knot","tory","ibis","yaks","vets","foxy","sank","cone","pius","tall","seem","wool","flap","gird","lore","coot","mewl","sere","real","puts","sell","nuts","foil","lilt","saga","heft","dyed","goat","spew","daze","frye","adds","glen","tojo","pixy","gobi","stop","tile","hiss","shed","hahn","baku","ahas","sill","swap","also","carr","manx","lime","debs","moat","eked","bola","pods","coon","lacy","tube","minx","buff","pres","clew","gaff","flee","burn","whom","cola","fret","purl","wick","wigs","donn","guys","toni","oxen","wite","vial","spam","huts","vats","lima","core","eula","thad","peon","erie","oats","boyd","cued","olaf","tams","secs","urey","wile","penn","bred","rill","vary","sues","mail","feds","aves","code","beam","reed","neil","hark","pols","gris","gods","mesa","test","coup","heed","dora","hied","tune","doze","pews","oaks","bloc","tips","maid","goof","four","woof","silo","bray","zest","kiss","yong","file","hilt","iris","tuns","lily","ears","pant","jury","taft","data","gild","pick","kook","colt","bohr","anal","asps","babe","bach","mash","biko","bowl","huey","jilt","goes","guff","bend","nike","tami","gosh","tike","gees","urge","path","bony","jude","lynn","lois","teas","dunn","elul","bonn","moms","bugs","slay","yeah","loan","hulk","lows","damn","nell","jung","avis","mane","waco","loin","knob","tyke","anna","hire","luau","tidy","nuns","pots","quid","exec","hans","hera","hush","shag","scot","moan","wald","ursa","lorn","hunk","loft","yore","alum","mows","slog","emma","spud","rice","worn","erma","need","bags","lark","kirk","pooh","dyes","area","dime","luvs","foch","refs","cast","alit","tugs","even","role","toed","caph","nigh","sony","bide","robs","folk","daft","past","blue","flaw","sana","fits","barr","riot","dots","lamp","cock","fibs","harp","tent","hate","mali","togs","gear","tues","bass","pros","numb","emus","hare","fate","wife","mean","pink","dune","ares","dine","oily","tony","czar","spay","push","glum","till","moth","glue","dive","scad","pops","woks","andy","leah","cusp","hair","alex","vibe","bulb","boll","firm","joys","tara","cole","levy","owen","chow","rump","jail","lapp","beet","slap","kith","more","maps","bond","hick","opus","rust","wist","shat","phil","snow","lott","lora","cary","mote","rift","oust","klee","goad","pith","heep","lupe","ivan","mimi","bald","fuse","cuts","lens","leer","eyry","know","razz","tare","pals","geek","greg","teen","clef","wags","weal","each","haft","nova","waif","rate","katy","yale","dale","leas","axum","quiz","pawn","fend","capt","laws","city","chad","coal","nail","zaps","sort","loci","less","spur","note","foes","fags","gulp","snap","bogs","wrap","dane","melt","ease","felt","shea","calm","star","swam","aery","year","plan","odin","curd","mira","mops","shit","davy","apes","inky","hues","lome","bits","vila","show","best","mice","gins","next","roan","ymir","mars","oman","wild","heal","plus","erin","rave","robe","fast","hutu","aver","jodi","alms","yams","zero","revs","wean","chic","self","jeep","jobs","waxy","duel","seek","spot","raps","pimp","adan","slam","tool","morn","futz","ewes","errs","knit","rung","kans","muff","huhs","tows","lest","meal","azov","gnus","agar","sips","sway","otis","tone","tate","epic","trio","tics","fade","lear","owns","robt","weds","five","lyon","terr","arno","mama","grey","disk","sept","sire","bart","saps","whoa","turk","stow","pyle","joni","zinc","negs","task","leif","ribs","malt","nine","bunt","grin","dona","nope","hams","some","molt","smit","sacs","joan","slav","lady","base","heck","list","take","herd","will","nubs","burg","hugs","peru","coif","zoos","nick","idol","levi","grub","roth","adam","elma","tags","tote","yaws","cali","mete","lula","cubs","prim","luna","jolt","span","pita","dodo","puss","deer","term","dolt","goon","gary","yarn","aims","just","rena","tine","cyst","meld","loki","wong","were","hung","maze","arid","cars","wolf","marx","faye","eave","raga","flow","neal","lone","anne","cage","tied","tilt","soto","opel","date","buns","dorm","kane","akin","ewer","drab","thai","jeer","grad","berm","rods","saki","grus","vast","late","lint","mule","risk","labs","snit","gala","find","spin","ired","slot","oafs","lies","mews","wino","milk","bout","onus","tram","jaws","peas","cleo","seat","gums","cold","vang","dewy","hood","rush","mack","yuan","odes","boos","jami","mare","plot","swab","borg","hays","form","mesh","mani","fife","good","gram","lion","myna","moor","skin","posh","burr","rime","done","ruts","pays","stem","ting","arty","slag","iron","ayes","stub","oral","gets","chid","yens","snub","ages","wide","bail","verb","lamb","bomb","army","yoke","gels","tits","bork","mils","nary","barn","hype","odom","avon","hewn","rios","cams","tact","boss","oleo","duke","eris","gwen","elms","deon","sims","quit","nest","font","dues","yeas","zeta","bevy","gent","torn","cups","worm","baum","axon","purr","vise","grew","govs","meat","chef","rest","lame"};
        List<String> list = new ArrayList<>();
        for(String word:words){
            list.add(word);
        }
        long t1 = System.currentTimeMillis();
        System.out.println(wordLadder.ladderLength(begin,end,list));
        System.out.println();
        long t2 = System.currentTimeMillis();
        System.out.println(t2-t1);
        System.out.println(new _127().ladderLength(begin,end,list));
        long t3 = System.currentTimeMillis();
        System.out.println(t3-t2);
        Solutionagain solution = new Solutionagain();
        solution.ladderLength(begin,end,list);
    }
}


/**
 * 127. Word Ladder
 *
 *  Given two words (beginWord and endWord),
 *  and a dictionary's word list,
 *  find the length of shortest transformation sequence from beginWord to endWord, such that:
 *  Only one letter can be changed at a time.
 *  Each transformed word must exist in the word list. Note that beginWord is not a transformed word.
 For example,
 Given:
 beginWord = "hit"
 endWord = "cog"
 wordList = ["hot","dot","dog","lot","log","cog"]
 As one shortest transformation is "hit" -> "hot" -> "dot" -> "dog" -> "cog", return its length 5.
 Note:
 Return 0 if there is no such transformation sequence.
 All words have the same length.
 All words contain only lowercase alphabetic characters.
 You may assume no duplicates in the word list.
 You may assume beginWord and endWord are non-empty and are not the same.
 */

class _127 {

    /**this one https://discuss.leetcode.com/topic/29303/two-end-bfs-in-java-31ms fails by test case _127Test.test1().
     * All transformed words, including endWord must be in wordList.
     *
     * And we can share a visited set from both ends since we cannot remove word from dict.*/
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        Set<String> beginSet = new HashSet<>();
        Set<String> endSet = new HashSet<>();
        Set<String> visited = new HashSet<>();
        Set<String> dict = new HashSet<>(wordList);
        int len = 1;

        beginSet.add(beginWord);

        if (dict.contains(endWord)) {
            endSet.add(endWord);
        }

        while (!beginSet.isEmpty() && !endSet.isEmpty()) {
            if (beginSet.size() > endSet.size()) {
                Set<String> temp = beginSet;
                beginSet = endSet;
                endSet = temp;
            }

            Set<String> temp = new HashSet<>();
            for (String word : beginSet) {
                char[] chars = word.toCharArray();
                for (int i = 0; i < chars.length; i++) {
                    for (char c = 'a'; c <= 'z'; c++) {
                        char old = chars[i];
                        chars[i] = c;
                        String newWord = new String(chars);
                        if (endSet.contains(newWord)) {
                            return len + 1;
                        }

                        if (!visited.contains(newWord) && dict.contains(newWord)) {
                            visited.add(newWord);
                            temp.add(newWord);
                        }
                        chars[i] = old;
                    }
                }
            }

            beginSet = temp;
            len++;
        }
        return 0;
    }
}
class Solutionagain {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        Queue<String> queue = new LinkedList<>();
        queue.offer(beginWord);
        wordList.add(endWord);
        wordList.remove(beginWord);
        int level = 1;
        while(!queue.isEmpty()){
            int size = queue.size();
            for(int i=0;i<size;i++){
                String str = queue.poll();
                if(str.equals(endWord))return level;
                for(String neighbor : neighbors(str,wordList)){
                    queue.offer(neighbor);
                }
            }
            level++;
        }
        return 0;
    }

    public List<String> neighbors(String s, List<String> wordList){
        List<String> res = new LinkedList<>();
        for(int i=0;i<s.length();i++){
            char [] chars = s.toCharArray();
            for(char ch = 'a'; ch <= 'z'; ch++){
                chars[i] = ch;
                String word = new String(chars);
                if(wordList.remove(word)){
                    res.add(word);
                }
            }
        }
        return res;
    }
}package BasicAlgorithms.String;

/**
 * Created by hadoop on 15/10/17.
 */
public class DecodeWays {
    public int numDecodings(String s) {
        if(s == null || s.length() == 0){
            return 0;
        }
        int dp[] = new  int[s.length()+1];
        dp[0] = 1;
        if(isvalid(s.substring(0,1))){
            dp[1] = 1;
        }
        else {
            dp[0] = 0;
        }
        for(int i=2;i<=s.length();i++){
            dp[i]=0;
            if(isvalid(s.substring(i-1,i))) {
                dp[i] += dp[i - 1];
            }
            if(isvalid(s.substring(i-2,i))){
                dp[i] += dp[i-2];
            }
        }
        return dp[s.length()];
    }

    private boolean isvalid(String s) {

        if(s.charAt(0)=='0'){
            return false;
        }
        int element = Integer.parseInt(s);
        if(1<=element&& element<=26){
            return true;
        }
        return false;
    }
}

class recursive{
    public int numdecodings(String s){
        if(s.length() == 0){
            return 0;
        }
        return dfs(s);
    }

    private int dfs(String s) {
        if(s.length() == 0){
            return 1;
        }
        int total =0;
        for(int i=0;i<=1 && i<s.length();i++){
            if(isvalid(s.substring(0,i+1))) {
                total += numdecodings(s.substring(i+1));
            }
        }
        return total;
    }
    private boolean isvalid(String s) {

        if(s.charAt(0)=='0'){
            return false;
        }
        int element = Integer.parseInt(s);
        if(1<=element&& element<=26){
            return true;
        }
        return false;
    }
}package BasicAlgorithms.String;

/**
 * Created by hadoop on 14/10/17.
 */
public class ShortestPalindrome {
    public String shortestPalindrome(String s) {
        if(s == null || s.length() == 0){
            return s;
        }
        int max = 0;
        for(int i=0;i<s.length()-1;i++){
            max = Math.max(max,expand(i,i,s));
            max = Math.max(max,expand(i,i+1,s));
        }
        String suffix =  s.substring(max) ;
        StringBuilder sb = new StringBuilder(suffix);
        String ans = sb.reverse().toString() + s.substring(0,max) + suffix;
        return ans;
    }

    private int expand(int i, int j, String s) {
        int localmax = j-i+1;
        while (i>=0 && j<s.length() && s.charAt(i) == s.charAt(j)){
            localmax = j-i+1;
            i--;
            j++;
        }
        if(i == -1){
            return localmax;
        }
        return -1;
    }

    public static void main(String[] args) {
        ShortestPalindrome shortestPalindrome = new ShortestPalindrome();
        System.out.println(shortestPalindrome.shortestPalindrome("aacecaaa"));
    }
}package BasicAlgorithms.String;

import java.util.HashMap;

/**
 * Created by hadoop on 14/10/17.
 */
public class LongestSubstringTwoDistinct {
     int longestsub(String s){
     int start=0;
     int end=0;
     int length = 0;
     if(s == null || s.length() ==0){
         return length;
     }
     HashMap<Character,Integer>hashMap = new HashMap<>();
     int counter=0;
     while (end<s.length()){
         if(!hashMap.containsKey(s.charAt(end))) {
             hashMap.put(s.charAt(end),1);
             counter++;
         }
         else {
             hashMap.put(s.charAt(end),hashMap.get(s.charAt(end))+1);
         }
         while (counter>2){
             System.out.println("char "+s.charAt(start));
             int startFreq = hashMap.get(s.charAt(start));
             startFreq = startFreq-1;
             System.out.println("startfre "+startFreq);
             if(startFreq == 0){
                 counter--;
                 hashMap.remove(s.charAt(start));
             }
             else {
                 hashMap.put(s.charAt(start),startFreq);
             }
             start++;
         }
         System.out.println("start"+start);
         System.out.println("end"+end);
         length = Math.max(length,end-start+1);
         end++;
     }
     return length;

    }

    public static void main(String[] args) {
        LongestSubstringTwoDistinct longestSubstringTwoDistinct = new LongestSubstringTwoDistinct();
        System.out.println(longestSubstringTwoDistinct.longestsub("cdaba"));
    }
}
package BasicAlgorithms.String;

import java.util.HashMap;

/**
 * Created by hadoop on 15/10/17.
 */
public class LongestSubstringKdistinctChar {
    public int lengthOfLongestSubstringKDistinct(String s, int k) {
        HashMap<Character,Integer> hashMap = new HashMap<>();
        int counter=0;
        int start=0;
        int end =0;
        int dis =0;
        while (end<s.length()){
            if(!hashMap.containsKey(s.charAt(end))){
                counter++;
                hashMap.put(s.charAt(end),1);
            }
            else {
                hashMap.put(s.charAt(end),hashMap.get(s.charAt(end))+1);
            }
            while (counter>k){
                int freq = hashMap.get(s.charAt(start));
                freq= freq-1;
                if(freq == 0){
                    counter--;
                    hashMap.remove(s.charAt(start));
                }
                else {
                    hashMap.put(s.charAt(start), freq);
                }
                start++;
            }
            dis = Math.max(dis,end-start+1);
            end++;
        }
        return dis;
    }
}
package BasicAlgorithms.String;

import java.util.HashMap;

/**
 * Created by hadoop on 23/10/17.
 */
public class WordPattern {
    public boolean wordPattern(String pattern, String str) {
        String word[] = str.split(" ");
        HashMap<Character,String> patternMap = new HashMap<>();
        if(word.length != pattern.length()){
            return false;
        }
        for(int i=0;i<pattern.length();i++){
            Character pat = pattern.charAt(i);
            if(!patternMap.containsKey(pat)){
                if(patternMap.containsValue(word[i])){
                    return false;
                }
            }
            else {
                String wordInMap = patternMap.get(pat);
                if(!wordInMap.equals(word[i])){
                    return false;
                }
            }
            patternMap.put(pat,word[i]);
        }
        return true;
    }
}
package BasicAlgorithms.String;

import java.util.ArrayList;
import java.util.List;

public class Codec {

    // Encodes a list of strings to a single string.
    public String encode(List<String> strs) {
        StringBuilder sb = new StringBuilder();
        for(String str:strs) {
            sb.append(str).append("/");
        }
        return sb.toString();
    }

    // Decodes a single string to a list of strings.
    public List<String> decode(String s) {
        List<String> res = new ArrayList<>();
        int start=0;
        int end = 0;
        while (end<s.length()){
            while (end<s.length() && s.charAt(end)!='/'){
                end++;
            }
            res.add(s.substring(start,end));
            start = end+1;
            end++;
        }
        return res;
    }
}package BasicAlgorithms.String;

/**
 * Created by hadoop on 13/10/17.
 */
public class MultiplyStrings {
    public String multiply(String num1, String num2) {
        int []product = new int[num1.length()+num2.length()];
        int i=-1;
        int j=-1;
        for(i=num1.length()-1;i>=0;i--){
            for(j=num2.length()-1;j>=0;j--){
                int a = num1.charAt(i) - '0';
                int b = num2.charAt(j) - '0';
                product[i + j + 1] += a * b;
            }
        }
        int carry =0;
        for(int k=num1.length()+num2.length()-1;k>=0;k--){
            product[k] = product[k]+carry;
            carry = product[k]/10;
            product[k] = product[k]%10;
        }
        String ans = "";
        for( i=0;i<num1.length()+num2.length();i++) {
            ans = ans+product[i];
        }
        i=0;
        while (i<product.length && ans.charAt(i)=='0'){
            i++;
        }
        ans = ans.substring(i);
        return ans;
    }

    public static void main(String[] args) {
            MultiplyStrings multiplyStrings = new MultiplyStrings();
        System.out.println(multiplyStrings.multiply("99","20"));
    }
}package BasicAlgorithms.String;

import java.util.HashMap;

/**
 * Created by hadoop on 14/10/17.
 */
public class IsAnagram {
    public boolean isAnagram(String s, String t) {
        HashMap<Character,Integer> hashMap = new HashMap<>();
        int counter=0;
        for(int i=0;i<s.length();i++){
            if(!hashMap.containsKey(s.charAt(i))){
                hashMap.put(s.charAt(i),1);
                counter++;
            }
            else {
                hashMap.put(s.charAt(i),hashMap.get(s.charAt(i))+1);
                counter++;
            }
        }
        for(int i=0;i<t.length();i++){
            if(hashMap.containsKey(t.charAt(i))){
                System.out.println(hashMap);
                int freq = hashMap.get(t.charAt(i));
                freq = freq-1;
                System.out.println("t.charat"+t.charAt(i));
                System.out.println("frq"+freq);
                if(freq == 0){
                    hashMap.remove(t.charAt(i));
                }
                else {
                    hashMap.put(t.charAt(i),freq);
                }
                counter--;
            }
            else {
                return false;
            }
        }
        System.out.println(counter);
        return counter ==0;
    }

    public static void main(String[] args) {
        IsAnagram isAnagram = new IsAnagram();
        isAnagram.isAnagram("aacc","ccac");
    }
}package BasicAlgorithms.String;

import java.util.HashMap;
import java.util.List;
import java.util.*;

class Concatenation{
static class TrieNode {
           int value = 0;
           Map<Character, TrieNode> children = new HashMap<Character, TrieNode>();
       }
       TrieNode trie;

    // build a trie tree
    public List<Integer> findSubstring(String S, String[] L) {
        trie = buildTrie(L);
        int length = getTotalLength(L);
        List<Integer> result = new LinkedList<Integer>();
        for (int i = 0; i < S.length() - length + 1; i++) {
            if (isSubString(S, i, i + length))
                result.add(i);
        }
        return result;
    }
    
    private int getTotalLength(String[] L) {
        int sum = 0;
        for (String l : L)
            sum += l.length();
        return sum;
    }
    
    private TrieNode buildTrie(String[] L) {
        TrieNode root = new TrieNode();
        for (String l : L)
            addWord(root, l);
        return root;
    }
    
    private void addWord(TrieNode root, String s) {
        TrieNode node = root;
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            TrieNode next = node.children.get(c);
            if (next == null) {
                next = new TrieNode();
                node.children.put(c, next);
            }
            node = next;
        }
        node.value++;
    }
    
    private boolean isSubString(String S, int start, int end) {
        if (start == end)
    		return true;
        // search in the trie tree
        TrieNode node = trie;
        for (int i = start; i < end; i++) {
            char c = S.charAt(i);
            if (node.children.get(c) == null)
                return false;
            node = node.children.get(c);
            if (node.value > 0) {  // leaf & can be used
                node.value--; // mark as used
                if (isSubString(S, i + 1, end)) {
                    node.value++; // mark as unused
                    return true;
                }
                node.value++; // mark as unused
            }
        }
        return false;
    }
}package BasicAlgorithms.String;

/**
 * Created by hadoop on 15/10/17.
 */
public class StrStr {
    public int strStr(String haystack, String needle) {
        if(needle == null || needle.length() ==0){
            return -1;
        }
        if(haystack == null || needle.length() ==0){
            return -1;
        }
        for(int i=0;i<haystack.length()-needle.length()+1;i++){
            int j=0;
            for(int k=i;j<needle.length();j++){
                if(k<haystack.length() && haystack.charAt(k) == needle.charAt(j)){
                    k++;
                }
                else {
                    break;
                }
            }
            if(j ==needle.length()){
                return i;
            }
        }
        return -1;
    }

    public static void main(String[] args) {
        StrStr strStr = new StrStr();
        System.out.println(strStr.strStr("rajat","aj"));
    }
}package BasicAlgorithms.String;

/**
 * Created by hadoop on 14/10/17.
 */
public class StringInterleave {
    public boolean isInterleave(String s1, String s2, String s3) {
        if(s1.length()+s2.length()!= s3.length()){
            return false;
        }
        boolean[][]dp = new boolean[s1.length()+1][s2.length()+1];
        dp[0][0] = true;
        for(int i=0;i<=s1.length();i++){
            for(int j=0;j<=s2.length();j++){
                if( i==0 &&j!=0){
                    dp[0][j] =dp[0][j-1] && s2.charAt(j-1) == s3.charAt(j-1);
                    continue;
                }
                if( j==0 && i!=0){
                    dp[i][0] = dp[i-1][0] && s1.charAt(i-1) == s3.charAt(i-1);
                    continue;
                }
                if(i==0 && j==0){
                    dp[0][0] = true;
                    continue;
                }
                dp[i][j] =(dp[i-1][j] && s1.charAt(i-1) == s3.charAt(i+j-1)) ||
                        (dp[i][j-1] && s2.charAt(j-1) == s3.charAt(i+j-1));
            }
        }
        return dp[s1.length()][s2.length()];
    }
    public static void main(String args[]){
        StringInterleave stringInterleave = new StringInterleave();
        System.out.println(stringInterleave.isInterleave("raa","jt","rajat"));
    }
}package BasicAlgorithms.String;

import java.util.ArrayList;
import java.util.List;

/**
 * Created by hadoop on 13/10/17.
 */
public class FlipGame {
    public static List<String> generatePossibleNextMoves(String s){
        List<String> res = new ArrayList<>();
        if(s == null || s.length() == 0){
            return res;
        }
        for(int i=0;i<s.length()-1;i++){
            if(s.charAt(i)== '+' && s.charAt(i+1) == '+'){
                String result = s.substring(0,i)+"--"+s.substring(i+2);
                res.add(result);
            }
        }
        return res;
    }
}

package BasicAlgorithms.String;

import java.util.LinkedList;
import java.util.List;
import java.util.*;

/**
 * Created by hadoop on 15/10/17.
 */
public class SubStringConcatenation {
    public List<Integer> findSubstring(String s, String[] words) {
        List<Integer> list = new LinkedList<>();
        if (s == null || s.length() == 0 || words == null || words.length == 0) {
            return list;
        }
        HashMap<String, Integer> map = new HashMap<>();
        for (String word : words) {
            map.put(word, !map.containsKey(word) ? 1 : map.get(word) + 1);
        }
        System.out.println(map);
        int start=0;
        int end=0;
        int counter =0;
        int wordlength = words[0].length();
        int totallength = wordlength*words.length;
        for(int i=0;i<s.length()-totallength+1;i++){
            String substring = s.substring(i,i+totallength);
            System.out.println("sub   "+substring);
            if(search(substring,map,wordlength)){
                list.add(i);
            }
        }
        return list;

    }

    private boolean search(String substring, HashMap<String, Integer> map, int wordlength) {
        HashMap<String,Integer> clone = new HashMap<>();
        for(int i=0;i<substring.length()-wordlength+1;i=i+wordlength){
            String sub = substring.substring(i,i+wordlength);
            System.out.println("sub sub "+sub);
            Integer freq = map.get(sub);
            if(freq == null){
                return false;
            }
            freq = freq -1;
            if(freq == 0){
                map.remove(sub);
            }
            else {
                map.put(sub,freq);
            }
        }
        return true;
    }
    public static void main(String args[]){
        SubStringConcatenation subStringConcatenation = new SubStringConcatenation();
        String s= "barfoothefoobarman";
        String words[]={"foo", "bar"};
        System.out.print(subStringConcatenation.findSubstring(s,words));
    }
}package BasicAlgorithms.String;

/**
 * Created by hadoop on 15/10/17.
 */
public class PayPal {
    public String convert(String s, int numRows) {
        StringBuilder [] stringBuilders = new StringBuilder[numRows];
        for(int i=0;i<numRows;i++){
            stringBuilders[i] = new StringBuilder();
        }
        int i=0;
        while (i<s.length()){
            for(int index = 0;index<numRows-1 && i<s.length();index++){
                stringBuilders[index].append(s.charAt(i++));
            }
            for(int index = numRows-1;index>=1 && i<s.length();index--){
                stringBuilders[index].append(s.charAt(i++));
            }
        }
        String ans="";
        for(int k=0;k<numRows;k++){
            ans = ans+ stringBuilders[k].toString();
        }
        return ans;
    }
}package BasicAlgorithms.String;

import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;

/**
 * Created by hadoop on 14/10/17.
 */
public class ScrambleString {
    public boolean isScramble(String s1, String s2) {
        if (s1.length() != s2.length()) {
            return false;
        }
        if(s1.equals(s2)){
            return true;
        }
        HashMap<Character,Integer> hashMap = new HashMap<>();
        for(char a:s1.toCharArray()){
            if(!hashMap.containsKey(a)){
                hashMap.put(a,1);
            }
            else {
                hashMap.put(a,hashMap.get(a)+1);
            }
        }

        for(char b:s2.toCharArray()){
            if(!hashMap.containsKey(b)){
                return false;
            }
            int freq = hashMap.get(b);
            freq = freq-1;
            if(freq ==0){
                hashMap.remove(b);
            }
            else {
                hashMap.put(b,freq);
            }
        }
        System.out.println(hashMap);
        if(hashMap.keySet().size()!=0){
            System.out.println(hashMap.keySet().size());
            return false;
        }
        String reverse = new StringBuilder(s2).reverse().toString();
        for(int i=1;i<s1.length();i++){
            if(isScramble(s1.substring(0,i),s2.substring(0,i)) && isScramble(s1.substring(i),s2.substring(i))){
                return true;
            }
            if(isScramble(s1.substring(0,i),reverse.substring(0,i)) && isScramble(s1.substring(i),reverse.substring(i))){
                return true;
            }
        }
        return false;
    }

    public static void main(String[] args) {
        ScrambleString scrambleString = new ScrambleString();
        System.out.println(scrambleString.isScramble("dbdac","abcdd"));
    }
}package BasicAlgorithms.String;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

/**
 * Created by hadoop on 15/10/17.
 */
public class SlidingWindow {
    public List<Integer> findSubstring(String s, String[] words) {
        List<Integer> list = new ArrayList<>();
        if(s == null){
            return list;
        }
        if(words.length == 0){
            return list;
        }

        int length = words[0].length();
        int totalwords = words.length;
        if(length == 0){
            return list;
        }
        HashMap<String,Integer> wordsCount = new HashMap<>();
        for (String w : words) {
            if (wordsCount.containsKey(w)) {
                wordsCount.put(w, wordsCount.get(w) + 1);
            } else {
                wordsCount.put(w, 1);
            }
        }

        for(int i=0;i<length;i++) {
            int start = i;
            int end = i;
            HashMap<String, Integer> partMap = new HashMap<>();
            int counter = 0;
            while (end < s.length() - length + 1) {
                String sub = s.substring(end, end + length);
                if (wordsCount.containsKey(sub)) {
                    if (partMap.containsKey(sub)) {
                        partMap.put(sub, partMap.get(sub) + 1);
                        counter++;
                    } else {
                        partMap.put(sub, 1);
                        counter++;
                    }
                    while (partMap.get(sub) > wordsCount.get(sub)) {
                        String startword = s.substring(start,start + length);
                        partMap.put(startword, partMap.get(startword) - 1);
                        counter--;
                        start = start+length;
                    }
                    if (counter == totalwords) {
                        list.add(start);
                    }
                } else {
                    // this is addition step apart from sliding window.....
                    //
                    partMap.clear();
                    counter = 0;
                    start = end + length;
                }
                end = end + length;
            }
        }
        return list;
    }
    public static void main(String args[]){
        SlidingWindow slidingWindow = new SlidingWindow();
        String s= "barfoothefoobarman";
        String []words= {"foo", "bar"};
        System.out.println(slidingWindow.findSubstring(s,words));
    }
}package BasicAlgorithms.String;

/**
 * Created by hadoop on 14/10/17.
 */
public class LongestIncreasingSubsequence {
    public int lengthOfLIS(int[] nums) {
        int []lis = new int[nums.length];
        int maxlength=0;
        for(int i=1;i<nums.length;i++){
            for(int j=0;j<i;j++){
                if(nums[j]<nums[i] && lis[j]+1>lis[i]){
                    lis[i] = lis[j]+1;
                }
            }
            maxlength = Math.max(maxlength,lis[i]);
        }
        return maxlength;
    }
}package BasicAlgorithms.String;

/**
 * Created by hadoop on 14/10/17.
 */
public class ValidPalindrome {
    public boolean isPalindrome(String s) {
        s = s.toLowerCase();
        int i = 0;
        int j = s.length() - 1;
        while (i < j) {
            while (i < j && !isValid(s.charAt(i))) {
                i++;
            }
            while (i < j && !isValid(s.charAt(j))) {
                j--;
            }
            if(s.charAt(i)!=s.charAt(j)){
                return false;
            }
            i++;
            j--;
        }
        return true;
    }

    private boolean isValid(char c) {
        if(!(c>='a' && c<='z') && !(c>='A' && c<='Z') && !(c>='0' && c<='9')){
            return false;
        }
        return true;
    }

    public static void main(String[] args) {
        int n =40;
        String total_n = String.format("%4d", n);
        System.out.println(total_n);
        String s = "A man, a plan, a canal: Panama";
        s= s.toLowerCase();
        ValidPalindrome validPalindrome = new ValidPalindrome();
        System.out.println(validPalindrome.isPalindrome(s));
    }
}package BasicAlgorithms.String;

import java.util.Comparator;
import java.util.HashMap;
import java.util.Map;
import java.util.TreeMap;

/**
 * Created by hadoop on 13/10/17.
 */
public class IntToRoman {
    static Map<Integer,String> mappings = new TreeMap<>(new Comparator<Integer>() {
        @Override
        public int compare(Integer o1, Integer o2) {
            return o2-o1;
        }
    });
    static Map<String,Integer> maps = new HashMap<>();
    static {

    }
    static {
        mappings.put(1,"I");
        mappings.put(4,"IV");
        mappings.put(5,"V");
        mappings.put(9,"IX");
        mappings.put(10,"X");
        mappings.put(40,"XL");
        mappings.put(50,"L");
        mappings.put(90,"XC");
        mappings.put(100,"C");
        mappings.put(400,"CD");
        mappings.put(500,"D");
        mappings.put(900,"CM");
        mappings.put(1000,"M");
    }
    String inttostring(int num){
        String result="";
        for(Map.Entry<Integer,String> entry:mappings.entrySet()){
            int times = num/entry.getKey();
            for(int k=0;k<times;k++){
                result= result+entry.getValue();
            }
            int remainder = num%entry.getKey();
            num = remainder;
            if(remainder == 0){
                break;
            }
        }
        return result;
    }
    Integer stringtoint(String a){
        for(Map.Entry<Integer,String> entry:mappings.entrySet()){
            maps.put(entry.getValue(),entry.getKey());
        }
        int intvalue= 0;
        int i=0;
        for(;i<a.length()-1;i++){
            int prevvlaue=  maps.get(String.valueOf(a.charAt(i)));
            int nextvalue = maps.get(String.valueOf(a.charAt(i+1)));
            if(nextvalue>prevvlaue){
                intvalue = intvalue+maps.get(String.valueOf(a.charAt(i+1)))-maps.get(String.valueOf(a.charAt(i)));
                i++;
            }
            else {
                intvalue = intvalue+ maps.get(String.valueOf(a.charAt(i)));
            }
        }
        if(i == a.length()-1){
            intvalue = intvalue+ maps.get(String.valueOf(a.charAt(i)));
        }
        return intvalue;
    }
//    String stringtoint(String s){
//        String result="";
//        for(Map.Entry<Integer,String> entry:mappings.entrySet()){
//            int times = i/entry.getKey();
//            for(int k=0;k<times;k++){
//                result= result+entry.getValue();
//            }
//            int remainder = i%entry.getKey();
//            if(remainder == 0){
//                break;
//            }
//        }
//        return result;
//    }
public static void main(String[] args) {
    IntToRoman roman = new IntToRoman();
    System.out.println(roman.inttostring(13));
    System.out.println(roman.stringtoint("IX"));
}
}
package BasicAlgorithms.String;

/**
 * Created by hadoop on 15/10/17.
 */
public class ReplaceBlank {
    public int replaceBlank(char[] string, int length) {
        int additional=0;
        for(int i=0;i<string.length;i++){
            if(string[i] == ' '){
                additional = additional+2;
            }
        }
        int index = string.length+additional;
        int len = index;
        for(int i=string.length-1;i>=0;i--){
            if(string[i] == ' '){
                string[--index] = '0';
                string[--index] = '2';
                string[--index] = '%';
             }
            else {
                string[--index] = string[i];
            }
        }
        return len;
    }
}
package BasicAlgorithms.String;

/**
 * Created by hadoop on 14/10/17.
 */
public class ReverseWord {

    public String reverseWords(String s) {
        StringBuilder sb = new StringBuilder();
        for(int end = s.length()-1;end>=0 ;end--){
            if(s.charAt(end) == ' '){
                continue;
            }
            int start = end;
            while (start>=0 && s.charAt(start)!=' '){
                start--;
            }
            String word = s.substring(start+1,end+1);
            sb.append(word+" ");
            end = start;
        }
        return sb.toString();
    }

    public String reverseWordsBegining(String s) {
        StringBuilder sb = new StringBuilder();
        for(int start= 0;start<s.length();start++){
            if(s.charAt(start) == ' '){
                continue;
            }
            int end = start;
            while (end<s.length() && s.charAt(end)!=' '){
                end++;
            }
            String word = s.substring(start,end);
            String reverseWord = new StringBuilder(word).reverse().toString();
            sb.append(reverseWord).append(" ");
            System.out.println(sb.toString());
            start = end;
        }
        return sb.reverse().toString().trim();
    }
    public void reverseWords(char[] s) {
        System.out.println(s.length);
        for(int start=0;start<s.length;start++){
            if(s[start]==' ')
                continue;
            int end = start;
            while (end<s.length && s[end]!=' '){
                end++;
            }
            reversew(s,start,end-1);
            start = end;
        }
        reversew(s,0,s.length-1);
    }

    private void reversew(char[] s, int start, int end) {
        while (start<end){
            char temp = s[start];
            s[start] = s[end];
            s[end] = temp;
            start++;
            end--;
        }
    }
    public void reverseWordsAcc(char[] words) {
        int start=0;
        for(int i=0;i<words.length;i++){
            if(words[i] == ' '){
                reverseWordsHelper(words,start,i-1);
                start = i+1;
            }
            if(i == words.length -1){
                reverseWordsHelper(words,start,i);
            }
        }
        reverseWordsHelper(words,0,words.length-1);

    }

    private void reverseWordsHelper(char[] words, int start, int end) {
        while (start<end){
            char temp  = words[start];
            words[start] = words[end];
            words[end] = temp;
            start++;
            end--;
        }
    }

    public static void main(String[] args) {
        ReverseWord reverseWord = new ReverseWord();
       // System.out.println(reverseWord.reverseWordsBegining("rajat is good"));
        char d[] = {};
        char c [] = "".toCharArray();
        reverseWord.reverseWords(c);
        System.out.println(String.valueOf(c));
        System.out.println(String.valueOf(d));
        char []acc = "".toCharArray();
        reverseWord.reverseWordsAcc(acc);
        System.out.println("check"+String.valueOf(acc)+"ad");
    }
}package BasicAlgorithms.String;

import java.util.HashMap;

/**
 * Created by hadoop on 14/10/17.
 */
public class FindStringTemplate {

    int findSubString(String s){
        HashMap<Character,Integer> hashMap = new HashMap<>();
        int counter ; // to check if condtiodn is valid
        int begin=0;
        int end=0;
        int d ; // length of substring
        for( int i=0;i<s.length();i++ ){
            hashMap.put(s.charAt(i),1);
        }
        while (end<s.length()) {
            if (hashMap.containsKey(s.charAt(end))) {
                // modify counter
            }
            // while(counter based conditon){
          //  increase start to make condition valid or invalid based on quesiton
            //
        //}
           // while (!counter){
            //start++

              // update d as to min value
            //}


            // update d to find max value
            //One thing needs to be mentioned is that when asked to find maximum substring, we should update maximum after the inner while loop to guarantee that the substring is valid. On the other hand, when asked to find minimum substring, we should update minimum inside the inner while loop.

        }
        return 1;

    }
}
/*
For most substring problem, we are given a string and need to find a substring of it which satisfy some restrictions. A general way is to use a hashmap assisted with two pointers. The template is given below.

//int findSubstring(string s){
//        vector<int> map(128,0);
//        int counter; // check whether the substring is valid
//        int begin=0, end=0; //two pointers, one Point to tail and one  head
//        int d; //the length of substring
//
//        for() { /* initialize the hash map here */
//
//        while(end<s.size()){
//
//        if(map[s[end++]]-- ?){  /* modify counter here */ }
//
//        while(/* counter condition */){
//
//                 /* update d here if finding minimum*/
//
//        //increase begin to make it invalid/valid again
//
//        if(map[s[begin++]]++ ?){ /*modify counter here*/ }
//        }
//
//            /* update d here if finding maximum*/
//        }
//        return d;
//        }
//        One thing needs to be mentioned is that when asked to find maximum substring, we should update maximum after the inner while loop to guarantee that the substring is valid. On the other hand, when asked to find minimum substring, we should update minimum inside the inner while loop.
// */
package BasicAlgorithms.String;

import java.util.HashMap;

/**
 * Created by hadoop on 14/10/17.
 */
public class LongestSubstringWithoutRepeatingChar {
    int longestSubstring(String s){
        HashMap<Character,Integer> hashMap = new HashMap<>();
        int start=0;
        int end =0;
        int counter =0;
        int maxlength = 0;
        while (end<s.length()){
            if(!hashMap.containsKey(s.charAt(end))){
                hashMap.put(s.charAt(end),1);
            }
            else {
                hashMap.put(s.charAt(end),hashMap.get(s.charAt(end))+1);
                counter++;
            }
            while (counter>0){
                Integer startfreq = hashMap.get(s.charAt(start));
                System.out.println(startfreq);
                startfreq = startfreq-1;
                if(startfreq ==1){
                    counter--;
                }
                if(startfreq ==0){
                    hashMap.remove(s.charAt(start));
                }
                else {
                    hashMap.put(s.charAt(start),startfreq);
                }
                start++;
            }
            maxlength = Math.max(maxlength,end-start+1);
            end++;
        }
        return maxlength;
    }

    public static void main(String[] args) {
        LongestSubstringWithoutRepeatingChar longestSubstringWithoutRepeatingChar = new LongestSubstringWithoutRepeatingChar();
        System.out.println(longestSubstringWithoutRepeatingChar.longestSubstring("pwwkew"));
    }
}
package BasicAlgorithms.Sort;

/**
 * Created by hadoop on 24/10/17.
 */
class NBComparator {
    int cmp(String a,String b){
        return 1;
    }
}

public class NutsBolts {
    public void sortNutsAndBolts(String[] nuts, String[] bolts, NBComparator compare) {
        // write your code here
        if (nuts == null || bolts == null || nuts.length != bolts.length) {
            return;
        }
        quicksort(nuts, bolts, 0, nuts.length - 1, compare);
    }

    public void quicksort(String[] nuts, String[] bolts, int start, int end, NBComparator compare) {
        if (start >= end) {
            return;
        }
        int pivot = sortBolts(nuts[start], bolts, start, end, compare);
        sortNuts(nuts, bolts[pivot], start, end, compare);
        quicksort(nuts, bolts, start, pivot - 1, compare);
        quicksort(nuts, bolts, pivot + 1, end, compare);
    }

    public int sortBolts(String nut, String[] bolts, int start, int end, NBComparator compare) {
        int left = start;
        int right = end;
        while (left < right) {
            while (left < right && compare.cmp(nut, bolts[left]) < 0) {
                left++;
            }
            while (left < right && compare.cmp(nut, bolts[right]) > 0) {
                right--;
            }

            if (left < right) {
                swap(bolts, left, right);
            }
        }
        return left;
    }

    private void sortNuts(String[] nuts, String bolt, int start, int end, NBComparator compare){
        int left = start;
        int right = end;

        while(left < right){
            while(left < right && compare.cmp(nuts[left], bolt) > 0){
                left++;
            }
            while(left < right && compare.cmp(nuts[right], bolt) < 0){
                right--;
            }
            if(left < right) {
                swap(nuts, left, right);
            }
        }
    }
    public void swap(String[] s, int i, int j) {
        String temp = s[i];
        s[i] = s[j];
        s[j] = temp;
    }
}package BasicAlgorithms.Sort;

/**
 * Created by hadoop on 11/11/17.
 */
public class MyTournamentTree {
    public static void main(String[] args) {
        MyTournamentTree myTournamentTree = new MyTournamentTree();
        int []array = {8 ,7 ,5 ,15 ,1, 6, 9 ,4};
         int []tour = myTournamentTree.build(array);

        System.out.println(myTournamentTree.nextMax(tour));
        myTournamentTree.update(tour,1);
        System.out.println(myTournamentTree.nextMax(tour));
    }
    int [] build(int array[]){
        int []tournament = new int[2*array.length];
        for(int i=0;i<array.length;i++){
            tournament[i+array.length] = array[i];
        }
        for(int i=2*array.length-2;i>1;i= i-2){
            tournament[i/2] = Math.max(tournament[i],tournament[i+1]);
        }
        for(int i=0;i<2*array.length;i++){
            System.out.println(tournament[i]);
        }
        return tournament;
    }
    void update(int []tour,int index){
        int i= index;
        int val = tour[i];
        tour[i] = Integer.MIN_VALUE;
        while (i<=tour.length-1){
            int leftindex = 2*i;
            int rightindex = 2*i+1;
            if(leftindex <=tour.length-1 && tour[leftindex] == val ){
                i = leftindex;
                tour[leftindex] = Integer.MIN_VALUE;
            }
            if(rightindex<=tour.length-1 && tour[rightindex] == val){
                i = rightindex;
                tour[rightindex] = Integer.MIN_VALUE;
            }

            if(leftindex>=tour.length){
                break;
            }
        }


    }
    int nextMax(int []tournament){
        int index = 1;
        int next=Integer.MIN_VALUE;
        int counter = 0;
        System.out.println("in tree");
        while (index<=tournament.length-1){
            System.out.println(index);
            int leftindex = 2*index;
            int rightindex = 2*index+1;
            if(leftindex<= tournament.length-1){
                next = Math.max(next,tournament[leftindex]);
                index = leftindex;
            }
            if(rightindex<=tournament.length-1){
                if(next<tournament[rightindex]){
                    index = rightindex;
                    next = tournament[rightindex];
                }
            }
            if(leftindex >tournament.length-1){
                break;
            }
            counter++;
            if(counter>10){
                break;
            }
        }
        return next;
    }

}
package BasicAlgorithms.Sort;


import BasicAlgorithms.utils.ConsoleWriter;

/**
 * Created_By: stefanie
 * Date: 14-12-29
 * Time: 4:59
 */
public class G2_CountingArray {
    class Node{
        int value;
        int index;
        public Node(int value, int index){
            this.value = value;
            this.index = index;
        }

        @Override
        public String toString() {
            return "Node{" +
                    "value=" + value +
                    ", index=" + index +
                    '}';
        }
    }

    public int[] generate(int[] A){
        int[] B = new int[A.length];
        Node[] nodes = new Node[A.length];
        for(int i = 0; i < A.length; i++) nodes[i] = new Node(A[i], i);
        Node[] aux = new Node[A.length];
//        System.out.println("=====");
//        for(Node a:nodes){
//            System.out.print(a.value);
//        }
        mergeSort(nodes, aux, B, 0, A.length - 1);
//        System.out.println("=====");
        for(Node a:nodes){
            System.out.print(a.value);
        }
        System.out.println();
        return B;
    }

    public void mergeSort(Node[] A, Node[] aux, int[] B, int low, int high){
        if(low >= high) return;
        int mid = low + (high - low)/2;
        mergeSort(A, aux, B, low, mid);
        mergeSort(A, aux, B, mid + 1, high);
        merge(A, aux, B, low, mid, high);

    }

    public void merge(Node[] A, Node[] aux, int[] B, int low, int mid, int high) {
        for (int i = low; i <= high; i++) aux[i] = A[i];
        int i = mid;
        int j = high;
        for (int k = high; k >= low; k--) {
            if (i < 0) A[k] = aux[j--];
            else if (j < 0) A[k] = aux[i--];
            else if (aux[j].value >= aux[i].value) A[k] = aux[j--];
            else {
                B[aux[i].index] += j - mid;
                A[k] = aux[i--];
            }
        }
    }
//            }
//        }
//        ConsoleWriter.printIntArray(B);
//        for(int s= low;s<=high;s++){
//            System.out.print(A[s]);
//        }


    public static void main(String[] args){
        G2_CountingArray generator = new G2_CountingArray();
        int[] A = new int[]{5, 2, 6, 1};
        //4,0,1,1,0
        ConsoleWriter.printIntArray(generator.generate(A));
    }
}
/*
1, 0, 0, 0, 0,
2, 0, 0, 0, 0,
2, 0, 1, 1, 0,
4, 0, 1, 1, 0,
4, 0, 1, 1, 0,
 */package BasicAlgorithms.Sort;

/**
 * Created by hadoop on 11/11/17.
 */
public class SecondMinimum {
    public static Integer secondMin(Node root) {
        if(root.left == null || root.right == null) return Integer.MAX_VALUE;
        int min;
        if(root.left.val == root.val) {
            min = Math.min(root.right.val, secondMin(root.left));
        } else {
            min = Math.min(root.left.val, secondMin(root.right));
        }

        return min;
    }
    private class Node{
        Node left;
        Node right;
        int val;
    }
}
package BasicAlgorithms.Sort;

import java.util.ArrayList;

/**
 * Created by hadoop on 24/10/17.
 */
import java.util.*;
public class LargestNumber {
    public String largestNumber(int[] nums) {
        List<Integer> list = new ArrayList<Integer>();
        for(int num:nums){
            list.add(num);
        }
        Collections.sort(list, new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                String a= String.valueOf(o1);
                String b = String.valueOf(o2);
                return b.compareTo(a);
            }
        });
        String ans= "";
        for(Integer a:list){
            System.out.println(a);
            ans= ans + a;
        }
        System.out.println(ans);
        return ans;
    }

    public static void main(String[] args) {
        LargestNumber largestNumber = new LargestNumber();
        largestNumber.largestNumber(new int[]{121,12});
    }
}package BasicAlgorithms.Sort;

/**
 * Created by hadoop on 11/11/17.
 */
public class FindSecondSmallest {
    public int findSecondSmallest(int[] a){

        //We assume that the array has at least 2 elements
        return findMinAnd2ndSmallest(a, 0, a.length-1)[1];
    }

    //find min & second smallest
    private int[] findMinAnd2ndSmallest(int[] a, int start, int end){
        if(start == end) return new int[]{a[start], Integer.MAX_VALUE};
        int[] left = findMinAnd2ndSmallest(a, start, (start+end) / 2);
        int[] right = findMinAnd2ndSmallest(a,(start+end) / 2+1, end);
        int smallest = 0, secondSmallest = 0;
        if(left[0] < right[0]) {
            smallest = left[0]; secondSmallest = right[0];
            if(right[0] > left[1]) secondSmallest = left[1];
        }else {
            smallest = right[0]; secondSmallest = left[0];
            if(left[0] > right[1]) secondSmallest = right[1];
        }
        return new int[]{smallest, secondSmallest};
    }
}
package BasicAlgorithms.Sort.tournament;

import java.util.Scanner;

public class Tournament {
 static int min;

 public static void main(String[] args) {
  Scanner sc = new Scanner(System.in);
  int n = sc.nextInt();
  int arr[] = new int[2 * n + 1];
  for (int i = n; i <= 2 * n - 1; i++) {
   arr[i] = sc.nextInt();
  }
  min = arr[n];
  for (int i = 2 * n - 2; i >= 1; i -= 2)
   arr[i / 2] = max(arr[i], arr[i + 1]);

  for (int a : arr)
   System.out.print(a + " ");
  // System.out.println("\nmax:" + arr[1]);
  // System.out.println("\nmin:" + min);
  System.out.println("\n Sorted array");
  for (int i = 1; i <= n; i++) {
   {
    System.out.println(arr[1]);
    getNext(arr, n, min - 1);
   }
  }

 }

 static void getNext(int arr[], int n, int min) {
  // finding min. in arr
  int i = 2;
  for (i = 2; i <= 2 * n - 1;) {
   if (arr[i] < arr[i + 1]) {
    arr[i + 1] = min;
    i = (2*i + 2);

   } else {
    arr[i] = min;
    i = i * 2;
   }

  }

  for (i = i / 2; i >= 1; i = i / 2) {
   if (i % 2 == 0)
    arr[i / 2] = max(arr[i], arr[i + 1]);
   else
    arr[i / 2] = max(arr[i], arr[i - 1]);
  }

 }

 static int max(int a, int b) {
  if (a > b) {
   if (min > b)
    min = b;
   return a;
  } else {
   if (min > a)
    min = a;
   return b;
  }

 }

}package BasicAlgorithms.Sort;

import java.util.Scanner;

public class Tournament {
 static int min;

 public static void main(String[] args) {
  Scanner sc = new Scanner(System.in);
  int n = sc.nextInt();
  int arr[] = new int[2 * n];
  for (int i = n; i <= 2 * n - 1; i++) {
   arr[i] = sc.nextInt();
  }
  min = arr[n];
  for (int i = 2 * n - 2; i >= 1; i -= 2)
   arr[i / 2] = Math.max(arr[i], arr[i + 1]);

  for (int a : arr)
   System.out.print(a + " ");
  System.out.println("\nmax:" + arr[1]);
  // System.out.println("\nmin:" + min);
  System.out.println("\n Sorted array");
  for (int i = 1; i <= n; i++) {
   {
    System.out.println(arr[1]);
    getNext(arr, n, min - 1);
   }
  }
 }
 static void getNext(int arr[], int n, int min) {
  int i = 2;
  for (i = 2; i <= 2 * n - 1;) {
   if (arr[i] < arr[i + 1]) {
    arr[i + 1] = min;
    i = (i *2+ 1);

   } else {
    arr[i] = min;
    i = i * 2;
   }
  }

  for (i = i / 2; i >= 1; i = i / 2) {
   if (i % 2 == 0)
    arr[i / 2] = Math.max(arr[i], arr[i + 1]);
   else
    arr[i / 2] = Math.max(arr[i], arr[i - 1]);
  }
 }



 }
package BasicAlgorithms.Dp;

/**
 * Created by hadoop on 26/10/17.
 */
public class Transactions {
    public int maxProfit(int[] prices) {
        return maxProfitII(prices, 0);
    }
    private int maxProfitII(int[] prices, int pos) {
        int profit = 0;
        for (int i = pos+1; i < prices.length; i++) {
            int diff = prices[i] - prices[i-1];
            if (diff > 0)
                profit += diff;
        }
        return profit;
    }
}
package BasicAlgorithms.Dp;

/**
 * Created by hadoop on 26/10/17.
 */
import java.util.*;
public class KsumRecursion {
    private int dfsCache(int A[], int k, int target) {
        int[][][] cache = new int[k+1][A.length][target+1];
        for (int i = 0; i <= k; i++) {
            for (int j = 0; j < A.length; j++)
                Arrays.fill(cache[i][j], -1);
        }
        return dfsCache(A, 0, k, target, cache);
    }

    private int dfsCache(int A[], int pos, int k, int target, int[][][] cache) {
        if (target == 0 && k == 0)
            return 1;
        if (target < 0 || k <= 0 || pos+k > A.length)
            return 0;
        if (cache[k][pos][target] != -1)
            return cache[k][pos][target];
        int nWay = dfsCache(A, pos+1, k, target, cache);
        nWay += dfsCache(A, pos+1, k-1, target - A[pos], cache);
        cache[k][pos][target] = nWay;
        return nWay;
    }
}
package BasicAlgorithms.Dp;

/**
 * Created by hadoop on 26/10/17.
 */
import java.util.*;
public class DFSRECU {
    public int maxProfit(int k, int[] prices) {
        int [][] cache = new int [prices.length][k+1];
        for(int i=0;i<prices.length;i++){
            Arrays.fill(cache[i],-1);
        }
        return dfs(prices,0,k,cache);
    }
    // public int maxProfit(int[] prices) {
    //     return dfs(prices, 0,2);
    // }
    private int dfs(int[] prices, int pos, int k,int [][]cache) {
        if (k == 0 || pos == prices.length)
            return 0;
        int min = Integer.MAX_VALUE;
        if(cache[pos][k]!=-1){
            return cache[pos][k];
        }
        int profit = 0;
        for (int i = pos; i < prices.length; i++) {
            min = Math.min(min, prices[i]);
            int diff = prices[i] - min;
            if (diff > 0) {
                diff += dfs(prices, i+1, k-1,cache);
            }
            profit = Math.max(profit, diff);
        }
        return cache[pos][k]=profit;
    }

    public static void main(String[] args) {
        DFSRECU dfsrecu = new DFSRECU();
        int k =300;
        int []matrix={106,373,495,46,359,919,906,440,783,583,784,
                73,238,701,972,308,165,774,990,675,737,990,713,157,211};
//                880,961,132,980,136,285,239,628,221,948,939,28,541,414,180,171,640,297,873,
//                59,814,832,611,868,633,101,67,396,264,445,548,257,656,624,71,607,67,836,14,373,205,434,203,661,793,45,623,140,67,177,885,155,764,363,269,599,32,228,111,102,565,918,592,604,244,982,533,781,604,115,429,33,894,778,885,145,888,577,275,644,824,277,302,182,94,479,563,52,771,544,794,964,827,744,366,548,761,477,434,999,86,1000,5,99,311,346,609,778,937,372,793,754,191,592,860,748,297,610,386,146,220,7,113,657,438,482,700,158,884,877,964,777,139,809,489,383,92,581,970,899,947,864,443,490,825,674,906,402,270,416,611,949,476,775,899,837,796,227,232,226,11,266,889,215,6,182,430,5,706,994,128,359,841,439,263,491,689,638,485,763,695,135,800,763,54,569,387,112,316,193,675,546,531,954,571,208,282,557,892,469,875,765,592,374,276,892,843,625,180,249,292,477,882,837,112,46,667,187,93,418,790,903,12,978,510,647,446,597,958,678,897,420,907,256,170,669,920,711,635,995,259,994,634,583,175,380,435,942,739,921,132,455,986,567,464,301,10,579,84,745,717,588,414,375,319,770,310,510,521,88,445,59,460,120,765,480,441,169,374,180,947,179,346,490,417,149,140,577,624,427,238,341,686,623,228,672,859,372,938,567,141,133,671,255,997,272,591,115,340,692,531,235,123,677,980,31,774,135,194,956,723,779,375,546,59,695,616,416,362,38,145,782,184,418,806,444,177,360,485,941,998,85,840,740,545,49,570,17,824,845,749,177,727,238,656,787,425,473,323,683,578,442,436,444,595,367,44,467,93,507,949,598,579,471,1,347,982,232,878,217,845,777,284,527,529,100,482,456,814,457,251,494,419,922,139,706,384,954,365,680,70,810,764,820,992,622,29,697,294,553,655,63,934,827,157,680,812,729,486,403,151,988,926,460,193,294,423,774,715,906,957,598,929,339,119,686,88,228,803,806,743,430,315,224,712,724,69,606,411,271,700,520,179,916,490,652,319,69,245,827,185,200,911,363,335,50,353,551,737,15,429,966,766,307,829,379,184,779,239,254,904,262,719,321,380,253,564,348,878,570,470,313,752,563,164,301,239,856,491,154,795,640,199,940,420,201,254,400,865,886,819,424,292,257,572,112,590,984,421,639,705,707,779,660,4,817,265,465,737,56,564,797,178,552,988,621,98,665,379,607,300,439,269,196,94,860,540,830,756,294,806,321,930,623,206,440,730,829,566,420,488,49,438,447,294,548,804,514,45,383,431,373,424,11,377,868,559,316,831,464,211,710,803,680,665,39,523,951,219,293,909,838,708,663,627,220,100,565,269,982,236,185,194,697,556,767,541,360,103,497,271,919,19,206,73,393,50,421,466,970,329,105,618,17,687,578,260,759,366,334,686,613,616,893,351,847,861,452,454,454,88,135,357,194,220,504,36,916,246,718,172,395,292,613,533,662,983,701,877,842,445,263,529,679,526,31,385,918,898,584,846,474,648,67,331,890,174,766,274,476,414,701,835,537,531,578,7,479,906,93,667,735,435,899,49,953,854,843,326,322,13,865,791,828,686,760,957,655,601,406,185,738,788,519,874,630,440,839,511,149,715,566,988,0,354,498,81,193,335,196,157,515,590,768,366,287,386,502,143,547,659,616,822,479,813,497,222,285,6,453,363,906,388,733,804,624,963,634,319,817,674,754,378,999,373,793,419,246,274,960,1,130,186,576,382,204,227,607,435,299,790,603,196,236,955,654,812,214,297,926,721,977,568,339,913,297,621,783,242,257,483,325,998,164,586,782,597,210,522,369,676,339,626,650,634,477,793,85,12,695,655,53,287,730,0,689,225,805,593,430,610,963,172,148,740,579,16,523,570,802,627,220,664,945,788,500,90,410,916,481,454,538,622,161,373,523,757,446,855,958,390,333,927,253,814,442,77,325,14,655,502,200,791,58,714,951,370,557,261,859,199,46,775,249,369,233,321,733,310,503,539,618,839,272,315,999,229,390,359,528,334,878,342,977,869,704,564,506,867,77,248,674,557,258,710,126,617,531,969,289,578,947,103,581,599,918,686,143,253,56,393,58,144,211,806,285,635,203,194,884,687,653,856,688,623,568,394,749,302,534,631,894,167,111,227,296,41,854,81,147,656,319,748,530,457,340,223,896,77,166,974,659,36,338,177,496,483,690,569,504,211,554,758,732,660,61,62,669,273,0,616,899,789,380,386,357,403,251,926,636,419,148,820,774,485,497,370,907,973,255,277,341,466,254,333,219,819,521,974,213,590,981,697,927,904,717,726,574,94,625,991,378,249,388,786,355,69,318,357,467,695,825,585,940,323,993,549,485,564,833,530,398,789,608,59,541,915,81,681,544,460,318,954,764,879,708,258,276,259,505,649,529,824,914,660,490,666,676,618,339,712,981,802,239,605,270,29,491,41,243,361,644,327,472,460,725,864,129,142,610,782,935,929,63,865,287,316,740,212,152,567,620,591,394,805,586,177,918,516,911,944,427,128,778,930,965,27,633,534,567,575,247,691,571,775,456,622,219,698,772,305,27,810,690,555,222,877,985,493,202,84,180,133,129,539,151,275,234,999,676,629,715,839,6,789,663,467,435,275,580,296,8,73,849,456,681,794,954,543,602,615,4,131,593,778,175,
//                587,670,88,648,79,703,99,457,261,722,357,966,724,523,612,610,376,575,174,2,53,637,478,850,250,238,344,381,543,686,761,582,598,804,12,128,928,133,998,188,598,590,507,898,402,771,703,912,744,317,300,852,631,767,157,278,520,452,721,560,112,206,69,317,498,942,942,963,347,61,186,390,128,946,462,230,551,956,195,960,143,225,654,255,370,778,770,487,192,479,180,505,509,508,717,976,826,346,521,472,148,965,965,971,421,402,233,76,543,533,815,281,986,638,936,139,754,728,779,551,425,17,546,516,862,963,648,127,510,453,311,759,654,550,755,654,567,129,34,927,900,421,961,923,117,766,71,132,680,917,460,609,874,179,336,496,287,61,846,228,871,590,858,404,646,449,770,724,245,634,900,496,157,864,407,632,998,596,451,482,921,102,624,148,346,282,624,150,523,598,492,267,54,889,872,979,38,1,282,513,877,798,994,400,254,435,487,707,459,575,275,297,165,104,468,80,820,571,215,869,381,107,209,762,455,415,810,137,674,304,692,639,304,534,348,938,575,432,471,74,631,291,405,622,352,58,549,832,655,458,688,468,827,447,946,181,908,585,53,905,733,363,210,536,960,577,815,462,193,31,731,8,538,695,936,795,139,782,357,52,492,610,512,544,323,276,649,940,54,749,723,544,365,500,441,284,17,660,748,871,701,591,356,64,34,422,713,978,96,218,756,833,177,832,61,91,764,510,188,415,622,473,549,944,716,998,528,61,829,953,280,284,706,323,981,405,91,887,568,874,725,236,933,41,895,940,375,468,314,667,694,609,631,621,655,640,835,513,461,854,419,455,860,912,572,769,963,213,818,158,840,699,414,969,430,59,855,997,997,884,349,723,837,488,430,671,743,943,310,399,884,423,486,587,491,106,716,0,768,704,483,663,827,587,915,904,742,976,6,455,221,849,920,548,156,35,101,270,684,123,549,649,977,711,965,492,525,130,744,697,910,699,301,285,696,313,117,122,777,163,789,924,543,446,60,214,102,97,45,670,960,23,522,680,178,757,792,633,244,327,129,188,357,733,419,496,774,408,90,615,663,321,526,946,990,273,135,373,719,870,810,798,826,64,971,156,233,587,253,712,384,964,173,511,116,291,639,450,947,623,656,548,605,498,709,143,895,739,663,160,442,820,802,380,413,356,742,744,764,421,355,499,614,678,336,850,1000,463,794,388,478,188,576,822,164,209,465,901,116,729,891,952,611,15,798,731,711,6,459,587,278,996,220,642,563,363,271,16,379,959,332,315,414,659,602,786,571,78,450,544,393,404,953,480,215,771,419,8,738,36,191,138,204,146,923,413,908,998,46,928,678,425,584,372,689,245,721,177,833,44,784,121,164,16,714,680,974,685,340,810,101,301,791,716,697,768,33,901,994,417,353,248,559,807,64,450,724,896,889,880,818,89,495,848,915,450,409,958,413,149,743,782,64,687,196,737,769,311,429,598,585,690,919,331,94,211,633,888,856,844,870,931,934,66,407,121,902,417,522,423,821,196,625,855,830,673,463,181,857,775,374,490,971,751,835,823,770,79,916,80,829,810,856,674,524,352,251,548,899,363,465,0,989,322,51,86,740,542,920,310,365,677,287,688,373,225,774,331,430,482,630,46,567,236,370,502,347,191,137,646,218,634,399,278,423,540,26,612,700,43,508,176,268,525,267,676,257,651,88,349,556,6,463,29,410,753,224,693,535,747,40,854,155,376,192,434,12,342,98,718,639,951,205,923,354,564,988,960,676,965,29,104,898,535,915,868,768,269,294,944,523,145,895,382,53,935,671,518,338,623,524,204,146,900,161,258,739,417,119,825,336,182,123,749,355,188,109,740,945,826,921,123,65,69,682,461,259,661,247,523,796,153,142,851,411,536,190,478,417,296,113,158,263,754,532,368,748,42,890,129,643,717,564,525,5,348,204,383,427,696,861,684,902,591,609,467,837,104,565,168,828,916,645,232,153,794,384,642,753,550,176,142,132,141,192,635,14,634,329,403,790,460,29,512,443,15,74,114,456,487,303,13,822,429,136,113,637,283,542,519,411,564,220,346,907,389,780,479,480,179,385,285,445,393,508,885,697,168,542,357,553,149,710,126,508,271,845,689,231,217,984,848,905,87,168,1000,169,336,672,595,501,411,81,707,708,634,150,722,379,77,762,737,585,419,428,37,869,509,222,335,192,980,209,883,864,215,497,992,155,408,652,927,990,708,439,857,934,838,69,140,713,573,939,338,628,685,412,147,530,643,471,545,58,111,132,665,572,38,176,460,555,997,61,602,471,901,620,830,577,436,495,685,619,600,549,270,77,512,249,697,466,864,336,981,901,573,702,694,937,299,565,436,613,187,377,364,473,405,384,280,658,561,85,987,302,856,107,191,486,464,165,514,948,227,310,133,799,363,481,289,153,990,445,246,454,729,887,980,546,730,528,817,521,437,376,238,965,511,995,432,227,883,550,904,818,556,295,413,786,861,248,113,660,982,445,292,562,722,433,621,783,375,53,236,856,275,898,532,915,804,362,545,373,397,740,453,726,983,665,715,379,176,408,3,911,573,883,195,254,469,758,844,355,409,562,307,752,274,105,227,635,121,335,338,46,993,243,567,765,589,806,405,558,25,246,526,490,306,295,112,847,792,759,881,500,398,791,266,33,372,546,217,286,898,596,955,720,70,9,458,698,367,936,134,95,887,300,975,72,235,77,870,943,511,883,923,619,812,904,990,643,871,346,588,807,957,681,581,195,82,448,146,807,559,21,412,950,536,681,541,
//                856,631,378,258,736,116,580,20,606,748,537,343,681,22,711,628,536,395,422,874,135,519,294,876,185,583,392,253,220,80,341,203,970,825,762,558,942,797,651,290,8,414,375,913,167,977,94,706,970,286,278,349,909,422,887,921,492,467,550,538,555,841,446,199,312,816,562,296,609,39,393,240,763,222,828,802,944,714,325,334,936,995,950,487,433,195,370,498,926,109,543,885,463,687,171,703,985,292,123,314,174,183,588,487,857,63,736,126,156,172,367,313,672,494,56,202,470,821,735,72,812,282,570,756,633,82,52,920,300,199,927,534,214,354,764,84,419,462,5,246,787,305,788,852,58,698,241,184,904,533,333,857,215,531,81,862,567,56,773,741,169,982,965,302,724,145,342,731,184,914,977,933,727,918,420,438,491,300,104,107,730,506,214,214,968,351,66,844,965,758,845,503,495,503,208,281,622,905,49,751,660,268,420,360,354,971,441,565,513,711,283,695,109,432,127,399,177,640,67,77,364,327,943,1000,979,278,526,222,929,120,753,580,743,456,241,148,339,599,919,11,473,101,365,789,465,819,778,134,278,89,598,801,904,681,695,599,43,897,763,193,257,719,410,610,58,72,912,598,793,347,640,725,855,390,754,785,70,449,24,962,843,735,729,893,797,512,390,57,474,336,855,970,389,722,735,464,28,894,664,645,96,357,255,117,795,479,151,790,432,748,780,940,255,204,607,999,989,48,139,945,783,736,826,640,597,171,423,457,972,424,419,140,706,333,648,557,155,707,547,337,66,338,818,829,972,13,500,310,961,668,991,407,386,893,589,308,129,739,689,452,361,822,418,606,961,981,385,132,7,938,102,942,534,154,133,921,51,257,205,281,771,215,508,816,466,744,85,141,163,418,894,386,779,142,137,825,556,764,647,414,792,605,945,36,427,173,907,356,893,875,449,621,181,963,801,14,502,234,495,437,86,635,846,182,182,540,340,648,772,195,93,539,716,573,431,342,989,156,745,436,709,22,532,100,504,0,985,838,461,725,555,219,710,568,914,736,791,507,615,442,494,977,546,519,389,614,78,172,991,255,154,243,495,876,267,948,657,692,46,107,864,168,785,965,740,16,878,713,79,517,68,208,621,13,362,99,379,109,823,960,645,440,944,342,710,267,656,646,639,453,155,867,456,606,328,444,136,89,104,650,36,240,320,31,352,522,520,260,510,981,591,655,668,23,544,320,541,707,133,708,809,972,196,59,383,642,153,993,837,98,300,751,564,399,848,325,903,534,662,201,690,300,404,115,104,600,236,752,651,640,244,254,40,549,304,86,600,755,59,662,106,290,368,725,138,705,28,550,955,277,959,346,721,759,569,420,424,59,989,438,867,725,544,178,575,137,21,536,72,617,194,421,226,378,483,880,688,791,930,97,831,113,711,445,308,813,967,120,769,329,718,899,364,638,308,644,25,138,88,732,922,721,850,835,367,831,292,651,966,268,628,925,205,824,429,917,534,323,887,3,302,134,904,300,678,929,491,229,671,817,442,678,879,373,664,990,53,395,738,570,497,113,322,557,341,641,331,932,830,433,590,738,780,50,446,504,743,311,980,88,224,732,316,664,742,69,146,801,334,41,198,629,690,869,598,612,662,385,637,769,984,316,741,980,2,794,814,730,297,503,734,836,604,674,376,692,277,727,455,975,703,115,25,552,404,460,543,738,86,488,356,929,668,835,222,413,172,221,1000,30,888,350,514,908,870,323,991,201,738,335,189,437,604,316,514,575,531,514,318,43,592,594,9,773,609,952,708,868,291,962,572,772,291,214,992,238,275,36,882,631,376,150,838,376,862,996,258,545,331,907,958,925,503,1,745,559,147,617,487,185,623,287,658,340,84,835,563,168,845,401,395,928,277,136,890,276,45,806,121,264,416,417,596,208,106,738,352,995,746,731,72,258,112,885,445,165,74,847,633,343,721,237,20,91,575,410,765,274,233,738,893,999,283,104,414,981,448,761,47,48,725,459,265,318,564,353,260,896,874,563,492,710,336,952,80,195,326,311,716,167,561,556,234,680,631,112,573,248,422,130,219,134,75,722,188,221,238,193,689,63,787,657,956,214,895,657,169,349,575,577,869,64,325,187,471,535,572,39,872,966,22,232,427,501,855,239,487,263,335,645,461,973,447,923,922,788,286,610,55,708,827,250,355,481,379,322,926,796,815,2,952,268,257,61,795,364,999,535,494,664,619,711,228,411,587,292,345,671,640,231,384,859,88,640,838,904,27,235,605,766,887,23,438,816,764,91,12,324,709,411,659,405,927,769,505,259,383,714,333,652,648,663,604,596,231,114,320,955,689,626,495,758,96,848,43,189,848,656,114,475,349,148,995,467,94,519,141,125,598,738,822,701,194,46,936,332,370,764,944,711,889,568,508,186,981,48,400,69,182,698,25,526,808,272,963,451,335,883,718,199,185,437,81,987,4,274,482,263,509,584,767,141,53,365,14,657,712,837,161,378,525,313,685,183,869,202,382,339,351,686,15,667,636,756,553,848,57,740,862,962,838,410,722,409,589,891,370,520,790,880,276,478,26,459,671,728,301,296,75,194,173,116,938,933,977,812,863,868,286,973,984,265,631,456,436,683,28,126,319,285,62,247,88,60,824,710,26,602,897,765,998,610,138,773,555,153,114,932,21,111,171,282,246,909,419,647,781,166,966,200,521,188,808,295,685,1000,890,353,301,983,862,527,974,241,705,437,523,213,704,421,225,428,310,255,719,243,962,757,27,476,181,138,95,309,122,500,846,627,371,470,759,255,373,520,748,856,459,71,431,782,307,524,644,130,120,56,406,387,435,201,7,392,922,503,578,331,827,954,21,351,869,65,300,697,908,505,315,198,744,892,510,307,985,129,634,773,343,640,702,748,973,594,271,151,254,513,339,843,425,153,19,309,489,333,944,442,904,447,239,487,6,230,988,656,716,488,779,362,738,663,516,432,964,142,823,353,175,797,645,613,553,26,41,946,47,479,181,964,901,251,843,715,211,366,335,16,103,547,171,276,29,165,993,424,274,334,754,982,63,963,904,150,342,301,238,152,314,892,498,958,192,806,208,681,703,970,688,5,809,705,182,230,658,531,793,303,475,825,924,538,488,100,655,524,569,655,430,808,820,402,852,760,691,751,779,868,247,688,545,780,350,400,550,307,577,803,527,302,916,984,829,257,172,392,41,233,241,587,159,176,904,926,540,324,918,177,817,585,722,89,987,476,637,210,980,905,911,547,762,490,197,718,774,982,484,781,675,152,144,412,255,800,480,901,892,309,382,873,469,662,375,499,646,436,410,866,440,708,613,842,663,604,555,133,77,458,66,660,504,635,896,621,126,995,506,7,283,11,610,11,727,667,101,589,309,240,508,368,830,805,4,259,936,39,510,645,772,993,530,932,393,19,82,915,994,853,683,183,797,61,292,942,434,846,265,316,991,751,579,182,162,454,5,194,97,451,906,177,761,988,314,425,5,63,127,565,427,774,66,195,627,731,750,586,874,599,878,759,807,192,9,971,279,127,424,357,671,573,451,104,51,105,699,375,99,775,421,490,968,442,965,492,974,639,584,647,676,186,586,730,345,617,337,256,477,985,847,681,689,696,893,198,631,509,662,813,33,137,808,412,165,97,698,309,276,670,364,939,595,125,663,384,582,775,262,978,256,928,783,275,651,657,240,759,522,354,609,400,487,57,269,251,927,953,700,591,186,287,873,511,768,269,880,767,487,518,812,434,154,299,203,664,316,14,688,350,15,51,383,550,736,903,420,727,313,789,110,300,675,435,334,243,887,503,30,878,322,859,670,77,219,972,156,539,775,234,469,887,441,444,108,688,856,805,358,634,699,855,741,949,119,996,103,676,289,382,722,337,307,301,389,213,663,131,987,573,748,151,655,117,637,566,802,226,888,672,259,740,769,627,880,709,877,995,264,379,310,485,133,73,511,50,326,239,931,187,502,459,661,263,446,370,911,260,153,89,285,254,563,293,981,218,507,304,102,702,294,335,147,242,529,158,677,617,58,590,835,734,453,292,41,285,357,161,98,166,378,338,436,469,760,448,582,266,242,356,140,222,711,879,285,435,724,631,509,379,685,757,534,787,682,755,786,978,351,339,27,282,436,302,403,396,817,66,792,371,916,858,742,611,426,123,992,761,936,206,946,974,615,158,117,314,343,277,748,545,584,39,913,319,444,927,787,880,293,108,962,706,679,884,728,783,920,994,763,540,768,545,6,561,369,608,335,695,791,271,768,686,844,982,606,23,379,259,943,956,459,358,434,606,794,985,424,939,116,508,998,48,582,927,150,310,402,764,913,749,304,446,755,928,236,572,566,600,451,659,660,651,224,959,70,449,191,883,984,396,904,837,763,475,53,344,703,86,707,528,715,853,327,447,163,389,379,497,385,673,915,407,756,630,921,700,423,546,224,170,23,595,113,854,445,397,466,885,24,854,765,259,951,139,897,629,226,938,182,963,168,198,428,613,925,103,516,491,580,857,539,19,21,426,147,417,299,785,375,198,984,480,131,358,31,925,764,75,963,140,725,681,501,154,204,626,822,775,378,396,988,756,60,598,965,738,617,492,566,264,640,912,4,554,474,524,371,730,638,452,679,776,353,799,381,188,603,328,528,120,24,835,350,737,572,759,220,329,813,93,896,502,44,351,862,825,914,868,575,911,25,414,956,566,247,761,921,901,317,93,466,719,251,9,434,26,735,754,602,402,956,702,295,144,833,564,459,664,447,791,731,325,945,904,787,704,265,91,790,587,120,514,521,325,215,985,859,861,190,721,969,16,641,638,713,274,495,272,701,20,319,933,979,19,824,753,323,924,162,534,786,18,834,269,626,800,490,944,571,782,842,578,225,264,345,481,369,636,158,390,92,777,622,662,115,939,515,692,95,398,696,146,606,554,214,637,776,996,241,730,755,596,247,258,112,703,643,142,663,729,27,962,737,930,222,199,595,188,184,287,120,135,352,625,486,684,465,261,246,574,744,212,28,266,491,651,843,652,80,796,412,545,912,311,913,447,180,540,108,578,742,216,140,881,679,767,528,987,233,241,376,285,845,722,381,319,139,118,779,727,741,388,284,677,163,81,453,612,495,479,408,493,159,545,956,806,802,269,140,748,110,734,621,334,614,395,74,972,840,118,613,48,962,460,318,278,637,334,787,766,373,417,672,430,490,232,626,745,721,219,133,958,181,875,209,199,637,886,908,495,311,547,365,141,292,233,453,292,941,703,38,487,63,408,394,876,460,582,270,553,169,63,789,753,4,601,828,591,627,886,411,354,863,758,18,173,92,147,170,572,951,727,252,97,207,742,185,906,713,324,706,129,744,400,897,201,801,913,225,937,981,526,925,655,611,901,582,302,329,98,365,887,926,829,332,425,887,188,809,222,293,552,553,604,554,399,95,442,941,82,95,250,602,282,932,953,400,245,997,456,789,783,856,172,739,323,440,928,961,161,926,700,281,28,767,740,981,798,836,655,431,98,862,28,624,110,417,446,11,17,784,757,160,124,40,655,17,411,162,933,425,890,27,529,739,398,385,449,827,688,959,723,148,916,814,638,642,560,361,134,115,659,204,376,260,337,184,413,354,510,704,325,241,538,588,977,31,936,805,486,237,546,70,458,947,150,683,990,673,57,47,803,208,508,452,396,169,838,492,706,532,878,685,200,111,261,564,403,340,31,526,779,326,329,640,990,863,334,506,28,521,489,981,515,451,803,742,486,248,716,967,622,774,938,378,180,195,853,663,699,865,589,856,27,971,687,483,230,517,845,279,882,535,166,937,43,648,756,40,12,76,338,501,714,287,973,766,47,489,633,56,248,718,430,431,237,620,725,567,648,253,51,63,382,146,28,830,409,286,628,657,828,129,256,902,249,738,84,90,128,979,864,839,582,57,611,278,534,844,977,819,98,840,203,169,461,564,299,270,282,327,721,748,759,164,883,885,924,772,622,997,944,627,821,277,224,890,680,494,313,298,990,583,790,842,455,352,966,878,878,741,765,742,951,593,828,662,150,702,359,61,394,428,368,939,948,528,890,262,432,982,898,160,822,68,27,853,9,964,208,382,881,257,653,189,701,20,861,693,560,945,225,907,94,899,489,605,788,545,621,532,222,478,551,376,16,984,907,426,548,386,249,418,298,399,60,309,578,637,443,233,619,135,415,465,664,560,42,674,463,306,573,153,593,558,32,708,910,124,890,52,296,514,
//                823,172,459,821,833,409,460,363,745,658,290,50,607,912,127,595,563,193,802,238,439,23,741,729,793,402,325,671,766,669,517,374,318,468,489,639,136,553,31,448,740,834,114,313,879,721,16,778,503,716,55,806,14,876,429,380,223,646,487,160,922,653,159,379,18,970,68,840,383,505,776,912,461,251,707,634,803,821,47,650,865,851,311,206,449,48,859,192,337,634,991,515,78,331,190,747,210,320,469,45,299,376,491,449,948,194,579,824,470,543,632,131,807,535,824,696,266,106,65,701,90,457,502,929,745,660,592,319,280,45,218,977,853,365,562,864,890,551,788,27,849,295,29,670,872,554,77,80,105,524,11,123,707,376,269,883,316,263,650,80,590,767,793,943,948,396,753,786,227,1,973,53,984,116,795,551,273,141,288,836,450,501,459,574,536,730,398,660,213,211,501,94,336,272,100,582,356,874,51,921,745,853,980,714,360,102,479,26,988,68,701,965,635,641,95,812,727,253,464,155,784,911,997,746,652,431,402,104,12,417,401,796,71,459,64,214,834,525,319,160,718,188,228,270,309,910,630,389,826,759,680,506,928,749,58,670,933,918,84,329,421,410,860,280,238,986,873,928,120,486,257,310,579,436,950,164,143,393,535,280,187,122,713,703,345,560,913,568,529,197,172,358,6,140,781,0,525,275,755,504,429,58,8,460,444,883,151,971,992,694,707,595,745,236,470,925,527,427,331,163,903,739,455,430,485,485,60,552,743,3,771,335,448,863,675,107,99,255,105,397,702,317,171,863,497,653,313,158,668,975,425,417,981,188,172,141,946,688,276,389,969,86,198,893,771,547,153,875,203,963,463,553,92,160,348,37,401,599,370,394,537,698,676,38,927,755,3,333,814,361,763,583,974,778,342,473,277,690,34,84,393,612,178,414,342,576,628,863,321,1000,378,977,572,12,255,161,126,970,691,822,941,999,934,815,939,409,676,379,976,664,357,328,115,350,745,739,189,326,283,90,916,940,976,41,607,264,599,341,12,999,716,72,406,984,839,254,721,150,741,496,9,626,759,467,262,595,415,828,620,47,305,446,496,786,106,564,969,969,286,174,276,377,300,512,139,574,734,804,69,459,831,598,68,453,912,666,984,571,945,465,693,582,153,185,72,503,496,170,8,370,413,10,746,329,530,89,192,495,376,251,337,875,37,460,630,410,247,609,947,623,261,768,348,278,655,432,913,349,384,482,170,822,938,255,869,310,593,869,202,695,240,232,981,168,398,911,601,230,95,156,335,229,678,724,986,277,451,274,237,509,889,652,752,543,106,438,690,574,568,897,508,188,434,800,623,830,113,774,49,730,556,763,637,956,784,341,744,114,232,479,731,320,636,648,813,48,280,288,883,867,789,871,36,972,245,485,150,102,884,700,142,58,890,757,894,400,989,679,433,57,368,209,968,672,852,892,655,442,620,435,759,202,529,890,892,989,26,88,336,728,67,510,40,898,10,172,954,10,472,11,668,23,482,177,936,469,360,393,564,611,695,912,42,708,198,149,34,90,556,450,550,101,879,52,978,134,458,634,843,385,803,263,404,704,462,529,145,448,929,363,412,803,86,212,556,997,517,230,619,258,33,528,549,653,500,361,300,393,784,955,986,970,966,672,371,87,75,271,876,487,65,870,401,149,476,5,683,164,439,761,124,779,918,788,479,720,491,246,334,623,774,811,330,14,965,164,216,565,468,659,149,395,151,766,152,527,28,486,565,889,0,119,259,690,144,771,354,86,212,428,5,942,773,957,799,631,168,678,553,468,555,53,522,859,222,672,27,379,690,335,371,10,527,430,439,693,611,210,116,97,202,174,193,747,245,135,391,341,117,508,336,97,839,232,310,796,400,350,293,489,583,668,506,910,391,64,287,341,515,467,481,296,438,694,81,748,716,978,805,299,921,789,225,85,628,118,417,838,771,475,620,589,751,203,634,815,228,692,133,689,235,626,339,569,976,272,408,184,376,610,17,808,842,480,754,545,455,520,477,889,751,806,719,651,457,568,970,541,475,635,221,169,987,345,987,817,829,371,743,218,282,244,788,857,170,297,747,378,345,220,190,127,114,152,285,221,98,236,388,421,410,390,251,43,288,125,64,586,811,313,687,528,579,916,110,187,44,88,552,46,423,152,964,872,7,999,644,477,883,319,734,558,737,835,405,291,597,739,342,150,583,736,638,836,918,799,482,417,202,258,176,562,33,24,585,458,477,407,842,764,309,606,440,182,999,375,112,987,26,825,771,185,660,882,66,907,883,450,383,501,567,223,17,227,724,152,387,368,645,803,327,294,620,861,421,848,826,119,146,878,751,928,434,589,220,356,710,33,278,754,447,365,674,5,848,424,888,916,881,186,678,614,129,207,721,385,422,313,403,970,264,80,324,456,486,117,430,308,993,366,617,104,903,365,926,281,22,902,593,685,710,923,818,379,421,3,734,187,120,22,236,11,420,366,515,199,486,310,927,261,678,630,786,954,29,246,241,502,89,811,581,459,864,193,629,442,105,78,837,153,345,377,13,804,803,596,94,814,115,31,82,51,486,510,420,352,544,951,842,479,71,234,917,70,70,790,177,921,44,553,176,270,675,797,859,331,463,94,30,275,794,440,552,752,527,8,305,491,296,667,310,272,292,43,169,987,695,589,50,219,537,567,732,716,320,952,711,542,572,813,698,317,43,315,151,347,164,691,157,12,590,728,424,366,41,904,814,161,340,273,512,131,507,538,963,866,417,397,703,767,643,345,265,378,103,828,352,127,937,764,701,148,572,279,208,206,569,861,899,171,97,462,733,490,728,65,554,23,763,221,995,32,974,280,242,410,533,852,433,745,939,914,480,81,601,370,446,808,724,321,410,514,45,987,189,240,195,886,308,431,207,73,463,650,382,607,835,633,465,325,294,794,519,379,262,290,722,982,498,149,87,467,168,390,537,896,577,917,68,319,525,89,429,329,176,759,741,797,320,871,325,957,366,39,449,776,44,974,161,920,650,400,671,46,76,422,333,134,125,664,722,837,455,983,466,326,468,999,129,749,902,688,393,639,748,127,666,853,874,779,988,337,876,384,468,549,381,29,671,417,558,292,471,454,201,671,200,208,464,88,28,761,625,161,906,865,209,827,319,428,977,993,411,625,907,85,482,405,620,495,584,292,136,726,305,574,802,588,58,382,153,170,388,210,479,522,182,1000,323,952,97,972,164,874,963,536,375,331,216,756,526,513,110,34,247,824,356,90,908,389,217,684,1000,320,882,926,695,634,347,123,508,893,157,795,215,147,416,944,964,157,139,509,76,117,378,990,817,695,798,235,258,81,765,357,109,780,335,30,486,435,543,841,677,918,771,744,775,522,787,17,839,837,931,148,71,36,422,45,275,877,22,218,630,204,612,972,811,891,788,556,448,793,923,179,162,814,355,266,113,763,482,997,668,739,151,761,379,636,61,188,87,774,687,380,276,128,57,640,464,335,751,34,540,115,588,412,783,487,957,634,443,750,477,774,127,779,1,204,301,909,696,330,411,733,264,278,648,243,603,889,163,913,280,498,365,287,232,127,565,84,820,853,407,1,199,178,875,841,882,865,605,969,47,339,405,263,336,295,594,113,134,446,371,28,213,248,129,309,452,472,53,740,556,573,257,205,142,1000,101,251,150,368,632,16,289,557,759,948,280,993,146,980,149,348,592,932,953,621,191,710,311,940,325,556,338,773,1,188,310,706,325,708,639,77,959,434,474,698,980,658,144,199,316,191,800,325,389,927,587,292,678,624,401,237,974,465,105,34,643,685,260,317,320,891,541,557,661,365,152,693,160,171,386,564,986,191,915,119,3,505,5,132,432,420,49,31,858,365,670,429,149,350,208,885,819,95,676,465,625,103,394,326,645,502,289,350,454,925,870,427,510,668,552,978,551,343,5,259,687,779,447,158,170,65,50,835,826,988,93,36,14,495,904,516,523,672,154,992,884,907,912,380,354,81,595,133,120,45,486,916,884,403,46,173,663,947,359,221,871,956,51,227,65,546,878,273,904,279,655,500,660,284,75,525,921,257,384,367,504,17,62,742,92,459,861,798,242,60,984,172,235,97,528,720,537,676,942,326,654,61,782,562,418,609,259,745,983,726,457,347,957,440,112,152,888,360,141,555,423,432,845,827,140,593,80,870,95,10,400,104,861,470,405,403,971,538,972,918,892,467,173,712,471,578,408,559,723,952,857,798,987,476,418,240,959,496,802,795,835,607,701,158,816,180,567,975,496,542,876,54,722,646,418,78,49,858,191,935,42,127,222,574,37,636,47,557,535,294,202,679,930,575,415,602,71,425,645,132,421,363,889,719,32,23,415,477,107,357,495,552,3,501,986,766,985,556,353,963,464,867,728,669,637,309,575,500,666,967,842,135,270,176,831,683,283,700,897,127,927,116,61,934,874,403,405,483,73,662,365,997,114,160,859,537,687,23,685,329,589,483,318,602,420,265,589,406,899,881,201,931,848,144,524,345,61,102,216,928,832,269,387,549,866,552,803,367,676,877,175,304,701,395,918,886,909,949,593,497,689,619,830,868,599,559,564,597,944,19,810,773,370,932,84,755,342,814,840,569,273,685,129,685,756,305,709,506,679,724,783,47,607,197,869,318,43,409,41,773,153,560,589,655,184,764,936,976,259,545,660,597,302,294,582,791,1000,806,497,999,575,88,506,401,996,488,108,530,515,661,426,280,626,591,1000,531,884,620,523,566,74,775,871,167,163,275,385,451,407,511,2,471,628,265,757,523,77,532,731,671,61,821,17,491,292,279,326,678,275,413,647,156,935,554,465,442,692,469,645,175,48,852,694,283,997,400,282,574,381,149,471,196,701,730,339,767,459,779,997,641,691,908,255,268,880,788,89,467,840,571,424,373,75,930,435,20,331,833,118,540,434,452,297,129,384,852,946,265,362,459,240,658,438,608,856,448,540,587,973,91,675,44,132,297,721,545,351,298,605,801,127,31,178,872,51,65,867,981,723,823,374,506,948,759,795,328,803,416,98,91,498,224,528,402,48,413,461,391,71,518,595,658,846,123,7,979,848,69,797,425,12,183,778,493,364,479,35,132,513,938,554,802,765,181,644,336,484,932,264,
//                940,42,484,661,348,354,410,191,219,7,639,487,68,725,822,565,297,221,699,572,339,366,540,576,147,622,554,274,281,544,774,762,538,270,61,690,274,582,637,885,721,864,239,646,386,746,276,473,777,658,881,97,529,975,736,29,897,620,151,564,384,344,371,823,470,494,751,488,591,762,606,731,985,398,16,855,271,860,26,458,986,542,621,585,752,599,725,516,206,64,235,48,374,357,551,17,159,708,275,340,845,519,743,84,385,587,623,7,148,157,361,65,435,47,49,118,254,536,274,92,800,185,873,920,979,436,549,807,85,346,637,183,259,962,941,948,211,710,275,448,947,796,604,578,596,547,296,272,665,90,933,157,663,839,189,919,613,605,868,10,913,449,85,534,924,28,883,427,979,100,948,282,1,368,988,716,136,406,746,766,122,899,135,782,778,884,323,18,480,627,789,366,141,180,440,44,907,53,975,260,997,393,621,405,112,14,423,152,582,324,708,42,362,395,106,923,37,494,551,73,726,471,941,796,507,8,117,293,489,880,177,48,760,994,875,844,469,653,101,814,544,58,771,890,781,298,745,119,798,952,152,12,174,907,113,191,12,305,233,753,778,439,724,119,719,554,870,189,510,121,173,539,788,609,261,199,187,725,91,867,561,914,95,488,924,179,898,262,117,866,265,213,903,444,754,657,173,144,262,642,523,927,632,121,68,128,717,107,37,922,667,579,347,313,586,485,410,7,130,754,755,22,605,787,11,193,701,15,114,580,86,88,417,826,461,915,321,974,421,521,285,957,786,802,66,28,117,
//                904,258,996,337,441,717,188,318,127,480,280,953,953,889,541,288,109,809,181,926,888,111,303,414,263,94,326,642,416,987,742,24,35,950,888,55,165,903,169,690,986,175,938,623,734,212,824,108,597,181,168,858,471,745,226,467,427,226,143,552,62,255,350,280,554,158,335,685,588,827,484,882,196,170,318,264,212,687,369,548,550,112,895,599,676,605,105,862,934,688,729,949,843,806,341,523,168,576,455,204,709,648,999,78,662,712,712,969,206,43,559,636,705,699,761,571,703,823,377,359,429,161,498,18,933,990,450,653,771,510,146,88,90,859,657,525,78,886,852,610,353,586,207,898,140,823,470,63,458,747,221,585,169,879,699,794,592,529,495,370,857,419,796,913,416,360,535,170,726,743,195,912,971,937,649,880,766,301,481,484,868,163,194,790,345,210,30,342,556,714,512,398,297,912,121,856,832,858,19,454,532,531,672,438,366,500,234,672,977,417,629,87,171,512,53,968,782,517,99,352,475,128,6,439,115,388,535,815,547,188,982,179,761,778,58,296,623,692,563,820,481,410,581,147,784,315,774,857,549,828,659,959,798,956,888,345,736,630,433,611,853,828,726,614,942,988,184,289,494,36,37,790,470,896,842,800,803,648,180,944,906,867,696,47,948,647,40,842,555,676,38,651,389,659,518,655,12,278,980,380,694,930,619,867,854,710,279,113,768,557,827,914,317,301,53,832,665,222,229,672,182,514,586,938,177,608,287,243,281,236,956,86,247,744,416,387,871,909,594,673,377,366,765,839,244,588,502,724,930,280,185,743,64,648,527,15,116,517,876,370,246,347,441,546,283,95,304,849,574,125,116,13,295,198,546,460,335,680,616,670,53,551,978,806,775,565,169,719,291,64,31,780,706,702,164,397,330,426,708,773,583,465,258,673,958,681,389,986,863,823,435,406,961,454,107,799,615,318,884,52,705,65,845,484,579,246,363,46,286,217,190,262,138,260,181,307,733,469,754,12,417,854,315,268,171,145,837,667,600,83,222,537,913,962,817,419,184,537,611,972,972,886,593,791,253,239,377,37,967,301,661,608,122,177,33,368,577,543,221,319,624,673,919,879,27,609,618,742,860,682,702,115,589,642,140,102,869,522,440,927,440,284,942,307,631,294,771,234,913,447,708,603,68,601,683,842,210,292,711,322,647,246,749,159,799,385,393,857,630,36,542,523,992,421,406,5,835,396,535,708,659,816,943,760,773,162,587,913,957,383,972,138,929,644,348,63,708,596,142,277,395,361,524,876,647,413,717,241,527,287,338,662,441,546,274,39,404,806,598,23,638,180,725,497,462,180,332,444,998,205,108,6,898,203,226,832,93,478,142,152,747,476,374,783,239,123,888,553,40,158,940,720,676,855,520,415,188,91,91,242,573,292,372,9,441,790,605,39,505,476,657,836,252,504,397,303,731,723,115,181,903,802,657,746,821,40,982,549,898,859,459,573,772,165,436,196,958,706,860,201,371,428,331,220,117,765,753,271,84,544,226,700,22,926,180,96,829,515,315,706,547,243,46,396,315,652,776,895,989,65,582,901,282,684,676,915,882,653,539,969,693,1,651,244,500,65,49,830,988,250,974,352,904,422,182,530,568,152,345,657,777,920,927,18,672,974,273,923,181,171,673,35,62,648,169,691,409,283,508,554,764,408,478,200,623,241,940,113,579,284,854,493,231,779,435,237,194,692,444,538,726,728,511,108,115,869,922,98,294,311,703,723,800,286,970,994,434,973,980,704,746,283,824,26,780,463,446,407,761,178,887,375,256,290,624,243,327,398,390,482,227,660,482,816,254,951,82,235,860,5,545,121,882,766,513,399,79,675,433,738,924,149,68,878,71,597,680,648,664,390,736,979,834,45,465,724,851,567,732,182,958,530,302,435,102,944,989,366,832,632,76,93,252,2,244,945,522,336,751,230,415,331,855,506,726,496,663,662,862,447,417,272,486,63,280,618,686,713,468,723,512,78,119,338,665,278,634,186,506,896,345,281,124,826,217,494,652,982,418,825,918,714,299,308,800,260,793,365,989,873,396,110,576,533,690,734,635,235,743,356,792,508,313,866,512,888,827,127,727,805,711,826,134,64,729,623,79,313,776,245,896,43,669,143,935,450,463,967,337,242,169,849,755,262,790,661,165,863,744,797,979,86,432,67,202,813,244,112,54,844,327,106,708,892,535,667,870,740,150,695,329,987,39,168,54,553,192,581,478,324,569,145,536,911,549,880,884,994,367,997,138,606,236,547,452,250,683,23,596,172,598,865,972,528,243,442,560,342,840,643,221,174,282,746,779,686,709,657,623,258,770,793,364,770,9,456,459,623,739,524,209,997,974,386,635,547,790,849,703,489,493,132,132,389,869,727,405,182,25,887,361,447,483,483,226,94,408,938,89,546,296,497,551,704,152,816,955,674,856,594,598,711,766,336,852,258,653,849,322,209,895,596,684,286,12,547,392,263,60,548,772,562,391,772,757,994,656,468,520,667,329,600,612,222,528,601,721,832,954,918,33,381,9,27,95,328,623,163,783,854,313,635,943,25,619,121,676,993,115,614,651,76,157,744,834,190,298,127,66,733,949,616,750,598,313,968,784,884,653,111,108,833,995,981,661,856,506,276,519,345,801,822,818,17,921,691,225,688,952,915,50,532,401,412,258,193,752,757,890,714,156,157,20,371,43,723,426,976,725,54,212,132,251,288,33,237,944,945,451,105,595,937,120,896,372,367,300,251,760,366,907,390,977,518,527,724,749,593,984,450,206,31,70,734,543,986,944,965,180,8,933,148,936,84,441,557,167,689,412,378,642,29,179,324,209,9,955,750,486,719,784,147,200,791,484,292,337,925,882,179,347,694,656,5,420,135,23,825,627,884,943,627,41,412,664,32,190,150,89,914,961,952,906,453,568,348,840,296,632,672,164,209,77,743,994,965,787,616,288,58,722,459,400,361,800,210,680,885,707,361,966,843,703,679,469,883,627,927,391,66,896,668,569,675,151,706,446,194,11,562,85,621,335,170,548,438,455,821,363,861,466,673,560,430,737,216,403,401,895,559,589,434,561,188,313,846,36,956,119,161,90,353,594,530,204,544,652,433,625,270,886,802,207,437,438,918,406,710,308,463,68,856,560,26,399,238,302,324,405,794,488,194,737,711,409,451,920,599,184,693,165,153,76,501,139,583,646,845,347,262,72,246,645,541,135,385,251,632,983,474,342,188,500,155,927,21,743,268,354,694,904,992,520,175,697,363,647,2,692,308,355,721,161,590,104,497,305,177,493,531,486,918,634,821,46,952,313,843,915,376,478,325,19,399,541,425,561,381,885,836,143,582,174,868,406,608,813,951,122,812,269,816,88,220,847,94,754,265,169,413,12,728,327,118,832,499,369,285,944,246,953,182,205,357,463,884,142,220,32,639,84,902,275,827,389,828,982,913,554,105,849,226,45,154,239,856,526,359,730,180,344,541,478,354,990,991,636,1000,519,390,130,399,857,223,111,231,449,707,945,820,721,222,690,9,712,962,7,940,962,679,121,15,787,398,329,960,501,26,539,288,187,900,200,414,338,399,513,602,661,459,460,198,815,53,161,891,264,412,989,646,248,704,383,646,88,199,297,443,32,100,66,689,463,958,325,788,981,247,172,96,477,456,142,92,288,231,429,325,73,422,977,807,504,572,285,719,977,54,806,118,455,532,479,50,343,871,333,561,472,995,197,609,314,936,440,102,815,853,911,716,260,679,740,384,46,226,590,383,100,283,935,104,876,896,507,901,281,807,679,963,877,198,234,655,474,723,975,265,540,729,108,685,404,460,635,237,788,488,344,665,704,644,65,56,989,131,115,769,350,738,982,580,641,883,545,328,290,290,684,313,413,198,73,395,656,428,692,236,919,983,649,429,875,319,819,740,680,816,781,60,569,509,938,566,614,551,560,881,716,601,5,540,826,78,86,635,438,124,0,867,59,561,837,870,420,326,948,748,592,168,967,894,753,148,202,689,21,336,350,726,804,301,699,898,111,817,229,549,873,362,475,518,579,529,4,800,763,489,929,936,300,759,981,145,290,324,352,0,498,350,215,592,806,963,299,400,422,642,672,211,561,20,945,398,715,23,6,548,121,851,326,292,180,648,400,120,386,473,53,213,835,469,70,610,300,625,632,771,312,379,599,837,653,422,888,155,387,620,235,426,840,760,162,136,793,509,562,562,62,409,857,559,746,922,936,553,41,396,609,681,5,680,984,128,257,335,160,271,105,767,258,609,425,699,505,274,640,293,841,297,849,31,12,462,395,712,117,341,326,390,887,921,421,513,230,554,834,307,436,611,204,580,794,222,733,734,145,102,861,776,131,214,440,755,515,671,590,305,768,118,670,884,506,12,597,170,960,657,353,188,19,638,432,674,414,880,353,395,37,722,830,919,808,117,390,316,178,840,489,268,377,479,933,246,547,887,73,729,54,686,818,386,662,683,91,223,274,28,880,526,329,762,212,886,121,510,857,965,653,932,632,799,486,898,516,349,846,733,28,629,776,776,173,817,127,672,875,930,330,236,912,137,97,771,824,657,477,835,988,136,408,835,174,705,726,296,70,720,403,321,360,170,200,808,642,993,322,299,238,549,868,954,664,765,590,715,221,628,538,631,572,40,950,284,275,528,828,11,426,155,730,847,18,267,831,243,602,947,559,853,391,308,603,446,792,620,877,9,720,668,818,91,459,390,812,777,410,64,92,251,613,654,164,688,400,776,189,694,700,553,853,988,708,776,214,590,293,320,597,515,358,893,822,704,254,281,802,351,209,933,407,299,739,474,142,76,206,55,270,457,522,355,542,418,321,283,234,893,479,337,806,686,597,623,421,360,373,45,834,885,6,253,684,794,942,51,613,176,488,830,902,400,704,427,271,335,840,838,933,528,623,278,882,584,794,51}
//    ;
        System.out.println(dfsrecu.maxProfit(k,matrix));

    }
}
package BasicAlgorithms.Dp;

import java.util.*;
public class DifferentWays {
    public List<Integer> diffWaysToCompute(String input) {
        if (input.isEmpty())
            return null;
        return diffWaysToCompute(input, 0, input.length()-1);
    }
    boolean isOprator(char ch) {
        return ch == '+' || ch == '-' || ch == '*';
    }
    private static int cal(int left, int right, char operator) {
        if (operator == '+') {
            return left + right;
        } else if (operator == '-') {
            return left - right;
        } else {
            return left * right;
        }
    }
    public List<Integer> diffWaysToCompute(String input, int L, int R) {
        List<Integer> all = new ArrayList<Integer>();
        List<Integer> left;
        List<Integer> right;
        for (int i = L; i <= R; i++) {
            if (isOprator(input.charAt(i))) {
                left = diffWaysToCompute(input, L, i-1);
                right = diffWaysToCompute(input, i+1, R);
                for (int l : left) {
                    for (int r : right) {
                        all.add(cal(l, r, input.charAt(i)));
                    }
                }
            }
        }
        if (all.size() == 0) {
            all.add(Integer.parseInt(input.substring(L, R+1)));
        }
        return all;
    }
}package BasicAlgorithms.Dp;

/**
 * Created by hadoop on 26/10/17.
 */
public class BurstBallons {
    public int maxCoins(int[] nums) {
        if (nums == null || nums.length == 0)
            return 0;
        int n = nums.length;
        int num[] = new int[n+2];
        num[0] = 1;
        for (int i = 0; i < n; i++)
            num[i+1] = nums[i];
        num[n+1] = 1;

        return dfsCache(num, 1, n);
    }

    private int dfsCache(int[] num, int L, int R) {
        int n = R-L+1+2;
        int[][] cache = new int[n][n];

        return dfsCache(num, L, R, cache);
    }
    private int dfsCache(int[] num, int L, int R, int[][] cache) {
        if (cache[L][R] != 0)
            return cache[L][R];
        int coins = 0;
        for (int i = L; i <= R; i++) {
            int l = dfsCache(num, L, i-1, cache);
            int r = dfsCache(num, i+1, R, cache);
            int val = num[L-1]*num[i]*num[R+1] + l + r;
            coins = Math.max(coins, val);
        }
        cache[L][R] = coins;
        return coins;
    }
}
package BasicAlgorithms.Dp;

class Jump {
    /**
     * @param A: A list of integers
     * @return: The boolean answer
     **/
  //DP
  public boolean canJump(int[] A) {
        if (A == null || A.length == 0) {
            return false;
        }
    //By default, boolean[] can is all false
        boolean[] can = new boolean[A.length];
        can[0] = true;
        for (int i = 1; i < A.length; i++) {
            for (int j = 0; j < i; j++) {
                if (can[j] && (j + A[j] >= i)) {
                    can[i] = true;
                    break;
                }
            }
        }
        return can[A.length - 1];
    }
    public int jump(int[] A) {
        int[] steps = new int[A.length];
        steps[0] = 0;
        for (int i = 1; i < A.length; i++) {
            steps[i] = Integer.MAX_VALUE;
            for (int j = 0; j < i; j++) {
                if (steps[i] != Integer.MAX_VALUE && A[j] + j > i) {
                    steps[i] = steps[j] + 1;
                    break;
                }
            }
        }
        return steps[A.length - 1];
    }
}package BasicAlgorithms.Dp;

/**
 * Created by hadoop on 26/10/17.
 */
public class Rectangle {
    private int divideAndconquer(int[] heights, int L, int R) {
        if (L > R)
            return 0;

        int M = getMinIndex(heights, L, R);
        int area = heights[M] * (R-L+1);
        int leftArea = divideAndconquer(heights, L, M-1);
        int rightArea = divideAndconquer(heights, M+1, R);

        area = Math.max(leftArea, area);
        area = Math.max(rightArea, area);
        return area;
    }

    private int getMinIndex(int[] heights, int l, int r) {
        // Use Segment Tree to build the solution
        return 1;
    }
    private void buildMinIndex(int[] heights) {
        int n = heights.length;
        int [][]minIdx = new int[n][n];

        // Build minIdx arrary using DP
        for (int i = 0; i < n; i++)
            minIdx[i][i] = i;
        for (int len = 2; len <= n; len++) {
            for (int i = 0; i <= n-len; i++) {
                int j = i+len-1;
                if (heights[j] < heights[minIdx[i][j-1]])
                    minIdx[i][j] = j;
                else
                    minIdx[i][j] = minIdx[i][j-1];
            }
        }
    }
}
package BasicAlgorithms.Dp;

/**
 * Created by hadoop on 26/10/17.
 */
public class Ktransactions {
    public int maxProfit(int[] prices) {
        return dfs(prices, 0,2);
    }
    private int dfs(int[] prices, int pos, int k) {
        if (k == 0 || pos == prices.length)
            return 0;
        int min = Integer.MAX_VALUE;
        int profit = 0;
        for (int i = pos; i < prices.length; i++) {
            min = Math.min(min, prices[i]);
            int diff = prices[i] - min;
            if (diff > 0) {
                diff += dfs(prices, i+1, k-1);
            }
            profit = Math.max(profit, diff);
        }
        return profit;
    }
}
package BasicAlgorithms.QuickSelect;

import java.util.Collections;
import java.util.List;
import java.util.Random;

/**
 * Created by hadoop on 16/10/17.
 */
public class QuickSelect {

    // return the index of the kth smallest number
    // avg. O(n) time complexity
    int quickSelect(List<Integer> a, int lo, int hi, int k) {
        int i = partitionDutch(a,lo,hi);
        // count the nums that are <= pivot from lo
        int m = i - lo + 1;

        // pivot is the one!
        if (m == k) return i;
            // pivot is too big, so it must be on the left
        else if (m > k) return quickSelect(a, lo, i - 1, k);
            // pivot is too small, so it must be on the right
        else return quickSelect(a, i + 1, hi, k - m);
    }
    private static int partitionDutch(List<Integer>nums,int start,int end) {
        int pivot= nums.get(start);
        int left = start;
        int right = end;
        int middle = start;
        while (middle<=right){
            if(nums.get(middle) == pivot){
                middle++;
            }
            else if(nums.get(middle)<pivot){
                Collections.swap(nums,left,middle);
//                swap(nums,left,middle);
                middle++;
                left++;
            }
            else {
                Collections.swap(nums,right,middle);
//                swap(nums,right,middle);
                right--;
            }
        }
        return left;
    }
    private static void swap(int[] array, int startindex, int middle) {
        int temp = array[startindex];
        array[startindex] = array[middle];
        array[middle] = temp;
    }
}package BasicAlgorithms.QuickSelect;

/**
 * Created by hadoop on 16/10/17.
 */
public class Main {
    public static void main(String[] args) {
     int nums[]={1,2,3,4,5};
        System.out.println(get(nums,0));
        System.out.println(get(nums,1));
        System.out.println(get(nums,2));
        System.out.println(get(nums,3));
        System.out.println(get(nums,4));

    }
    private static int get(int[] nums, int i){
        if(i <= (nums.length / 2 - 1)) return i * 2 + 1;
        return (i - nums.length / 2) * 2;
    }
}
package BasicAlgorithms.QuickSelect;

import java.util.ArrayList;
import java.util.*;

/**
 * Created by hadoop on 16/10/17.
 */
public class MeetingPoint {
    public int minTotalDistance(int[][] grid) {
        List<Integer> listx = new ArrayList<>();
        List<Integer> listy = new ArrayList<>();
        for(int i=0;i<grid.length;i++){
            for (int j=0;j<grid[0].length;j++){
                if(grid[i][j]!=0) {
                    listx.add(i);
                    listy.add(j);
                }
            }
        }

        int xmedian = getmedian(listx);
        int ymedian = getmedian(listy);


        int dis=0;
        for(int i=0;i<listx.size();i++){
            dis = dis+ Math.abs(listx.get(i)-xmedian);
            dis = dis+ Math.abs(listy.get(i)-ymedian);
        }
        System.out.println(dis);

        return dis;
    }

    private int getmedian(List<Integer> listx) {
        int xmed = KthSmallestElement(listx,0,listx.size()-1,listx.size()/2 +1);
        return xmed;
    }

    private int KthSmallestElement(List<Integer> listx, int lo, int hi, int k) {
        if(lo>hi){
            return -1;
        }
        int partitionedindex = partitiondutch(listx,lo,hi);
        int sizeofpartition = partitionedindex-lo+1;
        if(sizeofpartition == k){
            return listx.get(partitionedindex);
        }
        if(sizeofpartition<k){
            return KthSmallestElement(listx,partitionedindex+1,hi,k-sizeofpartition);
        }
        else {
            return KthSmallestElement(listx,lo,partitionedindex-1,k);
        }
    }

    private int partitiondutch(List<Integer> listx, int lo, int hi) {

        int pivot = listx.get((lo+hi)/2);
        int start = lo;
        int middle = lo;
        int high = hi;
        while (middle<=high){
            if(listx.get(middle)>pivot) {
                Collections.swap(listx,high,middle);
                high--;
            }
            else if(listx.get(middle)<pivot){
                Collections.swap(listx,start,middle);
                start++;
                middle++;
            }
            else {
                middle++;
            }
        }
        return start;
    }
    public static void main(String args[]){
        int array[][]={{1,0,0,0,1},{0,0,0,0,0},{0,0,1,0,0}};
        MeetingPoint meetingPoint = new MeetingPoint();
        meetingPoint.minTotalDistance(array);
    }
}package BasicAlgorithms.QuickSelect;

/**
 * Created by hadoop on 16/10/17.
 */
public class MinMoves {
    public int minMoves2(int[] nums) {
        int median = getmedian(nums);
        int moves = 0;
        for(int i=0;i<nums.length;i++){
            moves = moves+Math.abs(nums[i]-median);
        }
        return moves;
    }
    private int getmedian(int[] nums) {
        return quickSelect(nums,0,nums.length-1,nums.length/2+1);
    }

    private int quickSelect(int []nums, int lo, int hi, int k) {
        if(lo>hi){
            return -1;
        }
        int partitionindex = dutchpartition(nums,lo,hi);
        System.out.println("par"+partitionindex);
        int size =partitionindex-lo+1;
        if(size == k){
            return nums[partitionindex];
        }
        else if(size<k){
            return quickSelect(nums,partitionindex+1,hi,k-size);
        }
        else {
            return quickSelect(nums,lo,partitionindex-1,k);
        }

    }

    private int dutchpartition(int[] nums, int lo, int hi) {
        int start = lo;
        int high = hi;
        int middle = lo;
        int pivot = nums[(lo+hi)/2];
        while(middle<=high) {
            if (nums[middle] > pivot) {
                swap(nums, middle, high);
                high--;
            } else if (nums[middle] < pivot) {
                swap(nums, start, middle);
                start++;
                middle++;
            } else {
                middle++;
            }
        }
        return start;
    }

    void swap(int[] array, int startindex, int middle) {
        int temp = array[startindex];
        array[startindex] = array[middle];
        array[middle] = temp;
    }
    public static void main(String args[]){
        MinMoves minMoves = new MinMoves();
        System.out.println(minMoves.getmedian(new int[]{1,2,3}));
        System.out.println(minMoves.minMoves2(new int[]{1,2,3}));

    }
}
package BasicAlgorithms.QuickSelect;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Created by hadoop on 16/10/17.
 */
public class MajorityElement {
    public int majorityElement(int[] nums) {
        int getmedian = getmedian(nums);
        return getmedian;
    }

    private int getmedian(int[] nums) {
        return quickSelect(nums,0,nums.length-1,nums.length/2+1);
    }

    private int quickSelect(int []nums, int lo, int hi, int k) {
        if(lo>hi){
            return -1;
        }
        int partitionindex = dutchpartition(nums,lo,hi);
        System.out.println("par"+partitionindex);
        int size =partitionindex-lo+1;
        if(size == k){
            return nums[partitionindex];
        }
        else if(size<k){
            return quickSelect(nums,partitionindex+1,hi,k-size);
        }
        else {
            return quickSelect(nums,lo,partitionindex-1,k);
        }

    }

    private int dutchpartition(int[] nums, int lo, int hi) {
        int start = lo;
        int high = hi;
        int middle = lo;
        int pivot = nums[(lo+hi)/2];
        while(middle<=high) {
            if (nums[middle] > pivot) {
                swap(nums, middle, high);
                high--;
            } else if (nums[middle] < pivot) {
                swap(nums, start, middle);
                start++;
                middle++;
            } else {
                middle++;
            }
        }
        return start;
    }

    void swap(int[] array, int startindex, int middle) {
        int temp = array[startindex];
        array[startindex] = array[middle];
        array[middle] = temp;
    }
    public static void main(String args[]){
        int array[]={3,2,3};
        MajorityElement majorityElement = new MajorityElement();
        majorityElement.getmedian(array);
    }
}package BasicAlgorithms.QuickSelect;

/**
 * Created by hadoop on 17/10/17.
 */
public class WIggleSort {
    public void wiggleSort(int[] nums) {
        if (nums.length == 0) return;
//        for(int i:nums){
//            System.out.print(i);
//        }
//        System.out.println();
        int median = findKthLargest(nums, (nums.length + 1) / 2);
//        for(int i:nums){
//            System.out.print(i);
//        }
        System.out.println();
        int odd = nums.length %2 == 1 ? nums.length - 2 : nums.length - 1;
        int even = nums.length % 2 == 0? nums.length - 2 : nums.length - 1;
        int[] temp = new int[nums.length];
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] > median) {
              //  System.out.println("entry here odd"+nums[i]);
                temp[odd] = nums[i];
                odd -= 2;
            }
            else if (nums[i] < median) {
               // System.out.println("entry here even"+nums[i]);
                temp[even] = nums[i];
                even -= 2;
            }
        }
        while (odd >=1) {
            temp[odd] = median;
            odd -= 2;
        }
        while (even>=0) {
            temp[even] = median;
            even -= 2;
        }
//        for(int i:temp){
//            System.out.print(i);
//        }
//        System.out.println();
        for (int i = 0; i < nums.length; i++) nums[i] = temp[i];
//        for(int i:nums){
//            System.out.print(i);
//        }
//        System.out.println();
    }

    public int findKthLargest(int[] a, int k) {
        int n = a.length;
        return quickSelect(a, 0, n - 1, n - k + 1);
    }

    public int quickSelect(int[] a, int lo, int hi, int k) {
        int i = lo, j = hi, pivot = a[hi];
        while (i < j) {
            if (a[i++] > pivot) swap(a, --i, --j);
        }
        swap(a, i, hi);

        int m = i - lo + 1;
        if (m == k) return a[i];
        else if (m > k) return quickSelect(a, lo, i - 1, k);
        else return quickSelect(a, i + 1, hi, k - m);
    }

    public void swap(int[] a, int i, int j) {
        int tmp = a[i];
        a[i] = a[j];
        a[j] = tmp;
    }

    public static void main(String[] args) {
        WIggleSort wIggleSort = new WIggleSort();
        wIggleSort.wiggleSort(new int[]{1, 2, 3, 4, 5, 6});
    }
}
package BasicAlgorithms.QuickSelect;

/**
 * Created by hadoop on 11/10/17.
 */
public class KthLargest {
    public static void main(String args[]){
        int array[] ={4,3,2,5,6,9};

        // min head best solution to find kth largest
        //          PriorityQueue<Integer> pq = new PriorityQueue<>(new Comparator<Integer>() {
//             @Override
//             public int compare(Integer o1, Integer o2) {
//                 return o1-o2;
//             }
//         });
//         for(int i=0;i<nums.length;i++){
//             if(i<k) {
//                 pq.add(nums[i]);
//             }
//             else {
//                 if(nums[i] >pq.peek()){
//                     pq.poll();
//                     pq.add(nums[i]);
//                 }

//             }
//         }
        System.out.println(kthlargest(array,4,0,array.length-1));
        System.out.println(findKthSmallestQuick(0,array.length-1,array,4));
    }
    public static int kthlargest(int []array,int k,int start,int end){

        if(end<start){
            return -1;
        }
        if(start == end){
            return array[start];
        }
        int partition = getpartition(array,k,start,end);
        if(partition-start +1 == k){
            return array[partition];
        }
        if(partition-start+1 >k){
            System.out.println("start"+start);
            System.out.println("partition"+partition);
            return kthlargest(array,k,start,partition-1);
        }
        else {
            return kthlargest(array,k-partition-1+start,partition+1,end);
        }
    }

    private static int getpartition(int[] array, int k, int start, int end) {
        int startindex= start;
        int middle = start;
        int endindex = end;
        int pivot = array[(start+end)/2];
        while (middle<=endindex){
            if(array[middle] == pivot){
                middle++;
            }
            if(array[middle]<pivot){
                swap(array,startindex,middle);
                startindex++;
                middle++;
            }
            if(array[middle]>pivot){
                swap(array,endindex,middle);
                endindex--;
            }
        }
        return startindex;
    }

    private static void swap(int[] array, int startindex, int middle) {
        int temp = array[startindex];
        array[startindex] = array[middle];
        array[middle] = temp;
    }
    static int findKthLargestQuickSelect(int nums[], int k){
        int start = 0;
        int end = nums.length-1;
        k = nums.length-k+1;
        return findKthSmallestQuick(start,end,nums,k);
    }
    static int findKthSmallestQuick(int start, int end, int nums[], int k){
        if(start>end){
            return -1;
        }
        if(start == end){
            return nums[start];
        }
        int index = partitionDutch(nums,start,end);
        if(index +1 -start == k){
            return nums[index];
        }
        else if(index+1-start<k){
            return findKthSmallestQuick(index+1,end,nums,k+start-index-1);
        }
        else {
            return findKthSmallestQuick(start,index-1,nums,k);
        }
    }

    private static int partitionDutch(int []nums,int start,int end) {
        int pivot= nums[start];
        int left = start;
        int right = end;
        int middle = start;
        while (middle<=right){
            if(nums[middle] == pivot){
                middle++;
            }
            else if(nums[middle]<pivot){
                swap(nums,left,middle);
                middle++;
                left++;
            }
            else {
                swap(nums,right,middle);
                right--;
            }
        }
        return left;
    }
}
package BasicAlgorithms.IntervalProblems;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.PriorityQueue;

/**
 * Created by hadoop on 16/10/17.
 */
public class MergeIntervals {
    private class Point {
        int pos;
        int flag;

        Point(int pos, int flag) {
            this.pos = pos;
            this.flag = flag;
        }
    }

    public List<Interval> merge(List<Interval> intervals) {
        List<Interval> mergedIntervals = new ArrayList<>();
        if(intervals == null || intervals.size() == 0){
            return mergedIntervals;
        }
        PriorityQueue<Point> priorityQueue = new PriorityQueue<>(new Comparator<Point>() {
            @Override
            public int compare(Point o1, Point o2) {
                return o1.pos-o2.pos;
            }
        });

        for(Interval interval:intervals){
            priorityQueue.add(new Point(interval.start,1));
            priorityQueue.add(new Point(interval.end,-1));
        }

        int count = 0;
        int start=0;
        int end=0;
        while (!priorityQueue.isEmpty()){
            Point point = priorityQueue.poll();
            if(count == 0){ //detect start
                start = point.pos;
            }
            count  = count+point.flag;
            // processing all points on same position
            while (!priorityQueue.isEmpty() && priorityQueue.peek().pos == point.pos){
                point = priorityQueue.poll();
                count = count+point.flag;
            }
            if(count == 0){ // detect end
                end = point.pos;
                mergedIntervals.add(new Interval(start,end));
            }
        }
        return mergedIntervals;
    }
}package BasicAlgorithms.IntervalProblems;

/**
 * Definition for an interval.
 * public class Interval {
 *     int start;
 *     int end;
 *     Interval() { start = 0; end = 0; }
 *     Interval(int s, int e) { start = s; end = e; }
 * }
 */
import java.util.*;
public class Solution {
    // Each room has a schedule
    public class Schedule {
        int end;
        Schedule(int end) {
            this.end = end;
        }
    }
    public int minMeetingRooms(Interval[] intervals) {
        if (intervals == null || intervals.length == 0) return 0;
        // Sort intervals by start time
        Arrays.sort(intervals, new Comparator<Interval>() {
            public int compare(Interval a, Interval b) {
                return a.start - b.start;
            }
        });
        // PriorityQueue to represent rooms
        PriorityQueue<Schedule> rooms = new PriorityQueue<Schedule>(10, new Comparator<Schedule>() {
            public int compare(Schedule a, Schedule b) {
                return a.end - b.end;
            }
        });
        rooms.offer(new Schedule(intervals[0].end));
        for (int i = 1; i < intervals.length; i++) {
            int lastEnd = rooms.peek().end;
            if (intervals[i].start >= lastEnd) {
                rooms.poll();
            }
            rooms.offer(new Schedule(intervals[i].end));
        }
        return rooms.size();
    }
}package BasicAlgorithms.IntervalProblems;

import java.util.Comparator;
import java.util.PriorityQueue;

/**
 * Created by hadoop on 16/10/17.
 */
public class MeetingRooms2 {
    private class Point{
        int pos;
        int flag;
        Point(int pos,int flag){
            this.pos = pos;
            this.flag = flag;
        }
    }

    int meetingrooms(Interval[] intervals){


        if(intervals == null || intervals.length==0){
            return 0;
        }
        PriorityQueue<Point> priorityQueue = new PriorityQueue<>(new Comparator<Point>() {
            @Override
            public int compare(Point o1, Point o2) {
                return o1.pos-o2.pos;
            }
        });

        for(Interval interval:intervals){
            priorityQueue.add(new Point(interval.start,1));
            priorityQueue.add(new Point(interval.end,-1));
        }
        int count=0;
        int maxmeetingrooms=0;
        while (!priorityQueue.isEmpty()){
            Point point = priorityQueue.poll();
            count = count+point.flag;
            while (!priorityQueue.isEmpty() && point.pos == priorityQueue.peek().pos){
                Point point1 = priorityQueue.poll();
                count = count +point1.flag;
            }
            maxmeetingrooms = Math.max(maxmeetingrooms,count);
        }
        return maxmeetingrooms;
    }

}
package BasicAlgorithms.IntervalProblems;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;

/**
 * Created by hadoop on 16/10/17.
 */
public class MinArrows {
    private static class Point{
        int start;
        int end;

        @Override
        public String toString() {
            return "Point{" +
                    "start=" + start +
                    ", end=" + end +
                    '}';
        }
    }
    public static List<Point> findMinArrowShotsHelper(int[][] points) {
        if(points.length ==0){
            return null;
        }
        Arrays.sort(points, new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                if(o1[0]==o2[0]){
                    return o1[1]-o2[1];
                }
                return o1[0]-o2[0];
            }
        });
        Point p = new Point();
        p.start = points[0][0];
        p.end = points[0][1];
        System.out.println(p);
        List<Point> list = new ArrayList<>();
        for(int i=1;i<points.length;i++){
            if(points[i][0]>p.end){
                Point p1 = new Point();
                p1.start = p.start;
                p1.end = p.end;
                list.add(p1);
                p.start = points[i][0];
                p.end = points[i][1];
            }
            else {
                p.start = points[i][0];
                p.end = Math.min(p.end,points[i][1]);
                System.out.println("p overlap"+p);
            }
        }
        Point p1 = new Point();
        p1.start = p.start;
        p1.end = p.end;
        list.add(p1);
        return list;
    }

    public static void main(String args[]){
        int [][]points = {{10,16}, {2,8}, {1,6}, {7,12}};
        System.out.println(findMinArrowShotsHelper(points));
    }
}
package BasicAlgorithms.IntervalProblems;

import java.util.ArrayList;
import java.util.List;

/**
 * Created_By: stefanie
 * Date: 14-9-20
 * Time: 7:08
 *
 * There is N task, each one need use a un-shared resource. Given the start time and end time of each task, it will use
 * the resource in duration of [start-time, end-time), write code to select the maximal set of un-conflict tasks.
 * Assume the input data about the tasks are sorted by end-time
 *
 * Greedy Assumption:
 *   The earlier ended task always in the maximal set of un-conflict tasks.
 *
 */
public class TQ37_TaskSelection {

    public static List<Integer> select(int[] start, int[] end){
        List<Integer> tasks = new ArrayList<>();

        int time = end[0];
        tasks.add(1);

        for(int i = 1; i < end.length; i++) {
            if(start[i] >= time){
                tasks.add(i + 1);
                time = end[i];
            }
        }

        return tasks;
    }

}
package BasicAlgorithms.IntervalProblems;

class Interval {
     int start;
     int end;
      Interval() { start = 0; end = 0; }
      Interval(int s, int e) { start = s; end = e; }
}package BasicAlgorithms.IntervalProblems;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.PriorityQueue;

/**
 * Created by hadoop on 16/10/17.
 */
public class InsertInterval {
    private class Point{
        int pos;
        int flag;
        Point(int pos,int flag){
            this.flag = flag;
            this.pos = pos;
        }
    }

    public ArrayList<Interval> insert(ArrayList<Interval> intervals, Interval newInterval) {
            ArrayList<Interval> ans = new ArrayList<>();
            if(intervals == null || intervals.size() == 0){
                if(newInterval!=null){
                    ans.add(newInterval);
                }
                return ans;
            }
        PriorityQueue<Point> priorityQueue = new PriorityQueue<>(new Comparator<Point>() {
            @Override
            public int compare(Point o1, Point o2) {
                return o1.pos-o2.pos;
            }
        });
            for(Interval interval:intervals){
                priorityQueue.add(new Point(interval.start,1));
                priorityQueue.add(new Point(interval.end,-1));
            }
            if(newInterval!=null) {
                priorityQueue.add(new Point(newInterval.start, 1));
                priorityQueue.add(new Point(newInterval.end, -1));
            }
            int start = 0;
            int end = 0;
            int count=0;
            while (!priorityQueue.isEmpty()){
                Point point = priorityQueue.poll();
                if(count == 0 ){
                    start = point.pos;
                }
                count = count+point.flag;
                while (!priorityQueue.isEmpty() && point.pos == priorityQueue.peek().pos){
                    point = priorityQueue.poll();
                    count = count + point.flag;
                }
                if(count == 0){
                    end = point.pos;
                    ans.add(new Interval(start,end));
                }
            }
            return ans;
    }

    public ArrayList<Interval> insertNew(ArrayList<Interval> intervals, Interval newInterval) {
        ArrayList<Interval> ans = new ArrayList<>();
        if(intervals == null || intervals.size() == 0){
            if(newInterval!=null){
                intervals.add(newInterval);
            }
            return intervals;
        }
        int positiontoinsert =-1;
        for(int i=0;i<intervals.size();i++){
            if(newInterval.start<=intervals.get(i).start) {
                positiontoinsert = i;
                break;
            }
        }
        if(positiontoinsert == 0){
            intervals.add(0,newInterval);
        }

        else if(positiontoinsert == -1){
            intervals.add(intervals.size()-1,newInterval);
        }
        else {
            intervals.add(positiontoinsert-1,newInterval);
        }

        Interval prev = intervals.get(0);

        for(int i=1;i<intervals.size();i++){
            Interval current = intervals.get(i);

            if(prev.end>=current.start){
                // max end point
                prev.end = Math.max(current.end,prev.end);
                intervals.remove(i);
                i--;
            }
            else {
                prev = current;
            }
        }
        return intervals;
    }
}

/*


List<Integer> nums = new ArrayList();
nums.add(1);
nums.add(2);
nums.add(3);
...
nums.add(10);

System.out.println("BEFORE REMOVE: " + nums);

for (Integer integer : nums) {
    if (integer < 3) {
        //not allowed
        nums.remove(integer);
    }
}



Iterator<Integer> it = nums.iterator();
while (it.hasNext()) {
    Integer integer = it.next();
    if (integer < 3) {
        it.remove();
    }
}
The only down-side of this approach is that you need to switch your for-each to a while. However, this approach is the most efficient one, especially for LinkedList where it is O(n)O(n) (it's O(n2)O(n2) for ArrayList because it has to copy array data on each remove(index) call). This is the approach I would recommend in most cases.



Use CopyOnWriteArrayList
and if you want to remove it, do the following:

for (Iterator<String> it = userList.iterator(); it.hasNext() ;)
{
    if (wordsToRemove.contains(word))
    {
        it.remove();
    }
}

The iterators returned by this class's iterator and listIterator methods are fail-fast: if the list is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove or add methods, the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future.
List<String> names = ....
Iterator<String> i = names.iterator();
while (i.hasNext()) {
   String s = i.next(); // must be called before you can call i.remove()
   // Do something
   i.remove();
}

clone before you remove
for (String databaseName : new ArrayList<String>(names)) {
    // Do something
    names.remove(nameToRemove);
}


 */
package BasicAlgorithms.IntervalProblems;

import java.util.Comparator;
import java.util.PriorityQueue;

/**
 * Created by hadoop on 16/10/17.
 */
public class MeetingRooms {
    private class Point {
        int pos;
        int flag;

        public Point(int pos, int flag) {
            this.pos = pos;
            this.flag = flag;
        }
    }
    public boolean canattendAllMeetings(Interval[] intervals){
        if(intervals == null || intervals.length == 0){
            return true;
        }

        PriorityQueue<Point> priorityQueue = new PriorityQueue<>(new Comparator<Point>() {
            @Override
            public int compare(Point o1, Point o2) {
                return o1.pos-o2.pos;
            }
        });

        for(Interval interval:intervals){
            priorityQueue.add(new Point(interval.start,1));
            priorityQueue.add(new Point(interval.end,-1));
        }
        int count=0;
        while (!priorityQueue.isEmpty()){

            Point point = priorityQueue.poll();
            count = count + point.flag;

            while (!priorityQueue.isEmpty() && priorityQueue.peek().pos == point.pos){
                Point point1 = priorityQueue.poll();
                count = count+point1.flag;
            }
            //at anytime count sould not be more than 1
            if(count>1){
                return false;
            }
        }
        return true;
    }
}

// determine if a person can attend all meetings ..



package BasicAlgorithms.IntervalProblems;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;

/**
 * Created by hadoop on 16/10/17.
 */
public class OverLapIntervals {
    public int eraseOverlapIntervals(Interval[] intervals) {
        if (intervals == null || intervals.length == 0) {
            return 0;
        }
        Arrays.sort(intervals, new Comparator<Interval>() {
            @Override
            public int compare(Interval o1, Interval o2) {
                return o1.start - o2.start;
            }
        });
        List<Interval> intervalList = new ArrayList<>();
        // in case u r intersted to find intervals, we can add into list
        Interval prev = intervals[0];
        int count = 0;
        int totalcount = 0;
        for (int i = 1; i < intervals.length; i++) {
            Interval current = intervals[i];
            if (current.start >= prev.end) {
                totalcount = totalcount + count;
                count = 0;
                prev.start = current.start;
                prev.end = current.end;
            } else {
                prev.start = current.start;
                prev.end = Math.min(prev.end, current.end);
                intervalList.add(new Interval(prev.start, prev.end));
                count++;
            }
        }
        totalcount = totalcount + count;
        System.out.println(intervalList);
        return totalcount;
    }

    public static void main(String args[]) {

    }
}

    /*
https://discuss.leetcode.com/topic/94830/simple-clustering-o-n-solution
https://discuss.leetcode.com/topic/72901/a-concise-template-for-overlapping-interval-problem/2

    Actually, the problem is the same as "Given a collection of intervals, find the maximum number of intervals that are non-overlapping." (the classic Greedy problem: Interval Scheduling). With the solution to that problem, guess how do we get the minimum number of intervals to remove? : )

Sorting Interval.end in ascending order is O(nlogn), then traverse intervals array to get the maximum number of non-overlapping intervals is O(n). Total is O(nlogn).

    public int eraseOverlapIntervals(Interval[] intervals) {
        if (intervals.length == 0)  return 0;

        Arrays.sort(intervals, new myComparator());
        int end = intervals[0].end;
        int count = 1;

        for (int i = 1; i < intervals.length; i++) {
            if (intervals[i].start >= end) {
                end = intervals[i].end;
                count++;
            }
        }
        return intervals.length - count;
    }

    class myComparator implements Comparator<Interval> {
        public int compare(Interval a, Interval b) {
            return a.end - b.end;
        }
    }

    In fact, sort by start or by end doesn't matter at all. Sort by start also works.

18 / 18 test cases passed
Status: Accepted
Runtime: 9 ms

class Solution {
public:
    int eraseOverlapIntervals(vector<Interval>& intervals) {
        sort(intervals.begin(), intervals.end(), [](Interval& i1, Interval& i2){ return i1.start < i2.start; });
        int res = 0, e = INT_MIN;
        for (auto& itv : intervals) {
            if (itv.start < e) {
                res++;
                if (itv.end < e) e = itv.end;
            } else e = itv.end;
        }
        return res;
    }
};

hi same strategy, but don't need to use intervals.length - count
we can directly count how many we need to kick out

public int eraseOverlapIntervals(Interval[] intervals) {
    if (intervals.length == 0)
        return 0;
    Arrays.sort(intervals, new MyComparator());
    int count = 0;
    int end = intervals[0].end;
    for (int i =1; i < intervals.length; i++){
        if(intervals[i].start < end){
            count += 1;
        }
        else end = intervals[i].end;
    }
    return count;

}
2.Why sort by finish time can get max compatible intervals? Refer to CLRS Theorem 16.1. Briefly speaking, if earliest finished is not included, we can always replace the first interval in the set with it.

    public int eraseOverlapIntervals(Interval[] intervals) {
        Arrays.sort(intervals, Comparator.comparingInt(i -> i.end));
        int max = 0, lastend = Integer.MIN_VALUE;
        for (Interval in : intervals) {
            if (lastend <= in.start) {
                lastend = in.end;
                max++;
            }
        }
        return intervals.length - max;
    }
     */package BasicAlgorithms.TwoPointers;

/**
 * Created by hadoop on 13/10/17.
 */
public class TrappedWater {
    public static void main(String[] args) {
        int nums[]={0,1,0,2,1,0,1,3,2,1,2,1};
        System.out.println(trap(nums));
    }
static  int trap(int heights[]){
    int left = 0;
    int right = heights.length-1;
    int water=0;
    while (left<right){
        int min = Math.min(heights[left],heights[right]);
        if(heights[left] == min){
            left++;
            while (left<right && min>heights[left]){
                water = water+ min-heights[left];
                left++;
            }
        }
        else {
            right--;
            while (left<right && min >heights[right]){
                water = water + min-heights[right];
                right--;
            }
        }
    }
    return water;
}
    static  int trapWaterAgainBetterSOlution(int heights[]) {
    int maxIndex = find(heights);
    int sum=0;
    for(int i=0;i<maxIndex;i++){

        int prev = 0;
        // whenever there is increase in height
        if(heights[i] >prev){
            sum = sum + (heights[i]-prev) *(maxIndex-i);
            prev = heights[i];
        }
        sum = sum - heights[i];
    }
    int prev = 0;
    for(int i=heights.length-1;i>maxIndex;i--){
        if(heights[i]>prev){
            sum = sum +(heights[i]-prev) * (maxIndex-i);
            prev = heights[i];
        }
        sum = sum -heights[i];
    }

    return sum;
    }

    private static int find(int[] heights) {
        int max = Integer.MIN_VALUE;
        int index = -1;
        for(int i=0;i<heights.length;i++){
            if(heights[i]>max){
                max = heights[i];
                index = i;
            }
        }
        return index;
    }
}
package BasicAlgorithms.TwoPointers;

/**
 * Created by hadoop on 13/10/17.
 */
public class ProductArraySelf {
    public static void main(String[] args) {
        int []array = {1,2,3,4};
        int []ans = productapartfromself(array);
        for(int i=0;i<ans.length;i++){
            System.out.println(ans[i]);
        }
    }
    static int [] productapartfromself(int []nums){
        int []left = new int[nums.length];
        int right[] = new int[nums.length];
        left[0] = 1;
        for(int i=1;i<nums.length;i++){
            left[i] = left[i-1]*nums[i-1];
        }
        right[nums.length-1] = 1;
        for(int i=nums.length-2;i>=0;i--){
            right[i] = right[i+1]*nums[i+1];
        }
        for(int i=0;i<nums.length;i++){
            left[i] = left[i]*right[i];
        }
        return left;
    }
}
package BasicAlgorithms.TwoPointers;

/**
 * Created by hadoop on 13/10/17.
 */
public class RemoveElement {
    int remove(int nums[],int val){
        int index =0;
        int i=0;
        while (i<nums.length){
            if(nums[i]!=val){
                nums[index++] = nums[i];
            }
            i++;
        }
        return index;
    }
    int removeandmovevaltoend(int nums[],int val){
        int start = 0;
        int end = nums.length-1;
        while (start<=end){
            if(nums[start] == val){
                swap(nums,start,end);
                end--;
            }
            else {
                start++;
            }
        }
        return start;
    }

    private void swap(int[] nums, int start, int end) {
        int temp = nums[start];
        nums[start] = nums[end];
        nums[end] = temp;
    }
}
package BasicAlgorithms.TwoPointers;

class SortColors {
    public void sortColors(int[] a) {
        
        int start =0;
        int end = a.length-1;
        int middle = 0;
        while(middle<=end){
            if(a[middle] == 1){
                middle++;
            }
            else if(a[middle] == 0){
                swap(a,middle,start);
                start++;
                middle++;
            }
            else if(a[middle] == 2){
                swap(a,middle,end);
                end--;
            }
        }
    }
    private void swap(int[] nums, int start, int end) {
        int temp = nums[start];
        nums[start] = nums[end];
        nums[end] = temp;
    }
}package BasicAlgorithms.TwoPointers;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;

/**
 * Created by hadoop on 13/10/17.
 */
 class TwoSumAgain {
    public static void main(String[] args) {
        int nums[] = {3,2,4};
        int target = 6;
        int ans[] = twoSum(nums,target);
        System.out.println(ans[0]);
        System.out.println(ans[1]);
    }
    public static int[] twoSum(int[] nums, int target) {
        if(nums == null || nums.length == 0){
            return new int[]{-1,-1};
        }
        HashMap<Integer,Integer> hashMap = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            if(hashMap.containsKey(target-nums[i])){
                System.out.println(target-nums[i]);
                return new int[]{hashMap.get(target-nums[i]),i};
            }
            else {
                hashMap.put(nums[i],i);
            }
        }
        return new int[]{-1,-1};
    }
    public static int[] twoSumSort(int[] numbers, int target) {
        int start = 0;
        int end = numbers.length-1;
        while (start<end){
            if(numbers[start]+numbers[end] == target){
                return new int[]{start,end};
            }
            else if(numbers[start]+numbers[end] >target){
                end--;
            }
            else {
                start++;
            }
        }
        return new int[]{-1,-1};
    }


    }

    class TwoSum {
     Map<Integer,Integer> sortedMap = new HashMap<>();

     public TwoSum() {

     }

        /** Add the number to an internal data structure.. */
        public void add(int number) {
            if(sortedMap.containsKey(number)){
                sortedMap.put(number,2);
            }
            sortedMap.put(number,1);
        }

        /** Find if there exists any pair of numbers which sum is equal to the value. */
        public boolean find(int value) {
            Set<Integer> set = sortedMap.keySet();
            for(Integer x:set){
                if(value == 2*x) {
                    if(sortedMap.get(x) ==2){
                        return true;
                    }
                    else return false;
                }
                else {
                    if (set.contains(value - x)) {
                        return true;
                    }
                }
            }
            return false;
        }

        public boolean findagain(int value){
            for(int key:sortedMap.keySet()){
                if(sortedMap.containsKey(value-key)){
                    if(sortedMap.get(value-key)>=2 || sortedMap.get(value-key) == 1 && key!=value-key){
                        return true;
                    }
                }
            }
            return false;
        }

    }
package BasicAlgorithms.TwoPointers;

/**
 * Created by hadoop on 13/10/17.
 */
public class DuplicatesAgain {
    public static void main(String args[]){
        int nums[] = {2,5,1,1,4,3};
        int ans = duplicate(nums);
        System.out.println("ans"+ans);
    }

    private static int duplicate(int[] nums) {
        int slow = 0;
        int fast = 0;
        do{
            slow = nums[slow];
            fast = nums[nums[fast]];
        }while (slow!=fast);

        slow = 0;
        while (slow!=fast){
            slow = nums[slow];
            fast = nums[fast];
        }
        return slow+1;
    }

}
package BasicAlgorithms.TwoPointers;

import SmallAndAmazingGitBookToGiveYouConfidence.KsumDP;

/**
 * Created by hadoop on 13/10/17.
 */
public class Ksum {
    int ksumtotal(int []num,int k ,int target) {
        int ans [][][] = new int[k+1][target+1][num.length];

        for(int p=0;p<num.length;p++){
            ans[0][0][p]++;
        }

        for(int i=0;i<num.length;i++){
            ans[1][num[i]][i]++;
        }
        System.out.println("k "+k);

        for(int i=2;i<k+1;i++){
            for(int j=0;j<target+1;j++){
                for(int y=1;y<num.length;y++){
                    if(y+1<k){
                        continue;
                    }
                    if(j>=num[y]) {
                        ans[i][j][y] += ans[i - 1][j - num[y]][y - 1];
                    }
                        ans[i][j][y] += ans[i][j][y-1];
                }
            }
        }
        return ans[k][target][num.length-1];
    }
    public static void main(String[] args) {
        Ksum  ksum = new Ksum();
        int []num = {1,2,3,4};
        int target = 5;
        int k =2;
        System.out.println(ksum.ksumtotal(num,2,8));
        System.out.println(ksum.kSum(num,2,8));
        System.out.println(ksum.ksumtotalagain(num,2,5));


    }
    public int kSum(int A[], int k, int target) {
        // write your code here
        if (target < 0) {
            return 0;
        }
        int len = A.length;
        int[][][] dp = new int[k + 1][len + 1][target + 1];
        dp[0][0][0] = 1;

        for (int i = 0; i <= k; i++) {
            for (int j = 0; j <= len; j++) {
                for (int t = 0; t <= target; t++) {
                    if (i == 0 && t == 0) {
                        dp[i][j][t] = 1;
                    } else if (!(i == 0 || j == 0 || t == 0)) {
                        dp[i][j][t] = dp[i][j-1][t];
                        if (t - A[j - 1] >= 0) {
                            dp[i][j][t] += dp[i - 1][j - 1][t - A[j - 1]];
                        }
                    }
                }
            }
        }
        return dp[k][len][target];
    }

    int ksumtotalagain(int []A,int k ,int target) {
        if(target<0){
            return 0;
        }
        int count [][][] = new int[k+1][A.length+1][target+1];
        count[0][0][0] = 1;
        for(int i=0;i<k+1;i++){
            for(int j=0;j<A.length+1;j++){
                for(int t=0;t<target+1;t++){
                    if(i ==0 && t ==0){
                        count[i][j][t] =1;
                        continue;
                    }
                    if(i!=0 && j!=0 && t!=0){
                        count[i][j][t] = count[i][j-1][t];
                        if(t>=A[j-1]){
                            count[i][j][t]+= count[i-1][j-1][t-A[j-1]];
                            }
                        }
                    }
                }
            }
            return count[k][A.length][target];
        }

    }

package BasicAlgorithms.TwoPointers;

/**
 * Created by hadoop on 13/10/17.
 */
public class Minimumsizesubarray {
    public static void main(String[] args) {
        int nums[] = {2,3,1,2,4,3};
        int sum = 7;
        System.out.println(minsize(sum,nums));
    }
    public static int minsize(int s, int []nums){
        int minlength = Integer.MAX_VALUE;
        int right=0;
        int left=0;
        int sum = 0;

        while (right<nums.length){
            sum = sum + nums[right];
            while (sum>=s){
                sum = sum-nums[left];
                minlength = Math.min(minlength,right-left+1);
                left = left+1;
            }
            right++;
        }
        return minlength;
    }
}
package BasicAlgorithms.TwoPointers;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;

/**
 * Created by hadoop on 13/10/17.
 */
public class Sum3Smaller {
    static int ans (int number[],int k){
        int count = 0;
        Arrays.sort(number);
        for(int i=0;i<number.length-2;i++){
            if(i>0 && number[i] == number[i-1]){
                continue;
            }
            int start = i+1;
            int end = number.length-1;
            while (start<end){
                if(start>i+1 && number[start] == number[start-1]){
                    start++;
                    continue;
                }
                if(end<number.length-1 && number[end] == number[end+1]){
                    end--;
                    continue;
                }
                int target = number[i]+number[start]+number[end];
                if(target <k){
                    count = count+end-start;
                    start++;
                }
                else if (target>=k){
                    end--;
                }
            }
        }
        return count;
    }
}
package BasicAlgorithms.TwoPointers;

import java.util.ArrayList;
import java.util.Arrays;

public class KsumUsingDFS {
    public ArrayList<ArrayList<Integer>> kSumII(int[] A, int k, int target) {
			        // write your code here
			        ArrayList<ArrayList<Integer>> res = new ArrayList<>();
			        ArrayList<Integer> item = new ArrayList<>();
			        Arrays.sort(A);
			        helper(A, 0, k, target, res, item);
			        return res;
			    }
			    
			    public void helper(int[] A,int start, int k, int target, ArrayList<ArrayList<Integer>> res, ArrayList<Integer> item) {
			        if (target < 0) {
			            return;
			        }
			        if (target == 0 && item.size() == k) {
			            res.add(new ArrayList<>(item));
			            return;
			        }
			        for (int i = start; i < A.length; i++) {
			            item.add(A[i]);
			            helper(A, i + 1, k, target - A[i], res, item);
			            item.remove(item.size() - 1);
			        }
    }
}


 class KsumDFS{

	public int ksum(int []array,int k , int target){
		if(k<1||k >array.length){
			return 0;
		}
		return ksumhelper(array,k,target,0);
	}

	private int ksumhelper(int[] array, int k, int target, int index) {
		int totalways = 0;
		if(target<0){
			return 0;
		}
		if(k<0){
			return 0;
		}
		if(k == 0){
			if(target ==0) return 1;
			return 0;
		}
		for(int i=index;i<array.length;i++){
			target = target-array[i];
			totalways +=ksumhelper(array,k-1,target,i+1);
			target = target-array[i];
		}
		return totalways;
	}
}package BasicAlgorithms.TwoPointers;

/**
 * Created by hadoop on 13/10/17.
 */
public class MaxWater {
    int maxwater(int nums[]){
        int left = 0;
        int right  = nums.length-1;

        int ans = Integer.MIN_VALUE;
        while (left<right){
            if(nums[left]<nums[right]){
                ans = Math.max(ans,(right-left+1)*nums[left]);
                left++;
            }
            else{
                ans = Math.max(ans,(right-left+1)*nums[right]);
                right++;
            }
        }
        return ans;
    }
}
package BasicAlgorithms.TwoPointers;

import java.util.ArrayList;

/**
 * Created by hadoop on 13/10/17.
 */
public class KsumDFSApproach {
    ArrayList<ArrayList<Integer>> result = new ArrayList<>();
    ArrayList<Integer> path = new ArrayList<>();
    public ArrayList<ArrayList<Integer>> kSumII(int[] A, int k, int target) {
        ksumhelper(0,k,A,target);
        return result;
    }

    private void ksumhelper(int index, int k, int[] a, int target) {
        if(target<0){
            return;
        }
        if(k<0){
            return;
        }
        if(target == 0 && k ==0){
            result.add(new ArrayList<>(path));
            return;
        }
        else {
            for(int i=index;i<a.length;i++){
                path.add(a[i]);
                ksumhelper(i+1,k-1,a,target-a[i]);
                path.remove(path.size()-1);
            }
        }
    }

    public static void main(String[] args) {
        int nums []={1,2,3,4,5};
        int target = 5;
        int k =2;
        KsumDFSApproach ksumDFSApproach = new KsumDFSApproach();
        System.out.println(ksumDFSApproach.kSumII(nums,k,target));
    }
}package BasicAlgorithms.TwoPointers;

/**
 * Created by hadoop on 13/10/17.
 */
public class MoveZeros {
    public static void main(String[] args) {
        int nums[]= {0,1,0,3,12};
        movezero(nums);
        for(int i=0;i<nums.length;i++){
            System.out.println(nums[i]);
        }
    }
    static void movezero(int nums[]){
        int firstZero =-1;
        for(int i=0;i<nums.length;i++){
            if(nums[i]!=0){
                swap(nums,i,++firstZero);
            }
        }
    }
    private static void swap(int[] nums, int start, int end) {
        int temp = nums[start];
        nums[start] = nums[end];
        nums[end] = temp;
    }
}
package BasicAlgorithms.TwoPointers;

import java.util.Arrays;

class Duplicates {
 public int findDuplicate(int[] nums) {
        Arrays.sort(nums);
        int start = 0;
        int end = nums.length-1;
        while(start<end){
            int mid = start + (end-start)/2;
            if(mid+1<=nums[mid]){
                start = mid +1;
            }
            else{
                end = mid;
            }
        }
        return nums[start];
    }

}package BasicAlgorithms.TwoPointers;

import java.util.*;

/**
 * Created by hadoop on 13/10/17.
 */
public class Sum3 {
    HashSet set = new HashSet();

    public static void  main(String args[]){
            int nums []={-1,0,1,2,-1,-4};
        System.out.println(ans(nums));
    }
    static List<List<Integer>> ans ( int number[]){
        List<List<Integer>> list = new ArrayList<>();
        Arrays.sort(number);
        for(int i=0;i<number.length-2;i++){
            if(i>0 && number[i] == number[i-1]){
                continue;
            }
            int start = i+1;
            int end = number.length-1;
            while (start<end){
                if(start>i+1 && number[start] == number[start-1]){
                    start++;
                    continue;
                }
                if(end<number.length-1 && number[end] == number[end+1]){
                    end--;
                    continue;
                }
                int target = number[i]+number[start]+number[end];
                if(target == 0){
                    List linkedlist = new LinkedList();
                    linkedlist.add(number[i]);
                    linkedlist.add(number[start]);
                    linkedlist.add(number[end]);
                    list.add(linkedlist);
                    start++;
                    end--;
                }
                else if(target>0){
                    end--;
                }
                else {
                    start++;
                }
            }
        }
        return list;
    }
}
package BasicAlgorithms.UnionFInd;

import java.util.HashMap;
import java.util.Map;

/**
 * Created by hadoop on 12/10/17.
 */
//public class DisjointSet {
//    int count;
//    private Map<Long,Node> map = new HashMap<>();
//    private class Node{
//        long data;
//        Node parent;
//        int rank;
//    }
//    public void makeSet(long data){
//        count++;
//        Node node = new Node();
//        node.data = data;
//        node.parent = node;
//        node.rank = 0;
//        map.put(data,node);
//    }
//
//    public boolean union(long data1,long data2){
//        Node node1 = map.get(data1);
//        Node node2 = map.get(data2);
//
//        if(node1 == null || node2 == null){
//            return false;
//        }
//        Node parent1 = findSet(node1);
//        Node parent2 = findSet(node2);
//
//        if(parent1 == parent2){
//            return false;
//        }
//        if(parent1.rank<parent2.rank){
//            parent1.parent = parent2;
//        }
//        else if(parent2.rank<parent1.rank){
//            parent2.parent = parent1;
//        }
//        else {
//            parent2.parent = parent1;
//            parent1.rank = parent1.rank+1;
//        }
//        count--;
//        System.out.println("count "+count);
//        return true;
//    }
//    public boolean connected(long data1,long data2){
//        Node node1 = map.get(data1);
//        Node node2 = map.get(data2);
//
//        if(node1 == null || node2 == null){
//            return false;
//        }
//        Node parent1 = findSet(node1);
//        Node parent2 = findSet(node2);
//        if(parent1 == parent2){
//            return true;
//        }
//        return false;
//    }
//
//    private Node findSet(Node node1) {
//        Node parent= node1.parent;
//        if(parent == node1){
//            return parent;
//        }
//        node1.parent = findSet(node1.parent);
//        return node1.parent;
//    }
//    public Node findSet(long x){
//        Node node = map.get(x);
//        if(node == null){
//            return null;
//        }
//        else {
//            return findSet(node);
//        }
//    }
//    public int getCount(){
//        return count;
//    }
//}
// disjoint set make node and hashmap of
    //  koi value mein insert karna hu inside i create node of that type and put mapping
    // in the hashmap
    //
public class DisjointSet<T> {
    Map<T,Node> map = new HashMap<>();
    int count;
    private class Node<T>{
        T data;
        Node parent;
        int rank;
    }
    public void makeset(T data){
        Node<T> node = new Node<>();
        node.data = data;
        node.rank = 0;
        node.parent = node;
        count++;
        map.put(data,node);
    }
    public Node<T> findset(T data){
        Node<T> node1 = map.get(data);
        if(node1 == null){
            return null;
        }
        Node<T> parent = findParent(node1);
        return parent;
    }
    public T findsetid(T data){
        Node<T> node1 = map.get(data);
        if(node1 == null){
            return null;
        }
        Node<T> parent = findParent(node1);
        return parent.data;
    }

    private Node findParent(Node node1) {
        Node parent = node1.parent;
        if(parent == node1){
            return parent;
        }
        node1.parent = findParent(parent);
        return node1.parent;
    }
    public boolean isConnected(T data1, T data2){
        Node<T> parent1 = findset(data1);
        Node<T> parent2 = findset(data2);
        if(parent1 == parent2){
            return true;
        }
        return false;
    }
    public boolean Union(T data1, T data2){
        Node<T> parent1 = findset(data1);
        Node<T> parent2 = findset(data2);
        if(parent1 == parent2){
            return false;
        }

        if(parent1.rank<parent2.rank){
            parent1.parent = parent2;
        }
        else if(parent2.rank>parent1.rank){
            parent2.parent = parent1;
        }
        else {
            parent1.parent = parent2;
            parent2.rank = parent2.rank+1;
        }
        count--;
        return true;
    }
    public int getCount(){
        return count;
    }
}package BasicAlgorithms.UnionFInd;

import java.util.ArrayList;
import java.util.List;

/**
 * Created by hadoop on 13/10/17.
 */
/*
Thoughts trick is always find ... first if two nodes belong to same parent or not ..
if they belong to same parent already .....if parents are not same then make it same since they are adjacent
parent needs to be adjaent
 if(disjointSet.findset(newx*n+newy)!=null){
 disjointSet.Union(index,newx*n+newy);



 U need to create set for all1 possible in the matrix ....
 idea in unoin find  is first to crete setsssss nodesssssss very imp and then work accorindgly
 before making union always check if nodes are connected or not .. .

}
 */
public class NumberOfIslands2 {
    public static void main(String args[]){
        int pos[][] = {{0,0}, {0,1}, {1,2}, {2,1}};
        System.out.println(numIslands2(3,3,pos));
    }
    public static List<Integer> numIslands2(int m, int n, int[][] positions) {
        int dirx[] = {1,-1,0,0};
        int diry[] = {0,0,1,-1};
        DisjointSet<Integer> disjointSet =new DisjointSet<>();
        List<Integer> res = new ArrayList<>();
        for(int i=0;i<positions.length;i++){
            int x = positions[i][0];
            int y = positions[i][1];
            int index = x*n+y;
            disjointSet.makeset(index);
            // first we make new set ... and then check its neighbours

            for(int k=0;k<4;k++){
                int newx = x+ dirx[k];
                int newy = y + diry[k];
                if(!isValid(newx,newy,m,n)){
                    continue;
                }
                if(disjointSet.findset(newx*n+newy)!=null){
                    disjointSet.Union(index,newx*n+newy);
                }
            }
            res.add(disjointSet.getCount());
        }
        return res;
    }

    private static boolean isValid(int newx, int newy,int m,int n) {
        if(newx>=0 && newx<m && newy>=0 && newy<n){
            return true;
        }
        return false;
    }
}package BasicAlgorithms.UnionFInd;

/**
 * Created by hadoop on 13/10/17.
 */
public class NumberOfConnectedComponents {
    public static void main(String[] args) {
        int n = 5 ;
        int edges[][] = {{0, 1}, {1, 2}, {3, 4},{2,3}};
        System.out.println(countComponents(n,edges));
    }
    public static int countComponents(int n, int[][] edges) {
        DisjointSet<Integer> disjointSet = new DisjointSet<>();
        for(int i=0;i<n;i++){
            disjointSet.makeset(i);
        }
        for(int i=0;i<edges.length;i++){
            int x = edges[i][0];
            int y = edges[i][1];

            disjointSet.Union(x,y);
        }
        return disjointSet.getCount();
    }
}/**
 * 
 */
package BasicAlgorithms.UnionFInd;

import java.util.*;


/**
 * @author Raj
 *
 */
public class KruskalMST {
	private static class Edge{
		int v1;
		int v2;
		int weight;

		public Edge(int v1, int v2, int weight) {
			this.v1 = v1;
			this.v2 = v2;
			this.weight = weight;
		}

		@Override
		public String toString() {
			return "Edge{" +
					"v1=" + v1 +
					", v2=" + v2 +
					", weight=" + weight +
					'}';
		}
	}
	private static class Graph{
		HashMap<Integer,HashSet<Integer>> adj;
		HashMap<Integer,HashSet<Edge>> adj2 = new HashMap<>();
		Set<Edge> getEdges(){
			HashSet<Edge> allEdges = new HashSet<>();
			for(HashSet<Edge> edge:adj2.values()){
				allEdges.addAll(edge);
			}
			return allEdges;
		}
		Set<Integer> getVertices(){
			return adj2.keySet();
		}
		void addEdge(int u,int v,int weight){
			if(!adj2.containsKey(u)){
				adj2.put(u,new HashSet<>());
			}
			adj2.get(u).add(new Edge(u,v,weight));
		}
	}
	public List<Edge> kruskalMST(Graph graph) {
		List<Edge> result = new ArrayList<>();
		DisjointSet<Integer> ds = new DisjointSet();

		for (int v : graph.getVertices()) {
			ds.makeset(v);
		}

		List<Edge> edges = new ArrayList<>(graph.getEdges());
		Collections.sort(edges, new Comparator<Edge>() {
			@Override
			public int compare(Edge e1, Edge e2) {
				return e1.weight - e2.weight;
			}
		});

		for (Edge e : edges) {
			int parent1 = ds.findsetid(e.v1);
			int parent2 = ds.findsetid(e.v2);
			if (parent1 == parent2) {
				continue;
			}
			ds.Union(parent1, parent2);
			result.add(e);
			if (result.size() == graph.getVertices().size() - 1) {
				break;
			}
		}

		return result;
	}

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		Graph graph = new Graph();
		graph.addEdge(1, 2, 4);
		graph.addEdge(1, 3, 1);
		graph.addEdge(2, 5, 1);
		graph.addEdge(2, 6, 3);
		graph.addEdge(2, 4, 2);
		graph.addEdge(6, 5, 2);
		graph.addEdge(6, 4, 3);
		graph.addEdge(4, 7, 2);
		graph.addEdge(3, 4, 5);
		graph.addEdge(3, 7, 8);
		graph.addEdge(7, 1, 8);
		graph.addEdge(5, 1, 8);

		KruskalMST obj = new KruskalMST();
		List<Edge> result = obj.kruskalMST(graph);
		System.out.println(result);
		System.out.println(graph.getVertices());
	}

}
package BasicAlgorithms.UnionFInd;

/**
 * Created by hadoop on 25/11/17.
 */
public class ReducantConnection {
    public int[] findRedundantConnection(int[][] edges) {
        int len = edges.length;
        int[] parent = new int[len+1];
        for(int i=0;i<len+1;i++){
            parent[i] = i;
        }
        for(int [] edge:edges){
            if(!unionFind(parent,edge[0],edge[1])){
                return edge;
            }
        }
        return new int[2];
    }

    private boolean unionFind(int[] parent, int u, int v) {
        int parentu = find(parent,u);
        int parentv = find(parent,v);
        if(parentu == parentv){
            return false;
        }
        else {
            parent[parentu] = parentv;
            return true;
        }
    }

    private int find(int[] parentArray,int x){
        int parent = parentArray[x];
        while (parent!=parentArray[parent]){
            parent = parentArray[parent];
        }
        return parent;
    }
}package BasicAlgorithms.HashTable;

/**
 * Created by hadoop on 23/10/17.
 */
import java.util.*;
public class RepeatedDNA {

    public List<String> findRepeatedDnaSequences(String s) {
        List<String> ans = new ArrayList<>();
        Set<String> set = new HashSet<>();
        for (int i = 0; i <= s.length() - 9; i++) {
            String sub = s.substring(i, i + 10);
            if (set.contains(sub)) {
                ans.add(sub);
            } else {
                set.add(sub);
            }
        }
        return ans;
    }
}package BasicAlgorithms.HashTable;

/**
 * Created by hadoop on 23/10/17.
 */
import java.util.*;
public class ContainsDuplicates {
    public boolean containsDuplicate(int[] nums) {
        if (nums.length == 0 || nums == null) {
            return false;
        }
        HashSet<Integer> set = new HashSet<Integer>();
        for (int i : nums) {
            if (set.contains(i)) {
                return true;
            } else {
                set.add(i);
            }
        }
        return false;
    }
    public boolean containsNearbyDuplicate(int[] nums, int k) {
        Set<Integer> set = new HashSet<>();
        for (int i = 0;i < nums.length; i++) {
            if (i >= k) set.remove(nums[i - k]);//Because the distance between i and i - k - 1 is large than k, so just let the nums[n-k-1] out
            if (!set.add(nums[i])) {
                return true;
            }
        }
        return false;
    }
    public boolean containsAlmostNearbyDuplicate(int[] nums, int k,int t) {
        TreeSet<Integer> set = new TreeSet<>();
        for (int i = 0;i < nums.length; i++) {
            //Because the distance between i and i - k - 1 is large than k, so just let the nums[n-k-1] out
            Integer floor = set.floor(nums[i]+t);
            Integer ceil = set.ceiling(nums[i]-t);
            if(floor!=null  && floor >=nums[i] || ceil!=null && ceil<=nums[i] ) {
                return false;
            }
            set.add(nums[i]);
            if (i >= k) set.remove(nums[i - k]);
        }
        return false;
    }
    private TreeNode add(TreeNode root, TreeNode nNode) {
        if(root == null) {
            return nNode;
        }
        else if(root.val < nNode.val) {
            root.right = add(root.right, nNode);
            return root;
        }
        else {
            root.left = add(root.left, nNode);
            return root;
        }
    }

    private TreeNode delete(TreeNode root, TreeNode dNode) {
        if(root == null) {
            return null;
        }
        else if(root.val < dNode.val) {
            root.right = delete(root.right, dNode);
            return root;
        }
        else if(root.val > dNode.val) {
            root.left = delete(root.left, dNode);
            return root;
        }
        else if(root == dNode) {
            if(dNode.left == null && dNode.right == null) return null;
            else if(dNode.left != null && dNode.right == null) return dNode.left;
            else if(dNode.right != null && dNode.left == null) return dNode.right;
            else {
                TreeNode p = dNode.right;
                while(p.left != null) p = p.left;
                dNode.right = delete(dNode.right, p);
                p.left = dNode.left;
                p.right = dNode.right;
                return p;
            }
        }
        else {
            return root;
        }
    }

    private boolean search(TreeNode root, long val, int t) {
        if(root == null) {
            return false;
        }
        else if(Math.abs((root.val - val)) <= t) {
            return true;
        }
        else if((root.val - val) > t) {
            return search(root.left, val, t);
        }
        else {
            return search(root.right, val, t);
        }
    }

    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {
        if(k < 1 || t < 0 || nums.length <= 1) {
            return false;
        }
        int len = nums.length;
        TreeNode[] map = new TreeNode[len];
        map[0] = new TreeNode((long)nums[0]);
        TreeNode root = null;
        root = add(root, map[0]);
        for(int i = 1; i < len; i++) {
            if(search(root, (long)nums[i], t)) {
                return true;
            }
            map[i] = new TreeNode((long)nums[i]);
            if(i - k >= 0) {
                root = delete(root, map[i-k]);
            }
            root = add(root, map[i]);
        }
        return false;
    }
    private class TreeNode{
        long val;
        TreeNode left;
        TreeNode right;
        public TreeNode(long x) {
            val = x;
        }
    }
    private class Solution {
        public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {

            TreeSet<Long> ts = new TreeSet<>();
            for (int i=0; i<nums.length; i++) {
                // -t <= x-nums[i] <= t
                if (ts.floor((long)nums[i]+(long)t) != null
                        && ts.floor((long)nums[i]+(long)t) >= (long)nums[i]-(long)t) {
                    return true;
                }
                ts.add((long)nums[i]);
                if (i >= k) {
                    ts.remove((long)nums[i-k]);
                }
            }
            return false;

        }
    }
}
package BasicAlgorithms.HashTable;

import java.util.HashMap;

/**
 * Created by hadoop on 23/10/17.
 */
public class MaxPointsInAline {
//    public int maxPoints(Point[] points) {
//        if(points == null || points.length ==0){
//            return 0;
//        }
//        int max =1;
//        for(int i=0;i<points.length;i++){
//            int localmax =1;
//            HashMap<Float,Integer> hashMap = new HashMap<>();
//            int samexpoint = 1; // for slope is infiinty
//            int samepoints = 1;
//
//            for(int j=0;j<points.length;j++){
//                if(i == j){
//                    continue;
//                }
//                if(points[i].x == points[j].x && points[i].y==points[i].y){
//                    samepoints++;
//                    continue;
//                }
//
//                if(points[i].x == points[j].x){
//                    samexpoint++;
//                }
//                float slope = (float) (points[i].y-points[j].y)/(points[i].x-points[j].x);
//                if(!hashMap.containsKey(slope)){
//                    hashMap.put(slope,1);
//                }
//                hashMap.put(slope,hashMap.get(slope)+1);
//            }
//            for(int point:hashMap.values()){
//                localmax = Math.max(localmax,point);
//            }
//            localmax = Math.max(localmax,samexpoint);
//            localmax = localmax + samepoints;
//            max = Math.max(max,localmax);
//        }
//        return max;
//    }
public int maxPoints(Point[] points) {
    if(points.length <= 0) return 0;
    if(points.length <= 2) return points.length;
    int result = 0;
    for(int i = 0; i < points.length; i++){
        HashMap<Float, Integer> hm = new HashMap<Float, Integer>();
        int samex = 1;
        int samep = 0;
        for(int j = 0; j < points.length; j++){
            if(j != i){
                if((points[j].x == points[i].x) && (points[j].y == points[i].y)){
                    samep++;
                    continue;
                }
                if(points[j].x == points[i].x){
                    samex++;
                    continue;
                }
                float k = (float) (points[j].y - points[i].y) / (float) (points[j].x - points[i].x);
                System.out.println("slope " +k);
                if(hm.containsKey(k)){
                    hm.put(k,hm.get(k) + 1);
                }else{
                    hm.put(k, 2);
                }//result = Math.max(result, hm.get(k) + samep);
            }
        }
        for(int ans:hm.values()){
            result = Math.max(result,ans+samep);
        }
        result = Math.max(result, samex+samep);
    }
    return result;
}
    private static class  Point{
        int x;
        int y;
        Point(int x,int y){
            this.x = x;
            this.y = y;
        }
    }

    public static void main(String[] args) {
        MaxPointsInAline maxPointsInAline = new MaxPointsInAline();
        Point [] points = new Point[3];
        points[0] = new Point(0,0);
        points[1] = new Point(94911151,94911150);
        points[2] = new Point(94911152,94911151);
        System.out.println(maxPointsInAline.maxPoints(points));
    }
}
package BasicAlgorithms.HashTable;

/**
 * Created by hadoop on 23/10/17.
 */
import java.util.*;
public class PalindromPairs {
    public List<List<Integer>> palindromePairs(String[] words) {
        List<List<Integer>> res = new ArrayList<>();
        if(words.length ==0){
            return res;
        }

        HashMap<String,Integer> hashMap = new HashMap<>();
        for(int i=0;i<words.length;i++){
            hashMap.put(words[i],i);
        }
        for(int i=0;i<words.length;i++){
            for(int j=0;j<=words[i].length();j++){
                String str1 = words[i].substring(0,j);
                String str2 = words[i].substring(j);
                if(isPalindrome(str1)){
                    String reversedStr2 = new StringBuilder((str2)).reverse().toString();
                    if(hashMap.containsKey(reversedStr2) && hashMap.get(reversedStr2)!=i){
                        List<Integer> list = new ArrayList<Integer>();
                        list.add(i);
                        list.add(hashMap.get(reversedStr2));
                        res.add(list);
                    }
                }
                if(isPalindrome(str2)){
                    String reversedStr1 = new StringBuilder((str1)).reverse().toString();
                    if(hashMap.containsKey(reversedStr1) && hashMap.get(reversedStr1)!=i && reversedStr1!=""){
                        List<Integer> list = new ArrayList<Integer>();
                        list.add(i);
                        list.add(hashMap.get(reversedStr1));
                        res.add(list);
                    }
                }
            }
        }
        return res;
    }

    private boolean isPalindrome(String s) {
        int start = 0;
        int end = s.length() - 1;
        while (start < end) {
            if (s.charAt(start++) != s.charAt(end--)) {
                return false;
            }
        }
        return true;
    }
}package BasicAlgorithms.HashTable;

import java.util.*;
public class LRUCache {
    class DoubleLinkedListNode {
        int key, val;
        DoubleLinkedListNode next,prev;
        public DoubleLinkedListNode(int key, int val){
            this.key = key;
            this.val = val;
            next = null;
            prev = null;
        }
    }
    public int capacity;
    public HashMap<Integer, DoubleLinkedListNode> map;
    public DoubleLinkedListNode head, tail;
    public LRUCache(int capacity) {
        this.capacity = capacity;
        this.map = new HashMap<Integer, DoubleLinkedListNode>();
        this.head = new DoubleLinkedListNode(-1, -1);
        this.tail = new DoubleLinkedListNode(-1, -1);
        head.next = tail;
        head.prev = tail;
        tail.next = head;
        tail.prev = head;
    }
    
    public int get(int key) {
        if (map.containsKey(key)) {
            DoubleLinkedListNode node = map.get(key);
            moveToHead(node);
            return node.val;
        } else {
            return -1;
        }
    }
    
    public void set(int key, int value) {
        if (map.containsKey(key)) {
            map.get(key).val = value;
            moveToHead(map.get(key));
        } else {
            DoubleLinkedListNode node = new DoubleLinkedListNode(key, value);
            if (map.size() >= this.capacity) {
                DoubleLinkedListNode rm = tail.prev;
                remove(rm);
                map.remove(rm.key);
            }
            insertHead(node);
            map.put(key, node);
        }
    }

    public void moveToHead(DoubleLinkedListNode node) {
        remove(node);
        insertHead(node);
    }
    
    //Helper functions
    public void insertHead(DoubleLinkedListNode node) {
        DoubleLinkedListNode next = head.next;
        head.next = node;
        node.prev = head;
        node.next = next;
        next.prev = node;
    }

    public void remove(DoubleLinkedListNode node) {
        DoubleLinkedListNode front = node.prev;
        DoubleLinkedListNode end = node.next;
        front.next = end;
        end.prev = front;
    }  
}package BasicAlgorithms.HashTable;

/**
 * Created by hadoop on 23/10/17.
 */
import java.util.*;
public class GroupStrings {
    public List<List<String>> groupStrings(String[] strings) {

        HashMap<String, List<String>> hm = new HashMap<>();

        for(String word:strings){
            if(word.length()>0){
                int offset = word.charAt(0)-'a' ;
                String updatedString = updated(word,offset);
                if(!hm.containsKey(updatedString)){
                    hm.put(updatedString,new ArrayList<>());
                }
                hm.get(updatedString).add(word);
            }
            else {
                String empty="";
                if(!hm.containsKey(empty)){
                    hm.put(empty,new ArrayList<>());
                }
                hm.get(empty).add("");
            }
        }
        List<List<String>> result = new ArrayList<>();
        for(List<String>value:hm.values()){
            result.add(new ArrayList<>(value));
        }
        return  result;
    }

    private String updated(String word, int offset) {
        StringBuilder sb = new StringBuilder(word);
        for(int i=0;i<word.length();i++){
            int newchar = sb.charAt(i)-offset;
            if(newchar<'a'){
                newchar = newchar+26;
            }
            sb.setCharAt(i,(char)newchar);

        }
        System.out.println(sb.toString());
        return sb.toString();
    }

    public static void main(String[] args) {
        GroupStrings groupStrings = new GroupStrings();
        System.out.println(groupStrings.groupStrings(new String[]{"abc", "bcd", "acef", "xyz", "az", "ba", "a", "z"}));
    }
}package BasicAlgorithms.HashTable;

/**
 * Created by hadoop on 23/10/17.
 */
public class ReHashing {
    public ListNode[] rehashing(ListNode[] hashTable) {
        int size = hashTable.length;
        int newsize = 2*size;
        ListNode[] newHashTable = new ListNode[newsize];
        for(int i=0;i<size;i++){
            rehash(newHashTable,hashTable,i);
        }
        return newHashTable;
    }

    private void rehash(ListNode[] newHashTable, ListNode[] hashTable, int index) {

        int newsize= newHashTable.length;
        ListNode startNode = hashTable[index];
        if(startNode == null){
            return;
        }

        while (startNode!=null){
            int val = startNode.val;
            ListNode newNode = new ListNode(val);
            int hashedIndex = (val+newsize)%newsize;
            addintonewtable(newHashTable,newNode,hashedIndex);
            startNode= startNode.next;
        }
    }

    private void addintonewtable(ListNode[] newHashTable, ListNode newNode, int hashedIndex) {
        if(newHashTable[hashedIndex] == null){
            newHashTable[hashedIndex] = newNode;
            return;
        }
        else {
            ListNode oldHead = newHashTable[hashedIndex];
            newHashTable[hashedIndex] = newNode;
            newNode.next = oldHead;
        }
    }

    private class ListNode{
        int val;
        ListNode next;
        ListNode(int x){
            this.val = x;
        }
    }
}package BasicAlgorithms.DivideAndConquer;

/**
 * Created by hadoop on 22/10/17.
 */
	//Given a string that contains only digits 0-9 and a target value, return all possibilities to add binary operators (not unary) +, -, or * between the digits so they evaluate to the target value.
import java.util.*;
public class DifferentStringsOutput {
    public List<String> addOperators(String num, int target) {
        List<String> path = new LinkedList<>();
        List<List<String>> result = new LinkedList<>();
        List<String> ans = new LinkedList<>();
        if (num.length() == 1) {
            if (Integer.parseInt(num) == target) {
                ans.add(num);
                return ans;
            } else {
                return ans;
            }
        }

        String previousChar = "";
        addOperatorsHelper(num, 0, path, result, target, 0, 0, 0, previousChar);
        for(List<String> list :result){
            String start="";
            for(String x:list){
                start = start+x;
            }
            ans.add(start);
        }
        return ans;
    }

    private void addOperatorsHelper(String num, int start, List<String> path, List<List<String>> result, long target, long calculatedTillNow, long calculatedTillPrevious, long previousNumber, String previousChar) {
       // System.out.println("start "+start);
        if (start == num.length()) {
          //  System.out.println("entry here "+calculatedTillNow);
            if (calculatedTillNow == target) {
            //    System.out.println("target"+target);
                result.add(new ArrayList<>(path));
            }
            return;
        }

        for (int index = start; index < num.length(); index++) {

            String currentString = num.substring(start, index + 1);
            Long number = Long.parseLong(currentString);
            if(currentString.startsWith("0") && currentString.length()>1){
                continue;
            }
            if (start == 0) {
                path.add(currentString);
                addOperatorsHelper(num, index+1, path, result, target, number, 0, number, previousChar);
                path.remove(path.size() - 1);
            } else {
                path.add("+" + currentString);
                addOperatorsHelper(num, index + 1, path, result, target, calculatedTillNow+number, calculatedTillNow, number, "+");
                path.remove(path.size() - 1);
                path.add("-" + currentString);
                addOperatorsHelper(num, index + 1, path, result, target, calculatedTillNow-number, calculatedTillNow, number, "-");
                path.remove(path.size() - 1);

                path.add("*" + currentString);

                if (previousChar == "+") {
                    addOperatorsHelper(num, index + 1, path, result, target, calculatedTillPrevious +previousNumber*number, calculatedTillPrevious, previousNumber*number, "+");
                }
                else if (previousChar == "-") {
                    addOperatorsHelper(num, index + 1, path, result, target, calculatedTillPrevious -previousNumber*number, calculatedTillPrevious, previousNumber*number, "-");
                }
                else if (previousChar == "*") {
                    addOperatorsHelper(num, index + 1, path, result, target, calculatedTillPrevious +previousNumber*number, calculatedTillPrevious, previousNumber*number, "*");
                }
                else {
                    addOperatorsHelper(num, index + 1, path, result, target, calculatedTillPrevious +previousNumber*number, calculatedTillPrevious, previousNumber*number, "*");
                }
                path.remove(path.size() - 1);
            }
        }
    }

    public static void main(String[] args) {
        DifferentStringsOutput differentStringsOutput = new DifferentStringsOutput();
        System.out.println(differentStringsOutput.addOperators("105",5));
    }
}package BasicAlgorithms.DivideAndConquer;

/**
 * Created by hadoop on 22/10/17.
 */
/*
	Different Ways to Add Parentheses
	Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *.

	Example 1
		Input: "2-1-1".

		((2-1)-1) = 0
		(2-(1-1)) = 2
		Output: [0, 2]
	Example 2
		Input: "2*3-4*5"

		(2*(3-(4*5))) = -34
		((2*3)-(4*5)) = -14
		((2*(3-4))*5) = -10
		(2*((3-4)*5)) = -10
		(((2*3)-4)*5) = 10
		Output: [-34, -14, -10, -10, 10]
*/
import java.util.*;
public class DifferentWaysToAdd {
    //if there is parenthese then only one way but we want to add parenthses and see how
    // many results we can get .....
    List<Integer> res = new LinkedList<Integer>();
    public List<Integer> diffWaysToCompute(String input) {
        List<Integer> result = new LinkedList<>();
        return diffWaysToComputeHelper(input,0,input.length()-1);
    }

    private List<Integer> diffWaysToComputeHelper(String input, int start, int end) {
        List<Integer> list = new ArrayList<>();

        if(start>end){
            return list;

        }
        // base case
        if(start == end && (input.charAt(start)>='0' && input.charAt(start)<='9')){
            list.add(Integer.parseInt(input.substring(start,end+1)));
            return list;
        }
        for(int mid= start ;mid<=end;mid++) {
            if (input.charAt(mid) == '+' || input.charAt(mid) == '-' || input.charAt(mid) == '*') {
                // hey recursion give me ans of leftside
                List<Integer> leftResult = diffWaysToComputeHelper(input, start, mid - 1);
                // hey recursion give me ans of rightside
                List<Integer> rightResult = diffWaysToComputeHelper(input, mid + 1, end);

                for (Integer left : leftResult) {
                    for (Integer right : rightResult) {
                        if (input.charAt(mid) == '+') {
                            list.add(left + right);
                        }
                        if (input.charAt(mid) == '-') {
                            list.add(left - right);
                        }
                        if (input.charAt(mid) == '*') {
                            list.add(left * right);
                        }
                    }
                }
            }
        }
        return list;
    }

    public static void main(String[] args) {
        DifferentWaysToAdd differentWaysToAdd = new DifferentWaysToAdd();
        System.out.println(differentWaysToAdd.diffWaysToCompute("2*3-4*5"));
    }
}
package BasicAlgorithms.SlidingWindow;

import java.util.*;

/**
 * Created by hadoop on 21/10/17.
 */
public class MaximumSlidingWIndow {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int len = nums.length;
        int[] returnedAns = new int[len - k + 1]; // no of windows of length k
        PriorityQueue<Integer> pq = new PriorityQueue<>(new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o2 - o1;
            }
        });
        // another way to implement is

        for (int i = 0; i < k; i++) {
            pq.add(nums[i]);
        }
        returnedAns[0] = pq.peek();
        for (int i = k; i < nums.length; i++) {
            pq.remove(nums[i - k]);
            pq.add(nums[i]);
            returnedAns[i - k + 1] = pq.peek();
        }

        return returnedAns;


//        for(int i=0;i<nums.length;i++){
//            if(i<k-1){
//                pq.add(nums[i]);
//            }
//            else {
//                pq.add(nums[i]);
//                returnedAns[i-k] = pq.peek();
//                pq.remove(nums[i-(k-1)]);
//            }
//        }
//        return returnedAns;

    }

    public int[] maxSlidingWindow2(int[] nums, int k) {
        Deque<Integer> deque= new ArrayDeque<Integer>();

        int [] returnedAns = new int[nums.length-k+1];
        for(int i=0;i<nums.length;i++){
            // remove elements frm window
            if(i>=k) {
                if (!deque.isEmpty() && nums[deque.peekFirst()] <i-k+1){
                    deque.removeFirst();
                }
            }
            while (!deque.isEmpty() && nums[deque.peekLast()]<nums[i]){
                deque.removeLast();
            }
            deque.addLast(i);
            if(i>=k-1)
            returnedAns[i-k+1] =nums[deque.peekFirst()];
        }
        return returnedAns;
    }


    private class Solution {

        /**
         * Keep monotonic deque: containing index, and nums[index] is monotonic in
         * deque peek element is the index of the max number in current sliding
         * window and the numbers that indices in this deque represents are in
         * non-ascending order
         * */
        public int[] maxSlidingWindow(int[] nums, int k) {
            int n = nums.length;
            if (n == 0) {
                return new int[]{};
            }
            int[] res = new int[n - k + 1];
            // peek element is the index of the max number in current sliding window
            // and the numbers that indices in this deque represents are in non-ascending order
            Deque<Integer> descendIndices = new LinkedList<>();
            for (int i = 0; i < n; i++) {
                int num = nums[i];
                //define window and move accrodingly things easier to work for index
                int window = i - k + 1;
                // poll elements out of current window
                while (!descendIndices.isEmpty() && descendIndices.peekFirst() < i - k + 1) {
                    descendIndices.removeFirst();
                }
                // build descending indices
                while (!descendIndices.isEmpty() && nums[descendIndices.peekLast()] < num) {
                    descendIndices.removeLast();
                }
                descendIndices.addLast(i);
                if (window >= 0) {
                    res[window] = nums[descendIndices.peekFirst()];
                }
            }
            return res;
        }

    }
}package BasicAlgorithms.SlidingWindow;

import java.util.ArrayList;
import java.util.Deque;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Random;

public class ViewSunset {
  // @include
  private static class BuildingWithHeight {
    public Integer id;
    public Integer height;

    public BuildingWithHeight(Integer id, Integer height) {
      this.id = id;
      this.height = height;
    }
    // @exclude

    @Override
    public String toString() {
      return "(id = " + id + ", height = " + height + ")";
    }
    // @include
  }

  public static Deque<BuildingWithHeight> examineBuildingsWithSunset(
      Iterator<Integer> sequence) {
    int buildingIdx = 0;
    Deque<BuildingWithHeight> buildingsWithSunset = new LinkedList<>();
    while (sequence.hasNext()) {
      Integer buildingHeight = sequence.next();
      while (!buildingsWithSunset.isEmpty()
             && (Integer.compare(buildingHeight,
                                 buildingsWithSunset.getLast().height)
                 >= 0)) {
        buildingsWithSunset.removeLast();
      }
      buildingsWithSunset.addLast(
          new BuildingWithHeight(buildingIdx++, buildingHeight));
    }
    return buildingsWithSunset;
  }
  // @exclude

  public static void main(String[] args) {
    Random r = new Random();
    for (int times = 0; times < 1000; ++times) {
      int n;
      if (args.length == 1) {
        n = Integer.parseInt(args[0]);
      } else {
        n = r.nextInt(10000) + 1;
      }
      List<Integer> A = new ArrayList<>();
      for (int i = 0; i < n; ++i) {
        Integer height = r.nextInt(2 * n) + 1;
        A.add(height);
      }
      Deque<BuildingWithHeight> res = examineBuildingsWithSunset(A.iterator());
      BuildingWithHeight prev = res.removeFirst();
      System.out.println(prev);
      while (!res.isEmpty()) {
        BuildingWithHeight current = res.removeFirst();
        System.out.println(current);
        assert(prev.id < current.id);
        assert(prev.height > current.height);
        prev = current;
      }
    }
  }
}
package BasicAlgorithms.SlidingWindow;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.PriorityQueue;

/**
 * Created by hadoop on 21/9/17.
 */


// template
    /*
    first add number
    then remove if moving outside window
    // once removed then
     */
public class SlidingWindowMedian {

    List<Integer> slidingWindow(int []num, int k){
        ArrayList<Integer> list = new ArrayList<>();
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return Integer.compare(o2,o1);
            }
        });
        for(int i=0;i<num.length;i++){
            // add the number
            //if number if lower than max heap value than in max heap
            // rmeove the value from window /////
            if(maxHeap.isEmpty() || num[i]<maxHeap.peek()){
                maxHeap.add(num[i]);
            }
            else {
                minHeap.add(num[i]);
            }
            // remove the number
            // remove element ffrom window
            if(i>=k){
                if(num[i-k]>maxHeap.peek()){
                    minHeap.remove(num[i-k]);
                }
                else {
                    maxHeap.remove(num[i-k]);
                }
            }
            // rebalance the number
            if(maxHeap.size()-minHeap.size() >=2){
                minHeap.add(maxHeap.poll());
            }
            if(minHeap.size() -maxHeap.size() >=1){
                maxHeap.add(minHeap.poll());
            }
            //find the peek 
            if( i>=k-1 ){
                list.add(maxHeap.peek());
                System.out.println(maxHeap.peek());
            }
        }
        return list;
    }
    double[] setMedian(int []array){
        PriorityQueue<Integer> loweres = new PriorityQueue<>(new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
               return  -1*o1.compareTo(o2);
            }
        });
        PriorityQueue<Integer> higher = new PriorityQueue<>();
        double[] median = new double[array.length];
        for( int i=0;i<array.length;i++){
            // here no removal only addition ... 
            addNumber(array[i],loweres,higher);
            balace(loweres,higher);
            median[i] = getMedian(loweres,higher);
        }
        return median;
    }

    private double getMedian(PriorityQueue<Integer> loweres, PriorityQueue<Integer> higher) {
            if(loweres.size() == higher.size()){
                return (loweres.peek() + higher.peek())/2;
            }
            return loweres.peek();
    }

    private void balace(PriorityQueue<Integer> maxheapOfLowersNumbers, PriorityQueue<Integer> minHeapOfHigherNumbers) {
        if(maxheapOfLowersNumbers.size()-minHeapOfHigherNumbers.size()>=2){
            minHeapOfHigherNumbers.add(maxheapOfLowersNumbers.poll());
        }
        if(minHeapOfHigherNumbers.size()-maxheapOfLowersNumbers.size()>=1){
            maxheapOfLowersNumbers.add(minHeapOfHigherNumbers.poll());
        }
    }

    private void addNumber(int i, PriorityQueue<Integer> loweres, PriorityQueue<Integer> higher) {
            if(loweres.isEmpty() || i<loweres.peek()){
                loweres.add(i);
            }
            else{
                higher.add(i);
            }
    }


    // straight forward solution to understand must see ..
    // simple fundaaaaa .. keep maxheapsie always more than 1  then addition check from premedian
    // which will me maxheap.peek() ..
   private  class Solution {
        PriorityQueue<Integer> minHeap;
        PriorityQueue<Integer> maxHeap;

        /**
         * @param nums: A list of integers.
         * @return: The median of the element inside the window at each moving.
         */
        public ArrayList<Integer> medianSlidingWindow(int[] nums, int k) {
            ArrayList<Integer> rst = new ArrayList<Integer>();
            if (nums == null || nums.length == 0 || k <= 0) {
                return rst;
            }
            minHeap = new PriorityQueue<Integer>();
            maxHeap = new PriorityQueue<Integer>(10, new Comparator<Integer>(){
                public int compare(Integer x, Integer y){
                    return y - x;
                }
            });
            maxHeap.offer(nums[0]);

            for (int i = 1; i < k; i++) {
                add(nums[i]);
            }

            rst.add(maxHeap.peek());
            for (int i = k; i < nums.length; i++) {
                add(nums[i]);
                remove(nums[i - k]);
                rst.add(maxHeap.peek());
            }
            return rst;
        }

        public void add(int val) {
            int preMedian = maxHeap.peek();
            if (val > preMedian) {
                minHeap.offer(val);
            } else {
                maxHeap.offer(val);
            }
            balance();
        }

        public void remove(int val) {
            int preMedian = maxHeap.peek();
            if (val > preMedian) {
                minHeap.remove(val);
            } else {
                maxHeap.remove(val);
            }
            balance();
        }

        public void balance() {
            if (maxHeap.size() > minHeap.size() + 1) {
                minHeap.offer(maxHeap.poll());
            } else if (maxHeap.size() < minHeap.size()) {
                maxHeap.offer(minHeap.poll());
            }
        }

    }
}
package BasicAlgorithms.SlidingWindow;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Created by hadoop on 25/11/17.
 */
public class slidingWindowTemplateByHarryChaoyangHe {
    public List<Integer> slidingWindowTemplateByHarryChaoyangHe(String s, String t) {
        // init a collection to store the final result
        List<Integer> result = new ArrayList<>();
        if (t.length() > s.length()) {
            return result;
        }
        Map<Character, Integer> map = new HashMap<>();
        //create a hashmap to save the Characters of the target substring.
        //(K, V) = (Character, Frequence of the Characters)
        for (char c : t.toCharArray()) {
            map.put(c, map.getOrDefault(c, 0) + 1);
        }
        //must be the map size, NOT the string size because the char may be duplicate.
        int counter = map.size();
        //Two Pointers: begin - left pointer of the window; end - right pointer of the window

        int begin = 0;
        int end = 0;
        //the length of the substring which match the target string.

        int len = Integer.MAX_VALUE;
        while (end < s.length()) {
            char x = s.charAt(end);
            if (map.containsKey(x)) {
                map.put(x, map.get(x) - 1);
                if (map.get(x) == 0) counter--;
            }
            end++;
            //increase begin pointer to make it invalid/valid again
            // counter condition. different question may have different condition */
            while (counter == 0) {
                char tempC = s.charAt(begin);
                if (map.containsKey(tempC)) {
                    map.put(tempC, map.get(tempC) + 1);
                    if (map.get(tempC) > 0) {
                        counter++;
                    }
                }
                begin++;
            }
        }
        return result;
    }
}
//package BasicAlgorithms.Stack;
//
//import java.util.Stack;
//
///**
// * Created by hadoop on 19/10/17.
// */
//public class GeneralExpressionPractice {
//    public int evaluateExpression(String[] expression) {
//        if(expression == null || expression.length == 0){
//            return 0;
//        }
//        // Lets take 2 stacks
//        // one number stack / list/ expression tree stack where we store result
//        // another is operatot stack
//        // if we get ( we push into that
//        // if we get ) we pop until ) and finall pop ) as well
//        // if we get operator then we compute previous things as per priority
//        // finall we push this operator
//        // once we converd all expression
//        // we pop things frm stack and perform things at last
//        // two stacka re requires must must must
//        // if number we push number stack
//        //if operator opetrator stack and perfomr thinsgs and push it to numberstack
//        // if open ( operatot stack for time being
//        // if close fetch from operatos stak and push to number stack
//        //
//        Stack<Integer> stack = new Stack<Integer>();
//        Stack<String> opStack = new Stack<>();
//        for(String token:expression) {
//            if (isNumber(token)) {
//                stack.push(Integer.parseInt(token));
//            } else if (token.equals("(")) {
//                opStack.push(token);
//            } else if (token.equals(")")) {
//                numStack.push(compute(numStack.pop(), numStack.pop(), opStack.pop()));
//                opStack.push(token);
//            } else {
//                while (!opStack.isEmpty() && getPriority(opStack.peek()) > getPriority(token)) {
//                    stack.push(compute(token, stack.pop(), stack.pop));
//                }
//            }
//        }
//    }
//
//
//
//    }
//}package BasicAlgorithms.Stack;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

/**
 * Created by hadoop on 19/10/17.
 */
public class BasicCalculator {
    public int calculate(String s) {
        List<String> list = new ArrayList<>();
        String array[] = null;
        int index = 0;
        for(int i=0;i<s.length();){
            int num=0;
            if(Character.isDigit(s.charAt(i))){
                while (i < s.length() && Character.isDigit(s.charAt(i))) {
                    num = num * 10 + s.charAt(i) - '0';
                    i++;
                }
                list.add(String.valueOf(num).trim());
            }
            else if(i<s.length() && s.charAt(i)=='('){
                list.add(String.valueOf(s.charAt(i)).trim());
                i++;
            }
            else if(i<s.length() && s.charAt(i)==')'){
                list.add(String.valueOf(s.charAt(i)).trim());
                i++;
            }
            else if(i<s.length() && s.charAt(i)=='+'){
                list.add(String.valueOf(s.charAt(i)).trim());
                i++;
            }
            else if(i<s.length() && s.charAt(i)=='-'){
                list.add(String.valueOf(s.charAt(i)).trim());
                i++;
            }
            else {
                i++;
            }
        }
       // System.out.println("list"+list);
        array = new String[list.size()];
        for(String tokens:list){
            array[index++] = tokens;
        }
        return evaluateExpression(array);
        //return -1;
    }
    public int evaluateExpression(String[] expression) {
        if (expression == null || expression.length == 0) {
            return 0;
        }
        Stack<Integer> numStack = new Stack<>();
        Stack<String> opStack = new Stack<>();
        for (String token : expression) {
            if (isNumber(token)) {
                numStack.push(Integer.valueOf(token));
            } else if (token.equals("(")) {
                opStack.push(token);
            } else if (token.equals(")")) {
                while (!opStack.peek().equals("(")) {
                    numStack.push(compute(numStack.pop(), numStack.pop(), opStack.pop()));
                }
                opStack.pop();  // pop out "("
            } else {
                while (!opStack.isEmpty() && getPriority(opStack.peek()) >= getPriority(token)) {
                    numStack.push(compute(numStack.pop(), numStack.pop(), opStack.pop()));
                }
                opStack.push(token);
            }
        }
        while (!opStack.isEmpty()) {
            numStack.push(compute(numStack.pop(), numStack.pop(), opStack.pop()));
        }
        return numStack.isEmpty() ? 0 : numStack.pop();
    }

    private boolean isNumber(String token) {
        return Character.isDigit(token.charAt(0));
    }

    private int getPriority(String op) {
        if (op.equals("(")) {
            return 0;
        } else if (op.equals("+") || op.equals("-")) {
            return 1;
        } else {
            return 2;
        }
    }

    private int compute(int num2, int num1, String token) {
        int result;
        if (token.equals("+")) {
            result = num1 + num2;
        } else if (token.equals("-")) {
            result = num1 - num2;
        } else if (token.equals("*")) {
            result = num1 * num2;
        } else {
            result = num1 / num2;
        }
        return result;
    }

    public static void main(String[] args) {
        BasicCalculator bs = new BasicCalculator();
        System.out.println(bs.calculate("(1+(4+5+2)-3)+(6+8)"));
       // "1 + 1" = 2
       //" 2-1 + 2 " = 3
        //"(1+(4+5+2)-3)+(6+8)" = 23
    }
}
package BasicAlgorithms.Stack;

import java.util.Deque;
import java.util.LinkedList;
import java.util.Stack;

/**
 * Created by hadoop on 19/10/17.
 */
public class SimplfyPath {
    public String simplifyPath(String path) {
        String array[] = path.split("/");

        Deque<String> deque = new LinkedList<>();
        for(int i=0;i<array.length;i++){
            System.out.println(array[i]);
            if(array[i].equals(".") || array[i].equals("")){
                continue;
            }
            else if(array[i].equals("..")){
                if(!deque.isEmpty()){
                    deque.pop();
                }
                continue;
            }
            else{
                deque.push(array[i]);

            }
        }
        String ans = "";
        if(deque.isEmpty()){
            return "/";
        }
        while (!deque.isEmpty()){
            ans = ans + "/"+deque.pollLast();
        }
        return ans;
    }

    public static void main(String[] args) {
        SimplfyPath simplfyPath = new SimplfyPath();
        System.out.println(simplfyPath.simplifyPath("/a/./b/../../c/"));
        System.out.println(simplfyPath.simplifyPath("/home/"));
    }
}package BasicAlgorithms.Stack;

import java.util.Stack;

/**
 * Created by hadoop on 19/10/17.
 */
public class EvalRPN {
    public int evalRpn(String[] tokens) {
        Stack<Integer> stack = new Stack<>();
        for(String token:tokens){
            if(isOperator(token)){
                stack.push(compute(stack.pop(),stack.pop(),token));
            }else {
                stack.push(Integer.parseInt(token));
            }
        }
        return stack.pop();
    }

    private boolean isOperator(String token) {
        if(token.equals("+") || token.equals("-") || token.equals("*") || token.equals("/")){
            return true;
        }
        return false;
    }
    int compute(int num2, int num1,String operator){
        int result = 0;
        switch (operator.charAt(0)) {
            case '+': result = num1 + num2; break;
            case '-': result = num1 - num2; break;
            case '*': result = num1 * num2; break;
            case '/': result = num1 / num2; break;
        }
        return result;
    }
}package BasicAlgorithms.Stack;

import BasicAlgorithms.utils.ConsoleWriter;

import java.util.Stack;

/**
 * Created by hadoop on 26/10/17.
 */
import java.util.*;
public class NextGreaterElement {
    public int[] nextGreaterElement(int[] findNums, int[] nums) {
        Map<Integer,Integer> hashMap = new HashMap<>();
        Stack<Integer> stack = new Stack<>();
        for(int i=nums.length-1;i>=0;i--){
            while (!stack.isEmpty() && nums[i]>stack.peek()){
                stack.pop();
            }
            if(stack.isEmpty()){
                hashMap.put(nums[i],-1);
            }
            else {
                hashMap.put(nums[i],stack.peek());
            }
            stack.push(nums[i]);

        }
        System.out.println(hashMap);
        int []ans = new int[findNums.length];
        for(int i=0;i<findNums.length;i++){
            ans[i] = hashMap.get(findNums[i]);
        }
        return ans;
    }
    public int[] nextGreaterElements(int[] nums) {
        Stack<Integer> stack = new Stack<>();
        List<Integer>list = new ArrayList<Integer>();
        for(int i=nums.length-1;i>=0;i--){
            while (!stack.isEmpty() && nums[i]>stack.peek()){
                stack.pop();
            }
            if(stack.isEmpty()){
                list.add(0,-1);
            }
            else {
                list.add(0,stack.peek());
            }
            stack.push(nums[i]);
        }
        int []ans = new int[list.size()];
        int index=0;
        for(int a:list){
            ans[index++] = a;
        }
        return ans;
    }
    public int[] nextGreaterElementsFromFront(int[] nums) {
        Stack<Integer> stack = new Stack<>();
        int n = nums.length;
        int []ans = new int[n];
        for(int i=0;i<ans.length;i++){
            ans[i] =-1;
        }
        for(int i=0;i<2*nums.length;i++){
            while (!stack.isEmpty() && nums[i%n]>nums[stack.peek()]){
                ans[stack.pop()]=nums[i%n];
            }
            if(i<n){
                stack.push(nums[i]);
            }
        }
        return ans;
    }
    public int[] nextGreaterElementForward(int[] findNums, int[] nums) {
        Map<Integer, Integer> map = new HashMap<>(); // map from x to next greater element of x
        Stack<Integer> stack = new Stack<>();
        for (int num : nums) {
            while (!stack.isEmpty() && stack.peek() < num)
                map.put(stack.pop(), num);
            stack.push(num);
        }
        for (int i = 0; i < findNums.length; i++)
            findNums[i] = map.getOrDefault(findNums[i], -1);
        return findNums;
    }
        public static void main(String args[]){
        NextGreaterElement nextGreaterElement=  new NextGreaterElement();
      //  ConsoleWriter.printIntArray(nextGreaterElement.nextGreaterElement(new int[]{2,4},new int[]{1,2,3,4}));
       // ConsoleWriter.printIntArray(nextGreaterElement.nextGreaterElements(new int[]{1,2,1}));
            System.out.println(nextGreaterElement.nextPermutation(12222333));
    }

    int nextPermutation(int n){
            char []array = String.valueOf(n).toCharArray();
            int ans = nextpermu(array);
            if(ans == -1){
                return -1;
            }
            Long finalAns= Long.valueOf(String.valueOf(array));
            if(finalAns>=Integer.MAX_VALUE){
                return -1;
            }
            return finalAns.intValue();
    }

    private int nextpermu(char[] array) {
        int breakpoint = -1;
        int i=0;
        for(i = array.length-2;i>=0;i--){
            if(array[i]<array[i+1]){
                for(int j = array.length-1;j>i;j--){
                    if(array[j]>array[i]){
                        breakpoint = j;
                        break;
                    }
                }
                break;
            }
            else if(i ==0) {
                return -1;
            }
        }
        if(breakpoint == -1){
            return -1;
        }
        System.out.println(breakpoint);
        char temp = array[i];
        array[i] = array[breakpoint];
        array[breakpoint]= temp;


        for(int p=0;p<array.length;p++){
            System.out.print(array[p]);
        }
        System.out.println();
        System.out.println(i+1);
        System.out.println(array.length-1);
        reverse(array,i+1,array.length-1);
        for(int p=0;p<array.length;p++){
            System.out.print(array[p]);
        }
        System.out.println();
        return 1;
    }

    private void reverse(char[] array, int start, int end) {
        while (start < end) {
            char temp = array[start];
            array[start] = array[end];
            array[end] = temp;
            start++;
            end--;
            System.out.println("rev");
        }
    }
}
package BasicAlgorithms.Stack;

import java.util.Deque;
import java.util.LinkedList;
import java.util.Stack;

/**
 * Created by hadoop on 19/10/17.
 */
/*
Given a string with unbalanced brackets how do you remove minimum number
 * of extra brackets so that you are left with balanced brackets in the string
 *
 * e.g )( -> empty string
 *     (a) -> (a)
 *     ((mnq)abc))) -> ((mna)abc)
 *     (abc)(( -> (abc)
 *
 *     https://github.com/mission-peace/interview/blob/master/src/com/interview/stackqueue/RemoveExtraBrackets.java
 */
public class RemoveInvalidChars {
    public int remove(char input[]) {
        if (input == null) {
            return 0;
        }
        Deque<Integer> deque = new LinkedList<>();

        for (int i = 0; i < input.length; i++) {
            if (input[i] != '(' && input[i] != ')')
                continue;

            // add opening bracekets
            if (input[i] == '(') {
                deque.addFirst(i);
            } else if (input[i] == ')') {
                if (!deque.isEmpty() && input[deque.getFirst()] == '(') {
                    deque.pollFirst();
                } else {
                    deque.addFirst(i);
                }
            }
        }
        int index = 0;
        for (int i = 0; i < input.length; i++) {
            if (!deque.isEmpty() && i == deque.getLast()) {
                deque.pollLast();
            } else {
                input[index++] = input[i];
            }
        }
        return index;
    }

    public String balance(String s) {
        Stack<Integer> stack = new Stack<>();
        StringBuilder sb = new StringBuilder(s);
        // stack would have all indexes to remove

        for(int i=0;i<s.length();i++){
            Character c= s.charAt(i);
            if(c == '('){
                stack.push(i);
            }
            else {
                // pushing ) into the stack
                if(stack.empty()){
                    stack.push(i);
                }

                // if not empty try to see match
                Integer peek = stack.peek();
                if(matching(s.charAt(peek),c)){
                    stack.pop();
                }
                else {
                    // not matched means for sure its gona be )) case in the stack
                    stack.push(i);
                }

            }
        }
        while (!stack.isEmpty()){
            sb.deleteCharAt(stack.pop());
        }
        return sb.toString();
    }

    private boolean matching(Character peek, char c) {
        if (peek == '(' && c == ')') {
            return true;
        }
        if (peek == '[' && c == ']') {
            return true;
        }
        if (peek == '{' && c == '}') {
            return true;
        }
        return false;
    }
}package BasicAlgorithms.Stack;

import java.util.Stack;

/**
 * Created by hadoop on 21/10/17.
 */
public class Histogram {
    public int largestRectangleArea(int[] heights) {

        Stack<Integer> stack = new Stack<Integer>();
        int max = 0;
        for (int i = 0; i < heights.length; i++) {
            if (stack.isEmpty()) {
                stack.push(i);
                continue;
            }

            while (!stack.isEmpty() && heights[i] < heights[stack.peek()]) {
                int toppedHeight = heights[stack.pop()];
                int width = 0;
                if (!stack.isEmpty()) {
                    width = i - stack.peek() - 1;
                } else {
                    width = i;
                }
                max = Math.max(max, toppedHeight * width);
            }
            stack.push(i);
        }
        while (!stack.isEmpty()) {
            int toppedHeight = heights[stack.pop()];
            int width = 0;
            if (!stack.isEmpty()) {
                width = heights.length - stack.peek() - 1;
            } else {
                width = heights.length;
            }
            max = Math.max(max, toppedHeight * width);
        }
        return max;
    }

    public int maximalRectangle(char[][] matrix) {
        int max = Integer.MIN_VALUE;
        int[] histogram = new int[matrix[0].length];
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j <= matrix[0].length; j++) {
                if (matrix[i][j] == '0') {
                    histogram[j] = 0;
                } else {
                    histogram[j]++;
                }
            }
            max = Math.max(max, largestRectangleArea(histogram));
        }
        return max;
    }

    public static int maxSum(int[][] matrix) {
        int max = Integer.MIN_VALUE;
        for(int i=0;i<matrix.length;i++){
            int rowsum[] = new int[matrix[0].length];
            for(int j=0;j<matrix.length;j++){

                for(int k=0;k<matrix[0].length;k++){
                    rowsum[k] = rowsum[k]+matrix[j][k];
                }

                max = Math.max(max,kadanesAlgo(rowsum));
            }
        }
        return max;
    }

    private static int kadanesAlgo(int[] rowsum) {
        int left[] = new int[rowsum.length];
        int currentmax = 0;
        int globalmax = 0;
        for(int i=0;i<rowsum.length;i++){
            if(i ==0){
                left[i] = rowsum[i];
                currentmax = rowsum[i];
            }
            else {
                currentmax = Math.max(rowsum[i],currentmax +rowsum[i]);
                left[i] =Math.max(left[i-1],currentmax);
            }
            globalmax = Math.max(globalmax,left[i]);
        }
        return globalmax;
    }
    public static void main(String args[]){
        Histogram histogram = new Histogram();
        int array[] = {2,1,5,6,2,3};
        System.out.println(histogram.largestRectangleArea(array));
    }
}package BasicAlgorithms.Stack;

import java.util.Stack;

/**
 * Created by hadoop on 18/10/17.
 */
public class LongestValid {

    public int longestValidParentheses(String s) {
        if (s == null || s.length() == 0) {
            return 0;
        }
        Stack<Integer> stack = new Stack<>();

        int start = 0;
        int longest = Integer.MIN_VALUE;
        for(int i=0;i<s.length();i++){
            char c = s.charAt(i);
            if(c =='('){
                stack.push(i);
            }
            else {
                if(stack.isEmpty()){
                    start = i+1;
                }
                else {
                    stack.pop();

                    if(stack.isEmpty()){
                        longest = Math.max(longest,i-start+1);
                    }
                    else {
                        longest = Math.max(longest,i-stack.peek());
                    }
                }
            }
        }
        return longest;
    }
    private boolean matching(Character peek, char c) {
        if (peek == '(' && c == ')') {
            return true;
        }
        if (peek == '[' && c == ']') {
            return true;
        }
        if (peek == '{' && c == '}') {
            return true;
        }
        return false;
    }
    public static void main(String args[]){
        LongestValid longestValid = new LongestValid();
        System.out.println(longestValid.longestValidParentheses(")()())"));
    }
}
package BasicAlgorithms.Stack;

import java.util.Stack;

public class ExpressionValidate {

	public static String validateExpression(String expr) {

		char r[] = expr.toCharArray();
        char s[] = expr.toCharArray();
		Stack<Integer> st = new Stack<Integer>();
		int i = 0;
		while (i < s.length) 
		{
			if (s[i] == '(') {
				if (s[i + 1] == '(') {
					st.push(-i);
				} else {
					st.push(i);
				}
				i++;
			} else if (s[i] != ')' && s[i] != '(') {
				i++;
			} else if (s[i] == ')') {
				int top = st.peek();
				if (s[i - 1] == ')' && top < 0) {
					r[-top] = '$';
					r[i] = '$';
					st.pop();
				}

				else if (s[i - 1] == ')' && top > 0) {
					System.out.println("Something is wrong!!");
				}

				else if (s[i - 1] != ')' && top > 0)
					st.pop();
				i++;
			}
		}

		StringBuffer result = new StringBuffer();

		for (i = 0; i<r.length; i++) {
			if (r[i] == '$') {
				continue;
			}
			result.append(r[i]);
		}

		return result.toString();

	}

	public static void main(String[] args) {
		String expr = "((((A+B))C))";
		System.out.println("Validate expression"+validateExpression(expr));

	}

}
/*
How to remove extra bracket from expressions like ((((A+B))C)) to give (A+B)C in the most optimized way?

Remember the input expression will be valid expression and output expression generated must also be valid and should give the same result as the input expression.

This can be done in O(n) time complexity using stack data structure.

The algorithm

Start traversing the expression from left examining every bracket.
If you encounter "(" such that there is another "(" to the right of it, this might be one of the extra brackets to be removed. However we can't be sure right now. So put the minus times the index of this bracket in the integer stack.(we put minus times the index to distinguish brackets having similar brackets to their right from the ones not having )
If you encounter "(" such that there is a character other than "(" to its right , put its index in the stack.
If you encounter ")" such that there is another ")" to its left and we have a negative number on the top of the stack, pop the stack and replace current ")" and bracket at the index minus times top of the stack with "$"(so that these brackets can be removed later and are useless).
If you encounter ")" such that there is a character other than ")" to its left and top of the stack has the positive number than you need that bracket so just pop the stack.
At the end we will have useless brackets replaced with "$" sign, which can be removed in a single traversal. Thus giving us an O(n) complexity. Here is the running code using above explained algorithm.
 */package BasicAlgorithms.Stack;

import java.util.Stack;

/**
 * Created by hadoop on 18/10/17.
 */
public class IsValidParenthesis {
    public boolean isValid(String s) {
        if (s == null || s.length() == 0) {
            return true;
        }
        if(s.length() == 1){
            return false;
        }
        Stack<Character> stack = new Stack<>();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (c == '(' || c == '{' || c == '[') {
                stack.push(c);
            } else {
                if (!stack.isEmpty() && matching(stack.peek(), c)) {
                    stack.pop();
                }
                else{
                    return false;
                }
            }
        }
        return stack.isEmpty();
    }

    private boolean matching(Character peek, char c) {
        if (peek == '(' && c == ')') {
            return true;
        }
        if (peek == '[' && c == ']') {
            return true;
        }
        if (peek == '{' && c == '}') {
            return true;
        }
        return false;
    }
}package BasicAlgorithms.Stack;

import java.util.*;
/**
 * Created by hadoop on 19/10/17.
 */

class BasicCalculator2 {
    public int calculate(String s) {
        List<String> list = new ArrayList<>();
        String array[] = null;
        int index = 0;
        for(int i=0;i<s.length();){
            int num=0;
            if(Character.isDigit(s.charAt(i))){
                while (i < s.length() && Character.isDigit(s.charAt(i))) {
                    num = num * 10 + s.charAt(i) - '0';
                    i++;
                }
                list.add(String.valueOf(num).trim());
            }
            else if(i<s.length() && s.charAt(i)=='('){
                list.add(String.valueOf(s.charAt(i)).trim());
                i++;
            }
            else if(i<s.length() && s.charAt(i)==')'){
                list.add(String.valueOf(s.charAt(i)).trim());
                i++;
            }
            else if(i<s.length() && s.charAt(i)=='+'){
                list.add(String.valueOf(s.charAt(i)).trim());
                i++;
            }
            else if(i<s.length() && s.charAt(i)=='-'){
                list.add(String.valueOf(s.charAt(i)).trim());
                i++;
            }
            else if(i<s.length() && s.charAt(i)=='*'){
                list.add(String.valueOf(s.charAt(i)).trim());
                i++;
            }
            else if(i<s.length() && s.charAt(i)=='/'){
                list.add(String.valueOf(s.charAt(i)).trim());
                i++;
            }
            else {
                i++;
            }
        }
        // System.out.println("list"+list);
        array = new String[list.size()];
        for(String tokens:list){
            array[index++] = tokens;
        }
        return evaluateExpression(array);
        //return -1;
    }
    public int evaluateExpression(String[] expression) {
        if (expression == null || expression.length == 0) {
            return 0;
        }
        Stack<Integer> numStack = new Stack<>();
        Stack<String> opStack = new Stack<>();
        for (String token : expression) {
            if (isNumber(token)) {
                numStack.push(Integer.valueOf(token));
            } else if (token.equals("(")) {
                opStack.push(token);
            } else if (token.equals(")")) {
                while (!opStack.peek().equals("(")) {
                    numStack.push(compute(numStack.pop(), numStack.pop(), opStack.pop()));
                }
                opStack.pop();  // pop out "("
            } else {
                while (!opStack.isEmpty() && getPriority(opStack.peek()) >= getPriority(token)) {
                    numStack.push(compute(numStack.pop(), numStack.pop(), opStack.pop()));
                }
                opStack.push(token);
            }
        }
        while (!opStack.isEmpty()) {
            numStack.push(compute(numStack.pop(), numStack.pop(), opStack.pop()));
        }
        return numStack.isEmpty() ? 0 : numStack.pop();
    }

    private boolean isNumber(String token) {
        return Character.isDigit(token.charAt(0));
    }

    private int getPriority(String op) {
        if (op.equals("(")) {
            return 0;
        } else if (op.equals("+") || op.equals("-")) {
            return 1;
        } else {
            return 2;
        }
    }

    private int compute(int num2, int num1, String token) {
        int result;
        if (token.equals("+")) {
            result = num1 + num2;
        } else if (token.equals("-")) {
            result = num1 - num2;
        } else if (token.equals("*")) {
            result = num1 * num2;
        } else {
            result = num1 / num2;
        }
        return result;
    }

}package BasicAlgorithms.Stack;

import java.util.*;

/**
 * Created by hadoop on 19/10/17.
 */
/*
"()())()" -> ["()()()", "(())()"]
				"(a)())()" -> ["(a)()()", "(a())()"]
				")(" -> [""]
 */


// very nice multiple are possibel hence apply bfs to get
    // shortest all possible paths ..
    // rememver bfs template /// very nice problem it is ..

public class RemoveInvalidParenthesesGenerateValidone {
    public List<String> removeInvalidParentheses(String s) {
        List<String> list = new ArrayList<>();
        if(s == null || s.length() == 0){
            return list;
        }
        Set<String> visited = new HashSet<>();
        String source = s;
        int infinity = Integer.MAX_VALUE;
        HashMap<String,Integer> distance = new HashMap<>();
        HashMap<String,String> path = new HashMap<>();
        LinkedList<String> queue = new LinkedList<>();
        distance.put(s,0);
        queue.add(s);
        visited.add(s);
        boolean found = false;
        while (!queue.isEmpty()){
            String polled = queue.poll();
            System.out.println("polled "+polled);
            // check if state has been achiveed
            if(isValid(polled)){
                list.add(polled);
                // instead of iterating get all shortest paths and qui
                // done enter loop and look for states
                found = true;
            }
            if(found){
                continue;
            }
            // we cant look for validity since here
            /// we might validity after romaval of several characnerts
            // bit different  but inytereting
            List<String> states = getAllStates(polled);
            System.out.println("all satteds "+states );
            for(String neightbour:states){
                if(!visited.contains(neightbour)) {
                    visited.add(neightbour);
                    distance.put(neightbour,distance.get(polled)+1);
                    path.put(neightbour,polled);
                    queue.add(neightbour);
                }
            }
        }
        return list;
    }

    private List<String> getAllStates(String polled) {
        List<String> states = new LinkedList<>();
        for(int i=0;i<polled.length();i++){
            if(polled.charAt(i)=='(' || polled.charAt(i)==')') {
                states.add(polled.substring(0, i) + polled.substring(i + 1));
            }
        }
        return states;
    }

    public boolean isValid(String s) {
        if (s == null || s.length() == 0) {
            return true;
        }
//        if(s.length() == 1){
//            return false;
//        }
        Stack<Character> stack = new Stack<>();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (c == '(' || c == '{' || c == '[') {
                stack.push(c);
            } else if(c == ')' || c == '}' || c == ']') {
                if (!stack.isEmpty() && matching(stack.peek(), c)) {
                    stack.pop();
                }
                else{
                    return false;
                }
            }
            else {

            }
        }
        return stack.isEmpty();
    }

    private boolean matching(Character peek, char c) {
        if (peek == '(' && c == ')') {
            return true;
        }
        if (peek == '[' && c == ']') {
            return true;
        }
        if (peek == '{' && c == '}') {
            return true;
        }
        return false;
    }
    public static void main(String args[]){
        RemoveInvalidParenthesesGenerateValidone r = new RemoveInvalidParenthesesGenerateValidone();
        System.out.println(r.removeInvalidParentheses("()())()"));

    }
}package BasicAlgorithms.Stack;//Java Code to count minimum reversal for
//making an expression balanced.
 
import java.util.Stack;
 
public class GFG 
{
 
    // Method count minimum reversal for
    //making an expression balanced.
    //Returns -1 if expression cannot be balanced
    static int countMinReversals(String expr)
    {
        int len = expr.length();
     
        // length of expression must be even to make
        // it balanced by using reversals.
        if (len%2 != 0)
        return -1;
     
        // After this loop, stack contains unbalanced
        // part of expression, i.e., expression of the
        // form "}}..}{{..{"
        Stack<Character> s=new Stack<>();
         
        for (int i=0; i<len; i++)
        {
            char c = expr.charAt(i);
            if (c =='}' && !s.empty())
            {
                if (s.peek()=='{')
                    s.pop();
                else
                    s.push(c);
            }
            else
                s.push(c);
        }
     
        // Length of the reduced expression
        // red_len = (m+n)
        int red_len = s.size();
     
        // count opening brackets at the end of
        // stack
        int n = 0;
        while (!s.empty() && s.peek() == '{')
        {
            s.pop();
            n++;
        }
     
        // return ceil(m/2) + ceil(n/2) which is
        // actually equal to (m+n)/2 + n%2 when
        // m+n is even.
        return (red_len/2 + n%2);
    }
     
    // Driver method
    public static void main(String[] args) 
    {
        String expr = "}}{{";
         
        System.out.println(countMinReversals(expr));
    }
 
}package BasicAlgorithms.Stack;

import java.util.Stack;

/**
 * Created by hadoop on 18/10/17.
 */
public class IsValidAgainWithDepth {
    public boolean isValid(String s) {
        if (s == null || s.length() == 0) {
            return true;
        }
        Stack<Character> stack = new Stack<>();
        for(int i=0;i<s.length();i++){
            char c = s.charAt(i);
            if(c == '(' || c== '[' || c== '{'){
                stack.push(c);
            }
            else {

                if(stack.isEmpty()){
                    return false;
                }
                Character peek = stack.peek();
                if(matching(peek,c)){
                    stack.pop();
                }
                else {
                    return false;
                }
            }
        }
        return stack.isEmpty();
    }

    private boolean matching(Character peek, char c) {
        if (peek == '(' && c == ')') {
            return true;
        }
        if (peek == '[' && c == ']') {
            return true;
        }
        if (peek == '{' && c == '}') {
            return true;
        }
        return false;
    }
}package BasicAlgorithms.Stack;

import java.util.ArrayList;
import java.util.List;

/**
 * Created by hadoop on 18/10/17.
 */
//https://discuss.leetcode.com/topic/33127/java-easy-to-understand-recursive-dp-method-with-explanations
public class GenerateParenthesis {
    public List<String> generateParenthesis(int n) {

        return generateParenthesisHelper(0,n-1);
    }

    private List<String> generateParenthesisHelper(int start, int end) {
        List<String> list = new ArrayList<>();
        if(start == end){
            list.add("()");
            return list;
        }
        if(start>end){
            list.add("");
            return list;
        }
        if(start>end){
            return list;
        }
        for(int mid = start;mid<=end;mid++) {
            List<String> leftAns = generateParenthesisHelper(start, mid - 1);
            List<String> rightAns = generateParenthesisHelper(mid + 1, end);
            for (String left : leftAns) {
                for (String right : rightAns) {
                    list.add("(" + left + ")" + right);
                }
            }
        }
        return list;
    }
    public static void main(String args[]){
        GenerateParenthesis generateParenthesis = new GenerateParenthesis();
        System.out.println(generateParenthesis.generateParenthesis(3));
    }


}
package BasicAlgorithms.SegmentTree;

/**
 * Created by hadoop on 25/10/17.
 */
import java.util.*;
public class InsertInTreeBasedOnIndex {
    private class Solution {
        // with array insert: 18ms, 86%
        // with tree: 21ms, 61%
        public int[][] reconstructQueue(int[][] people) {
            if (people.length <= 1) return people;
            // sort height in descending order (same height: sort position in ascending order)
            Arrays.sort(people, new Comparator<int[]>() {
                @Override
                public int compare(int[] a, int[] b) {
                    return a[0] != b[0] ? b[0] - a[0] : a[1] - b[1];
                }
            });
        /*
        List<int[]> list = new ArrayList<>();
        for (int[] i : people) {
            list.add(i[1], i);
        }
        int[][] res = new int[people.length][2];
        for (int i = 0; i < people.length; i++) {
            res[i] = list.get(i);
        }
        */
            // add to tree according to its position/rank
            TreeNode root = new TreeNode(people[0]);
            for (int i = 1; i < people.length; i++) {
                addToTree(root, people[i], people[i][1]);
            }
            // inoder traversal
            int[][] res = new int[people.length][2];
            dfs(root, res, new int[1]);
            return res;
        }

        private void dfs(TreeNode node, int[][] res, int[] i) {
            if (node == null) return;
            dfs(node.left, res, i);
            res[i[0]] = node.val;
            i[0]++;
            dfs(node.right, res, i);
        }

        private void addToTree(TreeNode root, int[] curr, int pos) {
            TreeNode node = root;
            while (node != null) {
                node.size++;
                if (pos <= sizeOf(node.left)) {
                    if (node.left == null) {
                        node.left = new TreeNode(curr);
                        break;
                    }
                    node = node.left;
                } else {
                    if (node.right == null) {
                        node.right = new TreeNode(curr);
                        break;
                    }
                    pos -= sizeOf(node.left) + 1;
                    node = node.right;
                }
            }
        }

        private int sizeOf(TreeNode node) {
            return node == null ? 0 : node.size;
        }
    }

    class TreeNode {
        int[] val;
        int size;
        TreeNode left, right;
        public TreeNode(int[] v) {
            val = v;
            size = 1;
        }
    }
}
package BasicAlgorithms.SegmentTree;

import BasicAlgorithms.utils.ConsoleWriter;

import java.util.*;
class QueueHeight {
    
    class PersonInQ {
        
        int height;
        int equalOrHighCount;
     
        public PersonInQ(int height, int equalOrHighCount) {
            this.height = height;
            this.equalOrHighCount = equalOrHighCount;
        }
        
        public String toString() {
            return "[" + height + "," + equalOrHighCount + "]";
        }
    }
    
    class PersonInQComparator implements Comparator<PersonInQ> {
        public int compare(PersonInQ p1, PersonInQ p2) {
            if (p1.height != p2.height) {
                return p2.height-p1.height;
            } else if (p1.height == p2.height) {
                if (p1.equalOrHighCount < p2.equalOrHighCount) {
                    return -1;
                } else if (p1.equalOrHighCount == p2.equalOrHighCount) {
                    return 0;
                } else {
                    return 1;
                }
            } else {
                return 1;
            }
        }
    }
    
    class BinaryIndexTree<T> {
    	
		T element;
		int leftCount;
		int rightCount;
		BinaryIndexTree<T> left;
		BinaryIndexTree<T> right;
		BinaryIndexTree<T> parent;
    	    	
    	public BinaryIndexTree(T element) {
    		this.element = element;
    	}
    	
    	public int getSize() {
    		return leftCount + rightCount + 1;
    	}

    	private void updateParentCounts(BinaryIndexTree<T> start) {
			BinaryIndexTree<T> current = start;
			while (current.parent != null) {
				if (current == current.parent.left) {
					current.parent.leftCount = current.getSize();
				} else if (current == current.parent.right) {
					current.parent.rightCount = current.getSize();
				}
				current = current.parent;
			}
    	}
    	
    	public void add(T element, int index) {  		
    		if (index < this.leftCount) {
    			this.left.add(element, index);
    		} else if (index == this.leftCount) {    			
				BinaryIndexTree<T> newNode = new BinaryIndexTree<>(element);
				newNode.left = this.left;
				newNode.parent = this;
				this.left = newNode;
				
				if (newNode.left != null) {
	    			newNode.left.parent = newNode;
	    			newNode.leftCount = newNode.left.getSize();
				}
				
				updateParentCounts(newNode);
    		} else if (index < this.getSize()) {    			
    			this.right.add(element, index - this.leftCount - 1);
    		} else if (index == this.getSize()) {
    			BinaryIndexTree<T> current = this;
    			while (current.right != null) {
    				current = current.right;
    			}
    			BinaryIndexTree<T> newNode = new BinaryIndexTree<>(element);
    			newNode.parent = current;
    			current.right = newNode;
    			current.rightCount = current.right.getSize();
    			updateParentCounts(newNode);
    		}
    	}
    	
    	public List<T> orderedList() {
    		
    		List<T> result = new ArrayList<>();
    		
    		List<T> leftList = null;
    		if (this.left != null) {
    			 leftList = this.left.orderedList();
    			 result.addAll(leftList);
    		}
    		
    		result.add(this.element);
    		
    		List<T> rightList = null;
    		if (this.right != null) {
    			 rightList = this.right.orderedList();
    			 result.addAll(rightList);
    		}
    		    		
    		return result;
    	}
    	
    	public void printOrdered() {
    		List<T> l = this.orderedList();
    		for (int i=0; i<l.size(); i++) {
    			System.out.print(l.get(i).toString() + " ");			
    		}    		
    	}
    }
    
    public int[][] reconstructQueue(int[][] people) {
        
        int[][] queue = new int[people.length][2];
        
        if (people.length == 0) {
            return queue;
        }
        
        List<PersonInQ> list = new ArrayList<PersonInQ>();

        for (int i=0; i<people.length; i++) {
        	list.add(new PersonInQ(people[i][0], people[i][1]));
        }
        
        Collections.sort(list, new PersonInQComparator());
		System.out.println(list);

		BinaryIndexTree<PersonInQ> root = new BinaryIndexTree<PersonInQ>(list.get(0));
        for (int i=1; i<list.size(); i++) {
        	root.add(list.get(i), list.get(i).equalOrHighCount);
        }
        
        List<PersonInQ> sortedResult = root.orderedList();
        
        for (int i=0; i<sortedResult.size(); i++) {
        	queue[i][0] = sortedResult.get(i).height;
        	queue[i][1] = sortedResult.get(i).equalOrHighCount;
        }
        
        return queue;
    }

	public static void main(String[] args) {
    	int matrix [][]={{7,0}, {4,4}, {7,1}, {5,0}, {6,1}, {5,2}}
;
		QueueHeight queueHeight = new QueueHeight();
		ConsoleWriter.printIntArray(queueHeight.reconstructQueue(matrix));
	}
}package BasicAlgorithms.SegmentTree;

/**
 * Created by hadoop on 25/10/17.
 */
public class FinalCompletInversionTopicPostOrder {
    private class Node implements Comparable<Node>{
        int index;
        int value;

        public Node(int value, int index) {
            this.index = index;
            this.value = value;
        }
        @Override
        public int compareTo(Node that){
            return this.value-that.value;
        }

        @Override
        public String toString() {
            return "Node{" +
                    "index=" + index +
                    ", value=" + value +
                    '}';
        }
    }
    public int mergeSortWithExtraCapabilities(int []array){
        Node [] nodes = new Node[array.length];
        for(int i=0;i<array.length;i++){
            nodes[i] = new Node(array[i],i);
        }
        int []extraAns = new int[array.length];
        breakAndMerge(nodes,extraAns,0,nodes.length-1);
        int ans = 0;
        for(int num:extraAns){
            ans = ans + num;
        }
        return ans;
    }

    private void breakAndMerge(Node[] nodes, int[] extraAns, int start, int end) {
        if(start>=end) return;
        int mid = (start + end)/2;
        breakAndMerge(nodes,extraAns,start,mid);
        breakAndMerge(nodes,extraAns,mid+1,end);

        Node []cache = new Node[nodes.length];
        int i = start;
        int j = mid +1;
        while (i<=mid){
            while (j<=end && nodes[i].value>2*nodes[j].value){
                j++;
            }
            extraAns[nodes[i].index]+= (j-1)-(mid+1)+1;
            i++;
        }

        i = start;
        j = mid +1;
        int k = start;
        while (i<=mid){
            while (j<=end && nodes[i].value>nodes[j].value){
                cache[k++] = nodes[j];
                j++;
            }
            cache[k++] = nodes[i];
            i++;
        }
        while (j<=end){
            cache[k++] = nodes[j];
            j++;
        }

        for(int s = start;s<=end;s++){
            nodes[s] = cache[s];
        }
    }

    public static void main(String[] args) {
        FinalCompletInversionTopicPostOrder finalCompletInversionTopicPostOrder = new FinalCompletInversionTopicPostOrder();
        System.out.println(finalCompletInversionTopicPostOrder.mergeSortWithExtraCapabilities(new int[]{2,4,3,5,1}));

    }
}
package BasicAlgorithms.SegmentTree;

/**
 * Created by hadoop on 24/10/17.
 */
public class SegmentTreeBuild {


    private class SegmentTreeNode{
        int start;
        int end;
        SegmentTreeNode left;
        SegmentTreeNode right;
        SegmentTreeNode(int start, int end){
            this.start = start;
            this.end = end;
        }
    }

    public SegmentTreeNode build(int start, int end) {
        if(start>end){
            return null;
        }
        if(start == end){
            SegmentTreeNode root = new SegmentTreeNode(start,start);
            return root;
        }
        int mid = start + (end-start)/2;
        SegmentTreeNode root = new SegmentTreeNode(start,end);
        root.left = build(start,mid);
        root.right = build(mid+1,end);
        return root;
    }

}
package BasicAlgorithms.SegmentTree;

import BasicAlgorithms.utils.ConsoleWriter;

/**
 * Created by hadoop on 24/10/17.
 */
public class CountInversion {
    class Node{
        int value;
        int index;
        public Node(int value,int index){
            this.index = index;
            this.value = value;
        }

        @Override
        public String toString() {
            return "Node{" +
                    "value=" + value +
                    ", index=" + index +
                    '}';
        }
    }
    public int[] generateInversionCount(int[] A){
        Node [] nodes = new Node[A.length];
        int []B  = new int[A.length];
        for(int i=0;i<A.length;i++){
            nodes[i] = new Node(A[i],i);
        }
        Node aux[] = new Node[A.length];
        mergeSort(nodes,aux,B,0,A.length-1);
//        for(Node a:nodes){
//            System.out.print(a.value);
//        }
//        System.out.println();
        return B;
    }

    private void mergeSort(Node[] nodes, Node[] aux, int[] b, int low, int high) {
        if(low>=high){
            return;
        }
        int mid = low + (high-low)/2;
        mergeSort(nodes,aux,b,low,mid);
        mergeSort(nodes,aux,b,mid+1,high);
        merge(nodes,aux,b,low,mid,high);
    }

    private void merge(Node[] nodes, Node[] aux, int[] b, int low, int mid, int high) {
        int left = low;
        int right = high;
        int j = high;
        int i = mid;
        int k = high;
        while (j>=mid+1 || i>=left){
            if(j<=mid){
                aux[k] = nodes[i];
                i--;
                k--;
            }
            else if(i<left){
                aux[k] = nodes[j];
                k--;
                j--;
            }
            else if(nodes[i].value>nodes[j].value){
                b[nodes[i].index]+=j-mid;
                aux[k] = nodes[i];
                k--;
                i--;
            }
            else {
                aux[k] = nodes[j];
                k--;
                j--;
            }
        }
        for(int s=left;s<=right;s++){
            nodes[s] = aux[s];
        }
//        ConsoleWriter.printIntArray(b);
//        for(int s= low;s<=high;s++){
//            System.out.print(nodes[s]);
//        }
    }

    public static void main(String[] args) {
        CountInversion countInversion = new CountInversion();
        int[] A = new int[]{5, 2, 6, 1};
        ConsoleWriter.printIntArray(countInversion.generateInversionCount(A));
    }
}
/*
1, 0, 0, 0, 0,
2, 0, 0, 0, 0,
2, 0, 1, 1, 0,
4, 0, 1, 1, 0,
4, 0, 1, 1, 0,
 */
/*
1, 0, 0, 0, 0,
2, 0, 0, 0, 0,
2, 0, 0, 1, 0,
2, 0, 0, 1, 0,
2, 0, 0, 1, 0,
 */package BasicAlgorithms.SegmentTree;

/**
 * Created by hadoop on 24/10/17.
 */
public class NumMatrixImmutable {
  //  class NumMatrix {
        int sum[][];
        int rows;
        int cols;
        public NumMatrixImmutable(int[][] matrix) {
            if(matrix == null || matrix.length ==0 ){
                return;
            }
            rows = matrix.length;
            cols = matrix[0].length;
            sum = new int[rows+1][cols+1];
            for(int i=1;i<=rows;i++){
                for(int j=1;j<=cols;j++){
                    sum[i][j] = sum[i-1][j] + sum[i][j-1] -sum[i-1][j-1] + matrix[i-1][j-1];
                }
            }
        }

        public int sumRegion(int row1, int col1, int row2, int col2) {
            if(sum == null){
                return Integer.MAX_VALUE;
            }
            return sum[row2+1][col2+1] -sum[row1][col2+1]-sum[row2+1][col1] +sum[row1][col1];
        }
   // }

    public static void main(String[] args) {
        int matrix[][] = {{3,0,1,4,2},{5,6,3,2,1},{1,2,0,1,5},{4,1,0,1,7},{1,0,3,0,5}};
        NumMatrixImmutable numMatrix = new NumMatrixImmutable(matrix);
        System.out.println(numMatrix.sumRegion(1,2,2,4));
    }
}
package BasicAlgorithms.SegmentTree;

import java.util.HashMap;

/**
 * Created by hadoop on 24/10/17.
 */
public class SubMatrixProblems {
    public static int maxSum(int[][] matrix) {
        int max = Integer.MIN_VALUE;
        for (int i = 0; i < matrix.length; i++) {
            int rowsum[] = new int[matrix[0].length];
            for (int j = i; j < matrix.length; j++) {

                for (int k = 0; k < matrix[0].length; k++) {
                    rowsum[k] = rowsum[k] + matrix[j][k];
                }

                max = Math.max(max, kadanesAlgo(rowsum));
            }
        }
        return max;
    }

    private static int kadanesAlgo(int[] rowsum) {
        int left[] = new int[rowsum.length];
        int currentmax = 0;
        int globalmax = 0;
        for (int i = 0; i < rowsum.length; i++) {
            if (i == 0) {
                left[i] = rowsum[i];
                currentmax = rowsum[i];
            } else {
                currentmax = Math.max(rowsum[i], currentmax + rowsum[i]);
                left[i] = Math.max(left[i - 1], currentmax);
            }
            globalmax = Math.max(globalmax, left[i]);
        }
        return globalmax;
    }
//    Submatrix Sum
//    Given an integer matrix, find a submatrix where the sum of numbers is zero. Your code should return the coordinate of the left-up and right-down number.
//
//    Example
//    Given matrix
//
//            [
//	  [1 ,5 ,7],
//              [3 ,7 ,-8],
//              [4 ,-8 ,9],
//              ]
//              return [(1,1), (2,2)]
//
//    Challenge
//    O(n3) time.
//if max sum asked then kadan's approach if zero asked then this approach

    public int[][] submatrixSum(int[][] matrix) {
        if (matrix.length == 0 || matrix == null) {
            return new int[][]{};
        }
        int rows = matrix.length;
        int columns = matrix[0].length;

        int sum[][] = new int[rows + 1][columns + 1];
        for (int i = 1; i <= rows; i++) {
            for (int j = 1; j <= columns; j++) {
                sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + matrix[i - 1][j - 1];
            }
        }
        int row1 = 1;
        int col1 = 2;
        int row2 = 2;
        int col2 = 3;
        int sumsub = getSum(row1, col1, row2, col2, sum);
        for (int i = 0; i < rows; i++) {
            for (int j = i + 1; j <= rows; j++) {
                HashMap<Integer, Integer> hashMap = new HashMap<>();
                hashMap.put(0, 0);
                for (int k = 1; k <= columns; k++) {
                    int diff = sum[j][k] - sum[i][k];
                    if (hashMap.containsKey(diff)) {
                        // please see why are we doing this ... with index
                        return new int[][]{{i, hashMap.get(diff)}, {j - 1, k - 1}};
                    }
                }
            }
        }
        return new int[][]{{}};
    }
    public int[][] submatrixSumEasyMethod(int[][] matrix) {
        if (matrix.length == 0 || matrix == null) {
            return new int[][]{};
        }
        for(int i=0;i<matrix.length;i++){
                int []cumulativeRow = new int[matrix[0].length];
            for(int j=i;j<matrix.length;j++){

                for(int k =0;k<matrix[0].length;k++){
                    cumulativeRow[k] = cumulativeRow[k] + matrix[j][k];
                }
                int []ans = getAnsFromOneD(cumulativeRow);
                if(ans!=null){
                    return new int[][]{{i,ans[0]},{j,ans[1]}};
                }
            }
        }
        return new int[][]{{}};
    }

    private int[] getAnsFromOneD(int[] cumulativeRow) {
        HashMap<Integer,Integer> hm = new HashMap<>();
        hm.put(0,-1);
        int sum = 0;
        for(int i=0;i<cumulativeRow.length;i++){
            sum = sum +cumulativeRow[i];
            if(hm.containsKey(sum)){
                return new int[]{hm.get(sum)+1,i};
            }
            hm.put(sum,i);
        }
        return null;
    }


    private int getSum(int row1, int col1, int row2, int col2, int[][] sum) {
        return sum[row2 + 1][col2 + 1] + sum[row1][col1] - sum[row2][col1] - sum[row1][col2];
    }

    public static int[] sumZero(int[] nums) {
        HashMap<Integer,Integer> hm = new HashMap<>();
        hm.put(0,-1);
        int sum = 0;
        for(int i=0;i<nums.length;i++){
            sum = sum +nums[i];
            if(hm.containsKey(sum)){
                return new int[]{hm.get(sum)+1,i};
            }
            hm.put(sum,i);
        }
        return new int[]{};
    }
}package BasicAlgorithms.SegmentTree;

/**
 * Created by hadoop on 25/10/17.
 */
public class RangeSum {
    int numberofelementsinrange(int []num, int lower,int upper){
        int []sum = new int[num.length+1];
        for(int i=1;i<=num.length;i++){
            sum[i] = sum[i-1] + num[i-1];
        }
        int result = 0;
        for(int i=0;i<sum.length;i++){
            for(int j=i+1;i<sum.length;j++){
                if(sum[j] -sum[j]>=lower && sum[j]-sum[i]<=upper){
                    result++;
                }
            }
        }
        return result;
    }
}
package BasicAlgorithms.SegmentTree;

/**
 * Created by hadoop on 10/10/17.
 */
public class SegmentTree {


    private class SegmentTreeNode {
        public int start;
        public int end;
        public int max;
        SegmentTreeNode left;
        SegmentTreeNode right;

        SegmentTreeNode(int start, int end, int max) {
            this.start = start;
            this.end = end;
            this.max = max;
        }
        SegmentTreeNode(int start,int end){
            this.start = start;
            this.end = end;
        }
    }
    SegmentTreeNode build(int a[],int start,int end){
        if(start>end){
            return null;
        }
        if(start == end){
            return  new SegmentTreeNode(start,end,a[start]);
        }
        int mid = (start+end)/2;
        SegmentTreeNode node = new SegmentTreeNode(start,end,Integer.MIN_VALUE);
        node.left = build(a,start,mid);
        node.right = build(a,mid+1,end);
        node.max = Math.max(node.left!=null ? node.left.max:Integer.MIN_VALUE,node.right!=null ?node.right.max:Integer.MIN_VALUE);
        return node;
    }
}package BasicAlgorithms.SegmentTree;

/**
 * Created by hadoop on 24/10/17.
 */
public class SegmentTreeBuild2 {
    private class SegmentTreeNode {
        SegmentTreeNode left;
        SegmentTreeNode right;
        int start;
        int end;
        int max;

        SegmentTreeNode(int start, int end) {
            this.start = start;
            this.end = end;
        }
    }

    public SegmentTreeNode build(int[] A) {
        int start = 0;
        int end = A.length-1;
        return buildHelper(A,start,end);
    }

    private SegmentTreeNode buildHelper(int[] a, int start, int end) {
        if(start>end){
            return null;
        }
        if(start == end){
            SegmentTreeNode root =  new SegmentTreeNode(start,start);
            root.max = a[start];
            return root;
        }
        SegmentTreeNode root = new SegmentTreeNode(start,end);
        int mid = start + (end-start)/2;
        root.left = buildHelper(a,start,mid);
        root.right = buildHelper(a,mid+1,end);
        if(root.left!=null){
            root.max = Math.max(root.max,root.left.max);
        }
        if(root.right!=null){
            root.max = Math.max(root.max,root.right.max);
        }
        return root;
    }
}package BasicAlgorithms.SegmentTree;

/**
 * Created by hadoop on 24/10/17.
 */
public class NumMatrix {
    TreeNode root;
    int [][]matrix ;
    public NumMatrix(int[][] matrix) {
        this.matrix = matrix;
        if (matrix.length == 0) {
            root = null;
        } else {
            root = buildTree(matrix, 0, 0, matrix.length-1, matrix[0].length-1);
        }
    }

    public void update(int row, int col, int val) {
        update(root, row, col, val);
    }

    private void update(TreeNode root, int row, int col, int val) {
        if (root.row1 == root.row2 && root.row1 == row && root.col1 == root.col2 && root.col1 == col) {
            root.sum = val;
            return;
        }
        int rowMid = (root.row1 + root.row2) / 2;
        int colMid = (root.col1 + root.col2) / 2;
        TreeNode next;
        if(row<=rowMid && col<=colMid) {
            update(root.c1,row,col,val);
        }
        if(row>rowMid && col<=colMid){
            update(root.c2,row,col,val);
        }
        if(row<=rowMid && col>colMid) {
            update(root.c3,row,col,val);
        }
        if(row>rowMid && col>colMid) {
            update(root.c4,row,col,val);
        }
        root.sum =( root.c1!=null?root.c1.sum:0) + (root.c2!=null?root.c2.sum:0) +(root.c3!=null?root.c3.sum:0) + (root.c4!=null?root.c4.sum:0);
        return;
    }

    public int sumRegion(int row1, int col1, int row2, int col2) {
        return sumRegion(root, row1, col1, row2, col2);
    }

    private int sumRegion(TreeNode root, int row1, int col1, int row2, int col2) {
        if(row1>row2 || col1>col2){
            return 0;
        }
        if (root.row1 == row1 && root.col1 == col1 && root.row2 == row2 && root.col2 == col2)
            return root.sum;
        int rowMid = (root.row1 + root.row2) / 2;
        int colMid = (root.col1 + root.col2) / 2;
        int leftquatersum = 0;
        int leftbottomquatersum =0;
        int rightquatersum = 0;
        int rightbottomquatersum = 0;

        if(row1<=rowMid && col1<=colMid){
            leftquatersum = sumRegion(root.c1,row1,col1,Math.min(row2,rowMid),Math.min(col2,colMid));
        }
        if(row2>rowMid && col1<=colMid){
            leftbottomquatersum = sumRegion(root.c2,Math.max(row1,rowMid+1),col1,row2,Math.min(col2,colMid));
        }
        if(row1<=rowMid && col2>colMid){
            rightquatersum = sumRegion(root.c3,row1,Math.max(colMid+1,col1),Math.min(row2,rowMid),col2);
        }
        if(row2>rowMid && col2>colMid){
            rightbottomquatersum = sumRegion(root.c4,Math.max(rowMid+1,row1),Math.max(colMid+1,col1),row2,col2);
        }
        return leftquatersum+ leftbottomquatersum + rightquatersum + rightbottomquatersum;
    }

    private TreeNode buildTree(int[][] matrix, int row1, int col1, int row2, int col2) {
        if (row2 < row1 || col2 < col1)
            return null;
        TreeNode node = new TreeNode(row1, col1, row2, col2);
        if (row1 == row2 && col1 == col2) {
            node.sum = matrix[row1][col1];
            return node;
        }
        int rowMid = (row1 + row2) / 2;
        int colMid = (col1 + col2) / 2;
        node.c1 = buildTree(matrix, row1, col1, rowMid, colMid);
        node.c2 = buildTree(matrix, rowMid+1, col1, row2,colMid );
        node.c3 = buildTree(matrix, row1, colMid+1, rowMid, col2);
        node.c4 = buildTree(matrix, rowMid+1, colMid+1, row2, col2);
        node.sum += node.c1 != null ? node.c1.sum : 0;
        node.sum += node.c2 != null ? node.c2.sum : 0;
        node.sum += node.c3 != null ? node.c3.sum : 0;
        node.sum += node.c4 != null ? node.c4.sum : 0;
        return node;
    }

    public class TreeNode {
        int row1, row2, col1, col2, sum;
        TreeNode c1, c2, c3, c4;
        public TreeNode (int row1, int col1, int row2, int col2) {
            this.row1 = row1;
            this.col1 = col1;
            this.row2 = row2;
            this.col2 = col2;
            this.sum = 0;
        }
    }

    public static void main(String[] args) {
        int matrix [][]= {{3,0,1,4,2},{5,6,3,2,1},{1,2,0,1,5},{4,1,0,1,7},{1,0,3,0,5}};
        NumMatrix numMatrix = new NumMatrix(matrix);
        System.out.println(numMatrix.sumRegion(2,1,4,3));
        numMatrix.update(3,2,2);
        System.out.println(numMatrix.sumRegion(2,1,4,3));

    }
}
package BasicAlgorithms.SegmentTree;

/**
 * Created by hadoop on 24/10/17.
 */

public class ShortCountInv {
    int[] helper;
    public int reversePairs(int[] nums) {
        this.helper = new int[nums.length];
        return mergeSort(nums, 0, nums.length-1);
    }
    private int mergeSort(int[] nums, int s, int e){
        if(s>=e) return 0;
        int mid = s + (e-s)/2;
        int cnt = mergeSort(nums, s, mid) + mergeSort(nums, mid+1, e);
        for(int i = s, j = mid+1; i<=mid; i++){
            while(j<=e && nums[i] > nums[j]) j++;
            cnt += j-(mid+1);
        }
        //Arrays.sort(nums, s, e+1);
        myMerge(nums, s, mid, e);
        return cnt;
    }

    private void myMerge(int[] nums, int s, int mid, int e){
        for(int i = s; i<=e; i++) helper[i] = nums[i];
        int p1 = s;//pointer for left part
        int p2 = mid+1;//pointer for rigth part
        int i = s;//pointer for sorted array
        while(p1<=mid || p2<=e){
            if(p1>mid || (p2<=e && helper[p1] >= helper[p2])){
                nums[i++] = helper[p2++];
            }else{
                nums[i++] = helper[p1++];
            }
        }
    }

    public static void main(String[] args) {
        ShortCountInv shortCountInv = new ShortCountInv();
        int[] A = new int[]{5, 1, 3, 4, 2};

        System.out.println(shortCountInv.reversePairs(A));
    }
}
package BasicAlgorithms.SegmentTree;

/**
 * Created by hadoop on 24/10/17.
 */
public class RangeQuery {
    SegmentTreeNode root= null;
    private class SegmentTreeNode {
        SegmentTreeNode left;
        SegmentTreeNode right;
        int start;
        int end;
        int sum;

        SegmentTreeNode(int start, int end) {
            this.start = start;
            this.end = end;
        }
    }
    private SegmentTreeNode buildHelper(int[] a, int start, int end) {
        if(start>end){
            return null;
        }
        if(start == end){
            SegmentTreeNode root =  new SegmentTreeNode(start,start);
            root.sum = a[start];
            return root;
        }
        SegmentTreeNode root = new SegmentTreeNode(start,end);
        int mid = start + (end-start)/2;
        root.left = buildHelper(a,start,mid);
        root.right = buildHelper(a,mid+1,end);
        root.sum = 0;
        if(root.left!=null){
            root.sum += root.left.sum;
        }
        if(root.right!=null){
            root.sum += root.right.sum;
        }
        return root;
    }
    public RangeQuery(int[] nums){
        root = buildHelper(nums,0,nums.length-1);
    }
    public int sumRange(int i, int j){
        return sumRangeHelper(root,i,j);
    }
    void update(int i, int val){
        updateHelper(root,i,val);
    }
    SegmentTreeNode updateHelper(SegmentTreeNode node,int index,int value){
        if(node == null){
            return null;
        }
        if(node.start == index && node.end == index){
            node.sum = value;
            return node;
        }

        int mid = node.start + (node.end-node.start)/2;
        if(index<=mid){
            SegmentTreeNode left = updateHelper(node.left,index,value);
        }
        else if(index>mid){
            SegmentTreeNode right = updateHelper(node.right,index,value);
        }
        node.sum = node.left.sum +node.right.sum;
        return node;
    }

    int sumRangeHelper(SegmentTreeNode node,int startrange,int endrange){
        if(node == null){
            return 0;
        }
        if(startrange ==node.start && endrange == node.end){
            return node.sum;
        }
        int mid = node.start + (node.end-node.start)/2;
        if(endrange<=mid){
            return sumRangeHelper(node.left,startrange,endrange);
        }
        else if(startrange>mid){
            return sumRangeHelper(node.right,startrange,endrange);
        }
        return sumRangeHelper(node.left,startrange,mid) + sumRangeHelper(node.right,mid+1,endrange);

    }
}
package BasicAlgorithms.SegmentTree;

/**
 * Created by hadoop on 24/10/17.
 */
public class Mutable2dMatrix {
    private int[][] colSums;
    private int[][] matrix;

    public Mutable2dMatrix(int[][] matrix) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return;
        }
        this.matrix = matrix;
        colSums = new int[matrix.length + 1][matrix[0].length];


        for (int i = 1; i <= matrix.length; i++) {
            for (int j = 0; j < matrix[0].length; j++) {
                colSums[i][j] = colSums[i - 1][j] + matrix[i - 1][j];
            }
        }
    }

    public void update(int row, int col, int val) {
        for(int i=row+1;i<=matrix.length;i++){
                colSums[i][col] = colSums[i][col] -matrix[row][col] +val;
        }
    }

    public int sumRegion(int row1, int col1, int row2, int col2) {
        int sum =0;
        for(int i=col1;i<=col2;i++){
            sum = sum + colSums[row2+1][i]-colSums[row1][i];
        }
        return sum;
    }
}package BasicAlgorithms.SegmentTree;

/**
 * Created by hadoop on 25/10/17.
 */

/**
 * Created by hadoop on 25/10/17.
 */
import BasicAlgorithms.utils.ConsoleWriter;

import java.util.*;
    public class Reverse {
        public Integer reversePairs(int[] A) {
            List<Integer> list = new ArrayList<>();
            if (A == null || A.length == 0) return 0;
            int[] ret = new int[A.length];
            Node array[] = new Node[A.length];
            for(int i=0;i<A.length;i++){
                array[i] = new Node(A[i],i);
            }
            search(A,array, 0, A.length - 1, ret);
            int ans =0;
            for(int n:ret){
                ans = ans + n;
            }
            ConsoleWriter.printIntArray(ret);
//            for(Node a:array){
//                System.out.print(a);
//            }
            return ans;
        }

        private void search(int[] A,Node[]nodes, int start, int end, int[] ret) {
            if (start == end) {
                //Node[] array = {new Node(A[start], start)};
                return ;
            }
           // Node[] array = new Node[nodes.length];
            search(A, nodes,start, (start + end) / 2, ret);
            search(A,nodes, (start + end) / 2 + 1, end, ret);
            int mid = (start + end)/2;
            int i = start;
            int j = mid +1;
            int t = mid +1;
            Node []cache= new Node[nodes.length];
            int k = start;
            System.out.println(nodes.length);
            while (i<=mid){
                System.out.println(i);
                System.out.println(nodes[i]);
                System.out.println("====");
                while (j<=end && nodes[i].val>2*nodes[j].val){
                    j++;
                    System.out.println(j);
//                    System.out.println(nodes[j]);
                }
                j--;
                ret[nodes[i].idx]+= j-(mid+1)+1;
                while (t<=end && nodes[i].val>nodes[t].val){
                    cache[k++] = nodes[t];
                    t++;
                }
                cache[k++] = nodes[i];
                i++;
            }
            for(int p=start;p<=end;p++){
                nodes[p] = cache[p];
            }
            //System.arraycopy(cache,start,nodes,start,end-start+1);
            //nodes = Arrays.copyOfRange(cache,start,mid+1);
           // Arrays.sort(nodes, start, end+1);
            //mymerge(nodes,start,end,mid,ret);
        }

//        private void mymerge(Node[] nodes, int start, int end, int mid,int []ret) {
//            Node []array = new Node[nodes.length];
//            int left = start;
//            int right = end;
//            int j = end;
//            int i = mid;
//            int k = end;
//            while (j>=mid+1 || i>=left){
//                if(j<=mid){
//                    array[k] = nodes[i];
//                    i--;
//                    k--;
//                }
//                else if(i<left){
//                    array[k] = nodes[j];
//                    k--;
//                    j--;
//                }
//                else if(nodes[i].val>nodes[j].val){
//                    if(nodes[i].val>2*nodes[j].val) {
//                        ret[nodes[i].idx] += j - mid;
//                    }
//                    array[k] = nodes[i];
//                    k--;
//                    i--;
//                }
//                else {
//                    array[k] = nodes[j];
//                    k--;
//                    j--;
//                }
//            }
//            for(int s=left;s<=right;s++){
//                nodes[s] = array[s];
//            }
//
//        }

        public static void main(String[] args) {
            Reverse c = new Reverse();
            System.out.println(c.reversePairs(new int[]{5,4,3,2,1}));
        }
        private class Node implements Comparable<Node>{
            int val, idx;
            public Node(int val, int idx) {
                this.val = val;
                this.idx = idx;
            }

            @Override
            public int compareTo(Node o) {
                return this.val-o.val;
            }

            @Override
            public String toString() {
                return "Node{" +
                        "val=" + val +
                        ", idx=" + idx +
                        '}';
            }
        }
    }
package BasicAlgorithms.SegmentTree;

import BasicAlgorithms.utils.ConsoleWriter;

import java.util.HashMap;
import java.util.TreeMap;
import java.util.TreeSet;

/**
 * Created by hadoop on 24/10/17.
 */
public class MaxSumRectangleNoGreaterThanK {
//    public int[][] submatrixSumEasyMethod(int[][] matrix,int k) {

    public Integer submatrixSumEasyMethod(int[][] matrix,int k) {
    if (matrix.length == 0 || matrix == null) {
           // return new int[][]{};
            return 0;
        }
        int answer = 0;
        for(int i=0;i<matrix.length;i++){
            int []cumulativeRow = new int[matrix[0].length];
            for(int j=i;j<matrix.length;j++){

                for(int col =0;col<matrix[0].length;col++){
                    cumulativeRow[col] = cumulativeRow[col] + matrix[j][col];
                }
           //     int []ans = getAnsFromOneD(cumulativeRow);
              //  ConsoleWriter.printIntArray(cumulativeRow);
                int []ans = maxsumNoGreaterThanKAgain(cumulativeRow,k);
                if(ans!=null){
                    answer = Math.max(answer,ans[0]);
//                    return new int[][]{{i,ans[0]},{j,ans[1]}};
                }
            }
        }
        return answer;
     //   return new int[][]{{}};
    }

    private int[] getAnsFromOneD(int[] cumulativeRow) {
        HashMap<Integer,Integer> hm = new HashMap<>();
        hm.put(0,-1);
        int sum = 0;
        for(int i=0;i<cumulativeRow.length;i++){
            sum = sum +cumulativeRow[i];
            if(hm.containsKey(sum)){
                return new int[]{hm.get(sum)+1,i};
            }
            hm.put(sum,i);
        }
        return null;
    }
    private int[] maxsumNoGreaterThanKAgain(int []cumulativeRow,int k) {
        int sum = 0;
        TreeSet<Integer> hm = new TreeSet<Integer>();
        int maxsumlessthank = Integer.MIN_VALUE;
        hm.add(0);
        for(int i=0;i<cumulativeRow.length;i++){
            sum = sum + cumulativeRow[i];
            //System.out.println(sum);
            if(hm.ceiling(sum-k)!=null) {
                maxsumlessthank = Math.max(maxsumlessthank, sum - hm.ceiling(sum - k));
            }
            hm.add(sum);
        }
        if(maxsumlessthank!=Integer.MIN_VALUE){
            return new int[]{maxsumlessthank};
        }
        return null;
    }

    private int[] maxsumNoGreaterThanK(int []cumulativeRow,int k){
        ConsoleWriter.printIntArray(cumulativeRow);
        int []left = new int[cumulativeRow.length];
        int []current = new int[cumulativeRow.length];
        int globalmaxsum = 0;
        int currentsum = 0;
        for(int i=0;i<cumulativeRow.length;i++){
            if(i ==0 ){
                left[i] = cumulativeRow[i];
                current[i] = cumulativeRow[i];
                globalmaxsum = cumulativeRow[i];
                currentsum = cumulativeRow[i];
            }
            else {
                currentsum = Math.max(currentsum + cumulativeRow[i],cumulativeRow[i]);
                System.out.println("current "+currentsum);
                current[i] = currentsum;
                globalmaxsum = Math.max(globalmaxsum,currentsum);
                left[i] = Math.max(left[i-1],currentsum);
            }
        }
        int ansagain=Integer.MIN_VALUE;
        ConsoleWriter.printIntArray(left);
        ConsoleWriter.printIntArray(current);
        for(int i=0;i<cumulativeRow.length;i++){
            if(current[i] <=k){
                ansagain = Math.max(current[i],ansagain);
            }
        }
        System.out.println("glo"+ansagain);
        if(ansagain<=k){
            return new int[]{ansagain};
        }
        else {
            return null;
        }
    }

    public static void main(String[] args) {
        MaxSumRectangleNoGreaterThanK maxSumRectangleNoGreaterThanK = new MaxSumRectangleNoGreaterThanK();
        int [][]matrix =
        {{5,-4,-3,4},{-3,-4,4,5},{5,1,5,-4}};

        int p = 3;
        System.out.println(maxSumRectangleNoGreaterThanK.submatrixSumEasyMethod(matrix,8));
        //System.out.println(maxSumRectangleNoGreaterThanK.maxsumNoGreaterThanKAgain(new int[]{2, -3, 9, 1},8)[0]);
    }
}
package BasicAlgorithms.SegmentTree;

/**
 * Created by hadoop on 25/10/17.
 */
import java.util.concurrent.*;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

public class ReversePairs {
    public int reversePairs(int[] nums) {
        TreeNode root = null;
        int totalans = 0;
        TreeSet<Double> set = new TreeSet<>();
        for(int i=nums.length-1;i>=0;i--){
           // System.out.println(nums[i]);
           // System.out.println(set.headSet(new Double(nums[i]/2)).size());
            int numberlessThancurrentby2 =countSmaller(root,(double)nums[i]/2);
            totalans = totalans + numberlessThancurrentby2;
            root = insert(root,nums[i]);
        }
        preorder(root);
        return totalans;
    }

    private class TreeNode{
        double val=0;
        int count =1;
        int leftSize =0;
        int rightSize =0;
        TreeNode left = null;
        TreeNode right = null;
        public TreeNode(double v){
            this.val = v;
            this.count = 1;
            this.leftSize = 0;
            this.rightSize =0;
        }
    }
    void preorder(TreeNode node){
        if(node == null){
            return;
        }
        //System.out.println(node.val +" "+node.count+" "+node.leftSize+" "+node.rightSize);
        preorder(node.left);
        preorder(node.right);
    }
    private TreeNode insert(TreeNode root,double val){
        //System.out.println(root);
        if(root == null){
            return new TreeNode(val);
        }
        else if(val<root.val){
            root.leftSize++;
            root.left = insert(root.left,val);
        }
        else if(val >root.val){
            root.rightSize++;
            root.right = insert(root.right,val);
        }
        else if(val == root.val){
            root.count++;
        }
        return root;
    }
    private int countSmaller(TreeNode root,double val){
        if(root == null){
            return 0;
        }
        else if(val<root.val){
            return countSmaller(root.left,val);
        }
        else if(val>root.val){
            return root.count+root.leftSize + countSmaller(root.right,val);
        }
        else {
            return root.leftSize;
        }
    }
    private int countHigher(TreeNode root,double val){
        if(root == null){
            return 0;
        }
        else if(val <root.val){
            return root.count + root.rightSize + countHigher(root.left,val);
        }
        else if(val >root.val){
            return countHigher(root.right,val);
        }
        else
            return root.rightSize;
    }
//    public void floorAndCeilOfBst(TreeNode root, int val, AtomicInteger floor, AtomicInteger ceil) {
//        if (root == null)
//            return;
//        if (val<root.val) {
//            ceil.set(root.val);
//            floorAndCeilOfBst(root.left, val,floor,ceil);
//        } else if (val>root.val) {
//            floor.set(root.val);
//            floorAndCeilOfBst(root.right, val,floor,ceil);
//        } else {
//            floor.set(root.val);
//            ceil.set(root.val);
//        }
//    }

    public static void main(String[] args) {
        ReversePairs reversePairs = new ReversePairs();
        System.out.println(reversePairs.reversePairs(new int[]{1,3,2,3,1}));
    }
}
package BasicAlgorithms.SegmentTree;

/**
 * Created by hadoop on 25/10/17.
 */
import java.util.*;
    public class cOUN {
        public List<Integer> countSmaller(int[] A) {
            List<Integer> list = new ArrayList<>();
            if (A == null || A.length == 0) return list;
            int[] ret = new int[A.length];
            Node array[] = new Node[A.length];
            for(int i=0;i<A.length;i++){
                array[i] = new Node(A[i],i);
            }
            search(A,array, 0, A.length - 1, ret);
            for(Node a:array){
                System.out.print(a);
            };
            for (int i : ret) list.add(i);
            return list;
        }

        private void search(int[] A,Node[]nodes, int start, int end, int[] ret) {
            if (start == end) {
                //Node[] array = {new Node(A[start], start)};
                return ;
            }
            Node[] array = new Node[nodes.length];
            search(A, nodes,start, (start + end) / 2, ret);
            search(A,nodes, (start + end) / 2 + 1, end, ret);
            int rightCount = 0;
            int left = start;
            int mid = (start +end)/2;
            int right = end;
            int j = end;
            int i = mid;
            int k = end;
            while (j>=mid+1 || i>=left){
                if(j<=mid){
                    array[k] = nodes[i];
                    i--;
                    k--;
                }
                else if(i<left){
                    array[k] = nodes[j];
                    k--;
                    j--;
                }
                else if(nodes[i].val>nodes[j].val){
                    ret[nodes[i].idx]+=j-mid;
                    array[k] = nodes[i];
                    k--;
                    i--;
                }
                else {
                    array[k] = nodes[j];
                    k--;
                    j--;
                }
            }
            for(int s=left;s<=right;s++){
                nodes[s] = array[s];
            }
        }

        public static void main(String[] args) {
            cOUN c = new cOUN();
            System.out.println(c.countSmaller(new int[]{5, 2, 6, 1}));
        }
    }
    class Node {
        int val, idx;
        public Node(int val, int idx) {
            this.val = val;
            this.idx = idx;
        }

        @Override
        public String toString() {
            return "Node{" +
                    "val=" + val +
                    ", idx=" + idx +
                    '}';
        }
    }

package BasicAlgorithms.SegmentTree;

import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

/**
 * Created by hadoop on 24/10/17.
 */
public class CountSmallerBiggerNumberElements {
    private class TreeNode{
        long val=0;
        int count =1;
        int leftSize =0;
        int rightSize =0;
        TreeNode left = null;
        TreeNode right = null;
        public TreeNode(long v){
            this.val = v;
            this.count = 1;
            this.leftSize = 0;
            this.rightSize =0;
        }
    }
    private TreeNode insert(TreeNode root,int val){
        if(root == null){
            return new TreeNode(val);
        }
        else if(val<root.val){
            root.leftSize++;
            root.left = insert(root.left,val);
        }
        else if(val >root.val){
            root.rightSize++;
            root.right = insert(root.right,val);
        }
        else if(val == root.val){
            root.count++;
        }
        return root;
    }
    private int countSmaller(TreeNode root,long val){
        if(root == null){
            return 0;
        }
        else if(val<root.val){
            return countSmaller(root.left,val);
        }
        else if(val>root.val){
            return root.count+root.leftSize + countSmaller(root.right,val);
        }
        else {
            return root.leftSize;
        }
    }
    private int countHigher(TreeNode root,long val){
        if(root == null){
            return 0;
        }
        else if(val <root.val){
            return root.count + root.rightSize + countHigher(root.left,val);
        }
        else if(val >root.val){
            return countHigher(root.right,val);
        }
        else
            return root.rightSize;
    }
    public void floorAndCeilOfBst(TreeNode root, int val, AtomicLong floor, AtomicLong ceil) {
        if (root == null)
            return;
        if (val<root.val) {
            ceil.set(root.val);
            floorAndCeilOfBst(root.left, val,floor,ceil);
        } else if (val>root.val) {
            floor.set(root.val);
            floorAndCeilOfBst(root.right, val,floor,ceil);
        } else {
            floor.set(root.val);
            ceil.set(root.val);
        }
    }

}
package BasicAlgorithms.Greedy;

/**
 * Created by hadoop on 23/10/17.
 */
public class MinPatches {
    public int minPatches(int[] nums, int n) {

        long miss = 1;
        int ans = 0;
        int i=0;
            while(miss<=n) {
                if (i<nums.length && nums[i] <= miss) {
                    i++;
                    miss = miss + nums[i];
                } else {
                    ans++;
                    miss = miss + miss;
                }
                if (miss >= n) {
                    return ans;
                }
            }
        return ans;
    }

    public static void main(String[] args) {
        int nums[] = {1, 2, 2};
        int n = 5;
        MinPatches minPatches = new MinPatches();
        System.out.println(minPatches.minPatches(nums,n));
    }
}package BasicAlgorithms.Greedy;

/**
 * Created by hadoop on 23/10/17.
 */
public class JumpStation {

    public boolean canJump(int[] nums) {
        int fathestIndex = 0 + nums[0];
        for (int i = 0; i < nums.length && i <= fathestIndex; i++) {
            if (i + nums[i] > fathestIndex) {
                fathestIndex = i + nums[i];
            }
        }
        if (fathestIndex >= nums.length - 1) {
            return true;
        }
        return false;
    }

    public int jump(int[] nums) {
        int steps=1;
        int fathestIndex = 0 + nums[0];
        int lastfarthestIndex = 0+nums[0];
        for (int i = 0; i < nums.length && i <= fathestIndex; i++) {
            if(i>lastfarthestIndex){
                System.out.println("i "+i);
                System.out.println(" last "+lastfarthestIndex);
                steps++;
            }
            if (i + nums[i] > fathestIndex) {
                lastfarthestIndex = fathestIndex;
                fathestIndex = i + nums[i];
            }
        }
//        if (fathestIndex >= nums.length - 1) {
//            return steps;
//        }
        return steps;
    }
    public int jumpagain(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        int maxCover = 0;
        int steps = 0;
        int lastCover = 0;
        for (int i = 0; i < nums.length && i <= maxCover; i++) {
            if (i > lastCover) {
                steps++;
                lastCover = maxCover;
            }

            //maxCover = Math.max(maxCover, A[i] + i);
            if (nums[i] + i > maxCover) {
                maxCover = nums[i] + i;
            }
        }
        if (maxCover < nums.length - 1) {
            return 0;
        }
        return steps;
    }

    public static void main(String[] args) {
        JumpStation jumpStation = new JumpStation();
        jumpStation.jump(new int[]{3,2,1});
    }
}package BasicAlgorithms.Greedy;

/**
 * Created by hadoop on 23/10/17.
 */
public class MaximumNumber {
}
package BasicAlgorithms.Greedy;

/**
 * Created by hadoop on 23/10/17.
 */
public class GasStation {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int total = 0;
        int start = 0;
        int intermediate = 0;
        for(int i=0;i<gas.length;i++){
            total = total + gas[i]-cost[i];
            intermediate = intermediate + gas[i]-cost[i];
            if(intermediate<0){
                start = i+1;
                intermediate = 0;
            }
        }
        if(total<0){
            return -1;
        }
        return start;
    }
}package BasicAlgorithms.Greedy;

/**
 * Created by hadoop on 23/10/17.
 */
import java.util.*;
public class RemoveDuplicates {
    public String removeDuplicateLetters(String s) {
        HashMap<Character,Integer> hashMap = new HashMap<>();
        for(int i=0;i<s.length();i++){
            if(!hashMap.containsKey(s.charAt(i))){
                hashMap.put(s.charAt(i),1);
            }
            else {
                hashMap.put(s.charAt(i),hashMap.get(s.charAt(i))+1);
            }
        }
        int end =0;
        List<Character> list = new LinkedList<>();
        while (end<s.length()){
            char c= s.charAt(end);
            int freq = hashMap.get(s.charAt(end));
            freq = freq -1;
            if(freq == 0){
                hashMap.remove(s.charAt(end));
            }
            hashMap.put(s.charAt(end),freq);
            end++;
            if(list.contains(c))continue;

            while (!list.isEmpty() && c<list.get(list.size()-1) && hashMap.get(list.get(list.size()-1))>0){
                list.remove(list.size()-1);
            }
            list.add(c);
        }
        String ans = "";
        for(Character c:list) {
            ans = ans + c;
        }
        return ans;
    }
}
package BasicAlgorithms.Greedy;

/**
 * Created by hadoop on 23/10/17.
 */
public class Candy {
    public int candy(int[] ratings) {
        int left[] = new int[ratings.length];
        int right[] = new int[ratings.length];

        left[0] = 1;
        for(int i=1;i<ratings.length;i++){
            if(ratings[i]>ratings[i-1]){
                left[i] = left[i-1]+1;
            }
            else {
                left[i] =1;
            }
        }
        right[ratings.length-1] = 1;
        for(int i = ratings.length-2;i>=0;i--){
            if(ratings[i]>ratings[i+1]){
                right[i] = right[i+1]+1;
            }
            else {
                right[i] = 1;
            }
        }
        int ans =0;

        for(int i=0;i<ratings.length;i++){
            ans = ans+ Math.max(left[i],right[i]);
        }
        return ans;
    }
}
package BasicAlgorithms.BinaryTree;

/**
 * Created by hadoop on 24/10/17.
 */
public class DeleteNode {
    public TreeNode deleteNode(TreeNode root, int key) {
        if(root == null){
            return null;
        }
        if(key<root.val){
            root.left = deleteNode(root.left,key);
        }
        else if(key>root.val){
            root.right = deleteNode(root.right,key);
        }
        else {
            if(root.left!=null && root.right!=null){
                int min = successor(root.right);
                root.val = min;
                root.right = deleteNode(root.right,min);
            }
            else {
                /// very imp point to undesrabe
                if(root.left == null && root.right!=null){
                    return root.right;
                }
                else {
                    return root.left;
                }
            }
        }
        return root;
    }

    private int successor(TreeNode right) {
        while (right.left!=null){
            right = right.left;
        }
        return right.val;
    }

    private class TreeNode{
        int val;
        TreeNode left;
        TreeNode right;
    }
}
package BasicAlgorithms.BinaryTree;

/**
 * Created by hadoop on 26/10/17.
 */
import java.util.*;
public class PrintKdistanceNodeApart {
    private class Node{
        Node left;
        Node right;
        int data;
    }


    void printkdistanceNodeDown(Node root, int k)
    {
        // Base Case
        if (root == null || k < 0)  return;

        // If we reach a k distant node, print it
        if (k==0)
        {
            System.out.println(root.data);
            return;
        }

        // Recur for left and right subtrees
        printkdistanceNodeDown(root.left, k-1);
        printkdistanceNodeDown(root.right, k-1);
    }

    // Prints all nodes at distance k from a given target node.
// The k distant nodes may be upward or downward.  This function
// Returns distance of root from target node, it returns -1 if target
// node is not present in tree rooted with root.
    int printkdistanceNode(Node root, Node target , int k)
    {
        // Base Case 1: If tree is empty, return -1
        if (root == null) return -1;

        // If target is same as root.  Use the downward function
        // to print all nodes at distance k in subtree rooted with
        // target or root
        if (root == target)
        {
            printkdistanceNodeDown(root, k);
            return 0;
        }

        // Recur for left subtree
        int dl = printkdistanceNode(root.left, target, k);

        // Check if target node was found in left subtree
        if (dl != -1)
        {
            // If root is at distance k from target, print root
            // Note that dl is Distance of root's left child from target
            if (dl + 1 == k)
                System.out.println(root.data);

            // Else go to right subtree and print all k-dl-2 distant nodes
            // Note that the right child is 2 edges away from left child
         else
            printkdistanceNodeDown(root.right, k-dl-2);

            // Add 1 to the distance and return value for parent calls
            return 1 + dl;
        }

        // MIRROR OF ABOVE CODE FOR RIGHT SUBTREE
        // Note that we reach here only when node was not found in left subtree
        int dr = printkdistanceNode(root.right, target, k);
        if (dr != -1)
        {
            if (dr + 1 == k)
                System.out.println(root.data) ;
         else
            printkdistanceNodeDown(root.left, k-dr-2);
            return 1 + dr;
        }

        // If target was neither present in left nor in right subtree
        return -1;
    }
    void kDistantFromLeafUtil(Node node, int path[], boolean visited[],
                              int pathLen, int k)
    {
        // Base case
        if (node==null) return;

        // append this Node to the path array
        path[pathLen] = node.data;
        visited[pathLen] = false;
        pathLen++;

        // it's a leaf, so print the ancestor at distance k only
        // if the ancestor is not already printed
        if (node.left == null && node.right == null &&
                pathLen-k-1 >= 0 && visited[pathLen-k-1] == false)
        {
            System.out.print(path[pathLen-k-1] + " ");
            visited[pathLen-k-1] = true;
            return;
        }

        // If not leaf node, recur for left and right subtrees
        kDistantFromLeafUtil(node.left, path, visited, pathLen, k);
        kDistantFromLeafUtil(node.right, path, visited, pathLen, k);
    }

    // Given a binary tree and a nuber k, print all nodes that are k
//   distant from a leaf
    void printKDistantfromLeaf(Node node, int k)
    {
        int MAX_HEIGHT = Integer.MAX_VALUE;
        int[] path = new int[MAX_HEIGHT];
        boolean[] visited = new boolean[MAX_HEIGHT];
        //all the elements false in visited
        Arrays.fill(visited, false);
        kDistantFromLeafUtil(node, path, visited, 0, k);
    }
}
package BasicAlgorithms.BinarySearch;

/**
 * Created by hadoop on 18/10/17.
 */
public class SortedArrayToList {
    public TreeNode sortedArrayToBST(int[] num) {
        return sortedArrayToBSTHelpler(0,num.length-1,num);
    }

    private TreeNode sortedArrayToBSTHelpler(int low, int end,int []num) {
        if(low>end){
            return null;
        }
        if(low == end){
            return new TreeNode(num[low]);
        }

        int mid = low + (end-low)/2;
        TreeNode root = new TreeNode(num[mid]);
        root.left = sortedArrayToBSTHelpler(low,mid-1,num);
        root.right = sortedArrayToBSTHelpler(mid+1,end,num);
        return root;
    }

    private class TreeNode{
        TreeNode left;
        TreeNode right;
        int val;
        TreeNode(int val){
            this.val = val;
        }
    }
}package BasicAlgorithms.BinarySearch;

/**
 * Created by hadoop on 18/10/17.
 */
public class InorderPreorder {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        return helper(preorder,0,preorder.length-1,inorder,0,inorder.length-1);
    }

    private TreeNode helper(int[] preorder, int pstart, int pend, int[] inorder, int istart, int iend) {
        if(pstart>pend){
            return null;
        }
        if(pstart == pend){
            return new TreeNode(preorder[pstart]);
        }
        int root = preorder[pstart];
        int findindexinorder = find(root,inorder,istart,iend);
        if(findindexinorder == -1){
            System.out.println("NO root found");
            System.exit(1);
        }
        int nummberofelementinleftsubtree = findindexinorder-1 -istart+1;
     //   int numberofelementsinrightsubtree = iend -findindexinorder-1+1;
        TreeNode node = new TreeNode(root);
        node.left = helper(preorder,pstart+1,pstart+nummberofelementinleftsubtree,inorder,istart,findindexinorder-1);
        node.right = helper(preorder,pstart+nummberofelementinleftsubtree+1,pend,inorder,findindexinorder+1,iend);
        return node;
    }

    private int find(int root, int[] inorder, int istart, int iend) {
        for (int i=istart;i<=iend;i++){
            if(inorder[i] == root){
                return i;
            }
        }
        return -1;
    }


    private class TreeNode{
        TreeNode left;
        TreeNode right;
        int val;
        TreeNode(int val){
            this.val = val;
        }
    }
}
package BasicAlgorithms.BinarySearch;

import java.util.concurrent.atomic.AtomicInteger;

/**
 * Created by hadoop on 18/10/17.
 */
public class Recover {

    private class Noderef{
        TreeNode node;
    }
    public void recoverTree(TreeNode root) {
        Noderef firstNode= new Noderef();
        Noderef secondNode = new Noderef();
        Noderef prev = new Noderef();
        prev.node = new TreeNode(Integer.MIN_VALUE);
        inorder(root,firstNode,secondNode,prev);

        if(secondNode.node == null){
            if(firstNode.node!=root){
                secondNode.node = root;
            }
            else {
                secondNode.node = firstNode.node.left!=null?firstNode.node.left:firstNode.node.right;
            }
        }
        int data = firstNode.node.val;
        firstNode.node.val = secondNode.node.val;
        secondNode.node.val = data;
    }

    private void findMin(TreeNode root,AtomicInteger atomicInteger) {
        if(root == null){
            return;
        }
        if(atomicInteger.get()>root.val){
            atomicInteger.set(root.val);
        }
        findMin(root.left,atomicInteger);
        findMin(root.right,atomicInteger);
    }

    private void inorder(TreeNode root, Noderef firstNode, Noderef secondNode,Noderef prev) {
        if(root == null){
            return;
        }

        inorder(root.left,firstNode,secondNode,prev);
        // anomly
        if(root.val<prev.node.val){
            if(firstNode.node == null){
                firstNode.node = prev.node;
            }
            else if(firstNode.node!=null){
                secondNode.node = root;
            }
        }
        prev.node = root;
        inorder(root.right,firstNode,secondNode,prev);
    }

    private class TreeNode{
        TreeNode left;
        TreeNode right;
        int val;
        TreeNode(int x){
            this.val = x;
        }
    }
}package BasicAlgorithms.BinarySearch;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

/**
 * Created by hadoop on 17/10/17.
 */
public class LevelOrderTraversal {
    public List<List<Integer>> levelOrder(TreeNode root) {

        List<List<Integer>> result = new ArrayList<>();
        if(root == null){
            return result;
        }

        LinkedList<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while (!queue.isEmpty()){
            int size  =queue.size();
            List<Integer> list = new ArrayList<>();
            for(int i=0;i<size;i++){
                TreeNode polled = queue.poll();
                list.add(polled.val);
                if(polled.left!=null){
                    queue.add(polled.left);
                }
                if(polled.right!=null){
                    queue.add(polled.right);
                }
            }
            result.add(list);
        }
        return result;
    }
    private class TreeNode{
        TreeNode left;
        TreeNode right;
        int val;
        TreeNode(int x){
            this.val = x;
        }
    }
}
package BasicAlgorithms.BinarySearch;

import java.util.concurrent.atomic.AtomicInteger;
import java.util.*;

class CodecAgain {

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        if(root == null){
            return "# ";
        }
        return root.val+" "+serialize(root.left) + serialize(root.right);

    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String a){
        AtomicInteger index = new AtomicInteger(0);

        List<String>list = new ArrayList<String>();
        String array[] = a.split(" ");
        for(int i=0;i<array.length;i++){
            list.add(array[i]);
        }
        System.out.println(list);
        return deserilizeHelper(list,index);
    }

    private TreeNode deserilizeHelper(List<String> list, AtomicInteger index) {
        if(index.get() >= list.size()){
            return null;
        }
        if(list.get(index.get()) .equals ("#")){
            return null;
        }
        TreeNode node = new TreeNode(Integer.parseInt(list.get(index.get())));
        index.set(index.get()+1);
        node.left = deserilizeHelper(list,index);
        index.set(index.get()+1);
        node.right = deserilizeHelper(list,index);
        return node;
    }
    private class TreeNode{
        TreeNode left;
        TreeNode right;
        int val;
        TreeNode(int x){
            val = x;
        }
    }
}package BasicAlgorithms.BinarySearch;

import java.util.Stack;

/**
 * Created by hadoop on 18/10/17.
 */
public class BSTIterator {

    Stack<TreeNode> stack = new Stack<TreeNode>();
    public BSTIterator(TreeNode root) {
        pushleftvalues(root);
    }

    /** @return whether we have a next smallest number */
    public boolean hasNext() {
        return !stack.isEmpty();
    }

    /** @return the next smallest number */
    public int next() {
        TreeNode popped = stack.pop();
        int val = popped.val;
        pushleftvalues(popped.right);
        return val;
    }
    private void pushleftvalues(TreeNode node){
        while (node!=null){
            stack.push(node);
            node = node.left;
        }
    }

    private class TreeNode{
        TreeNode left;
        TreeNode right;
        int  val;
        TreeNode( int val){
            this.val = val;
        }
    }
}
package BasicAlgorithms.BinarySearch;

/**
 * Created by hadoop on 18/10/17.
 */
public class InorderSucc {
    public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
        TreeNode beforeRightTurnsave = null;
        while (root!=null){
            if(root.val>p.val){
                beforeRightTurnsave = root;
                root = root.left;
            }
            else if(root.val<p.val) {
                root = root.right;
            }
            else {
                if (p.right!=null){
                    return leftmost(p.right);
                }
                else {
                    return beforeRightTurnsave;
                }
            }
        }
        return null;
    }

    private TreeNode leftmost(TreeNode right) {
        while (right.left!=null){
            right = right.left;
        }
        return right;
    }


    public class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;
        TreeNode(int x) { val = x; }
    }
}package BasicAlgorithms.BinarySearch;

import java.util.Stack;

/**
 * Created by hadoop on 18/10/17.
 */
public class Flatten {
    // will not work .. use recursion stack .. Really nice it is
    public void flatten(TreeNode root) {
        Stack<TreeNode> stack = new Stack<>();
        TreeNode dummy = new TreeNode(0);
        TreeNode head = dummy;
        TreeNode node = root;

        while (true){
            while (node!=null){

                head.right = root;
                head = head.right;
                stack.push(node);
                node = node.left;
            }
            TreeNode popped = stack.pop();
            node = popped.right;
        }
    }

    public TreeNode flattenRecursion(TreeNode root){
     Noderef head = new Noderef();
     head.node = null;
     TreeNode savehead = head.node;
     flattenRecursionHelper(root,head);
     return savehead;
    }

    private void flattenRecursionHelper(TreeNode root, Noderef lastvisitnode) {
        if(root == null){
            return;
        }
        TreeNode realRight = root.right;
        if(lastvisitnode.node == null){
            lastvisitnode.node = root;
        }
        else {
            lastvisitnode.node.right = root;
            lastvisitnode.node= root;
        }
        flattenRecursionHelper(root.left,lastvisitnode);
        flattenRecursionHelper(realRight,lastvisitnode);
    }

    private class Noderef{
        TreeNode node;
    }

    private class TreeNode{
        TreeNode left;
        TreeNode right;
        int val;
        TreeNode(int x){
            val = x;
        }
    }
}package BasicAlgorithms.BinarySearch;

/**
 * Created by hadoop on 18/10/17.
 */
public class ConnectNodes {
    public void connect(TreeLinkNode root) {
        if(root == null){
            return;
        }
        TreeLinkNode head = null;
        TreeLinkNode previous = null;
        TreeLinkNode current = root;
        while (current!=null){

            //process on same level
            while (current!=null) {

//                if (head == null) {
//                    if (current.left != null) {
//                        head = current.left;
//                    }
//                    if (current.right != null) {
//                        head = current.right;
//                    }
//                }

                if(current.left!=null){
                    if(previous != null){
                        previous = current.left;
                        head = current.left;
                    }else {
                        previous.next = current.left;
                        previous = current.left;
                    }
                }

                if(current.right!=null){
                    if(previous != null){
                        previous = current.right;
                        head = current.left;
                    }else {
                        previous.next = current.right;
                        previous = current.right;
                    }
                }

                current = current.next;
            }

            current = head;
            head = null;
            previous = null;
        }
    }

    private class TreeLinkNode{
        TreeLinkNode left;
        TreeLinkNode right;
        TreeLinkNode next;
        int val;
        TreeLinkNode(int x){
            val = x;
        }
    }
}package BasicAlgorithms.BinarySearch;

/**
 * Created by hadoop on 18/10/17.
 */
public class SortedListBinarySearchTree {
    public TreeNode sortedListToBST(ListNode head) {
    int sizeoflist = getsize(head)  ;
        NodeRef noderef = new NodeRef();
        noderef.node = head;
        return listtotree(0,sizeoflist-1,noderef);
    }

    private TreeNode listtotree(int start, int end,NodeRef nodeRef) {
        if(start>end){
            return null;
        }

        if(start == end){
            TreeNode root = new TreeNode(nodeRef.node.val);
            nodeRef.node = nodeRef.node.next;
            return root;
        }

        int mid = start+end/2;

        TreeNode  left = listtotree(start,mid-1,nodeRef);

        TreeNode root = new TreeNode(nodeRef.node.val);
        nodeRef.node = nodeRef.node.next;

        TreeNode right = listtotree(mid+1,end,nodeRef);

        root.left = left;
        root.right = right;
        return root;
    }

    private int getsize(ListNode head) {
        int i=0;
        while (head!=null){
            head = head.next;
            i++;
        }
        return i;
    }

    public class ListNode {
      int val;
      ListNode next;
      ListNode(int x) { val = x; }
  }
  public class NodeRef{
        ListNode node;
  }

  public class TreeNode {
      int val;
     TreeNode left;
      TreeNode right;
      TreeNode(int x) { val = x; }
  }
}

package BasicAlgorithms.BinarySearch;

import java.util.ArrayList;
import java.util.*;
import java.util.Stack;

/**
 * Created by hadoop on 17/10/17.
 */
public class PreOrderTraversal {
    public List<Integer> preorderTraversal(TreeNode root) {
        TreeNode node = root;
        Stack<TreeNode> stack = new Stack<>();
        List<Integer> list = new ArrayList<>();
        while (true){
            while (node!=null){
                stack.push(node);
                list.add(node.val);
                node = node.left;
            }
            TreeNode popped = stack.pop();
            if(stack.isEmpty()){
                break;
            }
            if(popped.right!=null){
                node = popped.right;
            }
        }
        return list;
    }

    public List<Integer> Inorder(TreeNode root) {
        return null;
    }

    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> list = new LinkedList<Integer>();
        Stack<TreeNode> s = new Stack<TreeNode>();
        TreeNode lastpost = null;
        TreeNode node = root;
        while(true)
        {
            while(node != null)
            {
                s.push(node);
                node = node.left;
            }

            if(s.isEmpty())break;
            TreeNode topagain= s.pop();

            if(topagain.right==null || topagain.right == lastpost){
                list.add(topagain.val);
                lastpost = topagain;
                node = null;
            }

            else {
                s.push(topagain);
                // s.push(topagain.right);
                node = topagain.right;
            }
        }
        return list;
    }
    public class TreeNode {
     int val;
      TreeNode left;
      TreeNode right;
      TreeNode(int x) { val = x; }
  }
}package BasicAlgorithms.BinarySearch;

import java.util.concurrent.atomic.AtomicInteger;

/**
 * Created by hadoop on 17/10/17.
 */
public class RootToLeaf {
    public int sumNumbers(TreeNode root) {
        if(root == null){
            return 0;
        }
        AtomicInteger integer = new AtomicInteger();
         sumnumberhelper(root,root.val,integer);
        return integer.intValue();
    }

    private void sumnumberhelper(TreeNode root, int val,AtomicInteger integer) {
        if(root == null){
            return ;
        }
        if(root.left== null && root.right == null){
            integer.set(integer.get()+val+root.val);
            return;
        }
        if(root.left!=null) {
            sumnumberhelper(root.left,10*val,integer);
        }
        if(root.right!=null){
            sumnumberhelper(root.right,10*val,integer);
        }

    }

    private class TreeNode{
        TreeNode left;
        TreeNode right;
        int val;
        TreeNode(int x){
            val = x;
        }
    }
}package BasicAlgorithms.BinarySearch;

/**
 * Created by hadoop on 17/10/17.
 */
public class SubTree {
    public boolean isSubtree(TreeNode s, TreeNode t) {
        if (s == null && t == null) {
            return true;
        }
        if (t == null){
            return false;
        }
        if (s == null){
            return false;
        }
        return issame(s,t) || isSubtree(s.left,t) || isSubtree(s.right,t);
    }


    public boolean issame(TreeNode s, TreeNode t){
        if(s == null && t == null){
            return true;
        }
        if(s == null){
            return false;
        }
        if(s!= null && t == null){
            return false;
        }
        if(s.val != t.val){
            return false;
        }
        return issame(s.left,t.left) && issame(s.right,t.right);
    }
    private class TreeNode {
        TreeNode left;
        TreeNode right;
        int val;

        TreeNode(int val) {
            this.val = val;
        }
    }
}package BasicAlgorithms.BinarySearch;

/**
 * Created by hadoop on 18/10/17.
 */
public class KthSmallest {
    public int kthSmallest(TreeNode root, int k) {
        if(root== null){
            return -1;
        }
        int numberOfElements = count(root.left);

        if(numberOfElements == k){
            return root.val;
        }
        else if(numberOfElements<k){
            return kthSmallest(root.right,k-numberOfElements);
        }
        else {
            return kthSmallest(root.left,k);
        }
    }

    private int count(TreeNode root) {
        if(root == null){
            return 0;
        }
        return 1+ count(root.left)+count(root.right);
    }

    private class TreeNode{
        TreeNode left;
        TreeNode right;
        int val;
        TreeNode(int x){
            this.val = x;
        }
    }
}package BasicAlgorithms.BinarySearch;

import java.util.*;

/**
 * Created by hadoop on 17/10/17.
 */
public class VerticalOrder {
    public List<List<Integer>> verticalOrder(TreeNode root) {
        List<List<Integer>> result = new ArrayList<>();
        TreeMap<Integer,TreeMap<Integer,List<Integer>>> treeMap = new TreeMap<>();
        dfs(root,0,0,treeMap);
        Iterator<TreeMap<Integer,List<Integer>>> it = treeMap.values().iterator();
        while (it.hasNext()){
            TreeMap<Integer,List<Integer>> integerListTreeMap = it.next();
            List<Integer> path = new ArrayList<>();
            Iterator<List<Integer>> list = integerListTreeMap.values().iterator();
            while (list.hasNext()){
                path.addAll(list.next());
            }
            result.add(path);
        }
        return result;
    }

    private void dfs(TreeNode root, int level,int height, TreeMap<Integer, TreeMap<Integer,List<Integer>>> treeMap) {
        if(root == null){
            return;
        }
        if(!treeMap.containsKey(level)){
            treeMap.put(level,new TreeMap<>());
        }
        if(!treeMap.get(level).containsKey(height)){
            treeMap.get(level).put(height,new ArrayList<>());
        }
        treeMap.get(level).get(height).add(root.val);
        dfs(root.left,level-1,height+1,treeMap);
        dfs(root.right,level+1,height+1,treeMap);
    }

    private class TreeNode{
        TreeNode left;
        TreeNode right;
        int val;
        TreeNode(int x){
            this.val = x;
        }
    }
}
package BasicAlgorithms.BinarySearch;

/**
 * Created by hadoop on 18/10/17.
 */
public class PredSuccRecursive {

    public TreeNode successor(TreeNode root, TreeNode p) {
        if (root == null){
            return null;
        }
        if(root == p){
            return successor(root.right,p);
        }
        else if(p.val<root.val){
            TreeNode left = successor(root.left,p);
            if(left==null){
                return root;
            }
            return left;
        }
        else {
            TreeNode right = successor(root.right,p);
            return right;
        }
    }
    public TreeNode predecessor(TreeNode root, TreeNode p) {

        if(root == null){
            return null;
        }
        if(root == p){
            TreeNode left = predecessor(root.left,p);
            return left;
        }
        if(p.val < root.val){
            TreeNode left = predecessor(root.left,p);
        }
        else{
            TreeNode right = predecessor(root.right,p);
            if(right!=null){
                return right;
            }
            return root;
        }
        return null;
    }
        private class TreeNode {
        TreeNode left;
        TreeNode right;
        int val;

        TreeNode(int val) {
            this.val = val;
        }
    }
}
package BasicAlgorithms.BinarySearch;

import java.util.concurrent.atomic.AtomicInteger;

/**
 * Created by hadoop on 17/10/17.
 */
public class CountUnivalSub {
    private class ResultType{
        int val;
        boolean isunisubtree;

        public ResultType(int val, boolean isunisubtree) {
            this.val = val;
            this.isunisubtree = isunisubtree;
        }
    }
    public int countUnivalSubtrees(TreeNode root) {
        if(root == null){
            return 0;
        }
        AtomicInteger integer = new AtomicInteger();
        countUnivalSubtreesHelper(root,integer);
        return integer.get();
    }

    ResultType countUnivalSubtreesHelper(TreeNode node,AtomicInteger integer){
        if(node == null){
            return new ResultType(Integer.MIN_VALUE,true);
        }
        if(node.left == null && node.right == null){
            integer.set(integer.get()+1);
            return new ResultType(node.val,true);
        }
        else {
            ResultType left = countUnivalSubtreesHelper(node.left,integer);
            ResultType right = countUnivalSubtreesHelper(node.right,integer);

            if(left.isunisubtree == false || right.isunisubtree == false){
                return new ResultType(Integer.MIN_VALUE,false);
            }


            if(node.val == left.val && node.val == right.val){
                integer.set(integer.get()+1);
                return new ResultType(node.val,true);
            }
            else {

                if(node.val == left.val && Integer.MIN_VALUE == right.val){
                    integer.set(integer.get()+1);
                    return new ResultType(node.val,true);
                }

                if(node.val == right.val && Integer.MIN_VALUE == left.val){
                    integer.set(integer.get()+1);
                    return new ResultType(node.val,true);
                }
            }
            return new ResultType(Integer.MAX_VALUE,false);
        }
    }
    private class TreeNode{
        TreeNode left;
        TreeNode right;
        int val;
        TreeNode(int val){
            this.val = val;
        }
    }
}package BasicAlgorithms.BinarySearch;

/**
 * Created by hadoop on 18/10/17.
 */
public class UpsideDown {
        public TreeNode upsideDownBinaryTree(TreeNode root) {
            if (root == null || (root.left == null && root.right == null)) {
                return root;
            }
            //newRoot
            TreeNode newRoot = upsideDownBinaryTree(root.left);
            //rootright left right
            //rootleftleftroot.left , root.right
            root.left.left = root.right;//
            root.left.right = root;//
            root.left = null;//
            root.right = null;//
            //root
            return newRoot;

        }
    private class TreeNode{
        TreeNode left;
        TreeNode right;
        int val;
        TreeNode(int x){
            val = x;
        }
    }
}
package BasicAlgorithms.BinarySearch;

/**
 * Created by hadoop on 17/10/17.
 */
public class CountNodes {
    public int countNodes(TreeNode root) {
        if(root == null){
            return 0;
        }
        int leftheight = leftheight(root);
        int rightheight = rightheight(root);
        if(leftheight == rightheight){
            return 1>>(leftheight) -1;
        }
        else {
            return 1 + countNodes(root.left)+countNodes(root.right);
        }
    }

    private int leftheight(TreeNode root) {
        int x = 1;
        while (root!=null){
            root = root.left;
            x++;
        }
        return x;
    }
    private int rightheight(TreeNode root) {
        int x = 1;
        while (root!=null){
            root = root.left;
            x++;
        }
        return x;
    }

    private class TreeNode{
        TreeNode left;
        TreeNode right;
        int val;
        TreeNode(int x){
            this.val = x;
        }
    }
}
package BasicAlgorithms.BinarySearch;

/**
 * Created by hadoop on 18/10/17.
 */
public class ClosestValue {

    public int closestValue(TreeNode root, double target) {
        if(root ==null){
            return (int)target;
        }
        double diff = Double.MAX_VALUE;
        int valueintree= -1;
        Double d = new Double(target);

        while (root!=null){
            if(diff >Math.abs(target-root.val)){
                diff = Math.abs(target-root.val);
                valueintree = root.val;
            }
            if(d-(double)root.val<0.001){
                root = root.left;
            }
            else {
                root = root.right;
            }
        }
        return valueintree;
    }


    public int closestValueConcise(TreeNode root, double target) {
        int closet = root.val;
        while (root != null) {
            if (Math.abs(root.val - target) <= Math.abs(closet - target)) {
                closet = root.val;
            }
            root = root.val < target ? root.right : root.left;
        }
        return closet;
    }

    private class TreeNode{
        TreeNode left;
        TreeNode right;
        int val;
        TreeNode(int val){
            this.val = val;
        }
    }
}
package BasicAlgorithms.BinarySearch;

import java.util.concurrent.atomic.AtomicInteger;

/**
 * Created by hadoop on 17/10/17.
 */
public class LongestConsecutivePath {
    public int longestConsecutive(TreeNode root) {
        if(root == null){
            return 0;
        }
        AtomicInteger atomicInteger = new AtomicInteger();
        atomicInteger.set(1);
        longestConsecutiveHelper(root,atomicInteger);
        return atomicInteger.get();
    }
    private class ResultType{
        int length;
        int lastvalue;
        ResultType(int length,int lastvalue){
            this.length = length;
            this.lastvalue = lastvalue;
        }
    }

    private ResultType longestConsecutiveHelper(TreeNode node,AtomicInteger atomicInteger) {
        if(node == null){
            return new ResultType(0,Integer.MIN_VALUE);
        }
        if(node.left == null && node.right ==null){
            return new ResultType(1,node.val);
        }

        ResultType leftLongest = longestConsecutiveHelper(node.left,atomicInteger);
        ResultType rightLongest = longestConsecutiveHelper(node.right,atomicInteger);

        int currentval = node.val;
        int currentmaxlength = 1;
        int leftlongest =0;
        int rightlongest = 0;
        //   System.out.println("left value"+leftLongest.lastvalue);
        //  System.out.println("left longest"+leftLongest.length);

        //    System.out.println("right value"+rightLongest.lastvalue);
        //   System.out.println("right longest"+rightLongest.length);

        if(currentval +1 == leftLongest.lastvalue){
            leftlongest = leftLongest.length;
        }
        if(currentval +1 == rightLongest.lastvalue){
            rightlongest = rightLongest.length;
        }
        currentmaxlength = Math.max(leftlongest,rightlongest)+1;
        if(currentmaxlength>atomicInteger.get()){
            atomicInteger.set(currentmaxlength);
        }
        return new ResultType(currentmaxlength,currentval);
    }

    class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;
        TreeNode(int x) { val = x; }
    }
}package BasicAlgorithms.BinarySearch;

/**
 * Created by hadoop on 18/10/17.
 */
public class PreOrderStrings {
    public String tree2str(TreeNode t) {
        if(t == null){
            return "";
        }
        if(t.left == null && t.right == null){
            return ""+t.val;
        }
        String result="";
        if(t.left!=null && t.right!=null){
            return result = result  +"("+tree2str(t.left)+")" +"("+tree2str(t.right)+")";
        }
        else if(t.left == null && t.right!=null){
            return result = result  +"("+tree2str(t.left)+")" +"("+tree2str(t.right)+")";
        }
        else {
            return result = result  +"("+tree2str(t.left)+")";
        }
    }
    private class TreeNode{
        TreeNode left;
        TreeNode right;
        int val;
        TreeNode(int val){
            this.val = val;
        }
    }
}
package BasicAlgorithms.BinarySearch;

/**
 * Created by hadoop on 24/10/17.
 */
public class Diameter {
    public int diameterOfBinaryTree(TreeNode root) {
        ResultType ans = dfsHelper(root);
        return ans.diameter;
    }

    private ResultType dfsHelper(TreeNode root) {
        if(root == null){
            return new ResultType(0,Integer.MIN_VALUE);
        }
        if(root.left == null && root.right == null){
            return new ResultType(1,1);
        }
        ResultType left = dfsHelper(root.left);
        ResultType right = dfsHelper(root.right);

        int localheight = Math.max(left.height,right.height)+1;
        int diameter = Math.max(Math.max(left.diameter,right.diameter),left.height + right.height +1);
        ResultType resultType = new ResultType(localheight,diameter);
        return resultType;
    }

    private class ResultType{
        int height;
        int diameter;

        public ResultType(int height, int diameter) {
            this.height = height;
            this.diameter = diameter;
        }
    }
    class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;
        TreeNode(int x) { val = x; }
    }
}
package BasicAlgorithms.BinarySearch;

/**
 * Created by hadoop on 18/10/17.
 */
public class ReconstructTreeFromPreorder {

    //12122 // 2 are leaves and 1 is non-leaf
    ListNode head;
    TreeNode constructTree(){
        if(head == null){
            return null;
        }
        TreeNode node = new TreeNode(head.val);
        head = head.next;
        if(head.next.val == 1){
            node.val =1;
            node.left = constructTree();
            node.right = constructTree();
        }
        else {
            node.val = 2;
            node.left = null;
            node.right = null;
        }
        return node;

    }
    private class TreeNode{
        TreeNode left;
        TreeNode right;
        int val;
        TreeNode(int val){
            this.val = val;
        }
    }
    private class ListNode{
        int val;
        ListNode next;
    }

}
package BasicAlgorithms.BinarySearch;

import java.util.ArrayList;
import java.util.List;

/**
 * Created by hadoop on 17/10/17.
 */
public class GetTreePath {
    public List<String> binaryTreePaths(TreeNode root) {

        List<String> path = new ArrayList<>();
        List<String> result = new ArrayList<>();
        if(root == null){
            return result;
        }
        path.add(String.valueOf(root.val));
        binaryTreePathsHelper(root,path,result);
        return result;
    }

    private void binaryTreePathsHelper(TreeNode root, List<String> path, List<String> result) {
        if(isLeaf(root)){
            String ans = "";
            for(int i=0;i<path.size()-1;i++) {
                ans =  ans+path.get(i)+"->";
            }
            ans = ans + path.get(path.size()-1);
            result.add(ans);
            return;
        }
        if(root.left!=null){
            path.add(String.valueOf(root.left.val));
            binaryTreePathsHelper(root.left,path,result);
            path.remove(path.size()-1);
        }
        if(root.right!=null){
            path.add(String.valueOf(root.right.val));
            binaryTreePathsHelper(root.right,path,result);
            path.remove(path.size()-1);
        }
    }

    private boolean isLeaf(TreeNode root) {
        if(root.left==null && root.right==null){
            return true;
        }
        return false;
    }

    class TreeNode {
      int val;
      TreeNode left;
      TreeNode right;
      TreeNode(int x) { val = x; }
  }
}
package BasicAlgorithms.BinarySearch;

import java.util.StringTokenizer;

/**
 * Created by hadoop on 18/10/17.
 */
public class PreorderSerilazation {
    public boolean isValidSerialization(String preorder) {
        int indegree = -1;
        int outdegree = 0;
        String[] array = preorder.split(",");
        int hashcount = 0;
        int nodecount = 0;
        for (int i = 0; i < array.length; i++) {
            if (array[i].equals("#")) {
                hashcount++;
            } else {
                nodecount++;
            }
        }
        return nodecount + 1 == hashcount;
    }

        public boolean isValidSerializationagain (String preorder){
            int indegree = 0;
            int outdegree = 2;
            String[] array = preorder.split(",");
            if (array.length == 1) {
                return array[0].equals("#");
            }
            if (array == null || array.length == 0) {
                return true;
            }
            if (array[0].equals("#")) {
                return false;
            }
            for (int i = 1; i < array.length; i++) {

                // throughtout the traveeral indegreee has to be lesss than out degree if indegree becomes equals to outdegree means theere
                // is no edge that we can form
                if (indegree >= outdegree) {
                    return false;
                }
                if (array[i].equals("#")) {
                    indegree++;
                } else {
                    indegree++;
                    outdegree = outdegree + 2;
                }
                System.out.println("inde " + indegree);
                System.out.println("out " + outdegree);
            }
            System.out.println("inde " + indegree);
            System.out.println("out " + outdegree);
            return indegree == outdegree;
        }

    public boolean isValidSerializationEasy(String preorder) {
        StringTokenizer tokens = new StringTokenizer(preorder, ",");
        return dfs(tokens) && !tokens.hasMoreTokens();
    }

    private boolean dfs(StringTokenizer tokens) {
        if(!tokens.hasMoreTokens())
            return false;

        String token = tokens.nextToken();
        if (token.equals("#"))
            return true;

        return dfs(tokens) && dfs(tokens);
    }
    }


package BasicAlgorithms.BinarySearch;

import java.util.ArrayList;
import java.util.List;
import java.util.PriorityQueue;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * Created by hadoop on 18/10/17.
 */
public class Closest2 {
    public List<Integer> closestKValues(TreeNode root, double target, int k) {

        PriorityQueue<Integer> priorityQueue = new PriorityQueue<>();
        AtomicInteger integer = new AtomicInteger();
        closestKValuesHelper(root,target,integer,k,priorityQueue);
        List<Integer> list = new ArrayList<>();
        while (!priorityQueue.isEmpty()) {
            list.add(priorityQueue.poll());
        }
        return list;
    }

    private void closestKValuesHelper(TreeNode root, double target, AtomicInteger integer, int k,PriorityQueue<Integer> priorityQueue) {
        if(root == null){
            return;
        }
        closestKValuesHelper(root.left,target,integer,k,priorityQueue);
        if(integer.get()<k){
            priorityQueue.add(root.val);
            integer.set(integer.get()+1);
        }
        else {
            if(Math.abs(priorityQueue.peek()-target)>Math.abs(root.val-target)){
                Integer remove = priorityQueue.poll();
                priorityQueue.add(root.val);
            }
        }
        closestKValuesHelper(root.right,target,integer,k,priorityQueue);
    }

    private class  TreeNode{
        TreeNode left;
        TreeNode right;
        int val;
        TreeNode(int val){
            this.val = val;
        }
    }
}package BasicAlgorithms.BinarySearch;

import java.util.Stack;

/**
 * Created by hadoop on 18/10/17.
 */
/*
DO next hihest index and stack method .. thats all u have to do ..

 */
public class PreorderRange {
    public boolean isbst(int []nums){
        int start = 0;
        int end = nums.length-1;
        return isbstHelper(nums,start,end, Integer.MIN_VALUE, Integer.MAX_VALUE);
    }

    private boolean isbstHelper(int[] nums, int start, int end, int min,int max) {
        boolean ans = false;
        if(start>end){
            return true;
        }
        int root = nums[start];

        if(!(root>min && root<max))
            return false;

        int nexthighestindex = start;
        for(int k = start+1;k<=end;k++){
            if(nums[k]>nexthighestindex){
                nexthighestindex = k;
            }
        }
        return isbstHelper(nums,start+1,nexthighestindex-1,min,nums[nexthighestindex])
                && isbstHelper(nums,nexthighestindex,end,nums[nexthighestindex],max);
    }

    private boolean isBst(int nums[],int start,int end){
        if(start>= end){
            return true;
        }
        int root = nums[start];
        int nexthighestindex = start;
        for(int i=start+1;i<=end;i++){
            if(nums[i] > root){
                nexthighestindex = i;
                break;
            }
        }
        if(nexthighestindex !=start) {
            for (int i = nexthighestindex + 1; i <= end; i++) {
                if (nums[i] < root) {
                    return false;
                }
            }
            return isBst(nums,start+1,nexthighestindex-1) && isBst(nums,nexthighestindex,end);
        }
        else {
            return isBst(nums,start+1,end);
        }
    }
    private boolean isBst(int nums[]){
        Stack<Integer> stack = new Stack<>();

        int popped = Integer.MAX_VALUE;
        for(int i=0;i<nums.length;i++){
            if(nums[i]<popped){
                return false;
            }
            if(stack.isEmpty()){
                stack.push(nums[i]);
            }
            else {
                while (!stack.isEmpty() && stack.peek()<nums[i]){
                    popped = stack.pop();
                }
                stack.push(nums[i]);
            }

        }
        return true;
    }
    private boolean helper(int[] preorder, int start , int end, int min, int max) {
        if (start > end) {
            return true;
        }

        int rootValue = preorder[start];
        if (rootValue < min || rootValue > max) {
            return false;
        }

        int rightIndex = start;
        while (rightIndex <= end && preorder[rightIndex] <= rootValue) {
            rightIndex++;
        }
        System.out.println("start"+start);
        System.out.println("end"+end);
        System.out.println("rightin "+rightIndex);
        System.out.println("callleft"+(start+1));
        System.out.println("callleft"+(rightIndex-1));
        System.out.println("callright"+(rightIndex));
        System.out.println("callright"+end);
        return helper(preorder, start + 1, rightIndex - 1, min, rootValue) &&
                helper(preorder, rightIndex, end, rootValue, max);
    }
    private boolean isBstnotworking(int nums[],int start,int end,int min,int max){

        if(start>=end){
            return true;
        }

        int root = nums[start];
        if(root>max || root <min){
            return false;
        }
        int nexthighestindex = start;
        for(int i = start+1;i<=end;i++){
            if(nums[i]> root){
                nexthighestindex = i;
                break;
            }
        }
        System.out.println("start"+start);
        System.out.println("end"+end);
        System.out.println("rightin "+nexthighestindex);
        System.out.println("callleft"+(start+1));
        System.out.println("callleft"+(nexthighestindex-1));
        System.out.println("callright"+(nexthighestindex));
        System.out.println("callright"+end);
        //System.out.println(start);
        //System.out.println(end);
         if(nexthighestindex == start){ // means no right nodes available
             return isBstnotworking(nums,start+1,end,min,root);
         }
        // else{
        return isBstnotworking(nums,start+1,nexthighestindex-1,min,root) && isBstnotworking(nums,nexthighestindex,end,root,max);
        //}
    }

    public static void main(String[] args) {
        int nums[] = {1,2,3,4};
        int num[]={1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999,1000,1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1011,1012,1013,1014,1015,1016,1017,1018,1019,1020,1021,1022,1023,1024,1025,1026,1027,1028,1029,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039,1040,1041,1042,1043,1044,1045,1046,1047,1048,1049,1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099,1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117,1118,1119,1120,1121,1122,1123,1124,1125,1126,1127,1128,1129,1130,1131,1132,1133,1134,1135,1136,1137,1138,1139,1140,1141,1142,1143,1144,1145,1146,1147,1148,1149,1150,1151,1152,1153,1154,1155,1156,1157,1158,1159,1160,1161,1162,1163,1164,1165,1166,1167,1168,1169,1170,1171,1172,1173,1174,1175,1176,1177,1178,1179,1180,1181,1182,1183,1184,1185,1186,1187,1188,1189,1190,1191,1192,1193,1194,1195,1196,1197,1198,1199,1200,1201,1202,1203,1204,1205,1206,1207,1208,1209,1210,1211,1212,1213,1214,1215,1216,1217,1218,1219,1220,1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1231,1232,1233,1234,1235,1236,1237,1238,1239,1240,1241,1242,1243,1244,1245,1246,1247,1248,1249,1250,1251,1252,1253,1254,1255,1256,1257,1258,1259,1260,1261,1262,1263,1264,1265,1266,1267,1268,1269,1270,1271,1272,1273,1274,1275,1276,1277,1278,1279,1280,1281,1282,1283,1284,1285,1286,1287,1288,1289,1290,1291,1292,1293,1294,1295,1296,1297,1298,1299,1300,1301,1302,1303,1304,1305,1306,1307,1308,1309,1310,1311,1312,1313,1314,1315,1316,1317,1318,1319,1320,1321,1322,1323,1324,1325,1326,1327,1328,1329,1330,1331,1332,1333,1334,1335,1336,1337,1338,1339,1340,1341,1342,1343,1344,1345,1346,1347,1348,1349,1350,1351,1352,1353,1354,1355,1356,1357,1358,1359,1360,1361,1362,1363,1364,1365,1366,1367,1368,1369,1370,1371,1372,1373,1374,1375,1376,1377,1378,1379,1380,1381,1382,1383,1384,1385,1386,1387,1388,1389,1390,1391,1392,1393,1394,1395,1396,1397,1398,1399,1400,1401,1402,1403,1404,1405,1406,1407,1408,1409,1410,1411,1412,1413,1414,1415,1416,1417,1418,1419,1420,1421,1422,1423,1424,1425,1426,1427,1428,1429,1430,1431,1432,1433,1434,1435,1436,1437,1438,1439,1440,1441,1442,1443,1444,1445,1446,1447,1448,1449,1450,1451,1452,1453,1454,1455,1456,1457,1458,1459,1460,1461,1462,1463,1464,1465,1466,1467,1468,1469,1470,1471,1472,1473,1474,1475,1476,1477,1478,1479,1480,1481,1482,1483,1484,1485,1486,1487,1488,1489,1490,1491,1492,1493,1494,1495,1496,1497,1498,1499,1500,1501,1502,1503,1504,1505,1506,1507,1508,1509,1510,1511,1512,1513,1514,1515,1516,1517,1518,1519,1520,1521,1522,1523,1524,1525,1526,1527,1528,1529,1530,1531,1532,1533,1534,1535,1536,1537,1538,1539,1540,1541,1542,1543,1544,1545,1546,1547,1548,1549,1550,1551,1552,1553,1554,1555,1556,1557,1558,1559,1560,1561,1562,1563,1564,1565,1566,1567,1568,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578,1579,1580,1581,1582,1583,1584,1585,1586,1587,1588,1589,1590,1591,1592,1593,1594,1595,1596,1597,1598,1599,1600,1601,1602,1603,1604,1605,1606,1607,1608,1609,1610,1611,1612,1613,1614,1615,1616,1617,1618,1619,1620,1621,1622,1623,1624,1625,1626,1627,1628,1629,1630,1631,1632,1633,1634,1635,1636,1637,1638,1639,1640,1641,1642,1643,1644,1645,1646,1647,1648,1649,1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1660,1661,1662,1663,1664,1665,1666,1667,1668,1669,1670,1671,1672,1673,1674,1675,1676,1677,1678,1679,1680,1681,1682,1683,1684,1685,1686,1687,1688,1689,1690,1691,1692,1693,1694,1695,1696,1697,1698,1699,1700,1701,1702,1703,1704,1705,1706,1707,1708,1709,1710,1711,1712,1713,1714,1715,1716,1717,1718,1719,1720,1721,1722,1723,1724,1725,1726,1727,1728,1729,1730,1731,1732,1733,1734,1735,1736,1737,1738,1739,1740,1741,1742,1743,1744,1745,1746,1747,1748,1749,1750,1751,1752,1753,1754,1755,1756,1757,1758,1759,1760,1761,1762,1763,1764,1765,1766,1767,1768,1769,1770,1771,1772,1773,1774,1775,1776,1777,1778,1779,1780,1781,1782,1783,1784,1785,1786,1787,1788,1789,1790,1791,1792,1793,1794,1795,1796,1797,1798,1799,1800,1801,1802,1803,1804,1805,1806,1807,1808,1809,1810,1811,1812,1813,1814,1815,1816,1817,1818,1819,1820,1821,1822,1823,1824,1825,1826,1827,1828,1829,1830,1831,1832,1833,1834,1835,1836,1837,1838,1839,1840,1841,1842,1843,1844,1845,1846,1847,1848,1849,1850,1851,1852,1853,1854,1855,1856,1857,1858,1859,1860,1861,1862,1863,1864,1865,1866,1867,1868,1869,1870,1871,1872,1873,1874,1875,1876,1877,1878,1879,1880,1881,1882,1883,1884,1885,1886,1887,1888,1889,1890,1891,1892,1893,1894,1895,1896,1897,1898,1899,1900,1901,1902,1903,1904,1905,1906,1907,1908,1909,1910,1911,1912,1913,1914,1915,1916,1917,1918,1919,1920,1921,1922,1923,1924,1925,1926,1927,1928,1929,1930,1931,1932,1933,1934,1935,1936,1937,1938,1939,1940,1941,1942,1943,1944,1945,1946,1947,1948,1949,1950,1951,1952,1953,1954,1955,1956,1957,1958,1959,1960,1961,1962,1963,1964,1965,1966,1967,1968,1969,1970,1971,1972,1973,1974,1975,1976,1977,1978,1979,1980,1981,1982,1983,1984,1985,1986,1987,1988,1989,1990,1991,1992,1993,1994,1995,1996,1997,1998,1999,2000,2001,2002,2003,2004,2005,2006,2007,2008,2009,2010,2011,2012,2013,2014,2015,2016,2017,2018,2019,2020,2021,2022,2023,2024,2025,2026,2027,2028,2029,2030,2031,2032,2033,2034,2035,2036,2037,2038,2039,2040,2041,2042,2043,2044,2045,2046,2047,2048,2049,2050,2051,2052,2053,2054,2055,2056,2057,2058,2059,2060,2061,2062,2063,2064,2065,2066,2067,2068,2069,2070,2071,2072,2073,2074,2075,2076,2077,2078,2079,2080,2081,2082,2083,2084,2085,2086,2087,2088,2089,2090,2091,2092,2093,2094,2095,2096,2097,2098,2099,2100,2101,2102,2103,2104,2105,2106,2107,2108,2109,2110,2111,2112,2113,2114,2115,2116,2117,2118,2119,2120,2121,2122,2123,2124,2125,2126,2127,2128,2129,2130,2131,2132,2133,2134,2135,2136,2137,2138,2139,2140,2141,2142,2143,2144,2145,2146,2147,2148,2149,2150,2151,2152,2153,2154,2155,2156,2157,2158,2159,2160,2161,2162,2163,2164,2165,2166,2167,2168,2169,2170,2171,2172,2173,2174,2175,2176,2177,2178,2179,2180,2181,2182,2183,2184,2185,2186,2187,2188,2189,2190,2191,2192,2193,2194,2195,2196,2197,2198,2199,2200,2201,2202,2203,2204,2205,2206,2207,2208,2209,2210,2211,2212,2213,2214,2215,2216,2217,2218,2219,2220,2221,2222,2223,2224,2225,2226,2227,2228,2229,2230,2231,2232,2233,2234,2235,2236,2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247,2248,2249,2250,2251,2252,2253,2254,2255,2256,2257,2258,2259,2260,2261,2262,2263,2264,2265,2266,2267,2268,2269,2270,2271,2272,2273,2274,2275,2276,2277,2278,2279,2280,2281,2282,2283,2284,2285,2286,2287,2288,2289,2290,2291,2292,2293,2294,2295,2296,2297,2298,2299,2300,2301,2302,2303,2304,2305,2306,2307,2308,2309,2310,2311,2312,2313,2314,2315,2316,2317,2318,2319,2320,2321,2322,2323,2324,2325,2326,2327,2328,2329,2330,2331,2332,2333,2334,2335,2336,2337,2338,2339,2340,2341,2342,2343,2344,2345,2346,2347,2348,2349,2350,2351,2352,2353,2354,2355,2356,2357,2358,2359,2360,2361,2362,2363,2364,2365,2366,2367,2368,2369,2370,2371,2372,2373,2374,2375,2376,2377,2378,2379,2380,2381,2382,2383,2384,2385,2386,2387,2388,2389,2390,2391,2392,2393,2394,2395,2396,2397,2398,2399,2400,2401,2402,2403,2404,2405,2406,2407,2408,2409,2410,2411,2412,2413,2414,2415,2416,2417,2418,2419,2420,2421,2422,2423,2424,2425,2426,2427,2428,2429,2430,2431,2432,2433,2434,2435,2436,2437,2438,2439,2440,2441,2442,2443,2444,2445,2446,2447,2448,2449,2450,2451,2452,2453,2454,2455,2456,2457,2458,2459,2460,2461,2462,2463,2464,2465,2466,2467,2468,2469,2470,2471,2472,2473,2474,2475,2476,2477,2478,2479,2480,2481,2482,2483,2484,2485,2486,2487,2488,2489,2490,2491,2492,2493,2494,2495,2496,2497,2498,2499,2500,2501,2502,2503,2504,2505,2506,2507,2508,2509,2510,2511,2512,2513,2514,2515,2516,2517,2518,2519,2520,2521,2522,2523,2524,2525,2526,2527,2528,2529,2530,2531,2532,2533,2534,2535,2536,2537,2538,2539,2540,2541,2542,2543,2544,2545,2546,2547,2548,2549,2550,2551,2552,2553,2554,2555,2556,2557,2558,2559,2560,2561,2562,2563,2564,2565,2566,2567,2568,2569,2570,2571,2572,2573,2574,2575,2576,2577,2578,2579,2580,2581,2582,2583,2584,2585,2586,2587,2588,2589,2590,2591,2592,2593,2594,2595,2596,2597,2598,2599,2600,2601,2602,2603,2604,2605,2606,2607,2608,2609,2610,2611,2612,2613,2614,2615,2616,2617,2618,2619,2620,2621,2622,2623,2624,2625,2626,2627,2628,2629,2630,2631,2632,2633,2634,2635,2636,2637,2638,2639,2640,2641,2642,2643,2644,2645,2646,2647,2648,2649,2650,2651,2652,2653,2654,2655,2656,2657,2658,2659,2660,2661,2662,2663,2664,2665,2666,2667,2668,2669,2670,2671,2672,2673,2674,2675,2676,2677,2678,2679,2680,2681,2682,2683,2684,2685,2686,2687,2688,2689,2690,2691,2692,2693,2694,2695,2696,2697,2698,2699,2700,2701,2702,2703,2704,2705,2706,2707,2708,2709,2710,2711,2712,2713,2714,2715,2716,2717,2718,2719,2720,2721,2722,2723,2724,2725,2726,2727,2728,2729,2730,2731,2732,2733,2734,2735,2736,2737,2738,2739,2740,2741,2742,2743,2744,2745,2746,2747,2748,2749,2750,2751,2752,2753,2754,2755,2756,2757,2758,2759,2760,2761,2762,2763,2764,2765,2766,2767,2768,2769,2770,2771,2772,2773,2774,2775,2776,2777,2778,2779,2780,2781,2782,2783,2784,2785,2786,2787,2788,2789,2790,2791,2792,2793,2794,2795,2796,2797,2798,2799,2800,2801,2802,2803,2804,2805,2806,2807,2808,2809,2810,2811,2812,2813,2814,2815,2816,2817,2818,2819,2820,2821,2822,2823,2824,2825,2826,2827,2828,2829,2830,2831,2832,2833,2834,2835,2836,2837,2838,2839,2840,2841,2842,2843,2844,2845,2846,2847,2848,2849,2850,2851,2852,2853,2854,2855,2856,2857,2858,2859,2860,2861,2862,2863,2864,2865,2866,2867,2868,2869,2870,2871,2872,2873,2874,2875,2876,2877,2878,2879,2880,2881,2882,2883,2884,2885,2886,2887,2888,2889,2890,2891,2892,2893,2894,2895,2896,2897,2898,2899,2900,2901,2902,2903,2904,2905,2906,2907,2908,2909,2910,2911,2912,2913,2914,2915,2916,2917,2918,2919,2920,2921,2922,2923,2924,2925,2926,2927,2928,2929,2930,2931,2932,2933,2934,2935,2936,2937,2938,2939,2940,2941,2942,2943,2944,2945,2946,2947,2948,2949,2950,2951,2952,2953,2954,2955,2956,2957,2958,2959,2960,2961,2962,2963,2964,2965,2966,2967,2968,2969,2970,2971,2972,2973,2974,2975,2976,2977,2978,2979,2980,2981,2982,2983,2984,2985,2986,2987,2988,2989,2990,2991,2992,2993,2994,2995,2996,2997,2998,2999,3000,3001,3002,3003,3004,3005,3006,3007,3008,3009,3010,3011,3012,3013,3014,3015,3016,3017,3018,3019,3020,3021,3022,3023,3024,3025,3026,3027,3028,3029,3030,3031,3032,3033,3034,3035,3036,3037,3038,3039,3040,3041,3042,3043,3044,3045,3046,3047,3048,3049,3050,3051,3052,3053,3054,3055,3056,3057,3058,3059,3060,3061,3062,3063,3064,3065,3066,3067,3068,3069,3070,3071,3072,3073,3074,3075,3076,3077,3078,3079,3080,3081,3082,3083,3084,3085,3086,3087,3088,3089,3090,3091,3092,3093,3094,3095,3096,3097,3098,3099,3100,3101,3102,3103,3104,3105,3106,3107,3108,3109,3110,3111,3112,3113,3114,3115,3116,3117,3118,3119,3120,3121,3122,3123,3124,3125,3126,3127,3128,3129,3130,3131,3132,3133,3134,3135,3136,3137,3138,3139,3140,3141,3142,3143,3144,3145,3146,3147,3148,3149,3150,3151,3152,3153,3154,3155,3156,3157,3158,3159,3160,3161,3162,3163,3164,3165,3166,3167,3168,3169,3170,3171,3172,3173,3174,3175,3176,3177,3178,3179,3180,3181,3182,3183,3184,3185,3186,3187,3188,3189,3190,3191,3192,3193,3194,3195,3196,3197,3198,3199,3200,3201,3202,3203,3204,3205,3206,3207,3208,3209,3210,3211,3212,3213,3214,3215,3216,3217,3218,3219,3220,3221,3222,3223,3224,3225,3226,3227,3228,3229,3230,3231,3232,3233,3234,3235,3236,3237,3238,3239,3240,3241,3242,3243,3244,3245,3246,3247,3248,3249,3250,3251,3252,3253,3254,3255,3256,3257,3258,3259,3260,3261,3262,3263,3264,3265,3266,3267,3268,3269,3270,3271,3272,3273,3274,3275,3276,3277,3278,3279,3280,3281,3282,3283,3284,3285,3286,3287,3288,3289,3290,3291,3292,3293,3294,3295,3296,3297,3298,3299,3300,3301,3302,3303,3304,3305,3306,3307,3308,3309,3310,3311,3312,3313,3314,3315,3316,3317,3318,3319,3320,3321,3322,3323,3324,3325,3326,3327,3328,3329,3330,3331,3332,3333,3334,3335,3336,3337,3338,3339,3340,3341,3342,3343,3344,3345,3346,3347,3348,3349,3350,3351,3352,3353,3354,3355,3356,3357,3358,3359,3360,3361,3362,3363,3364,3365,3366,3367,3368,3369,3370,3371,3372,3373,3374,3375,3376,3377,3378,3379,3380,3381,3382,3383,3384,3385,3386,3387,3388,3389,3390,3391,3392,3393,3394,3395,3396,3397,3398,3399,3400,3401,3402,3403,3404,3405,3406,3407,3408,3409,3410,3411,3412,3413,3414,3415,3416,3417,3418,3419,3420,3421,3422,3423,3424,3425,3426,3427,3428,3429,3430,3431,3432,3433,3434,3435,3436,3437,3438,3439,3440,3441,3442,3443,3444,3445,3446,3447,3448,3449,3450,3451,3452,3453,3454,3455,3456,3457,3458,3459,3460,3461,3462,3463,3464,3465,3466,3467,3468,3469,3470,3471,3472,3473,3474,3475,3476,3477,3478,3479,3480,3481,3482,3483,3484,3485,3486,3487,3488,3489,3490,3491,3492,3493,3494,3495,3496,3497,3498,3499,3500,3501,3502,3503,3504,3505,3506,3507,3508,3509,3510,3511,3512,3513,3514,3515,3516,3517,3518,3519,3520,3521,3522,3523,3524,3525,3526,3527,3528,3529,3530,3531,3532,3533,3534,3535,3536,3537,3538,3539,3540,3541,3542,3543,3544,3545,3546,3547,3548,3549,3550,3551,3552,3553,3554,3555,3556,3557,3558,3559,3560,3561,3562,3563,3564,3565,3566,3567,3568,3569,3570,3571,3572,3573,3574,3575,3576,3577,3578,3579,3580,3581,3582,3583,3584,3585,3586,3587,3588,3589,3590,3591,3592,3593,3594,3595,3596,3597,3598,3599,3600,3601,3602,3603,3604,3605,3606,3607,3608,3609,3610,3611,3612,3613,3614,3615,3616,3617,3618,3619,3620,3621,3622,3623,3624,3625,3626,3627,3628,3629,3630,3631,3632,3633,3634,3635,3636,3637,3638,3639,3640,3641,3642,3643,3644,3645,3646,3647,3648,3649,3650,3651,3652,3653,3654,3655,3656,3657,3658,3659,3660,3661,3662,3663,3664,3665,3666,3667,3668,3669,3670,3671,3672,3673,3674,3675,3676,3677,3678,3679,3680,3681,3682,3683,3684,3685,3686,3687,3688,3689,3690,3691,3692,3693,3694,3695,3696,3697,3698,3699,3700,3701,3702,3703,3704,3705,3706,3707,3708,3709,3710,3711,3712,3713,3714,3715,3716,3717,3718,3719,3720,3721,3722,3723,3724,3725,3726,3727,3728,3729,3730,3731,3732,3733,3734,3735,3736,3737,3738,3739,3740,3741,3742,3743,3744,3745,3746,3747,3748,3749,3750,3751,3752,3753,3754,3755,3756,3757,3758,3759,3760,3761,3762,3763,3764,3765,3766,3767,3768,3769,3770,3771,3772,3773,3774,3775,3776,3777,3778,3779,3780,3781,3782,3783,3784,3785,3786,3787,3788,3789,3790,3791,3792,3793,3794,3795,3796,3797,3798,3799,3800,3801,3802,3803,3804,3805,3806,3807,3808,3809,3810,3811,3812,3813,3814,3815,3816,3817,3818,3819,3820,3821,3822,3823,3824,3825,3826,3827,3828,3829,3830,3831,3832,3833,3834,3835,3836,3837,3838,3839,3840,3841,3842,3843,3844,3845,3846,3847,3848,3849,3850,3851,3852,3853,3854,3855,3856,3857,3858,3859,3860,3861,3862,3863,3864,3865,3866,3867,3868,3869,3870,3871,3872,3873,3874,3875,3876,3877,3878,3879,3880,3881,3882,3883,3884,3885,3886,3887,3888,3889,3890,3891,3892,3893,3894,3895,3896,3897,3898,3899,3900,3901,3902,3903,3904,3905,3906,3907,3908,3909,3910,3911,3912,3913,3914,3915,3916,3917,3918,3919,3920,3921,3922,3923,3924,3925,3926,3927,3928,3929,3930,3931,3932,3933,3934,3935,3936,3937,3938,3939,3940,3941,3942,3943,3944,3945,3946,3947,3948,3949,3950,3951,3952,3953,3954,3955,3956,3957,3958,3959,3960,3961,3962,3963,3964,3965,3966,3967,3968,3969,3970,3971,3972,3973,3974,3975,3976,3977,3978,3979,3980,3981,3982,3983,3984,3985,3986,3987,3988,3989,3990,3991,3992,3993,3994,3995,3996,3997,3998,3999,4000,4001,4002,4003,4004,4005,4006,4007,4008,4009,4010,4011,4012,4013,4014,4015,4016,4017,4018,4019,4020,4021,4022,4023,4024,4025,4026,4027,4028,4029,4030,4031,4032,4033,4034,4035,4036,4037,4038,4039,4040,4041,4042,4043,4044,4045,4046,4047,4048,4049,4050,4051,4052,4053,4054,4055,4056,4057,4058,4059,4060,4061,4062,4063,4064,4065,4066,4067,4068,4069,4070,4071,4072,4073,4074,4075,4076,4077,4078,4079,4080,4081,4082,4083,4084,4085,4086,4087,4088,4089,4090,4091,4092,4093,4094,4095,4096,4097,4098,4099,4100,4101,4102,4103,4104,4105,4106,4107,4108,4109,4110,4111,4112,4113,4114,4115,4116,4117,4118,4119,4120,4121,4122,4123,4124,4125,4126,4127,4128,4129,4130,4131,4132,4133,4134,4135,4136,4137,4138,4139,4140,4141,4142,4143,4144,4145,4146,4147,4148,4149,4150,4151,4152,4153,4154,4155,4156,4157,4158,4159,4160,4161,4162,4163,4164,4165,4166,4167,4168,4169,4170,4171,4172,4173,4174,4175,4176,4177,4178,4179,4180,4181,4182,4183,4184,4185,4186,4187,4188,4189,4190,4191,4192,4193,4194,4195,4196,4197,4198,4199,4200,4201,4202,4203,4204,4205,4206,4207,4208,4209,4210,4211,4212,4213,4214,4215,4216,4217,4218,4219,4220,4221,4222,4223,4224,4225,4226,4227,4228,4229,4230,4231,4232,4233,4234,4235,4236,4237,4238,4239,4240,4241,4242,4243,4244,4245,4246,4247,4248,4249,4250,4251,4252,4253,4254,4255,4256,4257,4258,4259,4260,4261,4262,4263,4264,4265,4266,4267,4268,4269,4270,4271,4272,4273,4274,4275,4276,4277,4278,4279,4280,4281,4282,4283,4284,4285,4286,4287,4288,4289,4290,4291,4292,4293,4294,4295,4296,4297,4298,4299,4300,4301,4302,4303,4304,4305,4306,4307,4308,4309,4310,4311,4312,4313,4314,4315,4316,4317,4318,4319,4320,4321,4322,4323,4324,4325,4326,4327,4328,4329,4330,4331,4332,4333,4334,4335,4336,4337,4338,4339,4340,4341,4342,4343,4344,4345,4346,4347,4348,4349,4350,4351,4352,4353,4354,4355,4356,4357,4358,4359,4360,4361,4362,4363,4364,4365,4366,4367,4368,4369,4370,4371,4372,4373,4374,4375,4376,4377,4378,4379,4380,4381,4382,4383,4384,4385,4386,4387,4388,4389,4390,4391,4392,4393,4394,4395,4396,4397,4398,4399,4400,4401,4402,4403,4404,4405,4406,4407,4408,4409,4410,4411,4412,4413,4414,4415,4416,4417,4418,4419,4420,4421,4422,4423,4424,4425,4426,4427,4428,4429,4430,4431,4432,4433,4434,4435,4436,4437,4438,4439,4440,4441,4442,4443,4444,4445,4446,4447,4448,4449,4450,4451,4452,4453,4454,4455,4456,4457,4458,4459,4460,4461,4462,4463,4464,4465,4466,4467,4468,4469,4470,4471,4472,4473,4474,4475,4476,4477,4478,4479,4480,4481,4482,4483,4484,4485,4486,4487,4488,4489,4490,4491,4492,4493,4494,4495,4496,4497,4498,4499,4500,4501,4502,4503,4504,4505,4506,4507,4508,4509,4510,4511,4512,4513,4514,4515,4516,4517,4518,4519,4520,4521,4522,4523,4524,4525,4526,4527,4528,4529,4530,4531,4532,4533,4534,4535,4536,4537,4538,4539,4540,4541,4542,4543,4544,4545,4546,4547,4548,4549,4550,4551,4552,4553,4554,4555,4556,4557,4558,4559,4560,4561,4562,4563,4564,4565,4566,4567,4568,4569,4570,4571,4572,4573,4574,4575,4576,4577,4578,4579,4580,4581,4582,4583,4584,4585,4586,4587,4588,4589,4590,4591,4592,4593,4594,4595,4596,4597,4598,4599,4600,4601,4602,4603,4604,4605,4606,4607,4608,4609,4610,4611,4612,4613,4614,4615,4616,4617,4618,4619,4620,4621,4622,4623,4624,4625,4626,4627,4628,4629,4630,4631,4632,4633,4634,4635,4636,4637,4638,4639,4640,4641,4642,4643,4644,4645,4646,4647,4648,4649,4650,4651,4652,4653,4654,4655,4656,4657,4658,4659,4660,4661,4662,4663,4664,4665,4666,4667,4668,4669,4670,4671,4672,4673,4674,4675,4676,4677,4678,4679,4680,4681,4682,4683,4684,4685,4686,4687,4688,4689,4690,4691,4692,4693,4694,4695,4696,4697,4698,4699,4700,4701,4702,4703,4704,4705,4706,4707,4708,4709,4710,4711,4712,4713,4714,4715,4716,4717,4718,4719,4720,4721,4722,4723,4724,4725,4726,4727,4728,4729,4730,4731,4732,4733,4734,4735,4736,4737,4738,4739,4740,4741,4742,4743,4744,4745,4746,4747,4748,4749,4750,4751,4752,4753,4754,4755,4756,4757,4758,4759,4760,4761,4762,4763,4764,4765,4766,4767,4768,4769,4770,4771,4772,4773,4774,4775,4776,4777,4778,4779,4780,4781,4782,4783,4784,4785,4786,4787,4788,4789,4790,4791,4792,4793,4794,4795,4796,4797,4798,4799,4800,4801,4802,4803,4804,4805,4806,4807,4808,4809,4810,4811,4812,4813,4814,4815,4816,4817,4818,4819,4820,4821,4822,4823,4824,4825,4826,4827,4828,4829,4830,4831,4832,4833,4834,4835,4836,4837,4838,4839,4840,4841,4842,4843,4844,4845,4846,4847,4848,4849,4850,4851,4852,4853,4854,4855,4856,4857,4858,4859,4860,4861,4862,4863,4864,4865,4866,4867,4868,4869,4870,4871,4872,4873,4874,4875,4876,4877,4878,4879,4880,4881,4882,4883,4884,4885,4886,4887,4888,4889,4890,4891,4892,4893,4894,4895,4896,4897,4898,4899,4900,4901,4902,4903,4904,4905,4906,4907,4908,4909,4910,4911,4912,4913,4914,4915,4916,4917,4918,4919,4920,4921,4922,4923,4924,4925,4926,4927,4928,4929,4930,4931,4932,4933,4934,4935,4936,4937,4938,4939,4940,4941,4942,4943,4944,4945,4946,4947,4948,4949,4950,4951,4952,4953,4954,4955,4956,4957,4958,4959,4960,4961,4962,4963,4964,4965,4966,4967,4968,4969,4970,4971,4972,4973,4974,4975,4976,4977,4978,4979,4980,4981,4982,4983,4984,4985,4986,4987,4988,4989,4990,4991,4992,4993,4994,4995,4996,4997,4998,4999,5000,5001,5002,5003,5004,5005,5006,5007,5008,5009,5010,5011,5012,5013,5014,5015,5016,5017,5018,5019,5020,5021,5022,5023,5024,5025,5026,5027,5028,5029,5030,5031,5032,5033,5034,5035,5036,5037,5038,5039,5040,5041,5042,5043,5044,5045,5046,5047,5048,5049,5050,5051,5052,5053,5054,5055,5056,5057,5058,5059,5060,5061,5062,5063,5064,5065,5066,5067,5068,5069,5070,5071,5072,5073,5074,5075,5076,5077,5078,5079,5080,5081,5082,5083,5084,5085,5086,5087,5088,5089,5090,5091,5092,5093,5094,5095,5096,5097,5098,5099,5100,5101,5102,5103,5104,5105,5106,5107,5108,5109,5110,5111,5112,5113,5114,5115,5116,5117,5118,5119,5120,5121,5122,5123,5124,5125,5126,5127,5128,5129,5130,5131,5132,5133,5134,5135,5136,5137,5138,5139,5140,5141,5142,5143,5144,5145,5146,5147,5148,5149,5150,5151,5152,5153,5154,5155,5156,5157,5158,5159,5160,5161,5162,5163,5164,5165,5166,5167,5168,5169,5170,5171,5172,5173,5174,5175,5176,5177,5178,5179,5180,5181,5182,5183,5184,5185,5186,5187,5188,5189,5190,5191,5192,5193,5194,5195,5196,5197,5198,5199,5200,5201,5202,5203,5204,5205,5206,5207,5208,5209,5210,5211,5212,5213,5214,5215,5216,5217,5218,5219,5220,5221,5222,5223,5224,5225,5226,5227,5228,5229,5230,5231,5232,5233,5234,5235,5236,5237,5238,5239,5240,5241,5242,5243,5244,5245,5246,5247,5248,5249,5250,5251,5252,5253,5254,5255,5256,5257,5258,5259,5260,5261,5262,5263,5264,5265,5266,5267,5268,5269,5270,5271,5272,5273,5274,5275,5276,5277,5278,5279,5280,5281,5282,5283,5284,5285,5286,5287,5288,5289,5290,5291,5292,5293,5294,5295,5296,5297,5298,5299,5300,5301,5302,5303,5304,5305,5306,5307,5308,5309,5310,5311,5312,5313,5314,5315,5316,5317,5318,5319,5320,5321,5322,5323,5324,5325,5326,5327,5328,5329,5330,5331,5332,5333,5334,5335,5336,5337,5338,5339,5340,5341,5342,5343,5344,5345,5346,5347,5348,5349,5350,5351,5352,5353,5354,5355,5356,5357,5358,5359,5360,5361,5362,5363,5364,5365,5366,5367,5368,5369,5370,5371,5372,5373,5374,5375,5376,5377,5378,5379,5380,5381,5382,5383,5384,5385,5386,5387,5388,5389,5390,5391,5392,5393,5394,5395,5396,5397,5398,5399,5400,5401,5402,5403,5404,5405,5406,5407,5408,5409,5410,5411,5412,5413,5414,5415,5416,5417,5418,5419,5420,5421,5422,5423,5424,5425,5426,5427,5428,5429,5430,5431,5432,5433,5434,5435,5436,5437,5438,5439,5440,5441,5442,5443,5444,5445,5446,5447,5448,5449,5450,5451,5452,5453,5454,5455,5456,5457,5458,5459,5460,5461,5462,5463,5464,5465,5466,5467,5468,5469,5470,5471,5472,5473,5474,5475,5476,5477,5478,5479,5480,5481,5482,5483,5484,5485,5486,5487,5488,5489,5490,5491,5492,5493,5494,5495,5496,5497,5498,5499,5500,5501,5502,5503,5504,5505,5506,5507,5508,5509,5510,5511,5512,5513,5514,5515,5516,5517,5518,5519,5520,5521,5522,5523,5524,5525,5526,5527,5528,5529,5530,5531,5532,5533,5534,5535,5536,5537,5538,5539,5540,5541,5542,5543,5544,5545,5546,5547,5548,5549,5550,5551,5552,5553,5554,5555,5556,5557,5558,5559,5560,5561,5562,5563,5564,5565,5566,5567,5568,5569,5570,5571,5572,5573,5574,5575,5576,5577,5578,5579,5580,5581,5582,5583,5584,5585,5586,5587,5588,5589,5590,5591,5592,5593,5594,5595,5596,5597,5598,5599,5600,5601,5602,5603,5604,5605,5606,5607,5608,5609,5610,5611,5612,5613,5614,5615,5616,5617,5618,5619,5620,5621,5622,5623,5624,5625,5626,5627,5628,5629,5630,5631,5632,5633,5634,5635,5636,5637,5638,5639,5640,5641,5642,5643,5644,5645,5646,5647,5648,5649,5650,5651,5652,5653,5654,5655,5656,5657,5658,5659,5660,5661,5662,5663,5664,5665,5666,5667,5668,5669,5670,5671,5672,5673,5674,5675,5676,5677,5678,5679,5680,5681,5682,5683,5684,5685,5686,5687,5688,5689,5690,5691,5692,5693,5694,5695,5696,5697,5698,5699,5700,5701,5702,5703,5704,5705,5706,5707,5708,5709,5710,5711,5712,5713,5714,5715,5716,5717,5718,5719,5720,5721,5722,5723,5724,5725,5726,5727,5728,5729,5730,5731,5732,5733,5734,5735,5736,5737,5738,5739,5740,5741,5742,5743,5744,5745,5746,5747,5748,5749,5750,5751,5752,5753,5754,5755,5756,5757,5758,5759,5760,5761,5762,5763,5764,5765,5766,5767,5768,5769,5770,5771,5772,5773,5774,5775,5776,5777,5778,5779,5780,5781,5782,5783,5784,5785,5786,5787,5788,5789,5790,5791,5792,5793,5794,5795,5796,5797,5798,5799,5800,5801,5802,5803,5804,5805,5806,5807,5808,5809,5810,5811,5812,5813,5814,5815,5816,5817,5818,5819,5820,5821,5822,5823,5824,5825,5826,5827,5828,5829,5830,5831,5832,5833,5834,5835,5836,5837,5838,5839,5840,5841,5842,5843,5844,5845,5846,5847,5848,5849,5850,5851,5852,5853,5854,5855,5856,5857,5858,5859,5860,5861,5862,5863,5864,5865,5866,5867,5868,5869,5870,5871,5872,5873,5874,5875,5876,5877,5878,5879,5880,5881,5882,5883,5884,5885,5886,5887,5888,5889,5890,5891,5892,5893,5894,5895,5896,5897,5898,5899,5900,5901,5902,5903,5904,5905,5906,5907,5908,5909,5910,5911,5912,5913,5914,5915,5916,5917,5918,5919,5920,5921,5922,5923,5924,5925,5926,5927,5928,5929,5930,5931,5932,5933,5934,5935,5936,5937,5938,5939,5940,5941,5942,5943,5944,5945,5946,5947,5948,5949,5950,5951,5952,5953,5954,5955,5956,5957,5958,5959,5960,5961,5962,5963,5964,5965,5966,5967,5968,5969,5970,5971,5972,5973,5974,5975,5976,5977,5978,5979,5980,5981,5982,5983,5984,5985,5986,5987,5988,5989,5990,5991,5992,5993,5994,5995,5996,5997,5998,5999,6000,6001,6002,6003,6004,6005,6006,6007,6008,6009,6010,6011,6012,6013,6014,6015,6016,6017,6018,6019,6020,6021,6022,6023,6024,6025,6026,6027,6028,6029,6030,6031,6032,6033,6034,6035,6036,6037,6038,6039,6040,6041,6042,6043,6044,6045,6046,6047,6048,6049,6050,6051,6052,6053,6054,6055,6056,6057,6058,6059,6060,6061,6062,6063,6064,6065,6066,6067,6068,6069,6070,6071,6072,6073,6074,6075,6076,6077,6078,6079,6080,6081,6082,6083,6084,6085,6086,6087,6088,6089,6090,6091,6092,6093,6094,6095,6096,6097,6098,6099,6100,6101,6102,6103,6104,6105,6106,6107,6108,6109,6110,6111,6112,6113,6114,6115,6116,6117,6118,6119,6120,6121,6122,6123,6124,6125,6126,6127,6128,6129,6130,6131,6132,6133,6134,6135,6136,6137,6138,6139,6140,6141,6142,6143,6144,6145,6146,6147,6148,6149,6150,6151,6152,6153,6154,6155,6156,6157,6158,6159,6160,6161,6162,6163,6164,6165,6166,6167,6168,6169,6170,6171,6172,6173,6174,6175,6176,6177,6178,6179,6180,6181,6182,6183,6184,6185,6186,6187,6188,6189,6190,6191,6192,6193,6194,6195,6196,6197,6198,6199,6200,6201,6202,6203,6204,6205,6206,6207,6208,6209,6210,6211,6212,6213,6214,6215,6216,6217,6218,6219,6220,6221,6222,6223,6224,6225,6226,6227,6228,6229,6230,6231,6232,6233,6234,6235,6236,6237,6238,6239,6240,6241,6242,6243,6244,6245,6246,6247,6248,6249,6250,6251,6252,6253,6254,6255,6256,6257,6258,6259,6260,6261,6262,6263,6264,6265,6266,6267,6268,6269,6270,6271,6272,6273,6274,6275,6276,6277,6278,6279,6280,6281,6282,6283,6284,6285,6286,6287,6288,6289,6290,6291,6292,6293,6294,6295,6296,6297,6298,6299,6300,6301,6302,6303,6304,6305,6306,6307,6308,6309,6310,6311,6312,6313,6314,6315,6316,6317,6318,6319,6320,6321,6322,6323,6324,6325,6326,6327,6328,6329,6330,6331,6332,6333,6334,6335,6336,6337,6338,6339,6340,6341,6342,6343,6344,6345,6346,6347,6348,6349,6350,6351,6352,6353,6354,6355,6356,6357,6358,6359,6360,6361,6362,6363,6364,6365,6366,6367,6368,6369,6370,6371,6372,6373,6374,6375,6376,6377,6378,6379,6380,6381,6382,6383,6384,6385,6386,6387,6388,6389,6390,6391,6392,6393,6394,6395,6396,6397,6398,6399,6400,6401,6402,6403,6404,6405,6406,6407,6408,6409,6410,6411,6412,6413,6414,6415,6416,6417,6418,6419,6420,6421,6422,6423,6424,6425,6426,6427,6428,6429,6430,6431,6432,6433,6434,6435,6436,6437,6438,6439,6440,6441,6442,6443,6444,6445,6446,6447,6448,6449,6450,6451,6452,6453,6454,6455,6456,6457,6458,6459,6460,6461,6462,6463,6464,6465,6466,6467,6468,6469,6470,6471,6472,6473,6474,6475,6476,6477,6478,6479,6480,6481,6482,6483,6484,6485,6486,6487,6488,6489,6490,6491,6492,6493,6494,6495,6496,6497,6498,6499,6500,6501,6502,6503,6504,6505,6506,6507,6508,6509,6510,6511,6512,6513,6514,6515,6516,6517,6518,6519,6520,6521,6522,6523,6524,6525,6526,6527,6528,6529,6530,6531,6532,6533,6534,6535,6536,6537,6538,6539,6540,6541,6542,6543,6544,6545,6546,6547,6548,6549,6550,6551,6552,6553,6554,6555,6556,6557,6558,6559,6560,6561,6562,6563,6564,6565,6566,6567,6568,6569,6570,6571,6572,6573,6574,6575,6576,6577,6578,6579,6580,6581,6582,6583,6584,6585,6586,6587,6588,6589,6590,6591,6592,6593,6594,6595,6596,6597,6598,6599,6600,6601,6602,6603,6604,6605,6606,6607,6608,6609,6610,6611,6612,6613,6614,6615,6616,6617,6618,6619,6620,6621,6622,6623,6624,6625,6626,6627,6628,6629,6630,6631,6632,6633,6634,6635,6636,6637,6638,6639,6640,6641,6642,6643,6644,6645,6646,6647,6648,6649,6650,6651,6652,6653,6654,6655,6656,6657,6658,6659,6660,6661,6662,6663,6664,6665,6666,6667,6668,6669,6670,6671,6672,6673,6674,6675,6676,6677,6678,6679,6680,6681,6682,6683,6684,6685,6686,6687,6688,6689,6690,6691,6692,6693,6694,6695,6696,6697,6698,6699,6700,6701,6702,6703,6704,6705,6706,6707,6708,6709,6710,6711,6712,6713,6714,6715,6716,6717,6718,6719,6720,6721,6722,6723,6724,6725,6726,6727,6728,6729,6730,6731,6732,6733,6734,6735,6736,6737,6738,6739,6740,6741,6742,6743,6744,6745,6746,6747,6748,6749,6750,6751,6752,6753,6754,6755,6756,6757,6758,6759,6760,6761,6762,6763,6764,6765,6766,6767,6768,6769,6770,6771,6772,6773,6774,6775,6776,6777,6778,6779,6780,6781,6782,6783,6784,6785,6786,6787,6788,6789,6790,6791,6792,6793,6794,6795,6796,6797,6798,6799,6800,6801,6802,6803,6804,6805,6806,6807,6808,6809,6810,6811,6812,6813,6814,6815,6816,6817,6818,6819,6820,6821,6822,6823,6824,6825,6826,6827,6828,6829,6830,6831,6832,6833,6834,6835,6836,6837,6838,6839,6840,6841,6842,6843,6844,6845,6846,6847,6848,6849,6850,6851,6852,6853,6854,6855,6856,6857,6858,6859,6860,6861,6862,6863,6864,6865,6866,6867,6868,6869,6870,6871,6872,6873,6874,6875,6876,6877,6878,6879,6880,6881,6882,6883,6884,6885,6886,6887,6888,6889,6890,6891,6892,6893,6894,6895,6896,6897,6898,6899,6900,6901,6902,6903,6904,6905,6906,6907,6908,6909,6910,6911,6912,6913,6914,6915,6916,6917,6918,6919,6920,6921,6922,6923,6924,6925,6926,6927,6928,6929,6930,6931,6932,6933,6934,6935,6936,6937,6938,6939,6940,6941,6942,6943,6944,6945,6946,6947,6948,6949,6950,6951,6952,6953,6954,6955,6956,6957,6958,6959,6960,6961,6962,6963,6964,6965,6966,6967,6968,6969,6970,6971,6972,6973,6974,6975,6976,6977,6978,6979,6980,6981,6982,6983,6984,6985,6986,6987,6988,6989,6990,6991,6992,6993,6994,6995,6996,6997,6998,6999,7000,7001,7002,7003,7004,7005,7006,7007,7008,7009,7010,7011,7012,7013,7014,7015,7016,7017,7018,7019,7020,7021,7022,7023,7024,7025,7026,7027,7028,7029,7030,7031,7032,7033,7034,7035,7036,7037,7038,7039,7040,7041,7042,7043,7044,7045,7046,7047,7048,7049,7050,7051,7052,7053,7054,7055,7056,7057,7058,7059,7060,7061,7062,7063,7064,7065,7066,7067,7068,7069,7070,7071,7072,7073,7074,7075,7076,7077,7078,7079,7080,7081,7082,7083,7084,7085,7086,7087,7088,7089,7090,7091,7092,7093,7094,7095,7096,7097,7098,7099,7100,7101,7102,7103,7104,7105,7106,7107,7108,7109,7110,7111,7112,7113,7114,7115,7116,7117,7118,7119,7120,7121,7122,7123,7124,7125,7126,7127,7128,7129,7130,7131,7132,7133,7134,7135,7136,7137,7138,7139,7140,7141,7142,7143,7144,7145,7146,7147,7148,7149,7150,7151,7152,7153,7154,7155,7156,7157,7158,7159,7160,7161,7162,7163,7164,7165,7166,7167,7168,7169,7170,7171,7172,7173,7174,7175,7176,7177,7178,7179,7180,7181,7182,7183,7184,7185,7186,7187,7188,7189,7190,7191,7192,7193,7194,7195,7196,7197,7198,7199,7200,7201,7202,7203,7204,7205,7206,7207,7208,7209,7210,7211,7212,7213,7214,7215,7216,7217,7218,7219,7220,7221,7222,7223,7224,7225,7226,7227,7228,7229,7230,7231,7232,7233,7234,7235,7236,7237,7238,7239,7240,7241,7242,7243,7244,7245,7246,7247,7248,7249,7250,7251,7252,7253,7254,7255,7256,7257,7258,7259,7260,7261,7262,7263,7264,7265,7266,7267,7268,7269,7270,7271,7272,7273,7274,7275,7276,7277,7278,7279,7280,7281,7282,7283,7284,7285,7286,7287,7288,7289,7290,7291,7292,7293,7294,7295,7296,7297,7298,7299,7300,7301,7302,7303,7304,7305,7306,7307,7308,7309,7310,7311,7312,7313,7314,7315,7316,7317,7318,7319,7320,7321,7322,7323,7324,7325,7326,7327,7328,7329,7330,7331,7332,7333,7334,7335,7336,7337,7338,7339,7340,7341,7342,7343,7344,7345,7346,7347,7348,7349,7350,7351,7352,7353,7354,7355,7356,7357,7358,7359,7360,7361,7362,7363,7364,7365,7366,7367,7368,7369,7370,7371,7372,7373,7374,7375,7376,7377,7378,7379,7380,7381,7382,7383,7384,7385,7386,7387,7388,7389,7390,7391,7392,7393,7394,7395,7396,7397,7398,7399,7400,7401,7402,7403,7404,7405,7406,7407,7408,7409,7410,7411,7412,7413,7414,7415,7416,7417,7418,7419,7420,7421,7422,7423,7424,7425,7426,7427,7428,7429,7430,7431,7432,7433,7434,7435,7436,7437,7438,7439,7440,7441,7442,7443,7444,7445,7446,7447,7448,7449,7450,7451,7452,7453,7454,7455,7456,7457,7458,7459,7460,7461,7462,7463,7464,7465,7466,7467,7468,7469,7470,7471,7472,7473,7474,7475,7476,7477,7478,7479,7480,7481,7482,7483,7484,7485,7486,7487,7488,7489,7490,7491,7492,7493,7494,7495,7496,7497,7498,7499,7500,7501,7502,7503,7504,7505,7506,7507,7508,7509,7510,7511,7512,7513,7514,7515,7516,7517,7518,7519,7520,7521,7522,7523,7524,7525,7526,7527,7528,7529,7530,7531,7532,7533,7534,7535,7536,7537,7538,7539,7540,7541,7542,7543,7544,7545,7546,7547,7548,7549,7550,7551,7552,7553,7554,7555,7556,7557,7558,7559,7560,7561,7562,7563,7564,7565,7566,7567,7568,7569,7570,7571,7572,7573,7574,7575,7576,7577,7578,7579,7580,7581,7582,7583,7584,7585,7586,7587,7588,7589,7590,7591,7592,7593,7594,7595,7596,7597,7598,7599,7600,7601,7602,7603,7604,7605,7606,7607,7608,7609,7610,7611,7612,7613,7614,7615,7616,7617,7618,7619,7620,7621,7622,7623,7624,7625,7626,7627,7628,7629,7630,7631,7632,7633,7634,7635,7636,7637,7638,7639,7640,7641,7642,7643,7644,7645,7646,7647,7648,7649,7650,7651,7652,7653,7654,7655,7656,7657,7658,7659,7660,7661,7662,7663,7664,7665,7666,7667,7668,7669,7670,7671,7672,7673,7674,7675,7676,7677,7678,7679,7680,7681,7682,7683,7684,7685,7686,7687,7688,7689,7690,7691,7692,7693,7694,7695,7696,7697,7698,7699,7700,7701,7702,7703,7704,7705,7706,7707,7708,7709,7710,7711,7712,7713,7714,7715,7716,7717,7718,7719,7720,7721,7722,7723,7724,7725,7726,7727,7728,7729,7730,7731,7732,7733,7734,7735,7736,7737,7738,7739,7740,7741,7742,7743,7744,7745,7746,7747,7748,7749,7750,7751,7752,7753,7754,7755,7756,7757,7758,7759,7760,7761,7762,7763,7764,7765,7766,7767,7768,7769,7770,7771,7772,7773,7774,7775,7776,7777,7778,7779,7780,7781,7782,7783,7784,7785,7786,7787,7788,7789,7790,7791,7792,7793,7794,7795,7796,7797,7798,7799,7800,7801,7802,7803,7804,7805,7806,7807,7808,7809,7810,7811,7812,7813,7814,7815,7816,7817,7818,7819,7820,7821,7822,7823,7824,7825,7826,7827,7828,7829,7830,7831,7832,7833,7834,7835,7836,7837,7838,7839,7840,7841,7842,7843,7844,7845,7846,7847,7848,7849,7850,7851,7852,7853,7854,7855,7856,7857,7858,7859,7860,7861,7862,7863,7864,7865,7866,7867,7868,7869,7870,7871,7872,7873,7874,7875,7876,7877,7878,7879,7880,7881,7882,7883,7884,7885,7886,7887,7888,7889,7890,7891,7892,7893,7894,7895,7896,7897,7898,7899,7900,7901,7902,7903,7904,7905,7906,7907,7908,7909,7910,7911,7912,7913,7914,7915,7916,7917,7918,7919,7920,7921,7922,7923,7924,7925,7926,7927,7928,7929,7930,7931,7932,7933,7934,7935,7936,7937,7938,7939,7940,7941,7942,7943,7944,7945,7946,7947,7948,7949,7950,7951,7952,7953,7954,7955,7956,7957,7958,7959,7960,7961,7962,7963,7964,7965,7966,7967,7968,7969,7970,7971,7972,7973,7974,7975,7976,7977,7978,7979,7980,7981,7982,7983,7984,7985,7986,7987,7988,7989,7990,7991,7992,7993,7994,7995,7996,7997,7998,7999};
        PreorderRange preorderRange = new PreorderRange();
        System.out.println(preorderRange.helper(num,0,num.length-1,Integer.MIN_VALUE,Integer.MAX_VALUE));
        //System.out.println(
        //);
        //System.out.println();
       // System.out.println(preorderRange.isBstnotworking(num,0,num.length-1,Integer.MIN_VALUE,Integer.MAX_VALUE));

    }
}
package BasicAlgorithms.BinarySearch;

/**
 * Created by hadoop on 17/10/17.
 */
public class SameTree {
    public boolean isSameTree(TreeNode p, TreeNode q) {

        if( p == null && q == null){
            return true;
        }
        if((p!= null && q == null) || (q!=null && p== null)){
            return false;
        }
        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right) && p.val == q.val;

    }
    class TreeNode{
        int val;
        TreeNode left;
        TreeNode right;
        TreeNode(int x){
            val = x;
        }
    }
}package BasicAlgorithms.BinarySearch;

/**
 * Created by hadoop on 18/10/17.
 */
public class ReconstructTreeFromInorderPostoder {
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        return buildTreeHepler(postorder,0,postorder.length-1,inorder,0,inorder.length-1);
    }

    private TreeNode buildTreeHepler(int[] postorder, int pstart, int pend, int[] inorder, int istart, int iend) {
        if(pstart>pend){
            return null;
        }
        if(pstart == pend){
            return new TreeNode(postorder[pstart]);
        }
        int root = postorder[pend];
        int position = find(inorder,istart,iend,root);
        int numberofelementsinleft = position-1 -istart + 1;
        int numberofelementsinright = iend-position-1 +1;
        TreeNode node = new TreeNode(root);
        node.left = buildTreeHepler(postorder,pstart,pstart+numberofelementsinleft-1,inorder,istart,position-1);
        node.right = buildTreeHepler(postorder,pstart+numberofelementsinleft,pend-1,inorder,position+1,iend);
        return node;
    }

    private int find(int[] inorder, int istart, int iend, int root) {
        for(int i=istart;i<=iend;i++){
            if(inorder[i] == root){
                return i;
            }
        }
        return -1;
    }

    private class TreeNode{
        TreeNode left;
        TreeNode right;
        int val;
        TreeNode(int x){
            val = x;
        }
    }
}
package BasicAlgorithms.BinarySearch;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

/**
 * Created by hadoop on 18/10/17.
 */
public class PredSuccToValue {
    public List<Integer> closestKValues(TreeNode root, double target, int k) {
        Stack<Integer> pred = new Stack<>();
        Stack<Integer> succ = new Stack<>();
        getpredeccsors(root,target, pred);
        getsuccessor(root,target,succ);
        List<Integer> list = new ArrayList<>();
        while (k-->0){
            if(succ.isEmpty()){
                list.add(pred.pop());
            }
            else if(pred.isEmpty()){
                list.add(succ.pop());
            }
            else if(Math.abs(succ.peek()-target)>Math.abs(pred.peek()-target)){
                list.add(pred.pop());
            }
            else {
                list.add(succ.pop());
            }
        }
        return list;

    }

    private void getpredeccsors(TreeNode root, double target, Stack<Integer> pred) {
        if (root == null){
            return;
        }
        getpredeccsors(root.left,target,pred);
        if(root.val<target){
            return;
        }
        pred.push(root.val);
        getpredeccsors(root.right,target,pred);
    }
    private void getsuccessor(TreeNode root, double target, Stack<Integer> succ) {
        if (root == null){
            return;
        }
        getpredeccsors(root.right,target,succ);
        if(root.val>target){
            return;
        }
        succ.push(root.val);
        getpredeccsors(root.left,target,succ);
    }

    private class TreeNode {
        TreeNode left;
        TreeNode right;
        int val;

        TreeNode(int val) {
            this.val = val;
        }
    }
}package BasicAlgorithms.BinarySearch;

import java.util.ArrayList;

/**
 * Created by hadoop on 17/10/17.
 */
public class DandCtemplate {

    public ArrayList<Integer> preorderTraversal(TreeNode node) {
        ArrayList<Integer> result = new ArrayList<>();
        if (node == null) {
            return result;
        }

        ArrayList<Integer> left = preorderTraversal(node.left);
        ArrayList<Integer> right = preorderTraversal(node.right);

        result.add(node.val);
        result.addAll(left);
        result.addAll(right);
        return result;
    }

    private static class ResultType {
        int currentPath;
        int maxpath;

        ResultType(int currentPath, int maxpath) {
            this.maxpath = maxpath;
            this.currentPath = currentPath;
        }

        ResultType() {

        }

        @Override
        public String toString() {
            return "ResultType{" +
                    "currentPath=" + currentPath +
                    ", maxpath=" + maxpath +
                    '}';
        }
    }

    public ResultType traversal(TreeNode node) {
        // nulll or leaf depends wt questions
        if (node == null) {
            return new ResultType();
        }

        ResultType left = traversal(node.left);
        ResultType right = traversal(node.right);
        // conquer
        // Merge from left and right
        ResultType result = null; // merge from left and right ( merge)
        return result;
    }

    public int maxDepth(TreeNode node) {
        if (node == null) {
            return 0;
        }
        return maxDepthHelper(node);
    }

    public int maxDepthHelper(TreeNode node) {

//         if(root == null){
//             return 0;
//         }

//         LinkedList<TreeNode> queue = new LinkedList<>();
//         queue.add(root);
//         int level =0;
//         while (!queue.isEmpty()){
//             int size  =queue.size();
//             for(int i=0;i<size;i++){
//                 TreeNode polled = queue.poll();
//                 if(polled.left!=null){
//                     queue.add(polled.left);
//                 }
//                 if(polled.right!=null){
//                     queue.add(polled.right);
//                 }
//             }
//             level++;
//         }
//         return level;
        if (node == null) {
            return Integer.MIN_VALUE;
        }
        if (node.left == null && node.right == null) {
            return 1;
        }
        int lefheight = maxDepthHelper(node.left);
        int rigthheight = maxDepthHelper(node.right);

        int result = 1;
        result = result + Math.max(lefheight, rigthheight);
        return result;

    }

    public int minDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        return minDepthHelper(root);
    }

    public int minDepthHelper(TreeNode node) {
        if (node == null) {
            return Integer.MAX_VALUE;
        }
        if (node.left == null && node.right == null) {
            return 1;
        }
        int lefheight = minDepthHelper(node.left);
        int rigthheight = minDepthHelper(node.right);

        int result = 1;
        result = result + Math.min(lefheight, rigthheight);
        return result;

    }

    public boolean isbalanced(TreeNode node) {
        if (node == null) {
            return true;
        }
        int ans = isbalancedHelper(node);
        return ans != -1;
    }

    private int isbalancedHelper(TreeNode node) {
        if (node == null) {
            return 0;
        }
        if (node.left == null && node.right == null) {
            return 1;
        }
        int leftheight = isbalancedHelper(node.left);
        int rightheight = isbalancedHelper(node.right);

        if (leftheight == -1) {
            return -1;
        }
        if (rightheight == -1) {
            return -1;
        }
        int diff = Math.abs(leftheight - rightheight);
        if (diff < 2) {
            return Math.max(leftheight, rightheight) + 1;
        }
        return -1;
    }

    public static int maxpath(TreeNode node) {
        if (node == null) {
            return 0;
        }
        ResultType resultType = maxPathHelper(node);
        return resultType.maxpath;
    }

    private static ResultType maxPathHelper(TreeNode node) {
        System.out.println("here1");
        if (node == null) {
            System.out.println("here");

            return new ResultType(Integer.MIN_VALUE, Integer.MIN_VALUE);
        }
        if (node.right == null && node.left == null) {
            System.out.println("here");

            return new ResultType(node.val, node.val);
        }
        System.out.println("here");

        ResultType left = maxPathHelper(node.left);
        ResultType right = maxPathHelper(node.right);
        System.out.println("left" + left);
        System.out.println("right" + right);
        System.out.println("node" + node.val);


        int currentPath = Math.max(node.val, Math.max(left.currentPath, right.currentPath) + node.val);
        int maxpath = Math.max(left.maxpath, Math.max(right.maxpath, node.val +

                (right.currentPath != Integer.MIN_VALUE ? right.currentPath : 0) +
                (left.currentPath != Integer.MIN_VALUE ? left.currentPath : 0)));
        System.out.println("currentPath" + currentPath);
        System.out.println("maxpath" + maxpath);
        return new ResultType(currentPath, maxpath);
    }


    private static class TreeNode {
        TreeNode left;
        TreeNode right;
        int val;

        TreeNode(int x) {
            this.val = x;
        }
    }

    public static void main(String args[]) {
        TreeNode node = new TreeNode(1);
        node.left = new TreeNode(2);
        System.out.println(maxpath(node));
    }

    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null) {
            return null;
        }
        if (root.val > p.val && root.val > q.val) {
            return lowestCommonAncestor(root.left, p, q);
        } else if (root.val <= p.val && root.val >= q.val) {
            return root;
        } else if (root.val <= q.val && root.val >= p.val) {
            return root;
        } else {
            return lowestCommonAncestor(root.right, p, q);
        }
    }

    public static TreeNode commonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null) {
            return null;
        }
        if (root == p) {
            return root;
        }
        if (root == q) {
            return root;
        }
        TreeNode left = commonAncestor(root.left, p, q);
        TreeNode right = commonAncestor(root.right, p, q);
        if (left != null && right != null) {
            return root;
        }
        if (left != null) {
            return left;
        }
        return right;
    }
}
package BasicAlgorithms.BrainTreasure;

/**
 * Created by hadoop on 23/10/17.
 */
public class NimGame {
    public boolean canWinNim(int n) {
        if(n == 0){
            return false;
        }
        if(n == 1){
            return true;
        }
        if(n == 2){
            return true;
        }

        if(n == 3){
            return true;
        }

        if(!canWinNim(n-1) || !canWinNim(n-2) || !canWinNim(n-3)){
            return true;
        }
        return false;
    }
    boolean [] cache;
    public boolean canWinNimite(int n) {
        cache = new boolean[n+1];
        if(n == 0){
            return false;
        }
        if(n == 1){
            return true;
        }
        if(n == 2){
            return true;
        }

        if(n == 3){
            return true;
        }

        cache[0] = false;
        cache[1] = true;
        cache[2] = true;
        cache[3] = true;

        for(int i=4;i<=n;i++){
            cache[i]  = (!cache[i-1] || !cache[i-2] || !cache[i-3]);
        }

        return cache[n];
    }
}package BasicAlgorithms.JavaUtil;

import java.util.*;
public class MapUtil {
    public static <K, V extends Comparable<? super V>> Map<K, V>
    sortByValue(Map<K, V> map) {
        List<Map.Entry<K, V>> list =
                new LinkedList<Map.Entry<K, V>>(map.entrySet());
        Collections.sort(list, new Comparator<Map.Entry<K, V>>() {
            public int compare(Map.Entry<K, V> o1, Map.Entry<K, V> o2) {
                return (o1.getValue()).compareTo(o2.getValue());
            }
        });

        Map<K, V> result = new LinkedHashMap<K, V>();
        for (Map.Entry<K, V> entry : list) {
            result.put(entry.getKey(), entry.getValue());
        }
        return result;
    }
}
package BasicAlgorithms.Array;

import java.util.ArrayList;
import java.util.List;

/**
 * Created by hadoop on 12/10/17.
 */
public class SummaryRange {
    List<String> summaryRange(int []nums){
        List<String> summary = new ArrayList<>();
        for(int i=0;i<nums.length;i++){
            int val = nums[i];
            while (i+1<nums.length && nums[i+1]-nums[i] == 1){
                i++;
            }
            if(val!=nums[i]) {
                summary.add(String.valueOf(val)+"->"+String.valueOf(nums[i]));
            }
            else {
                summary.add(String.valueOf(val));
            }
            }
            return summary;
    }
}
package BasicAlgorithms.Array;

class Solution {
    public int solution(int[] A) {
        return missingnumber(A);
    }
    private static int missingnumber(int[] nums) {
        for(int i=0;i<nums.length;i++){
            if(nums[i]>0 && nums[i]<=nums.length && nums[nums[i]-1]!=i){
                swap(nums,nums[i]-1,i);
                i--;
            }
        }
        for(int i=0;i<nums.length;i++){
            if(i+1 !=nums.length){
                return i+1;
            }
        }
        return nums.length+1;
    }
     private static void swap(int[] nums, int i, int i1) {
        int temp = nums[i];
        nums[i] = nums[i1];
        nums[i1] = temp;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        solution.solution(new int[]{1, 3, 6, 4, 1, 2});
    }
}package BasicAlgorithms.Array;

/**
 * Created by hadoop on 11/10/17.
 */
public class SearchMatrix {
    public boolean searchMatrix(int [][] matrix,int target){
        if(matrix == null || matrix.length == 0 || matrix[0].length == 0){
            return false;
        }
        int m = matrix.length;
        int n = matrix[0].length;

        int start=0;
        int end = m*n-1;
        while (start<end){
            int mid = (start+end)/2;
            int row = mid/n;
            int column = mid%n;
            if(matrix[row][column] <target){
                start = mid+1;
            }
            else {
                end = mid;
            }
        }
        if(matrix[start/n][start%n] == target){
            return true;
        }
        return false;
    }
}
package BasicAlgorithms.Array;

/**
 * Created by hadoop on 12/10/17.
 */
public class shortestWordDistance {
    public int shortestDistance(String[] words, String word1, String word2) {
        int dist = Integer.MAX_VALUE;
        int index1 = -1;
        int index2 = -1;
        for(int i=0;i<words.length;i++){
            if(words[i].equals(word1)){
                index1 = i;
            }
            if(words[i].equals(word2)){
                index2 = i;
            }
            if(index1!=-1 && index2!=-1){
                dist = Math.min(dist,Math.abs(index1-index2));
            }
        }
        return dist;
    }
}package BasicAlgorithms.Array;

/**
 * Created by hadoop on 12/10/17.
 */
public class Celebrity {
    public int celeb(int n){
        int cel = 0;
        for(int i=1;i<n;i++){
            if(!knows(i,cel)){
                cel = i;
            }
        }
        for(int i=0;i<n;i++){
            if(cel !=i){
                if(!(!knows(cel,i) && knows(i,cel))){
                    return -1;
                }
            }
        }
        return cel;
    }
    boolean knows(int a,int b){
        return true;
    }
}
package BasicAlgorithms.Array;

import java.util.HashMap;

/**
 * Created by hadoop on 12/10/17.
 */
public class MaxSubarray {
    public static void main(String[] args) {
        int []nums = {2,3,1,2,4,3};
        int sum = 7;
        System.out.println(maxSubArrayLen(nums,sum));
    }
    public static int maxSubArrayLen(int[] nums, int k) {
        HashMap<Integer,Integer> hashMap = new HashMap<>();
        hashMap.put(0,-1);
        int sum =0;
        int maxlength = Integer.MIN_VALUE;
        for(int i=0;i<nums.length;i++){
            sum = sum+nums[i];
            if(hashMap.containsKey(sum-k)){
                maxlength = Math.max(maxlength,(i-hashMap.get(sum-k)));
            }
            hashMap.put(sum,i);
        }
        return maxlength;
    }
}
package BasicAlgorithms.Array;

/**
 * Created by hadoop on 11/10/17.
 */
public class GameOfLife {
    public static void main(String args[]){

    }
    public void gameOfLife(int [][]board){
        if(board == null || board.length == 0 || board[0].length == 0){
            return;
        }
        int []xdir = {1,-1,-1,1,0,-1,1,0};
        int []ydir = {1,-1,1,-1,-1,0,0,1};
        int m = board.length;
        int n = board[0].length;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                int live =0;
                for(int k=0;k<xdir.length;k++){
                    int newi = i+xdir[k];
                    int newj = j+ydir[k];
                    if(newi>=0 && newi <m && newj>=0 && newj<n) {
                        if (board[newi][newj] == 1 || board[newi][newj] == 2) {
                            live++;
                        }
                    }
                }
                if(board[i][j] == 1 && (live<2 || live>=4)){
                    // we have to choose different values here so that we can determine as how many
                    // lives were present in original state
                    board[i][j] = 2;
                }
                if(board[i][j] == 0 && live == 3){
                    // we need to see as how many dead state initially
                    board[i][j] = 3;
                }
            }
        }
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                board[i][j]%=2;
            }
        }
    }
}
package BasicAlgorithms.Array;

/**
 * Created by hadoop on 12/10/17.
 */
public class MaxDistanceWord3 {
    public static void main(String args[]){
        String []words = {"a","a","b","b"};
        String word1="b";
        String word2="b";

        System.out.println(shortestdistance(words,word1,word2));
        System.out.println(shortestWordDistance(words,word1,word2));
    }

    public static int shortestdistance(String[] words, String word1, String word2){
        int index1 = -1;
        int index2 = -1;
        int mindis = Integer.MAX_VALUE;
        for(int i=0;i<words.length;i++){
            if(words[i].equals(word1)){
                index1 = i;
            }
            if(words[i].equals(word2)){
                if(word1.equals(word2)){
                    index1 = index2;
                    System.out.println("index1"+index1);
                }
                index2 = i;
                System.out.println("index2"+index2);
            }
            System.out.println("index1"+index1);
            System.out.println("index2"+index2);
            System.out.println("diff"+Math.abs(index1-index2));
            mindis= Math.min(mindis,Math.abs(index1-index2));
        }
        return mindis;
    }
    public static int shortestWordDistance(String[] words, String word1, String word2) {
        int dist = words.length;
        int index1 = words.length;
        int index2 = -words.length;
        for (int i = 0; i < words.length; i++) {
            if (words[i].equals(word1)) {
                index1 = i;
            }
            if (words[i].equals(word2)) {
                if (word1.equals(word2)) {
                    index1 = index2;
                    System.out.println("index1"+index1);
                }
                index2 = i;
                System.out.println("index2"+index2);
            }
            if(index1!=-1 && index2!=-1) {
                dist = Math.min(dist, Math.abs(index2 - index1));
            }
        }
        return dist;
    }
}
package BasicAlgorithms.Array;

import java.util.ArrayList;
import java.util.List;

/**
 * Created by hadoop on 12/10/17.
 */
public class FindMissingRangeAgain {
    List<String> missing(int nums[],int lower,int after){
        List<String> list = new ArrayList<>();
        int  previous = lower-1;
        int higher = after;
        for(int i=0;i<nums.length;i++){
            higher = nums[i];
            if(higher-previous ==2){
                list.add(String.valueOf(previous+1));
            }
            else if(higher-previous>2){
                list.add(String.valueOf(previous+1)+"->"+String.valueOf(higher-1));
            }
            previous = nums[i];
            if(nums[i]>higher){
                break;
            }
        }
        higher = after;
        if(higher-previous==2){
            list.add(String.valueOf(previous+1));
        }
        else if(higher-previous>2){
            list.add(String.valueOf(previous+1)+"->"+String.valueOf(after));
        }
        return list;
    }
}
package BasicAlgorithms.Array;

import java.util.ArrayList;
import java.util.List;

/**
 * Created by hadoop on 11/10/17.
 */
public class SpiralWithN {
    public int [][] spiralOrder(int n) {
        int [][]matrix = new int[n][n];
        int n1 = 0;
        int n2 = matrix.length-1;
        int m1 = 0;
        int m2 = matrix[0].length-1;
        List<Integer> list = new ArrayList<>();
        int ans = 1;
        while (m1< m2 && n1 <n2){
            for(int j=m1;j<m2;j++){
                matrix[n1][j] = ans++;
            }
            for(int i=n1;i<n2;i++){
                matrix[i][m2] = ans++;
            }
            for(int j=m2;j>m1;j--){
                matrix[n2][j] = ans++;
            }
            for(int i=n2;i>n1;i--){
                matrix[i][m1] = ans++;
            }
            m1++;
            m2--;
            n1++;
            n2--;
        }
        if(n1 == n2 && m1 == m2 ){
            matrix[n1][m1] = ans++;
        }
//        else{
//            while (m1<=m2 && n1 == n2){
//                list.add( matrix[n1][m1++]);
//            }
//            while (n1<=n2 && m2 == m1){
//                list.add(matrix[n1++][m1]);
//            }
//        }

        return matrix;
    }
}
package BasicAlgorithms.Array;

import java.util.ArrayList;
import java.util.List;

/**
 * Created by hadoop on 12/10/17.
 */
public class FindMissingRange {
    public static void main(String[] args) {
        int nums[] = {0, 1, 3, 50, 75};
        int lower = 5;
        int higher = 56;
        System.out.println(findMissingRange(nums,lower,higher));
    }
    static  List<String> findMissingRange(int []nums, int lower, int upper){
        List<String> list = new ArrayList<>();
        if(nums.length == 0){
            list.add(getRange(lower,upper));
            return list;
        }
        if(lower<nums[0]){
            list.add(getRange(lower,nums[0]-1));
        }
        for(int i=1;i<nums.length;i++){
            if(nums[i]<lower){
                continue;
            }
            if(nums[i]>lower+1){
                list.add(getRange(lower,Math.min(nums[i]-1,upper)));
            }
            lower = nums[i];
            if(nums[i]>upper){
                break;
            }
        }
        if(lower+1<=upper){
            list.add(getRange(lower+1,upper));
        }
        return list;
    }

    private static String getRange(int lower, int upper) {
        if(lower == upper){
            return String.valueOf(lower);
        }
        else if(lower<upper){
            return lower+"->"+upper;
        }
        else {
            return "";
        }
    }
}

/*
public class Solution {

//if both start and end are same, then we just need one entry, else get the range
public String getRangeString(int start, int end){
    return (start==end)?String.valueOf(start):(start+"->"+end);
}

public List<String> findMissingRanges(int[] nums, int lower, int upper) {
    List<String> list = new ArrayList<>();
    //if input array is empty, then just generate the range between lower and upper
    if(nums.length==0){
        list.add(getRangeString(lower, upper));
        return list;
    }

    //if the first element and the lower vary by more than 0, then it means that the input array starts
    //atleast by +1 of lower, so we need to at the minimum add the lower as an entry for output. So we
    //generate the range of lower, first_element-1
    if(nums[0]-lower>0){
        list.add(getRangeString(lower, nums[0]-1));
        //set the lower as first element
        lower = nums[0];
    }

    //now just loop over the array finding the range if the difference is >=2. If the difference is just 1 then it
    //means that the two elements are contiguous, so no need to worry. If its 2 then it means we atleast miss one element,
    //so we find the range of lower+1, current_element-1
    for(int i=1;i<nums.length;i++){
        if(nums[i]-lower >=2){
            list.add(getRangeString(lower+1, nums[i]-1));
        }
        lower = nums[i];
    }

    //for the last element, we need to get the range between last_element+1 and the upper
    if(lower+1 <= upper){
        list.add(getRangeString(lower+1, upper));
    }

    //return the list
    return list;
}
 */package BasicAlgorithms.Array;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;

/**
 * Created by hadoop on 12/10/17.
 */
public class WordDistance2 {
    HashMap<String,List<Integer>> hashmap = new HashMap<String,List<Integer>>();
    WordDistance2(String []words){
        for(int i=0;i<words.length;i++){
            if(!hashmap.containsKey(words[i])){
                hashmap.put(words[i],new ArrayList<>());
            }
            hashmap.get(words[i]).add(i);
        }
    }
    public Integer shortest(String word1,String word2){
        List<Integer> list1 = hashmap.get(word1);
        List<Integer> list2 = hashmap.get(word2);
        if(list1 == null || list2 == null){
            return null;
        }
        int size1 = list1.size();
        int size2 = list2.size();
        int index1=0;
        int index2 =0;
        int mindist = Integer.MAX_VALUE;
        while (index1<size1  &&index2<size2){
            mindist = Math.min(mindist,Math.abs(index1-index2));
            if(index1<index2){
                index1++;
            }
            else {
                index2++;
            }
        }
        return mindist;
    }
}






/*


class WordDistance {


    String []words;
        HashMap<String,List<Integer>> hashmap = new HashMap<String,List<Integer>>();

    public WordDistance(String[] words) {
        this.words = words;
        for(int i=0;i<words.length;i++){
            if(!hashmap.containsKey(words[i])){
                hashmap.put(words[i],new ArrayList<>());
            }
            hashmap.get(words[i]).add(i);
        }
    }

    public Integer shortest(String word1, String word2) {
       List<Integer> list1 = hashmap.get(word1);
        List<Integer> list2 = hashmap.get(word2);
        if(list1 == null || list2 == null){
            return null;
        }
        int size1 = list1.size();
        int size2 = list2.size();
        int index1=0;
        int index2 =0;
        int mindist = Integer.MAX_VALUE;
        while (index1<size1  &&index2<size2){
            mindist = Math.min(mindist,Math.abs(list1.get(index1)-list2.get(index2)));
            if(list1.get(index1)<list2.get(index2)){
                index1++;
            }
            else {
                index2++;
            }
        }
        // while(index1<size1){
        //  mindist = Math.min(mindist,Math.abs(list1.get(index1)-list2.get(index2-1)));
        //     index1++;
        // }
        // while(index2<size2){
        //              mindist = Math.min(mindist,Math.abs(list1.get(index1-1)-list2.get(index2)));
        //             index2++;
        // }
        return mindist;
    }
    }


/**
 * Your WordDistance object will be instantiated and called as such:
 * WordDistance obj = new WordDistance(words);
 * int param_1 = obj.shortest(word1,word2);
 */
package BasicAlgorithms.Array;

import java.util.ArrayList;
import java.util.List;

/**
 * Created by hadoop on 10/10/17.
 */
public class SpiralPrint {
        public List<Integer> spiralOrder(int[][] matrix) {
            if( matrix == null || matrix.length == 0 || matrix[0].length == 0 ){
                return new ArrayList<>();
            }
            int n1 = 0;
            int n2 = matrix.length-1;
            int m1 = 0;
            int m2 = matrix[0].length-1;
            List<Integer> list = new ArrayList<>();

            while (m1< m2 && n1 <n2){
                for(int j=m1;j<m2;j++){
                    list.add(matrix[n1][j]);
                }
                for(int i=n1;i<n2;i++){
                    list.add(matrix[i][m2]);
                }
                for(int j=m2;j>m1;j--){
                    list.add(matrix[n2][j]);
                }
                for(int i=n2;i>n1;i--){
                    list.add(matrix[i][m1]);
                }
                m1++;
                m2--;
                n1++;
                n2--;
            }
            if(n1 == n2 && m1 == m2 ){
                list.add(matrix[n1][m1]);
            }
            else{
                while (m1<=m2 && n1 == n2){
                    list.add( matrix[n1][m1++]);
                }
                while (n1<=n2 && m2 == m1){
                    list.add(matrix[n1++][m1]);
                }
            }

            return list;
        }
    public List<Integer> spiralOrderAgain(int[][] matrix) {
        List<Integer> res = new ArrayList<>();
        if (matrix == null || matrix.length == 0) {
            return res;
        }
        int m = matrix.length;
        int n = matrix[0].length;
        int x = 0, y = 0;
        while (m > 0 && n > 0) {
            if (m == 1) {
                for (int i = 0; i < n; i++) {
                    res.add(matrix[x][y++]);
                }
                break;
            } else if (n == 1) {
                for (int i = 0; i < m; i++) {
                    res.add(matrix[x++][y]);
                }
                break;
            }
            for (int i = 0; i < n - 1; i++) {
                res.add(matrix[x][y++]);
            }
            for (int i = 0; i < m - 1; i++) {
                res.add(matrix[x++][y]);
            }
            for (int i = 0; i < n - 1; i++) {
                res.add(matrix[x][y--]);
            }
            for (int i = 0; i < m - 1; i++) {
                res.add(matrix[x--][y]);
            }
            m = m - 2;
            n = n - 2;
            x++;
            y++;
        }
        return res;
    }
}
package BasicAlgorithms.Array;

/**
 * Created by hadoop on 12/10/17.
 */
public class FirstMissingPositive {
    public static void main(String[] args) {
        int nums[] = {3,4,-1,-1};
        int first = missingnumber(nums);
    }

    private static int missingnumber(int[] nums) {
        for(int i=0;i<nums.length;i++){
            if(nums[i]>0 && nums[i]<=nums.length && nums[nums[i]-1]!=nums[i]){
                swap(nums,nums[i]-1,i);
                i--;
            }
        }
        for(int i=0;i<nums.length;i++){
            if(i+1 !=nums.length){
                return i+1;
            }
        }
        return nums.length+1;
    }

    private static void swap(int[] nums, int i, int i1) {
        int temp = nums[i];
        nums[i] = nums[i1];
        nums[i1] = temp;
    }
}

/*
public class Solution {
    public int firstMissingPositive(int[] A) {
        int i = 0;
        while(i < A.length){
            if(A[i] == i+1 || A[i] <= 0 || A[i] > A.length) i++;
            else if(A[A[i]-1] != A[i]) swap(A, i, A[i]-1);
            else i++;
        }
        i = 0;
        while(i < A.length && A[i] == i+1) i++;
        return i+1;
    }

    private void swap(int[] A, int i, int j){
        int temp = A[i];
        A[i] = A[j];
        A[j] = temp;
    }
}
 */package BasicAlgorithms.Array;

import java.util.Collections;
import java.util.List;

/**
 * Created by hadoop on 17/10/17.
 */
public class CountSort_RadixSort {
//http://opendatastructures.org/ods-java/11_2_Counting_Sort_Radix_So.html
    int maxgap(int []num){
        int maxvalue = Integer.MIN_VALUE;
        for(int i=0;i<num.length;i++){
            maxvalue = Math.max(maxvalue,num[i]);
        }
        // we will use radix / count sort method to sort
        int radix = 10; // 10 base system

        int exp = 1; // 1, 10 , 100 .... digits
        while (maxvalue/exp >0){
            int []count = new int[radix];
            for(int i=0;i<num.length;i++){
                count[(num[i]/exp)%10]+=1;
            }
            for(int i=1;i<radix;i++){
                count[i] += count[i-1];
            }
            int aux[] = new int[num.length];

            for(int i=num.length-1;i>=0;i--){
               // System.out.println(count[(num[i]/exp)%10]);
                aux[--count[(num[i]/exp)%10]] = num[i];
            }
            for(int i=0;i<num.length;i++){
                num[i]= aux[i];
            }
            exp = exp*10;
        }
        int maxdif = Integer.MIN_VALUE;
        for(int i=1;i<num.length;i++){
            maxdif = Math.max(maxdif,num[i]-num[i-1]);
        }
        return maxdif;
    }
    public static void main(String args[]){
        CountSort_RadixSort countSort_radixSort = new CountSort_RadixSort();
        System.out.println(countSort_radixSort.maxgap(new int[]{3,1,5,0,9,3,14}));

    }
}
package BasicAlgorithms.Array;

/**
 * Created by hadoop on 26/10/17.
 */
public class SplitArrayLargestSum {
    private boolean canSplit(int []nums,int maxvalue,int partitions){
        int count = 1;
        int sum = 0;
        for(int a:nums){
            sum = sum +a;
            if(sum>maxvalue){
                sum = a;
                count= count+1;
            }
            if(count>partitions){
                return false;
            }
        }
        return true;
    }

    public int splitArray(int []nums, int partitions){
        if(nums.length ==0){
            return 0;
        }
        int low = maxvalue(nums);
        int high = totalsum(nums);
        while (low<high){
            int mid = (low + high)/2;
            if(canSplit(nums,mid,partitions)){
                high = mid;
            }
            else {
                low = mid +1;
            }
        }
        return low;
    }

    private int totalsum(int[] nums) {
        int sum =0;
        for(int a:nums){
            sum = sum + a;
        }
        return sum;
    }


    private int maxvalue(int[] nums) {
        int max = Integer.MIN_VALUE;
        for(int a:nums){
            max = Math.max(max,a);
        }
        return max;
    }
    public int splitArrayDp(int[] nums, int m) {
        if (nums.length == 0 || nums == null || m == 0)
            return Integer.MAX_VALUE;
        return splitArray(nums, m, 0);
    }

    public int splitArray(int[] nums, int m, int start) {
        if (nums.length == 0 || nums == null || m == 0)
            return Integer.MAX_VALUE;
        if (start > nums.length)
            return Integer.MAX_VALUE;
        if (m == 1) {
            int sum = 0;
            for (int i = start; i < nums.length; i++)
                sum += nums[i];
            return sum;
        }
        int sum = 0;
        int split = 0;
        int min = Integer.MAX_VALUE;
        for (int i = start; i < nums.length; i++) {
            sum += nums[i];
            split = Math.max(sum, splitArray(nums, m - 1, i + 1));
            min = Math.min(min, split);
        }
        return min;
    }

}
/*
M(i,j) gives us maximum number in the range (i to j)
Opt(i,j):- MIN sum starting from i into j partitions
opt(1,m) ans ...
opt(1,m) - one parttion means maximum value = M(1,n)

opt(i,j) :- for(k ->i to length of array){
                min(M((i, K) + opt(k+1,j-1)) where k ranges from i to n-j
}





public int splitArray(int[] nums, int m) {
	if (nums.length == 0 || nums == null || m == 0)
		return Integer.MAX_VALUE;
	return splitArray(nums, m, 0);
}

public int splitArray(int[] nums, int m, int start) {
	if (nums.length == 0 || nums == null || m == 0)
		return Integer.MAX_VALUE;
	if (start > nums.length)
		return Integer.MAX_VALUE;
	if (m == 1) {
		int sum = 0;
		for (int i = start; i < nums.length; i++)
			sum += nums[i];
		return sum;
	}
	int sum = 0;
	int split = 0;
	int min = Integer.MAX_VALUE;
	for (int i = start; i < nums.length; i++) {
		sum += nums[i];
		split = Math.max(sum, splitArray(nums, m - 1, i + 1));
		min = Math.min(min, split);
	}
	return min;
	Define M[n, k] to be the minimum possible cost over all
partitionings of {s1, . . . , sn} into k ranges, where the cost of
a partition is the largest sum of elements in one of its parts.
Thus defined, this function can be evaluated:
M[n, k] =
n
min
i=1
max(M[i, k  1],
X
n
j=i+1
sj)
with the natural basis cases of
M[1, k] = s1, for all k > 0 and,
M[n, 1] =
X
n
i=1
s
}
 */
/*
 Let consider d[ i ][ j ] is solution of the problem when S = {s1, ..., si } and k = j. So it is easy to see that:

d[ 0 ][ j ] = 0 for each j from 1 to k
d[ i ][ 1 ] = sum(s1...si) for each i from 1 to n
d[ i ][ j ] = minfor t = 1 to i (max ( d[i - t][j - 1], sum(si - t + 1...si)) for i = 1 to n and j = 2 to k
Now let's see why this works:

When there is no elements in the sequence it is clear that only one interval there can be (an empty one) and sum of its elements is 0. That's why d[ 0 ][ j ] = 0 for all j from 1 to k.
When only one interval there can be, it is clear that solution is sum of all elements of the sequence. So d[ i ][ 1 ] = sum(s1...si).
Now let's consider there are i elements in the sequence and number of intervals is j, we can assume that last interval is (si - t + 1...si) where t is positive integer not greater than i, so in that case solution is max ( d[i - t][j - 1], sum(si - t + 1...si), but as we want the solution be minimal we should chose t such to minimize it, so we will get minfor t = 1 to i (max ( d[i - t][j - 1], sum(si - t + 1...si)).
Example:

S = (5,4,1,12), k = 2

d[0][1] = 0, d[0][2] = 0

d[1][1] = 5, d[1][2] = 5

d[2][1] = 9, d[2][2] = 5

d[3][1] = 10, d[3][2] = 5

d[4][1] = 22, d[4][2] = 12

Code:

#include <algorithm>
#include <vector>
#include <iostream>
using namespace std;

int main ()
{
    int n;
    const int INF = 2 * 1000 * 1000 * 1000;
    cin >> n;
    vector<int> s(n + 1);
    for(int i = 1; i <= n; ++i)
        cin >> s[i];
    vector<int> first_sum(n + 1, 0);
    for(int i = 1; i <= n; ++i)
        first_sum[i] = first_sum[i - 1] + s[i];
    int k;
    cin >> k;
    vector<vector<int> > d(n + 1);
    for(int i = 0; i <= n; ++i)
        d[i].resize(k + 1);
    //point 1
    for(int j = 0; j <= k; ++j)
        d[0][j] = 0;
    //point 2
    for(int i = 1; i <= n; ++i)
        d[i][1] = d[i - 1][1] + s[i]; //sum of integers from s[1] to s[i]
    //point 3
    for(int i = 1; i <= n; ++i)
        for(int j = 2; j <= k; ++j)
        {
            d[i][j] = INF;
            for(int t = 1; t <= i; ++t)
                d[i][j] = min(d[i][j], max(d[i - t][j - 1], first_sum[i] - first_sum[i - t]));
        }


    cout << d[n][k] << endl;
    return 0;*/
/*
public int maxProfit(int[] prices) {
    return dfs(prices, 2);
}
private int dfs(int[] prices, int pos, int k) {
    if (k == 0 || pos == prices.length)
        return 0;
    int min = Integer.MAX_VALUE;
    int profit = 0;
    for (int i = pos; i < prices.length; i++) {
        min = Math.min(min, prices[i]);
        int diff = prices[i] - min;
        if (diff > 0) {
            diff += dfs(prices, i+1, k-1);
        }
        profit = Math.max(profit, diff);
    }
    return profit;
}
 */package BasicAlgorithms.Array;

/**
 * Created by hadoop on 11/10/17.
 */
public class IncreasingTriplet {
    public static void main(String[] args) {
        int nums[] = {1,2,3,4};
        boolean ans = istrip(nums);
        System.out.println("ans" + ans);
        }

    private static boolean istrip(int[] nums) {
        if(nums.length<3) {
            return false;
        }
        int max;
        int min;
        if(nums[0]<nums[1]){
            max = nums[1];
            min = nums[0];
        }
        else {
            min = nums[1];
            max = Integer.MAX_VALUE;
        }
        for(int i=2;i<nums.length;i++){
            if(nums[i]>max){
                return true;
            }
            else {
                if(nums[i]<min){
                    min = nums[i];
                }
                else if(nums[i]!=min && nums[i]<max){
                    max = nums[i];
                }
            }
        }
        return false;
    }
}
package BasicAlgorithms.Array;

import java.util.Arrays;

/**
 * Created by hadoop on 22/10/17.
 */
public class CanJump {
    public boolean canJump(int[] nums) {
        boolean jump[] = new boolean[nums.length];
        jump[0] = true;
        for(int end=0;end<nums.length;end++){
            for(int i=0;i<end;i++){
                if(nums[i]+i>=end && jump[i]){
                    jump[end] = true;
                }
            }
        }
        return jump[nums.length-1];
    }
    public boolean canJumpGreedy(int[] nums) {

        int farthest = 0+nums[0];
        if (farthest == 0){
            return false;
        }
        int index =0;
        // for loop construct
        // init and then contitoion check and then icnrement condition check
        for(;index<nums.length && index<=farthest;index++){
            farthest = Math.max(farthest,index+nums[index]);
        }
        if(farthest>=nums.length-1){
            return true;
        }
        return false;
    }
    public int canJumpminSteps(int[] nums) {
        int jump[] = new int[nums.length];
        Arrays.fill(jump,Integer.MAX_VALUE);
        jump[0] = 0;
        for(int end=1;end<nums.length;end++){
            for(int i=0;i<end;i++){
                if(nums[i]+i>=end && jump[end]>jump[i]+1){
                    jump[end] = jump[i]+1;
                }
            }
        }
        return jump[nums.length-1];
    }

    public static void main(String[] args) {
        CanJump canJump = new CanJump();
        int nums[]={3,2,1,0,4};
        canJump.canJumpGreedy(nums);
        int nums1[] = {2,3,1,1,4};
        System.out.println(canJump.canJumpminSteps(nums1));
    }
}package BasicAlgorithms.Array;

/**
 * Created by hadoop on 11/10/17.
 */
public class ZigZag {
    public static void main(String args[]){
        int matrix [][] = {{1,2,3},
                {4,5,6},
                {7,8,9}};
        int result[] = zigzag(matrix);
        for(int x:result){
            System.out.print(x);
        }
    }
    static int [] zigzag(int [][]matrix){
        int r= 0;
        int c= 0;

        int endrow = matrix.length;
        int endcol = matrix[0].length;
        int count = 0;
        int total = endrow*endcol;
        int ans []= new int[total];
        while (count<total){
            // see the reason why we operated with r-1 and c+1;
            while (count<total && r-1>=0 && c+1<endcol){
                ans[count++]=matrix[r--][c++];
            }
            if(count<total  && c+1 <endcol){
                ans[count++] = matrix[r][c++];
            }
            else if(count<total){
                ans[count++ ] = matrix[r++][c];
            }

            while (count<total && r+1<endrow && c-1>=0){
                ans[count++] = matrix[r++][c--];
            }
            if(count<total && r+1<endrow){
                ans[count++] = matrix[r++][c];
            }
            else if(count<total){
                ans[count++] = matrix[r][c++];
            }
        }
        return ans;
    }
}
package BasicAlgorithms.Array;
import java.util.*;
public class WordDistance {

private Map<String, List<Integer>> map;

public WordDistance(String[] words) {
    map = new HashMap<String, List<Integer>>();
    for(int i = 0; i < words.length; i++) {
        String w = words[i];
        if(map.containsKey(w)) {
            map.get(w).add(i);
        } else {
            List<Integer> list = new ArrayList<Integer>();
            list.add(i);
            map.put(w, list);
        }
    }
}

public int shortest(String word1, String word2) {
    List<Integer> list1 = map.get(word1);
    List<Integer> list2 = map.get(word2);
    int ret = Integer.MAX_VALUE;
    for(int i = 0, j = 0; i < list1.size() && j < list2.size(); ) {
        int index1 = list1.get(i), index2 = list2.get(j);
        if(index1 < index2) {
            ret = Math.min(ret, index2 - index1);
            i++;
        } else {
            ret = Math.min(ret, index1 - index2);
            j++;
        }
    }
    return ret;
}
}package BasicAlgorithms.Array;

/**
 * Created by hadoop on 11/10/17.
 */
public class Reflection {
}

 class Matrix {
    public static void main(String[] args) {
        Matrix m = new Matrix();
        int[][] matrix = new int[][] { { 1, 6, 11, 16, 21 }, { 2, 7, 12, 17, 22 }, { 3, 8, 13, 18, 23 }, { 4, 9, 14, 19, 24 }, { 5, 10, 15, 20, 25 } };

        int[][] transpose = m.transpose(matrix);
        System.out.println("Transpose of Matrix");
        m.printMatrix(transpose);

        matrix = new int[][] { { 1, 6, 11, 16, 21 }, { 2, 7, 12, 17, 22 }, { 3, 8, 13, 18, 23 }, { 4, 9, 14, 19, 24 }, { 5, 10, 15, 20, 25 } };
        m.horizontalReflection(matrix);
        System.out.println("Horizontal Reflection of Matrix");
        m.printMatrix(matrix);

        matrix = new int[][] { { 1, 6, 11, 16, 21 }, { 2, 7, 12, 17, 22 }, { 3, 8, 13, 18, 23 }, { 4, 9, 14, 19, 24 }, { 5, 10, 15, 20, 25 } };
        m.verticalReflection(matrix);
        System.out.println("Vertical Reflection of Matrix");
        m.printMatrix(matrix);

        matrix = new int[][] { { 1, 6, 11, 16, 21 }, { 2, 7, 12, 17, 22 }, { 3, 8, 13, 18, 23 }, { 4, 9, 14, 19, 24 }, { 5, 10, 15, 20, 25 } };
        transpose = m.transpose(matrix);
        m.horizontalReflection(transpose);
        System.out.println("90 degree rotation of Matrix");
        m.printMatrix(transpose);

        matrix = new int[][] { { 1, 6, 11, 16, 21 }, { 2, 7, 12, 17, 22 }, { 3, 8, 13, 18, 23 }, { 4, 9, 14, 19, 24 }, { 5, 10, 15, 20, 25 } };
        m.horizontalReflection(matrix);
        m.verticalReflection(matrix);
        System.out.println("180 degree rotation of Matrix");
        m.printMatrix(matrix);

        matrix = new int[][] { { 1, 6, 11, 16, 21 }, { 2, 7, 12, 17, 22 }, { 3, 8, 13, 18, 23 }, { 4, 9, 14, 19, 24 }, { 5, 10, 15, 20, 25 } };
        transpose = m.transpose(matrix);
        m.verticalReflection(transpose);
        System.out.println("270 degree rotation of Matrix");
        m.printMatrix(transpose);
    }

    /*
     * Method to get transpose of a matrix. It creates a new matrix to copy the
     * elements because the physical structure of the matrix may change as a
     * part of the transpose operation in case its not a square matrix.
     */
    public int[][] transpose(int[][] mat) {
        if (mat == null)
            return null;

        int m = mat.length;
        int n = mat[0].length;
        int[][] matResult = new int[n][m];
        for (int i = 0; i< m; i++) {
            for (int j = 0; j < n; j++) {
                matResult[j][i] = mat[i][j];
            }
        }
        return matResult;
    }

    /*
     * Method to get the horizontal reflection of the matrix.
     */
    public void horizontalReflection(int[][] mat) {
        int m = mat.length;
        int n = mat[0].length;
        int temp = 0;
        for (int i = 0; i < m / 2; i++) {
            for (int j = 0; j < n; j++) {
                temp = mat[i][j];
                mat[i][j] = mat[m - (i + 1)][j];
                mat[m - (i + 1)][j] = temp;
            }
        }
    }

    /*
     * Method to get the vertical reflection of the given matrix
     */
    public void verticalReflection(int[][] mat) {
        int m = mat.length;
        int n = mat[0].length;
        int temp = 0;
        for (int i = 0; i < n / 2; i++) {
            for (int j = 0; j < m; j++) {
                temp = mat[j][i];
                mat[j][i] = mat[j][n - (i + 1)];
                mat[j][n - (i + 1)] = temp;
            }
        }
    }

    /*
     * Utility method to print the matrix.
     */
    public void printMatrix(int[][] mat) {
        int m = mat.length;
        int n = mat[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                System.out.print(mat[i][j] + "  ");
            }
            System.out.println();
        }
    }
}package BasicAlgorithms.Array;

import BasicAlgorithms.utils.ConsoleWriter;

import java.util.HashMap;

/**
 * Created by hadoop on 26/10/17.
 */
public class SplitArray {
    public boolean splitArray(int[] nums) {
        if(nums.length<7){
            return false;
        }
        int []sum = new int[nums.length+1];
        for(int i=1;i<=nums.length;i++){
            sum[i] = sum[i-1] +nums[i-1];
        }
        for(int i=1;i<=nums.length-6;i++){
            int firstPartitionSum = sum[i]; // 0 to i-1
            for(int j=i+2;j<=nums.length-4;j++){
                int secondPartitionSum = sum[j]-sum[i+1]; // i-1 to i+1
                if(firstPartitionSum !=secondPartitionSum){
                    continue;
                }
                for(int k = j+2;k<=nums.length-2;k++){
                    int thirdParititionSum = sum[k]-sum[j+1];
                    int fourthPartitionSum = sum[nums.length]-sum[k+1];

                    if(firstPartitionSum == secondPartitionSum && thirdParititionSum == fourthPartitionSum && firstPartitionSum == thirdParititionSum){
                        return true;
                    }
                }
            }
        }
        return false;
    }
    public boolean splitArrayop(int[] nums) {
        if(nums.length<7){
            return false;
        }
        int []sum = new int[nums.length+1];
        for(int i=1;i<=nums.length;i++){
            sum[i] = sum[i-1] +nums[i-1];
        }
        ConsoleWriter.printIntArray(sum);
        for(int j = 2;j<=nums.length-5;j++){
            HashMap<Integer,Integer> hashMap = new HashMap<>();
            for(int i=0;i<=j-2;i++){
                System.out.println(sum[i+1]);
                if(sum[i] == sum[j]-sum[i+1]){
                    hashMap.put(sum[i],1);
                    System.out.println(hashMap);
                }
            }
            for(int k= j+2;k<=nums.length-3;k++){
                // sum from j+1 to k-1
                if(sum[k]-sum[j+1] == sum[nums.length]-sum[k+1] && hashMap.containsKey(sum[k]-sum[j+1])){
                    return true;
                }
            }
        }
        return false;
    }

    public static void main(String[] args) {
        SplitArray splitArray = new SplitArray();
        splitArray.splitArrayop(new int[]{1,2,1,2,1,2,1});
    }
    }
    /*
        bool splitArray(vector<int>& nums) {
        if (nums.size() < 7) return false;
        int n = nums.size();
        vector<int> sum(n); sum[0] = nums[0];
        for (int i = 1; i < n; ++i) sum[i] = sum[i-1]+nums[i];
        for (int j = 3; j < n-3; ++j) {
            unordered_set<int> s;
            for (int i = 1; i < j-1; ++i) {
                if (sum[i-1] == sum[j-1]-sum[i]) s.insert(sum[i-1]);
            }
            for (int k = j+2; k < n-1; ++k) {
                if (sum[n-1]-sum[k] == sum[k-1]-sum[j] && s.count(sum[n-1]-sum[k])) return true;
            }
        }
        return false;
    }
};
     */package BasicAlgorithms.Array;

import BasicAlgorithms.utils.ConsoleWriter;

/**
 * Created by hadoop on 21/10/17.
 */
public class SetMatrixZero {

    public void setZeroes(int[][] matrix) {
        int rowLength = matrix.length;
        int columnLength = matrix[0].length;
        if(rowLength == 0 || columnLength == 0){
            return;
        }
        boolean firstRowZero = false;
        for(int j=0;j<columnLength;j++){
            if(matrix[0][j] == 0){
                firstRowZero= true;
            }
        }
        boolean firstColumnZero = false;

        for(int i=0;i<rowLength;i++){
            if(matrix[i][0] == 0){
                firstColumnZero = true;
            }
        }
        ConsoleWriter.printIntArray(matrix);
        System.out.println();

        for(int i=1;i<matrix.length;i++){
            for(int j=1;j<columnLength;j++){
                if(matrix[i][j] ==0){
                    matrix[i][0]=0;
                    matrix[0][j]=0;
                }
            }
        }
        ConsoleWriter.printIntArray(matrix);
        System.out.println();

        for(int i=1;i<matrix.length;i++){
                if(matrix[i][0]==0) {
                    for (int j = 0; j < columnLength; j++) {
                        matrix[i][j] = 0;
                    }
                }
        }
       // ConsoleWriter.printIntArray(matrix);
        System.out.println();

        for(int j=0;j<columnLength;j++){
            if(matrix[0][j] ==0){
                for(int i=0;i<rowLength;i++){
                    matrix[i][j] = 0;
                }

            }
        }
        ConsoleWriter.printIntArray(matrix);
        System.out.println();


//        for(int i=0;i<rowLength;i++){
//            for(int j=0;j<columnLength;j++){
//                if(matrix[0][j] == 0|| matrix[i][0] == 0 ){
//                    matrix[i][j] = 0;
//                }
//            }
//        }
        if(firstRowZero){
            for(int j=0;j<columnLength;j++){
                matrix[0][j] =0;
            }
        }
        if(firstColumnZero){
            for(int i=0;i<rowLength;i++){
                matrix[i][0] = 0;
            }
        }
    }
    public static void main(String args[]){

        SetMatrixZero setMatrixZero = new SetMatrixZero();
        int [][]matrix =
                {{0,0,0,5},{4,3,1,4},{0,1,1,4},{1,2,1,3},{0,0,1,1}};
        setMatrixZero.setZeroes(matrix);
        ConsoleWriter.printIntArray(matrix);
    }
}package BasicAlgorithms.Array;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Created by hadoop on 15/10/17.
 */
public class Kadanes {
    public int maxSub2arrays(Integer []temp) {
        int size = temp.length;
        int[] left = new int[size];
        int[] right = new int[size];
        int currentSum = 0;
        int maxSum = Integer.MIN_VALUE;
        for (int i = 0; i < temp.length; i++) {
            currentSum = Math.max(temp[i], currentSum + temp[i]);
            maxSum = Math.max(currentSum, maxSum);
            left[i] = maxSum;
        }
        for(int i=0;i<left.length;i++){
            System.out.print(left[i]+" ");
        }
        return -1;
    }
    public void kadan(Integer []temp){
        int maxSum = Integer.MIN_VALUE;
        int curretSum = 0;
        for(int num:temp){
            curretSum = Math.max(curretSum+num,num);
            maxSum = Math.max(curretSum,maxSum);
        }
        System.out.println("Max Sum" +maxSum);
    }
    public int maxSubArray(List<Integer> num){
        int len = num.size();
        int leftmax[]= new int[len];
        int leftmin[] = new int[len];
        int currentmax [] = new int[len];
        int currentmin [] = new int[len];
        int rightmax[] = new int[len];
        int rightmin[] = new int[len];
        int currentMax = 0;
        int currentMin = 0;
        for(int i=0;i<len;i++){
            currentMax = Math.max(currentMax+num.get(i),num.get(i));
            currentMin = Math.min(currentMin+num.get(i),num.get(i));
            currentmax[i] = currentMax;
            currentmin[i] = currentMin;
            if(i==0){
                leftmax[i] = currentMax;
                leftmin[i] = currentMin;
            }
            else {
                leftmax[i] = Math.max(leftmax[i - 1], currentMax);
                leftmin[i] = Math.min(leftmin[i - 1], currentMin);
            }
        }
        for(int i=0;i<len;i++){
            System.out.print(leftmax[i]+" ");
        }
        System.out.println();
        for(int i=0;i<len;i++){
            System.out.print(currentmax[i]+" ");
        }
        System.out.println();
        for(int i=0;i<len;i++){
            System.out.print(leftmin[i]+" ");
        }
        System.out.println();
        for(int i=0;i<len;i++){
            System.out.print(currentmin[i]+" ");
        }

        return 0;
    }

    public static void main(String[] args) {
        Integer nums[] = {-4,-5,-6,5,7,-2,4,5,-4,-14,-30,-10,10};
        Kadanes kadanes = new Kadanes();
        kadanes.maxSub2arrays(nums);
        kadanes.kadan(nums);
        kadanes.maxSubArray(Arrays.asList(nums));
    }
}
/*
for(int i = 0; i < N; i++){
max_ending_here += Number[i];

        if(max_ending_here > max_so_far)max_so_far = max_ending_here;

        if(max_ending_here < 0)max_ending_here = 0;

    }
 */package BasicAlgorithms.Array;

/**
 * Created by hadoop on 10/10/17.
 */
public class SparseMatrixMultiplication {
    public int [][]multiple(int [][]A,int [][]B){
        int m = A.length;
        int n = A[0].length;
        int nb = B[0].length;

        int answer[][] = new int[m][nb];
        for(int i=0;i<m;i++){
            for(int k =0;k<n;k++){
                if(A[i][k]!=0)
                for(int j=0;j<nb;j++){
                    answer[i][j]+=A[i][k]*B[k][j];
                }
            }
        }
        return answer;
    }
}
package BasicAlgorithms.Array;

import java.util.ArrayList;
import java.util.List;

/**
 * Created by hadoop on 11/10/17.
 */
public class PascalTriangle {
        public List<List<Integer>> generate(int rows) {
            List<Integer> list = new ArrayList<>();
            List<List<Integer>> result = new ArrayList<>();

            if(rows == 0){
                return result;
            }
            int array[][] = new int[rows+1][rows+1];
            for(int i=0;i<=rows;i++){
                array[i][1] = 1;
                array[i][i] = 1;
            }
            List<Integer> listAdd = new ArrayList<>();

            for(int i=1;i<=rows;i++){
                listAdd.clear();
                for(int j=1;j<=i;j++){
                    if(i == j){
                        array[i][j] = 1;
                    }
                    else{
                        array[i][j] = array[i-1][j-1]+array[i-1][j];
                    }
                    System.out.print(array[i][j]+",");
                    listAdd.add(array[i][j]);
                }
                System.out.println();
                result.add(new ArrayList<>(listAdd));
            }
            return result;
        }

    public static void main(String[] args) {
        PascalTriangle pascalTriangle = new PascalTriangle();
        pascalTriangle.generate(2);
    }
}

/*
List<Integer> list = new ArrayList<>();
        List<List<Integer>> result = new ArrayList<>();

        if(rows == 0){
            return result;
        }
        int array[][] = new int[rows+1][rows+1];
        List<Integer> listAdd = new ArrayList<>();
        for(int i=0;i<rows;i++){
            listAdd.clear();
            for(int j=0;j<=i;j++){
                if(i == j || j ==0 ){
                    array[i][j] = 1;
                }
                else{
                    array[i][j] = array[i-1][j-1]+array[i-1][j];
                }
                listAdd.add(array[i][j]);
            }
            result.add(new ArrayList<>(listAdd));
        }
        return result;
 */package BasicAlgorithms;

import java.util.HashSet;

/**
 * Created by hadoofgvp on 17/11/17.
 */
public class MinLines {
    public int solution(Point2D[] A) {
        HashSet<slope> slopes = new HashSet<>();
        int lines = 0;
        for (int i = 0; i < A.length; i++) {
            int xcor = A[i].x;
            int ycor = A[i].y;
            slope s = slopewithgcd(xcor, ycor);
            if (!slopes.contains(s)) {
                slopes.add(s);
                lines++;
            }
        }
        return lines;
    }

    slope slopewithgcd(int x, int y) {
        int gcd = getGCD(Math.abs(x), Math.abs(y));
        if(x ==0 && y>0){
            return new slope(1,0);
        }
        if(x ==0 && y <0){
            return new slope(-1,0);
        }
        if( y ==0 && x >0){
            return new slope(0,1);
        }
        if( y ==0 && x<0){
            return new slope(0,-1);
        }


        if (x < 0 && y < 0) {
            return new slope(-1 * Math.abs(y) / gcd, -1 * Math.abs(x) / gcd);
        } else if (x > 0 && y > 0) {
            return new slope(1 * Math.abs(y) / gcd, 1 * Math.abs(x) / gcd);
        } else if (x < 0) {
            return new slope(Math.abs(y) / gcd, -1 * Math.abs(x) / gcd);
        } else {
            return new slope(-1 * Math.abs(y) / gcd, 1 * Math.abs(x) / gcd);
        }

    }

    int getGCD(int x, int y) {
        if (y == 0) {
            return x;
        }
        return getGCD(y, x % y);
    }

//    public static void main(String[] args) {
//        Point2D A[] = new Point2D[5];
//        for (int i = 0; i < 5; i++) {
//            A[i] = new Point2D();
//        }
//        A[0].x = -1;
//        A[0].y = -2;
//        A[1].x = 1;
//        A[1].y = 2;
//        A[2].x = 2;
//        A[2].y = 4;
//        A[3].x = -3;
//        A[3].y = 2;
//        A[4].x = 2;
//        A[4].y = -2;
//        MinLines minLines = new MinLines();
//        System.out.println(minLines.solution(A));
//    }

    private class slope {
        int yslope;
        int xslope;

        public slope(int yslope, int xslope) {
            this.yslope = yslope;
            this.xslope = xslope;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;

            slope slope = (slope) o;

            if (yslope != slope.yslope) return false;
            return xslope == slope.xslope;
        }

        @Override
        public int hashCode() {
            int result = yslope;
            result = 31 * result + xslope;
            return result;
        }
    }
}
class Point2D{
    int x;
    int y;
}package BasicAlgorithms.MyGraph;

import java.util.Stack;
/*
Two-colorability: Can the vertices of a given graph be assigned one of two colors in such a way that no edge connects vertices of the same color? Bipartite.java uses depth-first search to determine whether a graph has a bipartition; if so, return one; if not, return an odd-length cycle. It takes time proportional to V + E in the worst case.
 */

/**
 * Created by hadoop on 19/10/17.
 */
// same as cycle just check for odd length cycle
    // if that exist means  you can remove that as well
public class Bipartitie {
    boolean []marked ;
    boolean []color; // kkeeping two colors but we can change as we go ahead
    Stack<Integer> cycle ; // keep it null until we find it
    int []edgeTo;
    boolean isBipartite;
    // if we wan to find that particular cycle
    Bipartitie(Graph g){
        marked = new boolean[g.getV()];
        color = new boolean[g.getV()];
        edgeTo = new int[g.getV()];
        for(int i=0;i<g.getV();i++){
            if(!marked[i]){
                dfs(g,i);
            }
        }
        // nedeed to this to find actual cycle
    }

    private void dfs(Graph g, int s) {
        marked[s] = true;
        edgeTo[s] = -1;
        color[s] = true;
        dfsHelper(g,s);
    }

    private void dfsHelper(Graph g, int s) {

        for(int w:g.adj(s)){
            if(cycle!=null){
                return;
            }
            if(!marked[w]){
                color[w] = !color[s];
                marked[w] = true;
                edgeTo[w] = s;
            }
            // we are sure that parent would have different color so parent passing not requied
            else if( color[w] == color[s]){
                // we found cycle lets prin tit
                isBipartite = true;
                cycle = new Stack<>();
                cycle.add(w);
                for(int x=s;x!=w;x = edgeTo[x]){
                    cycle.add(x);
                }
                // if you wanto add repeating cycle node once again
                cycle.add(w);
            }
        }
    }

}
package BasicAlgorithms.MyGraph;// Java program to find single source shortest paths in Directed Acyclic Graphs
/*




Following is complete algorithm for finding shortest distances.
1) Initialize dist[] = {INF, INF, .} and dist[s] = 0 where s is the source vertex.
2) Create a toplogical order of all vertices.
3) Do following for every vertex u in topological order.
..Do following for every adjacent vertex v of u
if (dist[v] > dist[u] + weight(u, v))
dist[v] = dist[u] + weight(u, v)
 */

import java.io.*;
import java.util.*;
 
class ShortestPath
{
    static final int INF=Integer.MAX_VALUE;
    class AdjListNode
    {
        private int v;
        private int weight;
        AdjListNode(int _v, int _w) { v = _v;  weight = _w; }
        int getV() { return v; }
        int getWeight()  { return weight; }
    }
 
    // Class to represent graph as an adjcency list of
    // nodes of type AdjListNode
    class Graph
    {
        private int V;
        private LinkedList<AdjListNode>adj[];
        Graph(int v)
        {
            V=v;
            adj = new LinkedList[V];
            for (int i=0; i<v; ++i)
                adj[i] = new LinkedList<AdjListNode>();
        }
        void addEdge(int u, int v, int weight)
        {
            AdjListNode node = new AdjListNode(v,weight);
            adj[u].add(node);// Add v to u's list
        }
 
        // A recursive function used by shortestPath.
        // See below link for details
        void topologicalSortUtil(int v, Boolean visited[], Stack stack)
        {
            // Mark the current node as visited.
            visited[v] = true;
            Integer i;
 
            // Recur for all the vertices adjacent to this vertex
            Iterator<AdjListNode> it = adj[v].iterator();
            while (it.hasNext())
            {
                AdjListNode node =it.next();
                if (!visited[node.getV()])
                    topologicalSortUtil(node.getV(), visited, stack);
            }
            // Push current vertex to stack which stores result
            stack.push(new Integer(v));
        }
 
        // The function to find shortest paths from given vertex. It
        // uses recursive topologicalSortUtil() to get topological
        // sorting of given graph.
        void shortestPath(int s)
        {
            Stack stack = new Stack();
            int dist[] = new int[V];
 
            // Mark all the vertices as not visited
            Boolean visited[] = new Boolean[V];
            for (int i = 0; i < V; i++)
                visited[i] = false;
 
            // Call the recursive helper function to store Topological
            // Sort starting from all vertices one by one
            for (int i = 0; i < V; i++)
                if (visited[i] == false)
                    topologicalSortUtil(i, visited, stack);
 
            // Initialize distances to all vertices as infinite and
            // distance to source as 0
            for (int i = 0; i < V; i++)
                dist[i] = INF;
            dist[s] = 0;
 
            // Process vertices in topological order
            while (stack.empty() == false)
            {
                // Get the next vertex from topological order
                int u = (int)stack.pop();
 
                // Update distances of all adjacent vertices
                Iterator<AdjListNode> it;
                if (dist[u] != INF)
                {
                    it = adj[u].iterator();
                    while (it.hasNext())
                    {
                        AdjListNode i= it.next();
                        if (dist[i.getV()] > dist[u] + i.getWeight())
                            dist[i.getV()] = dist[u] + i.getWeight();
                    }
                }
            }
 
            // Print the calculated shortest distances
            for (int i = 0; i < V; i++)
            {
                if (dist[i] == INF)
                    System.out.print( "INF ");
                else
                    System.out.print( dist[i] + " ");
            }
        }
    }
 
    // Method to create a new graph instance through an object
    // of ShortestPath class.
    Graph newGraph(int number)
    {
        return new Graph(number);
    }
 
    public static void main(String args[])
    {
        // Create a graph given in the above diagram.  Here vertex
        // numbers are 0, 1, 2, 3, 4, 5 with following mappings:
        // 0=r, 1=s, 2=t, 3=x, 4=y, 5=z
        ShortestPath t = new ShortestPath();
        Graph g = t.newGraph(6);
        g.addEdge(0, 1, 5);
        g.addEdge(0, 2, 3);
        g.addEdge(1, 3, 6);
        g.addEdge(1, 2, 2);
        g.addEdge(2, 4, 4);
        g.addEdge(2, 5, 2);
        g.addEdge(2, 3, 7);
        g.addEdge(3, 4, -1);
        g.addEdge(4, 5, -2);
 
        int s = 1;
        System.out.println("Following are shortest distances "+
                            "from source " + s );
        g.shortestPath(s);
    }
}
//This code is contributed by Aakash Hasija
package BasicAlgorithms.MyGraph;

/**
 * Created by hadoop on 19/10/17.
 */
public class KosarajuSharirSCC {
    private boolean [] marked;
    private int []id;
    private int count;

    public KosarajuSharirSCC(Digraph g){
        marked = new boolean[g.getV()];
        id = new int[g.getV()];
        DepthFirstSearchOrders depthFirstSearchOrders = new DepthFirstSearchOrders(g.reverse());

        for(int x:depthFirstSearchOrders.reversePostOrder()){
            if(!marked[x]){
                dfs(g,x);
                count++;
            }
        }
    }

    private void dfs(Digraph g, int v) {
        marked[v] = true;
        id[v] = count;
        for(int w:g.adj(v)){
            if(!marked[w]){
                dfs(g,v);
            }
        }
    }
    // Strongly connected components
    public int getCount() {
        return count;
    }
}
package BasicAlgorithms.MyGraph;
import java.util.*;
//https://codereview.stackexchange.com/questions/67704/optimizing-dijkstra-implementation-using-priorityqueue-in-java
class DijBest {
    public static int shortestPathDijkstra(Node source, Node target) {
        Map<Node, MyDijkstraNode> result = new HashMap<>(); // can be an array if vertices are integer-indexed.
        PriorityQueue<MyDijkstraNode> pq = new PriorityQueue<>(Comparator.comparingInt(MyDijkstraNode::getMinCost));

        MyDijkstraNode resultSource = new MyDijkstraNode(source);
        resultSource.setPre(null);
        resultSource.setMinCost(0);
        pq.add(resultSource);
        result.put(source, resultSource);

        Set<Node> btdt = new HashSet<>(); // can be a boolean array if vertices are integer-indexed.
        while (!pq.isEmpty()) {
            MyDijkstraNode uNode = pq.poll();
            Node u = uNode.getU();
            if (btdt.contains(u)) {
                continue;
            }
            btdt.add(u);
            Map<Node, Integer> edges = u.getNeighbours();
            for (Map.Entry<Node, Integer> e : edges.entrySet()) {
                Node v = e.getKey();
                int w = e.getValue();
                if (btdt.contains(v)) {
                    continue;
                }
                MyDijkstraNode existingNode = result.get(v);
                if (existingNode == null || existingNode.getMinCost() > uNode.getMinCost() + w) {
                    MyDijkstraNode newNode = new MyDijkstraNode(v);
                    newNode.setMinCost(uNode.getMinCost() + w);
                    newNode.setPre(uNode);
                    pq.add(newNode);
                    result.put(v, existingNode);
                }
            }
        }
        MyDijkstraNode targetDijkstraNode = result.get(target);
        if (targetDijkstraNode == null) {
            throw new RuntimeException("no path found");
        }
        return targetDijkstraNode.getMinCost();
        // or return targetDijkstraNode to get full path.
        // or return result to get all shortest paths to all other vertices from single source.
    }
}
class Node {
    private final char label;
    private final Map<Node, Integer> neighbours;

    public Node(char label) {
        this.label = label;
        neighbours = new HashMap<>();
    }

    public void addNeighbour(Node node, int distance) {
        neighbours.put(node, distance);
    }

    public char getLabel() {
        return label;
    }

    public Map<Node, Integer> getNeighbours() {
        return neighbours;
    }
}

class MyDijkstraNode {
    private Node u;
    private int minCost;
    private MyDijkstraNode pre;

    public MyDijkstraNode(Node u) {
        this.u = u;
    }

    public Node getU() {
        return u;
    }

    public int getMinCost() {
        return minCost;
    }

    public MyDijkstraNode getPre() {
        return pre;
    }

    public void setPre(MyDijkstraNode pre) {
        this.pre = pre;
    }

    public void setMinCost(int minCost) {
        this.minCost = minCost;
    }
}package BasicAlgorithms.MyGraph.geeksforgeeksgraph;// Java program to check if a given directed graph is strongly
// connected or not
import java.util.*;
import java.util.LinkedList;
 
// This class represents a directed graph using adjacency
// list representation
class StronglyConnected
{
    private int V;   // No. of vertices
    private LinkedList<Integer> adj[]; //Adjacency List
 
    //Constructor
    StronglyConnected(int v)
    {
        V = v;
        adj = new LinkedList[v];
        for (int i=0; i<v; ++i)
            adj[i] = new LinkedList();
    }
 
    //Function to add an edge into the graph
    void addEdge(int v,int w) {  adj[v].add(w); }
 
    // A recursive function to print DFS starting from v
    void DFSUtil(int v,Boolean visited[])
    {
        // Mark the current node as visited and print it
        visited[v] = true;
 
        int n;
 
        // Recur for all the vertices adjacent to this vertex
        Iterator<Integer> i = adj[v].iterator();
        while (i.hasNext())
        {
            n = i.next();
            if (!visited[n])
                DFSUtil(n,visited);
        }
    }
 
    // Function that returns transpose of this graph
    StronglyConnected getTranspose()
    {
        StronglyConnected g = new StronglyConnected(V);
        for (int v = 0; v < V; v++)
        {
            // Recur for all the vertices adjacent to this vertex
            Iterator<Integer> i = adj[v].listIterator();
            while (i.hasNext())
                g.adj[i.next()].add(v);
        }
        return g;
    }
 
    // The main function that returns true if graph is strongly
    // connected
    Boolean isSC()
    {
        // Step 1: Mark all the vertices as not visited
        // (For first DFS)
        Boolean visited[] = new Boolean[V];
        for (int i = 0; i < V; i++)
            visited[i] = false;
 
        // Step 2: Do DFS traversal starting from first vertex.
        DFSUtil(0, visited);
 
        // If DFS traversal doesn't visit all vertices, then
        // return false.
        for (int i = 0; i < V; i++)
            if (visited[i] == false)
                return false;
 
        // Step 3: Create a reversed graph
        StronglyConnected gr = getTranspose();
 
        // Step 4: Mark all the vertices as not visited (For
        // second DFS)
        for (int i = 0; i < V; i++)
            visited[i] = false;
 
        // Step 5: Do DFS for reversed graph starting from
        // first vertex. Staring Vertex must be same starting
        // point of first DFS
        gr.DFSUtil(0, visited);
 
        // If all vertices are not visited in second DFS, then
        // return false
        for (int i = 0; i < V; i++)
            if (visited[i] == false)
                return false;
 
        return true;
    }
 
    public static void main(String args[])
    {
        // Create graphs given in the above diagrams
        StronglyConnected g1 = new StronglyConnected(5);
        g1.addEdge(0, 1);
        g1.addEdge(1, 2);
        g1.addEdge(2, 3);
        g1.addEdge(3, 0);
        g1.addEdge(2, 4);
        g1.addEdge(4, 2);
        if (g1.isSC())
            System.out.println("Yes");
        else
            System.out.println("No");
 
        StronglyConnected g2 = new StronglyConnected(4);
        g2.addEdge(0, 1);
        g2.addEdge(1, 2);
        g2.addEdge(2, 3);
        if (g2.isSC())
            System.out.println("Yes");
        else
            System.out.println("No");
    }
}
// This code is contributed by Aakash Hasijapackage BasicAlgorithms.MyGraph.geeksforgeeksgraph;

public class LongestPathInDAG {
    public static void main(String[] args) {
        Graph g = new Graph(6);
        g.addEdge(0, 1, 5);
        g.addEdge(0, 2, 3);
        g.addEdge(1, 3, 6);
        g.addEdge(1, 2, 2);
        g.addEdge(2, 4, 4);
        g.addEdge(2, 5, 2);
        g.addEdge(2, 3, 7);
        g.addEdge(3, 5, 1);
        g.addEdge(3, 4, -1);
        g.addEdge(4, 5, -2);
        int s = 1;
        g.findLongestPath(s);
    }

    public static class Graph {
        private int V;
        private int[][] matrix;
        private int[] vertices;
        private boolean[] visited;
        private int[] distances;
        private int[] predecessor;
        private Stack stack;

        public Graph(int V) {
            this.V = V;
            vertices = new int[V];
            visited = new boolean[V];
            predecessor = new int[V];
            distances = new int[V];
            matrix = new int[V][V];
            stack = new Stack(V);
            for (int i = 0; i < V; i++) {
                addVertex(i);
                distances[i] = Integer.MIN_VALUE;
                predecessor[i] = -1;
            }
        }

        private void addVertex(int databaseName) {
            vertices[databaseName] = databaseName;
        }

        public void addEdge(int source, int destination, int weight) {
            matrix[source][destination] = weight;
        }

        public void findLongestPath(int source) {
            invokeTopologicalSort();
            distances[source] = 0; // Initialize source with 0
            updateMaxDistanceForAllAdjVertices(); // for all nodes connected,
                                                    // directly or indirectly,
                                                    // with source will have
                                                    // their distances
                                                    // calculated
            printDistances(source);
            printPath(source);
        }

        private void printDistances(int source) {
            System.out.println("Distances from source " + source + " are as follows: ");
            for (int to = 0; to < V; to++) {
                int distance = distances[to];
                System.out.print("from " + source + " to " + to + ": ");
                if (distance == Integer.MIN_VALUE) {
                    System.out.println(" -Infinity ");
                } else {
                    System.out.println(distance + " ");
                }
            }
            System.out.println();
        }

        private void printPath(int source) {
            System.out.println("Path from source " + source + " to other nodes are as follows: ");
            for (int i = 0; i < V; i++) {
                if (distances[i] == Integer.MIN_VALUE) {
                    System.out.println("No Path from " + source + " to " + i);
                } else if (i != source) {
                    int from = predecessor[i];
                    System.out.print("Path from " + source + " to " + i + ": ");
                    if (from == source) {
                        System.out.print(from + " ");
                    }
                    while (from != source) {
                        System.out.print(from + " ");
                        from = predecessor[from];
                    }
                    System.out.print(i + " ");
                    System.out.println();
                }
            }
        }

        private void updateMaxDistanceForAllAdjVertices() {
            while (!stack.isEmpty()) {
                int from = stack.pop();
                if (distances[from] != Integer.MIN_VALUE) {
                    for (int adjacent = 0; adjacent < V; adjacent++) {
                        if (matrix[from][adjacent] != 0) {
                            if (distances[adjacent] < distances[from] + matrix[from][adjacent]) {
                                predecessor[adjacent] = from;
                                distances[adjacent] = distances[from] + matrix[from][adjacent];
                            }
                        }
                    }
                }
            }
        }

        private void invokeTopologicalSort() {
            for (int i = 0; i < V; i++) {
                if (!visited[i]) {
                    dfs(i);
                }
            }
        }

        private void dfs(int source) {
            visited[source] = true;
            for (int adjacent = 0; adjacent < V; adjacent++) {
                if (matrix[source][adjacent] != 0 && !visited[adjacent]) {
                    dfs(adjacent);
                }
            }
            stack.push(source);
        }

    }

    public static class Stack {
        private int maxSize;
        private int[] stack;
        private int top = -1;
        private int size = 0;

        public Stack(int maxSize) {
            this.maxSize = maxSize;
            stack = new int[maxSize];
        }

        public void push(int item) {
            stack[++top] = item;
            size++;
        }

        public int pop() {
            int item = stack[top--];
            size--;
            return item;
        }

        public boolean isEmpty() {
            return size == 0;
        }
    }
}package BasicAlgorithms.MyGraph.geeksforgeeksgraph;

/**
 * Created by hadoop on 20/10/17.
 */

// A Java program to check if a given directed graph is Eulerian or not

// A class that represents an undirected graph
import java.util.*;
        import java.util.LinkedList;

// This class represents a directed graph using adjacency list
class GraphEulerDirected
{
    private int V;   // No. of vertices
    private LinkedList<Integer> adj[];//Adjacency List
    private int in[];           //maintaining in degree

    //Constructor
    GraphEulerDirected(int v)
    {
        V = v;
        adj = new LinkedList[v];
        in = new int[V];
        for (int i=0; i<v; ++i)
        {
            adj[i] = new LinkedList();
            in[i]  = 0;
        }
    }

    //Function to add an edge into the graph
    void addEdge(int v,int w)
    {
        adj[v].add(w);
        in[w]++;
    }

    // A recursive function to print DFS starting from v
    void DFSUtil(int v,Boolean visited[])
    {
        // Mark the current node as visited
        visited[v] = true;

        int n;

        // Recur for all the vertices adjacent to this vertex
        Iterator<Integer> i =adj[v].iterator();
        while (i.hasNext())
        {
            n = i.next();
            if (!visited[n])
                DFSUtil(n,visited);
        }
    }

    // Function that returns reverse (or transpose) of this graph
    GraphEulerDirected getTranspose()
    {
        GraphEulerDirected g = new GraphEulerDirected(V);
        for (int v = 0; v < V; v++)
        {
            // Recur for all the vertices adjacent to this vertex
            Iterator<Integer> i = adj[v].listIterator();
            while (i.hasNext())
            {
                g.adj[i.next()].add(v);
                (g.in[v])++;
            }
        }
        return g;
    }

    // The main function that returns true if graph is strongly
    // connected
    Boolean isSC()
    {
        // Step 1: Mark all the vertices as not visited (For
        // first DFS)
        Boolean visited[] = new Boolean[V];
        for (int i = 0; i < V; i++)
            visited[i] = false;

        // Step 2: Do DFS traversal starting from first vertex.
        DFSUtil(0, visited);

        // If DFS traversal doesn't visit all vertices, then return false.
        for (int i = 0; i < V; i++)
            if (visited[i] == false)
                return false;

        // Step 3: Create a reversed graph
        GraphEulerDirected gr = getTranspose();

        // Step 4: Mark all the vertices as not visited (For second DFS)
        for (int i = 0; i < V; i++)
            visited[i] = false;

        // Step 5: Do DFS for reversed graph starting from first vertex.
        // Staring Vertex must be same starting point of first DFS
        gr.DFSUtil(0, visited);

        // If all vertices are not visited in second DFS, then
        // return false
        for (int i = 0; i < V; i++)
            if (visited[i] == false)
                return false;

        return true;
    }

    /* This function returns true if the directed graph has an eulerian
       cycle, otherwise returns false  */
    Boolean isEulerianCycle()
    {
        // Check if all non-zero degree vertices are connected
        if (isSC() == false)
            return false;

        // Check if in degree and out degree of every vertex is same
        for (int i = 0; i < V; i++)
            if (adj[i].size() != in[i])
                return false;


        return true;
    }

    public static void main (String[] args) throws java.lang.Exception
    {
        GraphEulerDirected g = new GraphEulerDirected(5);
        g.addEdge(1, 0);
        g.addEdge(0, 2);
        g.addEdge(2, 1);
        g.addEdge(0, 3);
        g.addEdge(3, 4);
        g.addEdge(4, 0);

        if (g.isEulerianCycle())
            System.out.println("Given directed graph is eulerian ");
        else
            System.out.println("Given directed graph is NOT eulerian ");
    }
}
//This code is contributed by Aakash Hasijapackage BasicAlgorithms.MyGraph.geeksforgeeksgraph;

import java.util.*;
 
//Class to represent a graph
class Graph
{
    int V;// No. of vertices
     
    //An Array of List which contains 
    //references to the Adjacency List of 
    //each vertex
    List <Integer> adj[];
    public Graph(int V)// Constructor
    {
        this.V = V;
        adj = new ArrayList[V];
        for(int i = 0; i < V; i++)
            adj[i]=new ArrayList<Integer>();
    }
     
    // function to add an edge to graph
    public void addEdge(int u,int v)
    {
        adj[u].add(v);
    }
    // prints a Topological Sort of the complete graph  
    public void topologicalSort()
    {
        // Create a array to store indegrees of all
        // vertices. Initialize all indegrees as 0.
        int indegree[] = new int[V];
         
        // Traverse adjacency lists to fill indegrees of
        // vertices. This step takes O(V+E) time        
        for(int i = 0; i < V; i++)
        {
            ArrayList<Integer> temp = (ArrayList<Integer>) adj[i];
            for(int node : temp)
            {
                indegree[node]++;
            }
        }
         
        // Create a queue and enqueue all vertices with
        // indegree 0
        Queue<Integer> q = new LinkedList<Integer>();
        for(int i = 0;i < V; i++)
        {
            if(indegree[i]==0)
                q.add(i);
        }
         
        // Initialize count of visited vertices
        int cnt = 0;
         
        // Create a vector to store result (A topological
        // ordering of the vertices)
        Vector <Integer> topOrder=new Vector<Integer>();
        while(!q.isEmpty())
        {
            // Extract front of queue (or perform dequeue)
            // and add it to topological order
            int u=q.poll();
            topOrder.add(u);
             
            // Iterate through all its neighbouring nodes
            // of dequeued node u and decrease their in-degree
            // by 1
            for(int node : adj[u])
            {
                // If in-degree becomes zero, add it to queue
                if(--indegree[node] == 0)
                    q.add(node);
            }
            cnt++;
        }
         
        // Check if there was a cycle       
        if(cnt != V)
        {
            System.out.println("There exists a cycle in the graph");
            return ;
        }
         
        // Print topological order          
        for(int i : topOrder)
        {
            System.out.print(i+" ");
        }
    }
}
// Driver program to test above functions
class Main
{
    public static void main(String args[])
    {
        // Create a graph given in the above diagram
        Graph g=new Graph(6);
        g.addEdge(5, 2);
        g.addEdge(5, 0);
        g.addEdge(4, 0);
        g.addEdge(4, 1);
        g.addEdge(2, 3);
        g.addEdge(3, 1);
        System.out.println("Following is a Topological Sort");
        g.topologicalSort();
 
    }
}package BasicAlgorithms.MyGraph.geeksforgeeksgraph;

import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.PriorityQueue;

/**
 * Created by hadoop on 25/10/17.
 */
public class MazeCheck {
    // bfs, like-dijikstra
    static int[] dirx = {1, 0, -1, 0};
    static int[] diry = {0, -1, 0, 1};
    int m;
    int n;

    private class Point {
        int x;
        int y;
        int distance; // it is required to stich distance to node

        public Point(int x, int y, int distance) {
            this.x = x;
            this.y = y;
            this.distance = distance;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;

            Point point = (Point) o;

            if (x != point.x) return false;
          //  if (y != point.y) return false;
            return y == point.y;

        }

        @Override
        public int hashCode() {
            int result = x;
            result = 31 * result + y;
            //result = 31 * result + distance;
            return result;
        }

        @Override
        public String toString() {
            return "Point{" +
                    "x=" + x +
                    ", y=" + y +
                    ", distance=" + distance +
                    '}';
        }
    }

    public int shortDistance(int[][] maze, int[] start, int[] destination) {
        m = maze.length;
        n = maze[0].length;
        PriorityQueue<Point> pq = new PriorityQueue<>(new Comparator<Point>() {
            @Override
            public int compare(Point o1, Point o2) {
                return o1.distance - o2.distance;
            }
        });
        HashMap<Point, Integer> dist = new HashMap<>();
        HashMap<Point, Point> edgeTo = new HashMap<>();
        //HashSet<Point> nodesAlreadyVisited = new HashSet<>();
        Point startPoint = new Point(start[0], start[1], 0);
        pq.add(startPoint);
        edgeTo.put(startPoint, null);
        dist.put(startPoint, 0);
        int counter = 0;
        while (!pq.isEmpty()) {
            counter++;
            Point point = pq.poll();
            int distance = dist.get(point);
            if (isEndConfiguration(point, destination)) {
                return distance;
            }
            if (counter > 10000) System.exit(1);
            System.out.println("po"+point);
//            if (nodesAlreadyVisited.contains(point)){
//                System.out.println("loop back");
//                continue;
//            }
           // System.out.println("addeDsucc "+nodesAlreadyVisited.add(point));

            for (int i = 0; i < 4; i++) {
                if (counter > 10000) System.exit(1);
                Point neighbour = getNextValid(point, dirx[i], diry[i], maze);
               // System.out.println("contain"+nodesAlreadyVisited.contains(neighbour));
                if (neighbour == null) continue;
                //if (nodesAlreadyVisited.contains(neighbour))
                 //   continue;
                if (neighbour != null) {
                    System.out.println("point to Neighbour " + point + "  " + neighbour);
                }
                if (dist.get(neighbour) == null) {
                    dist.put(neighbour, neighbour.distance);
                    System.out.println("myans"+dist.get(neighbour));
                    pq.offer(neighbour);
                    edgeTo.put(neighbour, point);
                } else {
                    if (dist.get(neighbour) > neighbour.distance) {
                        System.out.println(dist.get(neighbour));
                //        pq.offer(neighbour);
                        dist.put(neighbour, neighbour.distance);
                        edgeTo.put(neighbour, point);
                    }
                }
            }
        }

        return -1;
    }

    private Point getNextValid(Point p, int xdir, int ydir, int[][] maze) {
        int counter = 0;
        int savex = p.x;
        int savey = p.y;
        int x = p.x;
        int y = p.y;
        int distance = p.distance;
        int dis = 0;
        while (isValid(x + xdir, y + ydir) && maze[x + xdir][y + ydir] != 1) {
            counter++;
            x = x + xdir;
            y = y + ydir;
            dis++;
            if (counter > 10000) System.exit(1);

        }
        if (savex == x && savey == y) {
            return null;
        }
        return new Point(x, y, distance + dis);
    }

    private boolean isValid(int newx, int newy) {
        if (newx >= 0 && newx < m && newy >= 0 && newy < n) {
            return true;
        }
        return false;
    }

    private boolean isEndConfiguration(Point point, int[] destination) {
        if (point.x == destination[0] && point.y == destination[1]) {
            return true;
        }
        return false;
    }

    public static void main(String[] args) {
        MazeCheck mazeCheck = new MazeCheck();
        int matrix[][] = {{0, 0, 1, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 1, 0}, {1, 1, 0, 1, 1}, {0, 0, 0, 0, 0}};
        System.out.println(mazeCheck.shortDistance(matrix, new int[]{0, 4}, new int[]{3, 2}));

        //mazeCheck.check();

    }

    public void check() {
        PriorityQueue<Point> priorityQueue = new PriorityQueue(new Comparator<Point>() {
            @Override
            public int compare(Point o1, Point o2) {
                return o2.distance - o1.distance;
            }
        });
        Point p = new Point(1, 2, 4);
        Point q = new Point(1, 2, 8);
        Point r = new Point(1, 2, 12);
        priorityQueue.add(p);
        priorityQueue.add(q);
        priorityQueue.add(r);
        System.out.println(priorityQueue.peek());
        r.distance = 7;
        System.out.println(priorityQueue.peek());
        HashSet<Point> hashSet = new HashSet<>();
        hashSet.add(p);
        System.out.println(hashSet.contains(p));

    }
}

//    public int shortestDistanceA(int[][] maze, int[] start, int[] destination) {
//        if (maze.length == 0 || maze[0].length == 0) return -1;
//        int m = maze.length, n = maze[0].length;
//        int[][] dist = new int[m][n];
//        boolean[][] visited = new boolean[m][n];
//
//        PriorityQueue<int[]> queue = new PriorityQueue<>(m, (i1, i2)->{
//            return i1[2]-i2[2];
//        });
//        queue.offer(new int[]{start[0], start[1], 0});
//        while (!queue.isEmpty()) {
//            int[] node = queue.poll();
//            if (visited[node[0]][node[1]]) continue;
//            if (node[0] == destination[0] && node[1] == destination[1]) return node[2];
//            visited[node[0]][node[1]] = true;
//
//            for (int[] dir: dirs) {
//                int x = node[0];
//                int y = node[1];
//                int step = node[2];
//                while (x+dir[0] >= 0 && x+dir[0] < m && y+dir[1] >= 0 && y+dir[1] < n && maze[x+dir[0]][y+dir[1]] != 1) {
//                    x += dir[0];
//                    y += dir[1];
//                    step++;
//                }
//                if (visited[x][y]) continue;
//                if (dist[x][y] == 0 || dist[x][y] > step) {
//                    dist[x][y] = step;
//                    queue.offer(new int[]{x,y,step});
//                }
//            }
//        }
//        return -1;
//    }
//}
package BasicAlgorithms.MyGraph.geeksforgeeksgraph;

// A naive recursive solution to find min cost path from station 0
// to station N-1
class shortest_path
{
 
    static int INF = Integer.MAX_VALUE,N = 4;
    // A recursive function to find the shortest path from
    // source 's' to destination 'd'.
    static int minCostRec(int cost[][], int s, int d)
    {
        // If source is same as destination
        // or destination is next to source
        if (s == d || s+1 == d)
          return cost[s][d];
      
        // Initialize min cost as direct ticket from
        // source 's' to destination 'd'.
        int min = cost[s][d];
      
        // Try every intermediate vertex to find minimum
        for (int i = s+1; i<d; i++)
        {
            int c = minCostRec(cost, s, i) +
                    minCostRec(cost, i, d);
            if (c < min)
               min = c;
        }
        return min;
    }
      
    // This function returns the smallest possible cost to
    // reach station N-1 from station 0. This function mainly
    // uses minCostRec().
    static int minCost(int cost[][])
    {
        return minCostRec(cost, 0, N-1);
    }
 
    public static void main(String args[])
    {
        int cost[][] = { {0, 15, 80, 90},
                      {INF, 0, 40, 50},
                      {INF, INF, 0, 70},
                      {INF, INF, INF, 0}
                    };
        System.out.println("The Minimum cost to reach station "+ N+
                                               " is "+minCost(cost));
    }
 
}/* This code is contributed by Rajat Mishra */
/*

There are N stations on route of a train. The train goes from station 0 to N-1. The ticket cost for all pair of stations (i, j) is given where j is greater than i. Find the minimum cost to reach the destination.

Consider the following example:

Input:
cost[N][N] = { {0, 15, 80, 90},
              {INF, 0, 40, 50},
              {INF, INF, 0, 70},
              {INF, INF, INF, 0}
             };
There are 4 stations and cost[i][j] indicates cost to reach j
from i. The entries where j < i are meaningless.

Output:
The minimum cost is 65
The minimum cost can be obtained by first going to station 1
from 0. Then from station 1 to station 3.
 */

/*
We can solve this problem using O(N) extra space and O(N2) time. The idea is based on the fact that given input matrix is a Directed Acyclic GraphTreeOrNot (DAG). The shortest path in DAG can be calculated using the approach discussed in below post.

Shortest Path in Directed Acyclic GraphTreeOrNot

We need to do less work here compared to above mentioned post as we know topological sorting of the graph. The topological sorting of vertices here is 0, 1, ..., N-1. Following is the idea once topological sorting is known.

The idea in below code is to first calculate min cost for station 1, then for station 2, and so on. These costs are stored in an array dist[0...N-1].

1) The min cost for station 0 is 0, i.e., dist[0] = 0

2) The min cost for station 1 is cost[0][1], i.e., dist[1] = cost[0][1]

3) The min cost for station 2 is minimum of following two.
     a) dist[0] + cost[0][2]
     b) dist[1] + cost[1][2]

3) The min cost for station 3 is minimum of following three.
     a) dist[0] + cost[0][3]
     b) dist[1] + cost[1][3]
     c) dist[2] + cost[2][3]

Similarly, dist[4], dist[5], ... dist[N-1] are calculated.

Below is the implementation of above idea.
C++Java

 */
// A Dynamic Programming based solution to find min cost
// to reach station N-1 from station 0.
class shortest_path_new
{

    static int INF = Integer.MAX_VALUE,N = 4;
    // A recursive function to find the shortest path from
    // source 's' to destination 'd'.

    // This function returns the smallest possible cost to
    // reach station N-1 from station 0.
    static int minCost(int cost[][])
    {
        // dist[i] stores minimum cost to reach station i
        // from station 0.
        int dist[] = new int[N];
        for (int i=0; i<N; i++)
            dist[i] = INF;
        dist[0] = 0;

        // Go through every station and check if using it
        // as an intermediate station gives better path
        for (int i=0; i<N; i++)
            for (int j=i+1; j<N; j++)
                if (dist[j] > dist[i] + cost[i][j])
                    dist[j] = dist[i] + cost[i][j];

        return dist[N-1];
    }


    public static void main(String args[])
    {
        int cost[][] = { {0, 15, 80, 90},
                {INF, 0, 40, 50},
                {INF, INF, 0, 70},
                {INF, INF, INF, 0}
        };
        System.out.println("The Minimum cost to reach station "+ N+
                " is "+minCost(cost));
    }

}/* This code is contributed by Rajat Mishra */
package BasicAlgorithms.MyGraph.geeksforgeeksgraph;

/**
 * Created by hadoop on 20/10/17.
 */
public class Toporderingallpaths {
}
/*
class Graph
{
    int V;    // No. of vertices

    // Pointer to an array containing adjacency list
    list<int> *adj;

    // Vector to store indegree of vertices
    vector<int> indegree;

    // A function used by alltopologicalSort
    void alltopologicalSortUtil(vector<int>& res,
                                bool visited[]);

public:
    Graph(int V);   // Constructor

    // function to add an edge to graph
    void addEdge(int v, int w);

    // Prints all Topological Sorts
    void alltopologicalSort();
};

//  Constructor of graph
Graph::Graph(int V)
{
    this->V = V;
    adj = new list<int>[V];

    // Initialising all indegree with 0
    for (int i = 0; i < V; i++)
        indegree.push_back(0);
}

//  Utility function to add edge
void Graph::addEdge(int v, int w)
{
    adj[v].push_back(w); // Add w to v's list.

    // increasing inner degree of w by 1
    indegree[w]++;
}

//  Main recursive function to print all possible
//  topological sorts
void Graph::alltopologicalSortUtil(vector<int>& res,
                                   bool visited[])
{
    // To indicate whether all topological are found
    // or not
    bool flag = false;

    for (int i = 0; i < V; i++)
    {
        //  If indegree is 0 and not yet visited then
        //  only choose that vertex
        if (indegree[i] == 0 && !visited[i])
        {
            //  reducing indegree of adjacent vertices
            list<int>:: iterator j;
            for (j = adj[i].begin(); j != adj[i].end(); j++)
                indegree[*j]--;

            //  including in result
            res.push_back(i);
            visited[i] = true;
            alltopologicalSortUtil(res, visited);

            // resetting visited, res and indegree for
            // backtracking
            visited[i] = false;
            res.erase(res.end() - 1);
            for (j = adj[i].begin(); j != adj[i].end(); j++)
                indegree[*j]++;

            flag = true;
        }
    }

    //  We reach here if all vertices are visited.
    //  So we print the solution here
    if (!flag)
    {
        for (int i = 0; i < res.size(); i++)
            cout << res[i] << " ";
        cout << endl;
    }
}

//  The function does all Topological Sort.
//  It uses recursive alltopologicalSortUtil()
void Graph::alltopologicalSort()
{
    // Mark all the vertices as not visited
    bool *visited = new bool[V];
    for (int i = 0; i < V; i++)
        visited[i] = false;

    vector<int> res;
    alltopologicalSortUtil(res, visited);
}

// Driver program to test above functions
int main()
{
    // Create a graph given in the above diagram
    Graph g(6);
    g.addEdge(5, 2);
    g.addEdge(5, 0);
    g.addEdge(4, 0);
    g.addEdge(4, 1);
    g.addEdge(2, 3);
    g.addEdge(3, 1);

    cout << "All Topological sorts\n";

    g.alltopologicalSort();

    return 0;
}
 */package BasicAlgorithms.MyGraph.geeksforgeeksgraph;// A Java Program to check whether a graph is tree or not
import java.util.*;
 
// This class represents a directed graph using adjacency
// list representation
class GraphTreeOrNot
{
    private int V;   // No. of vertices
    private LinkedList<Integer> adj[]; //Adjacency List
 
    // Constructor
    GraphTreeOrNot(int v)
    {
        V = v;
        adj = new LinkedList[v];
        for (int i=0; i<v; ++i)
            adj[i] = new LinkedList();
    }
 
    // Function to add an edge into the graph
    void addEdge(int v,int w)
    {
        adj[v].add(w);
        adj[w].add(v);
    }
 
    // A recursive function that uses visited[] and parent
    // to detect cycle in subgraph reachable from vertex v.
    Boolean isCyclicUtil(int v, Boolean visited[], int parent)
    {
        // Mark the current node as visited
        visited[v] = true;
        Integer i;
 
        // Recur for all the vertices adjacent to this vertex
        Iterator<Integer> it = adj[v].iterator();
        while (it.hasNext())
        {
            i = it.next();
 
            // If an adjacent is not visited, then recur for
            // that adjacent
            if (!visited[i])
            {
                if (isCyclicUtil(i, visited, v))
                    return true;
            }
 
            // If an adjacent is visited and not parent of 
            // current vertex, then there is a cycle.
            else if (i != parent)
               return true;
        }
        return false;
    }



    // check if graph has cycle and also check if all ndoes are reachable from a
    // particular node here we picked 0 node .....
    // if its not connected to all nodes than anyway is not gona be tree
    // so pick any node to perform cyclic operaions...

    // Returns true if the graph is a tree, else false.
    Boolean isTree()
    {
        // Mark all the vertices as not visited and not part
        // of recursion stack
        Boolean visited[] = new Boolean[V];
        for (int i = 0; i < V; i++)
            visited[i] = false;
 
        // The call to isCyclicUtil serves multiple purposes
        // It returns true if graph reachable from vertex 0
        // is cyclcic. It also marks all vertices reachable
        // from 0.
        // check for cycle and also check for conectivty
        if (isCyclicUtil(0, visited, -1))
            return false;
 
        // If we find a vertex which is not reachable from 0
        // (not marked by isCyclicUtil(), then we return false
        for (int u = 0; u < V; u++)
            if (!visited[u])
                return false;
 
        return true;
    }
 
    // Driver method
    public static void main(String args[])
    {
        // Create a graph given in the above diagram
        GraphTreeOrNot g1 = new GraphTreeOrNot(5);
        g1.addEdge(1, 0);
        g1.addEdge(0, 2);
        g1.addEdge(0, 3);
        g1.addEdge(3, 4);
        if (g1.isTree())
            System.out.println("GraphTreeOrNot is Tree");
        else
            System.out.println("GraphTreeOrNot is not Tree");
 
        GraphTreeOrNot g2 = new GraphTreeOrNot(5);
        g2.addEdge(1, 0);
        g2.addEdge(0, 2);
        g2.addEdge(2, 1);
        g2.addEdge(0, 3);
        g2.addEdge(3, 4);
 
        if (g2.isTree())
            System.out.println("GraphTreeOrNot is Tree");
        else
            System.out.println("GraphTreeOrNot is not Tree");
 
    }
}
// This code is contributed by Aakash Hasijapackage BasicAlgorithms.MyGraph.geeksforgeeksgraph;

import java.util.*;
import java.util.LinkedList;
 
// This class represents an undirected graph using adjacency list
// representation
class GraphEulerUndirected
{
    private int V;   // No. of vertices
 
    // Array  of lists for Adjacency List Representation
    private LinkedList<Integer> adj[];
 
    // Constructor
    GraphEulerUndirected(int v)
    {
        V = v;
        adj = new LinkedList[v];
        for (int i=0; i<v; ++i)
            adj[i] = new LinkedList();
    }
 
    //Function to add an edge into the graph
    void addEdge(int v, int w)
    {
        adj[v].add(w);// Add w to v's list.
        adj[w].add(v); //The graph is undirected
    }
 
    // A function used by DFS
    void DFSUtil(int v,boolean visited[])
    {
        // Mark the current node as visited
        visited[v] = true;
 
        // Recur for all the vertices adjacent to this vertex
        Iterator<Integer> i = adj[v].listIterator();
        while (i.hasNext())
        {
            int n = i.next();
            if (!visited[n])
                DFSUtil(n, visited);
        }
    }
 
    // Method to check if all non-zero degree vertices are
    // connected. It mainly does DFS traversal starting from
    boolean isConnected()
    {
        // Mark all the vertices as not visited
        boolean visited[] = new boolean[V];
        int i;
        for (i = 0; i < V; i++)
            visited[i] = false;
 
        // Find a vertex with non-zero degree
        for (i = 0; i < V; i++)
            if (adj[i].size() != 0)
                break;
 
        // If there are no edges in the graph, return true
        if (i == V)
            return true;
 
        // Start DFS traversal from a vertex with non-zero degree
        DFSUtil(i, visited);
 
        // Check if all non-zero degree vertices are visited
        for (i = 0; i < V; i++)
           if (visited[i] == false && adj[i].size() > 0)
                return false;
 
        return true;
    }
 
    /* The function returns one of the following values
       0 --> If grpah is not Eulerian
       1 --> If graph has an Euler path (Semi-Eulerian)
       2 --> If graph has an Euler Circuit (Eulerian)  */
    int isEulerian()
    {
        // Check if all non-zero degree vertices are connected
        if (isConnected() == false)
            return 0;
 
        // Count vertices with odd degree
        int odd = 0;
        for (int i = 0; i < V; i++)
            if (adj[i].size()%2!=0)
                odd++;
 
        // If count is more than 2, then graph is not Eulerian
        if (odd > 2)
            return 0;
 
        // If odd count is 2, then semi-eulerian.
        // If odd count is 0, then eulerian
        // Note that odd count can never be 1 for undirected graph
        return (odd==2)? 1 : 2;
    }
 
    // Function to run test cases
    void test()
    {
        int res = isEulerian();
        if (res == 0)
            System.out.println("graph is not Eulerian");
        else if (res == 1)
            System.out.println("graph has a Euler path");
        else
           System.out.println("graph has a Euler cycle");
    }
 
    // Driver method
    public static void main(String args[])
    {
        // Let us create and test graphs shown in above figures
        GraphEulerUndirected g1 = new GraphEulerUndirected(5);
        g1.addEdge(1, 0);
        g1.addEdge(0, 2);
        g1.addEdge(2, 1);
        g1.addEdge(0, 3);
        g1.addEdge(3, 4);
        g1.test();
 
        GraphEulerUndirected g2 = new GraphEulerUndirected(5);
        g2.addEdge(1, 0);
        g2.addEdge(0, 2);
        g2.addEdge(2, 1);
        g2.addEdge(0, 3);
        g2.addEdge(3, 4);
        g2.addEdge(4, 0);
        g2.test();
 
        GraphEulerUndirected g3 = new GraphEulerUndirected(5);
        g3.addEdge(1, 0);
        g3.addEdge(0, 2);
        g3.addEdge(2, 1);
        g3.addEdge(0, 3);
        g3.addEdge(3, 4);
        g3.addEdge(1, 3);
        g3.test();
 
        // Let us create a graph with 3 vertices
        // connected in the form of cycle
        GraphEulerUndirected g4 = new GraphEulerUndirected(3);
        g4.addEdge(0, 1);
        g4.addEdge(1, 2);
        g4.addEdge(2, 0);
        g4.test();
 
        // Let us create a graph with all veritces
        // with zero degree
        GraphEulerUndirected g5 = new GraphEulerUndirected(3);
        g5.test();
    }
}
// This code is contributed by Aakash Hasijapackage BasicAlgorithms.MyGraph;

import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Spliterator;

/**
 * Created by hadoop on 19/10/17.
 */
public class Bag<Item> implements Iterable<Item> {
    private Node<Item> first;
    private int n; // suggest size of Bag
    public Bag(){
        first = null;
        int n=0;
    }

    public boolean isEmpty(){
        return first == null;
    }
    public int size() {
        return n;
    }

    // linkedlist addition shud be o(1) stupidddd
    public void add(Item item){
        // does nt matter null or not
            Node<Item> oldFirst = first;
            first = new Node<>();
            first.item = item;
            first.next = oldFirst;
            n++;
    }


    /*
    Iterable : A class that can be iterated over. That is, one that has a notion of "get me the first thing, now the next thing, and so on, until we run out."

Iterator : A class that manages iteration over an iterable. That is, it keeps track of where we are in the current iteration, and knows what the next element is and how to get it.

To make an object iterable it needs to emit an Iterator object. To enforce this contract, Iterable interface is to be used. It contains a method named iterator() and it returns Iterator. Hence, any class that implements Iterable will return an Iterator.

public interface Collection<E> extends Iterable<E> {}
For example take any Collection. A Collection is an interface that represents container for series of elements. Every collections like ArrayList, Vector implements Collection and so Iterator.

One advantage of Iterable is, when you implement Iterable then those object gets support for for:each loop syntax.
     */

    @Override
    public Iterator<Item> iterator() {
        return new ListIterator<Item>(first);
    }

    private static class ListIterator<Item> implements Iterator<Item>{
        Node<Item> current;
        ListIterator(Node<Item> first){
            current = first;
        }
        @Override
        public boolean hasNext() {
            return current!=null;
        }

        @Override
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Node<Item> head = current;
            current = current.next;
            return head.item;
        }
    }
    private static class Node<Item> {
        Item item;
        Node<Item> next;
    }
    public static void main(String []args){
        Bag<String> mybag = new Bag<>();
        mybag.add("rajat");
        mybag.add("ahuja");
        System.out.println(mybag.size());

        for(String x:mybag){
            System.out.println("string"+x);
        }
    }
}
package BasicAlgorithms.MyGraph;

import java.util.ArrayList;
import java.util.List;

/**
 * Created_By: stefanie
 * Date: 14-11-23
 * Time: 1:40
 */
public class GraphNode {
    public int label;
    public List<GraphNode> neighbors;

    public GraphNode(int x) {
        label = x;
        neighbors = new ArrayList<GraphNode>();
    }

    public static List<GraphNode> sampleDirectedGraph(){
         /*
        1 ---] 2
        ]     /] \
        |    / |  ]
        |   /  |   3
        |  /   |  /
        | [    | [
        5 ----] 4
         */
        List<GraphNode> nodes = new ArrayList<>();
        for(int i = 0; i < 6; i++){
            nodes.add(new GraphNode(i));
        }

        nodes.get(1).neighbors.add(nodes.get(2));
        nodes.get(2).neighbors.add(nodes.get(5));
        nodes.get(2).neighbors.add(nodes.get(3));
        nodes.get(3).neighbors.add(nodes.get(4));
        nodes.get(4).neighbors.add(nodes.get(2));
        nodes.get(5).neighbors.add(nodes.get(4));
        nodes.get(5).neighbors.add(nodes.get(1));

        return nodes;
    }
}
package BasicAlgorithms.MyGraph;

import java.util.Iterator;

/**
 * Created by hadoop on 19/10/17.
 */
public class Queue<Item> implements Iterable<Item> {

    Node<Item> first;
    Node<Item> last;
    int n=0;
    private class Node<Item>{
        Node<Item> next;
        Item item;
    }

    Queue(){
        first = null;
        last = null;
        n =0;
    }
    boolean isEmpty(){
       return first == null;
    }
    int size(){
        return n;
    }
    public void enqueue(Item item) {
        Node<Item> node = new Node<>();
        node.item = item;
        if(first == null){
            first = last = node;
        }
        else {
            last.next = node;
            last = node;
        }
        n++;
    }
    public Item dequeue(){
        if(isEmpty()){
            return null;
        }
        Item returned = first.item;
        n--;
        if(first.next == null){
            last = first = null;
        }
        else {
            first = first.next;
        }
        return returned;
    }

        @Override
    public Iterator<Item> iterator() {
        return new ListIterator<>(first,last);
    }
    private class ListIterator<Item> implements Iterator<Item>{
        Node<Item> current;
        ListIterator(Node<Item> first,Node<Item> last){
            current = first;
        }
        @Override
        public boolean hasNext() {
            return current!=null;
        }

        @Override
        public Item next() {

            Item ans = current.item;
            current = current.next;
            return ans;
        }
    }
}
package BasicAlgorithms.MyGraph.KosarajuCode;// Java implementation of Kosaraju's algorithm to print all SCCs
import java.util.*;
import java.util.LinkedList;
 
// This class represents a directed graph using adjacency list
// representation
class Graph
{
    private int V;   // No. of vertices
    private LinkedList<Integer> adj[]; //Adjacency List
 
    //Constructor
    Graph(int v)
    {
        V = v;
        adj = new LinkedList[v];
        for (int i=0; i<v; ++i)
            adj[i] = new LinkedList();
    }
 
    //Function to add an edge into the graph
    void addEdge(int v, int w)  { adj[v].add(w); }
 
    // A recursive function to print DFS starting from v
    void DFSUtil(int v,boolean visited[])
    {
        // Mark the current node as visited and print it
        visited[v] = true;
        System.out.print(v + " ");
 
        int n;
 
        // Recur for all the vertices adjacent to this vertex
        Iterator<Integer> i =adj[v].iterator();
        while (i.hasNext())
        {
            n = i.next();
            if (!visited[n])
                DFSUtil(n,visited);
        }
    }
 
    // Function that returns reverse (or transpose) of this graph
    Graph getTranspose()
    {
        Graph g = new Graph(V);
        for (int v = 0; v < V; v++)
        {
            // Recur for all the vertices adjacent to this vertex
            Iterator<Integer> i =adj[v].listIterator();
            while(i.hasNext())
                g.adj[i.next()].add(v);
        }
        return g;
    }
 
    void fillOrder(int v, boolean visited[], Stack stack)
    {
        // Mark the current node as visited and print it
        visited[v] = true;
 
        // Recur for all the vertices adjacent to this vertex
        Iterator<Integer> i = adj[v].iterator();
        while (i.hasNext())
        {
            int n = i.next();
            if(!visited[n])
                fillOrder(n, visited, stack);
        }
 
        // All vertices reachable from v are processed by now,
        // push v to Stack
        stack.push(new Integer(v));
    }
 
    // The main function that finds and prints all strongly
    // connected components
    void printSCCs()
    {
        Stack stack = new Stack();
 
        // Mark all the vertices as not visited (For first DFS)
        boolean visited[] = new boolean[V];
        for(int i = 0; i < V; i++)
            visited[i] = false;
 
        // Fill vertices in stack according to their finishing
        // times
        for (int i = 0; i < V; i++)
            if (visited[i] == false)
                fillOrder(i, visited, stack);
 
        // Create a reversed graph
        Graph gr = getTranspose();
 
        // Mark all the vertices as not visited (For second DFS)
        for (int i = 0; i < V; i++)
            visited[i] = false;
 
        // Now process all vertices in order defined by Stack
        while (stack.empty() == false)
        {
            // Pop a vertex from stack
            int v = (int)stack.pop();
 
            // Print Strongly connected component of the popped vertex
            if (visited[v] == false)
            {
                gr.DFSUtil(v, visited);
                System.out.println();
            }
        }
    }
 
    // Driver method
    public static void main(String args[])
    {
        // Create a graph given in the above diagram
        Graph g = new Graph(5);
        g.addEdge(1, 0);
        g.addEdge(0, 2);
        g.addEdge(2, 1);
        g.addEdge(0, 3);
        g.addEdge(3, 4);
 
        System.out.println("Following are strongly connected components "+
                           "in given graph ");
        g.printSCCs();
    }
}
// This code is contributed by Aakash Hasijapackage BasicAlgorithms.MyGraph;

/**
 * Created by hadoop on 19/10/17.
 */
public class DirectedGraphsTheory {
}
/*
We say that a vertex w is reachable from a vertex v if there exists a directed path from v to w.
We say that two vertices v and w are strongly connected if they are mutually reachable: there is a directed path from v to w and a directed path from w to v.
A digraph is strongly connected if there is a directed path from every vertex to every other vertex.
A digraph that is not strongly connected consists of a set of strongly-connected components, which are maximal strongly-connected subgraphs.
A directed acyclic graph (or DAG) is a digraph with no directed cycles.
 */package BasicAlgorithms.MyGraph;

import java.util.Stack;

/**
 * Created by hadoop on 19/10/17.
 */
public class Graph {
    // number of nodes
    private int V;
    // number of edges
    private int E;
    private Bag<Integer>[]adj;
    public Graph(int V){
        //graph of V number of nodes
        this.V = V;
        // o edge at start
        this.E = 0;
        // not required as such
        adj = (Bag<Integer>[])new Bag[V];

    }
    Graph(Graph g){
        this.E = g.E;
        this.V = g.V;
        adj = new Bag[this.V];
        for(int i=0;i<V;i++){
            Stack<Integer> stack = new Stack<>();
            for(int x:g.adj(i)){
                stack.push(x);
            }
            for(int w:stack){
                // very imp pay attention to it
                // what we are doing is that
                //adding elemetnts to adjacency list of new cloned graph
                // get the bag of each element and clone it as the other bag of another graph
                // very imp
                // we could have called ad edge but add edge would have added
                // each elemtnt twice
                // so better to add here
                adj[i].add(w);
            }





        }

    }
    // In in we create scanner object out of all possible streams
    // be it socket sysout file //
    // any sorts of stream abstractions
    public Graph(In input){
        this.V = input.readInt();
        adj = (Bag<Integer>[])new Bag[V];
        // initliase adj list
        for(int i=0;i<V;i++){
            adj[i] = new Bag<Integer>();
        }

        // local edges
        int E = input.readInt();

        for(int i=0;i<this.E;i++){
            // get first node of edge
            int v = input.readInt();
            // second node
            int w = input.readInt();
            addEdge(v,w);
        }

    }

    private void addEdge(int v, int w) {
        // we keep incrementing number of edges as well
        // since its a undirected graph so we need to add aedges in both
        // the adjecency list
        this.E++;
        adj[v].add(w);
        adj[w].add(v);
    }
    public int degree(int v){
        return adj[v].size();
    }
    // since iterable is superclass of bag thats why
    // we could have retured bag itself
    public Iterable<Integer> adj(int v){
        return adj[v];
    }

    public int getV() {
        return V;
    }

    public int getE() {
        return E;
    }

    public Bag<Integer>[] getAdj() {
        return adj;
    }
}
package BasicAlgorithms.MyGraph;

import java.util.Stack;

/**
 * Created by hadoop on 19/10/17.
 */
public class DirectedGraphCycle {
    Stack<Integer> cycle ;
    boolean marked[];
    boolean onstack[];
    int edgeTo[];
    DirectedGraphCycle(Digraph g){
        marked = new boolean[g.getV()];
        onstack = new boolean[g.getV()];
        edgeTo = new int[g.getV()];
        for(int v=0;v<g.getV();v++){
            if(!marked[v]) {
                dfs(g, v);
            }
        }
    }

    private void dfs(Digraph g, int v) {
        marked[v] = true;
        onstack[v] = true;
        for(int w:g.adj(v)){

            if(cycle!=null){
                return;
            }
            if(!marked[w]){
                edgeTo[w] = v;
                dfs(g,w);
            }
            else if(onstack[w] = true){
                cycle = new Stack<>();
                for(int x=v;x!=w;x=edgeTo[x]){
                    cycle.push(x);
                }
                cycle.push(w);
            }
        }
        onstack[v] = false;
    }
}
package BasicAlgorithms.MyGraph;

import java.util.Stack;

/**
 * Created by hadoop on 19/10/17.
 */
public class Digraph {
    // number of nodes
    private int V;
    // number of edges
    private int E;
    private Bag<Integer>[]adj;
    int []indegree;
    public Digraph(int V){
        //graph of V number of nodes
        this.V = V;
        // o edge at start
        this.E = 0;
        // not required as such
        adj = (Bag<Integer>[])new Bag[V];
        indegree = new int[V];

    }
    Digraph(Digraph g){
        this.E = g.E;
        this.V = g.V;
        adj = new Bag[this.V];
        for(int i=0;i<V;i++){
            Stack<Integer> stack = new Stack<>();
            for(int x:g.adj(i)){
                stack.push(x);
            }
            for(int w:stack){
                // very imp pay attention to it
                // what we are doing is that
                //adding elemetnts to adjacency list of new cloned graph
                // get the bag of each element and clone it as the other bag of another graph
                // very imp
                // we could have called ad edge but add edge would have added
                // each elemtnt twice
                // so better to add here
                adj[i].add(w);
            }
        }

    }
    // In in we create scanner object out of all possible streams
    // be it socket sysout file //
    // any sorts of stream abstractions
    public Digraph(In input){
        this.V = input.readInt();
        indegree = new int[V];
        adj = (Bag<Integer>[])new Bag[V];
        // initliase adj list
        for(int i=0;i<V;i++){
            adj[i] = new Bag<Integer>();
        }

        // local edges
        int E = input.readInt();

        for(int i=0;i<this.E;i++){
            // get first node of edge
            int v = input.readInt();
            // second node
            int w = input.readInt();
            addEdge(v,w);
        }

    }

    private void addEdge(int v, int w) {
        // we keep incrementing number of edges as well
        // since its a undirected graph so we need to add aedges in both
        // the adjecency list
        this.E++;
        adj[v].add(w);
        indegree[w]++;
       //  for directed this is not required adj[w].add(v);
    }

    // outdegree simple length of adjaceny list
    // indegree we calculte while adding aedges
    public int outDegree(int v){
        return adj[v].size();
    }
    public int indegree(int v){
        return indegree[v];
    }
    // since iterable is superclass of bag thats why
    // we could have retured bag itself
    public Iterable<Integer> adj(int v){
        return adj[v];
    }

    public int getV() {
        return V;
    }

    public int getE() {
        return E;
    }

    public Bag<Integer>[] getAdj() {
        return adj;
    }

    public Digraph reverse() {
        Digraph reverse = new Digraph(V);
        for (int v = 0; v < V; v++) {
            for (int w : adj(v)) {
                reverse.addEdge(w, v);
            }
        }
        return reverse;
    }
}
package BasicAlgorithms.MyGraph;
import java.util.*;

/**
 * Created by hadoop on 21/10/17.
 */
public class ReconstructIterniary {
    public List<List<String>> findItinerary(String[][] tickets) {
        HashMap<String,HashSet<String>> graph = new HashMap<>();
        for(int i=0;i<tickets.length;i++){
            graph.put(tickets[i][0],new HashSet<>());
        }
        for(int i=0;i<tickets.length;i++){
            graph.get(tickets[i][0]).add(tickets[i][1]);
        }

        List<String> path = new ArrayList<>();
        List<List<String>> result  = new ArrayList<>();
        Set<Edge> visited = new HashSet<>();
        path.add("JFK");
        //visited.add("JFK");
        int numberOfNodes = tickets.length;
        dfsHelper(path,result,"JFK",graph,visited,numberOfNodes);
//        if(result.size()!=0){
//            return result.get(0);
//        }
        System.out.println(result);
        return result;
    }

    private void dfsHelper(List<String> path, List<List<String>> result, String u, HashMap<String, HashSet<String>> graph, Set<Edge> visited, int numberOfNodes) {
        if(path.size() == numberOfNodes+1){
            result.add(new ArrayList<>(path));
            return;
        }
        for(String v:graph.get(u)){
            if(!visited.contains(new Edge(u,v))){
                visited.add(new Edge(u,v));
                path.add(v);
                dfsHelper(path,result,v,graph,visited,numberOfNodes);
                visited.remove(new Edge(u,v));
                path.remove(path.size()-1);
            }
        }

    }
    private class Edge{
        String src;
        String dst;

        public Edge(String src, String dst) {
            this.src = src;
            this.dst = dst;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;

            Edge edge = (Edge) o;

            if (src != null ? !src.equals(edge.src) : edge.src != null) return false;
            return dst != null ? dst.equals(edge.dst) : edge.dst == null;
        }

        @Override
        public int hashCode() {
            int result = src != null ? src.hashCode() : 0;
            result = 31 * result + (dst != null ? dst.hashCode() : 0);
            return result;
        }
    }
    public static void main(String args[]){
        ReconstructIterniary reconstructIterniary = new ReconstructIterniary();
       // String [][]tickets={{"MUC", "LHR"}, {"JFK", "MUC"}, {"SFO", "SJC"}, {"LHR", "SFO"}};
        String [][]tickets = {{"JFK","SFO"},{"JFK","ATL"},{"SFO","ATL"},{"ATL","JFK"},{"ATL","SFO"}};
        System.out.println(reconstructIterniary.findItinerary(tickets));
    }

}package BasicAlgorithms.MyGraph;

import java.util.LinkedList;
import java.util.Queue;
import java.util.Stack;

/**
 * Created by hadoop on 19/10/17.
 */
public class BreadthFirstSearchPaths {
    int INFINITY = Integer.MAX_VALUE;
    boolean[] marked;
    int[] edgeTo;
    int[] distTo;

    public BreadthFirstSearchPaths(Graph g, int s) {
        marked = new boolean[g.getV()];
        edgeTo = new int[g.getV()];
        distTo = new int[g.getV()];
        for (int i = 0; i < g.getV(); i++) {
            distTo[i] = INFINITY;
        }
        // source distance always zero
        distTo[s] = 0;
        // after initialzation call bfs
        bfs(g, s);
    }

    private void bfs(Graph g, int s) {
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < g.getV(); i++) {
            distTo[i] = INFINITY;
        }
        // first 3 thinsg initilaze
        // then source properties set
        distTo[s] = 0;
        marked[s] = true;
        queue.add(s);

        while (!queue.isEmpty()) {
            int v = queue.poll();
            for (int w : g.adj(v)) {
                if (!marked[w]) {
                    distTo[w] = distTo[v] + 1;
                    marked[w] = true;
                    edgeTo[w] = v;
                    queue.add(w);
                }
            }
        }
    }

    // if sometimes we need to perfomr bfs from so many places we can perform bfs from multiple sources at once
    private void bfs(Graph g, Iterable<Integer> sources) {
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < g.getV(); i++) {
            distTo[i] = INFINITY;
        }
        // first 3 thinsg initilaze
        // then source properties set
        // thats all we need to do
        for (int s : sources) {
            distTo[s] = 0;
            marked[s] = true;
            queue.add(s);
        }

        while (!queue.isEmpty()) {
            int v = queue.poll();
            for (int w : g.adj(v)) {
                if (!marked[w]) {
                    distTo[w] = distTo[v] + 1;
                    marked[w] = true;
                    edgeTo[w] = v;
                    queue.add(w);
                }
            }
        }
    }

    // has path means from starting point fixeddddddd which is source of BFS
    public boolean hasPathTo(int v) {
        return marked[v] ;
    }
    public int disTo (int v){
        return distTo[v];
    }
    public Iterable<Integer> pathTo(int v){
        Stack<Integer> stack = new Stack<>();
        stack.add(v);
        pathToHelper(v,stack);
        return stack;
    }
    //it is nothing but DFS from backwards thats allllll it is so think abt dfs
    void pathToHelper(int v,Stack<Integer> stack){
        if(distTo[v]!=0){
            stack.push(edgeTo[v]);
            pathToHelper(edgeTo[v],stack);
        }
        else {
            //at last add the source as well
            stack.add(v);
        }
    }
}package BasicAlgorithms.MyGraph;// Java program to count islands in boolean 2D matrix
import java.util.*;
import java.lang.*;
import java.io.*;
 
class Islands
{
    //No of rows and columns
    static final int ROW = 5, COL = 5;
 
    // A function to check if a given cell (row, col) can
    // be included in DFS
    boolean isSafe(int M[][], int row, int col,
                   boolean visited[][])
    {
        // row number is in range, column number is in range
        // and value is 1 and not yet visited
        return (row >= 0) && (row < ROW) &&
               (col >= 0) && (col < COL) &&
               (M[row][col]==1 && !visited[row][col]);
    }
 
    // A utility function to do DFS for a 2D boolean matrix.
    // It only considers the 8 neighbors as adjacent vertices
    void DFS(int M[][], int row, int col, boolean visited[][])
    {
        // These arrays are used to get row and column numbers
        // of 8 neighbors of a given cell
        int rowNbr[] = new int[] {-1, -1, -1,  0, 0,  1, 1, 1};
        int colNbr[] = new int[] {-1,  0,  1, -1, 1, -1, 0, 1};
 
        // Mark this cell as visited
        visited[row][col] = true;
 
        // Recur for all connected neighbours
        for (int k = 0; k < 8; ++k)
            if (isSafe(M, row + rowNbr[k], col + colNbr[k], visited) )
                DFS(M, row + rowNbr[k], col + colNbr[k], visited);
    }
 
    // The main function that returns count of islands in a given
    //  boolean 2D matrix
    int countIslands(int M[][])
    {
        // Make a bool array to mark visited cells.
        // Initially all cells are unvisited
        boolean visited[][] = new boolean[ROW][COL];
 
 
        // Initialize count as 0 and travese through the all cells
        // of given matrix
        int count = 0;
        for (int i = 0; i < ROW; ++i)
            for (int j = 0; j < COL; ++j)
                if (M[i][j]==1 && !visited[i][j]) // If a cell with
                {                                 // value 1 is not
                    // visited yet, then new island found, Visit all
                    // cells in this island and increment island count
                    DFS(M, i, j, visited);
                    ++count;
                }
 
        return count;
    }
 
    // Driver method
    public static void main (String[] args) throws java.lang.Exception
    {
        int M[][]=  new int[][] {{1, 1, 0, 0, 0},
                                 {0, 1, 0, 0, 1},
                                 {1, 0, 0, 1, 1},
                                 {0, 0, 0, 0, 0},
                                 {1, 0, 1, 0, 1}
                                };
        Islands I = new Islands();
        System.out.println("Number of islands is: "+ I.countIslands(M));
    }
} //Contributed by Aakash Hasijapackage BasicAlgorithms.MyGraph.PracticeGraph;

import java.util.LinkedList;
import java.util.List;

/**
 * Created by hadoop on 20/10/17.
 */
public class EulerGraphUndirected {
    private int V;
    List<Integer> [] adj;

    public EulerGraphUndirected(int v) {
        V = v;
        adj = new LinkedList[V];

        for(int i=0;i<V;i++){
            adj[i] = new LinkedList<>();
        }
    }
    void addEdge(int i,int j){
        // since undirected we need to add both ways in adj list
        adj[i].add(j);
        adj[j].add(i);
    }

    void DfsHelper(int v,boolean []visited){
        visited[v] = true;
        for(int w:adj[v]){

            if(!visited[w]){
                DfsHelper(w,visited);
            }
        }
    }


    public boolean isConnected(){
        boolean [] visited = new boolean[V];

        // find a vertex with nonzero degree
        int i=0;
        for(i=0;i<V;i++){
            if(adj[i].size()!=0){
                break;
            }
        }
        if(i == V){

            System.out.println("Fuck all zero edges graph no edges present in this graph");
            return true;
        }

        DfsHelper(i,visited);
        // once visit is done
        // if a node is not visited and adjcency list size is not zero return false

        for(int k=0;k<V;k++){
            if(visited[k] == false && adj[k].size()>0){
                return false;
            }
        }
        return true;
    }
    int isEulerian(){

        if(isConnected() == false){
            return 0;
        }
        // count the odd degree of undirected graph
        int odd=0;
        for(int i=0;i<V;i++){
            if(adj[i].size()%2 ==1){
                odd++;
            }
        }
        if(odd>2){
            return 0;
        }
        // if count is more than 2 than graph can not be suler 
        // in path edhe will repeaat for sureeeeee 
        if(odd == 2){
            // means suler path is there not cycle 
            return 1;
        }
        if(odd == 0){
            // means euler cycle exists
            return 2;
        }
        return 0;
    }
    void test()
    {
        int res = isEulerian();
        if (res == 0)
            System.out.println("graph is not Eulerian");
        else if (res == 1)
            System.out.println("graph has a Euler path");
        else
            System.out.println("graph has a Euler cycle");
    }
    public static void main(String args[])
    {
        // Let us create and test graphs shown in above figures
        EulerGraphUndirected g1 = new EulerGraphUndirected(5);
        g1.addEdge(1, 0);
        g1.addEdge(0, 2);
        g1.addEdge(2, 1);
        g1.addEdge(0, 3);
        g1.addEdge(3, 4);
        g1.test();

        EulerGraphUndirected g2 = new EulerGraphUndirected(5);
        g2.addEdge(1, 0);
        g2.addEdge(0, 2);
        g2.addEdge(2, 1);
        g2.addEdge(0, 3);
        g2.addEdge(3, 4);
        g2.addEdge(4, 0);
        g2.test();

        EulerGraphUndirected g3 = new EulerGraphUndirected(5);
        g3.addEdge(1, 0);
        g3.addEdge(0, 2);
        g3.addEdge(2, 1);
        g3.addEdge(0, 3);
        g3.addEdge(3, 4);
        g3.addEdge(1, 3);
        g3.test();

        // Let us create a graph with 3 vertices
        // connected in the form of cycle
        EulerGraphUndirected g4 = new EulerGraphUndirected(3);
        g4.addEdge(0, 1);
        g4.addEdge(1, 2);
        g4.addEdge(2, 0);
        g4.test();

        // Let us create a graph with all veritces
        // with zero degree
        EulerGraphUndirected g5 = new EulerGraphUndirected(3);
        g5.test();
    }
}
package BasicAlgorithms.MyGraph.PracticeGraph;

import java.util.Arrays;
import java.util.LinkedList;

/**
 * Created by hadoop on 20/10/17.
 */
public class EulerDirectedGraph {
    private int V;
    LinkedList<Integer>[] adj;
    int[] in;

    EulerDirectedGraph(int v) {
        this.V = v;
        adj = new LinkedList[V];
        for (int i = 0; i < V; i++) {
            adj[i] = new LinkedList<>();
        }
        in = new int[this.V];
    }

    public void addEdge(int v, int w) {
        // Directed Graph
        adj[v].add(w);
        in[w]++;
    }

    EulerDirectedGraph transpose() {
        EulerDirectedGraph eulerDirectedGraph = new EulerDirectedGraph(this.V);
        // get current graph adjacnecy list
        LinkedList<Integer>[] adj = this.adj;
        LinkedList<Integer>[] transPose = new LinkedList[this.V];

        int[] in = new int[this.V];
        for (int i = 0; i < this.V; i++) {
            transPose[i] = new LinkedList<Integer>();
        }
        for (int i = 0; i < V; i++) {
            for (int node : adj[i]) {
                transPose[node].add(i);
                in[i]++;
            }
        }
        eulerDirectedGraph.adj = transPose;
        eulerDirectedGraph.in = in;
        return eulerDirectedGraph;
    }

    public boolean isSC() {

        boolean marked[] = new boolean[V];
        dfs(0, marked);
        for (int i = 0; i < V; i++) {
            if (!marked[i]) {
                return false;
            }
        }
        Arrays.fill(marked, false);

        EulerDirectedGraph transposedGraph = transpose();
        transposedGraph.dfs(0, marked);
        for (int i = 0; i < V; i++) {
            if (!marked[i]) {
                return false;
            }
        }
        return true;
    }

    private void dfs(int v, boolean[] marked) {
        marked[v] = true;
        for (int w : adj[v]) {
            if (!marked[w])
                dfs(w, marked);
        }
    }

    Boolean isEulerianCycle(){
        if(isSC() == false){
            return false;
        }
        
        for(int i=0;i<V;i++){
            int indegree = in[i];
            int outdegree = adj[i].size();
            if(indegree!=outdegree){
                // simpel for every indegree there has to be outdegree for corsisng
                // each edge exactly one 
                return false;
            }
        }
        return true;
        // check for indegree ..
        // indegree of all nodes has to be same as outgoing degree
    }
    public static void main (String[] args) throws java.lang.Exception
    {
        EulerDirectedGraph g = new EulerDirectedGraph(5);
        g.addEdge(1, 0);
        g.addEdge(0, 2);
        g.addEdge(2, 1);
        g.addEdge(0, 3);
        g.addEdge(3, 4);
        g.addEdge(4, 0);

        if (g.isEulerianCycle())
            System.out.println("Given directed graph is eulerian ");
        else
            System.out.println("Given directed graph is NOT eulerian ");
    }
}
package BasicAlgorithms.MyGraph.PracticeGraph;

import java.util.*;

/**
 * Created by hadoop on 20/10/17.
 */
public class TopologicalSort {
    int V;
    List<Integer> []adj;

    public TopologicalSort(int x){
        // nothing but array of list
        // wjhy are you getting confused
        //
        /*
        */
//        Integer []array = new Integer[V];
//        array[0] = new Integer(2);
//        array[1] = new Integer(3);
//
//        Map<String,String> arrayOfMap[] = new Map[];
//        arrayOfMap[0] = new HashMap<>();
//        arrayOfMap[1] = new HashMap<>();
//
//
//        // fucking array of any DS is possible
        this.V = x;

        adj = new List[V];

        for(int i=0;i<V;i++){
            adj[i] = new ArrayList<>();
        }
    }
    public void addEdge(int i,int j){
        adj[i].add(j);
    }

    public void topologicalSort(){
        int indegree[] = new int[V];

        for(int i=0;i<V;i++){
            for(int node:adj[i]){
                indegree[node]++;
            }
        }


        Queue<Integer> queue = new LinkedList<>();
        for(int i=0;i<V;i++){
            if(indegree[i] == 0){
                queue.add(i);
            }
        }
        int count = 0;
        Vector<Integer> topLogicalOrder = new Vector<>();
        while (!queue.isEmpty()){
            int polled = queue.poll();
            topLogicalOrder.add(polled);
            for(int node:adj[polled]){
                indegree[node]--;
                if(indegree[node] == 0){
                    queue.add(node);
                }
            }

            count++;
        }
        if(count!=V){
            System.out.println("There exist a cycle .. beware not a Dag");
        }

        for(Integer node:topLogicalOrder){
            System.out.print(" "+node);
        }
    }
}
class Main
{
    public static void main(String args[])
    {
        // Create a graph given in the above diagram
        TopologicalSort g=new TopologicalSort(6);
        g.addEdge(5, 2);
        g.addEdge(5, 0);
        g.addEdge(4, 0);
        g.addEdge(4, 1);
        g.addEdge(2, 3);
        g.addEdge(3, 1);
        System.out.println(" rajat Following is a Topological Sort");
        g.topologicalSort();

    }
}
package BasicAlgorithms.MyGraph;

import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Queue;

/**
 * Created by hadoop on 21/10/17.
 */
public class ValidTree {
    public boolean validTree(int n, int[][] edges) {
        // create graph
        // how would u create graph
        HashMap<Integer,HashSet<Integer>> graph = new HashMap<>();
        for (int i=0;i<n;i++){
            graph.put(i,new HashSet<>());
        }
        for(int []edge:edges){
            // since undirected graph
            graph.get(edge[0]).add(edge[1]);
            graph.get(edge[1]).add(edge[0]);
        }
        Queue<Integer> queue = new LinkedList<Integer>();

        boolean [] visited = new boolean[n];
        queue.add(0);
        while (!queue.isEmpty()){
            Integer v = queue.poll();
            if(visited[v]){ // means cycle is present
                return false;
            }
            for(Integer w:graph.get(v)){
                graph.get(w).remove(v); // whatttta  clasic approach
                queue.add(w);
                visited[w] = true;
            }
        }
        // all nodes should have visited ..
        for(int i=0;i<n;i++){
            if(visited[i] == false){
                return false;
            }
        }
        return true;
    }
}package BasicAlgorithms.MyGraph;

/**
 * Created by hadoop on 20/10/17.
 */

// Java implementation of Kosaraju's algorithm to print all SCCs
import java.util.*;
import java.util.LinkedList;

// This class represents a directed graph using adjacency list
// representation
class GraphGeeks
{
    private int V;   // No. of vertices
    private LinkedList<Integer> adj[]; //Adjacency List

    //Constructor
    GraphGeeks(int v)
    {
        V = v;
        adj = new LinkedList[v];
        for (int i=0; i<v; ++i)
            adj[i] = new LinkedList();
    }

    //Function to add an edge into the graph
    void addEdge(int v, int w)  { adj[v].add(w); }

    // A recursive function to print DFS starting from v
    void DFSUtil(int v,boolean visited[])
    {
        // Mark the current node as visited and print it
        visited[v] = true;
        System.out.print(v + " ");

        int n;

        // Recur for all the vertices adjacent to this vertex
        Iterator<Integer> i =adj[v].iterator();
        while (i.hasNext())
        {
            n = i.next();
            if (!visited[n])
                DFSUtil(n,visited);
        }
    }

    // Function that returns reverse (or transpose) of this graph
    GraphGeeks getTranspose()
    {
        GraphGeeks g = new GraphGeeks(V);
        for (int v = 0; v < V; v++)
        {
            // Recur for all the vertices adjacent to this vertex
            Iterator<Integer> i =adj[v].listIterator();
            while(i.hasNext())
                g.adj[i.next()].add(v);
        }
        return g;
    }

    void fillOrder(int v, boolean visited[], Stack stack)
    {
        // Mark the current node as visited and print it
        visited[v] = true;

        // Recur for all the vertices adjacent to this vertex
        Iterator<Integer> i = adj[v].iterator();
        while (i.hasNext())
        {
            int n = i.next();
            if(!visited[n])
                fillOrder(n, visited, stack);
        }

        // All vertices reachable from v are processed by now,
        // push v to Stack
        stack.push(new Integer(v));
    }

    // The main function that finds and prints all strongly
    // connected components
    void printSCCs()
    {
        Stack stack = new Stack();

        // Mark all the vertices as not visited (For first DFS)
        boolean visited[] = new boolean[V];
        for(int i = 0; i < V; i++)
            visited[i] = false;

        // Fill vertices in stack according to their finishing
        // times
        for (int i = 0; i < V; i++)
            if (visited[i] == false)
                fillOrder(i, visited, stack);

        // Create a reversed graph
        GraphGeeks gr = getTranspose();

        // Mark all the vertices as not visited (For second DFS)
        for (int i = 0; i < V; i++)
            visited[i] = false;

        // Now process all vertices in order defined by Stack
        while (stack.empty() == false)
        {
            // Pop a vertex from stack
            int v = (int)stack.pop();

            // Print Strongly connected component of the popped vertex
            if (visited[v] == false)
            {
                gr.DFSUtil(v, visited);
                System.out.println();
            }
        }
    }

    // Driver method
    public static void main(String args[])
    {
        // Create a graph given in the above diagram
        GraphGeeks g = new GraphGeeks(5);
        g.addEdge(1, 0);
        g.addEdge(0, 2);
        g.addEdge(2, 1);
        g.addEdge(0, 3);
        g.addEdge(3, 4);

        System.out.println("Following are strongly connected components "+
                "in given graph ");
        g.printSCCs();
    }
}
// This code is contributed by Aakash Hasijapackage BasicAlgorithms.MyGraph;

public class C6_18_GraphPainter {
    public static int[] paint(Graph graph){
        int[] color = new int[graph.getV()];

        for(int i = 0; i < graph.getV(); i++){
            if(graph.adj(i) == null) color[i] = 1;
        }

        int i = 0;
        while(i < graph.getV()){
            if(color[i] == 1);
            else if(color[i] == 0){
                color[i] = 1;
                for(Integer t : graph.adj(i)) {
                    color[t] = 2;
                }
            } else {
                for(Integer t: graph.adj(i)){
                    if(color[t] == color[i]) color[t]++;
                }
            }
            i++;
        }
        return color;
    }

}
package BasicAlgorithms.MyGraph;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class WeightedGraph {
	public class Edge implements Comparable<Edge>{
		public int s; 
		public int t;
		public double w;
		
		public Edge(int s, int t, double w){
			this.s = s;
			this.t = t;
			this.w = w;
		}

		@Override
		public int compareTo(Edge e) {
			if(this.w < e.w) 		return -1;
			else if(this.w > e.w) 	return 1;
			else 					return 0;
		}
		
		public void print(){
			System.out.printf("%d-%d(%.2f)\t", this.s, this.t, this.w);
		}
	}
	
	public double weight = 0;
	public boolean ordered;
	public int V;
	public Set<Edge>[] adj;
	
	@SuppressWarnings("unchecked")
	public WeightedGraph(int size, boolean ordered){
		this.V = size;
		this.ordered = ordered;
		adj = (Set<Edge>[]) new Set[V];
	}
	
	public void addDirectEdge(int v, int w, double weight){
		if(adj[v] == null){
			adj[v] = new HashSet<Edge>();
		}
		Edge edge = new Edge(v, w, weight);
		adj[v].add(edge);
	}
	
	public void addEdge(int v, int w, double weight){
		addDirectEdge(v, w, weight);
		if(!ordered)
			addDirectEdge(w, v, weight);
		this.weight += weight;
	}
	
	public void addEdge(Edge edge){
		addEdge(edge.s, edge.t, edge.w);
	}
	
	public Iterable<Edge> adj(int v){
		return adj[v]; 
	}
	
	public double weight(){
		return this.weight;
	}
	
	public List<Edge> edges(){
		List<Edge> edges = new ArrayList<Edge>();
		for(int i = 0; i < V; i++){
			if(adj[i] == null)	continue;
			for(Edge edge: adj(i)){
				edges.add(edge);
			}
		}
		return edges;
	}
	
	public void print(){
		for(int i = 0; i < V; i++){
			System.out.print(i + "\t");
			if(adj(i) != null){
				for(Edge edge : adj(i)){
					edge.print();
				}
			}
			System.out.println();
		}
	}
	
	public Iterable<Edge> getSortedEdge(boolean isAsc){
		List<Edge> edges = edges();
		if(isAsc){
			Collections.sort(edges);
		} else {
			Collections.sort(edges, Collections.reverseOrder());
		}
		return edges;
	}
}
package BasicAlgorithms.MyGraph;

/**
 * Created by hadoop on 21/10/17.
 */
import java.util.*;
import java.util.Queue;
public class MinimalHeigtTrees {
    public List<Integer> findMinHeightTrees(int n, int[][] edges) {
        HashMap<Integer,HashSet<Integer>> graph = new HashMap<>();

        // to find miinum height we are traversing BFS from the leaves nodes .. all at once
        // BFS from multiple sources and meeting at one location ...
        // when number of nodes are less than 2 ...
        // kind of finding middle point ... shortest distance .....
        // think of doing BFS from multiple sourcces
        for(int i=0;i<n;i++){
            graph.put(i,new HashSet<>());
        }
        for(int i=0;i<edges.length;i++){
            graph.get(edges[i][0]).add(edges[i][1]);
            graph.get(edges[i][1]).add(edges[i][0]);
        }
        List<Integer> startNodeLeaves = new LinkedList<>();
        for(int i=0;i<n;i++){
            // means degree is 1
            if(graph.get(i).size() == 1){
                startNodeLeaves.add(i);
            }
        }

        // we will start BFS from all leaves nodes ...
        Queue<Integer> queue = new LinkedList<Integer>();
        boolean []visited = new boolean[n];
        for(Integer v: startNodeLeaves){
            queue.add(v);
          //  visited[v] = true;
        }
        while (queue.size()>2){
            int polled = queue.poll();
            for(int v:graph.get(polled)) {
                graph.get(v).remove(polled);
                if(graph.get(v).size() == 1){
                    queue.add(v);
                }
            }
        }
        return new LinkedList<>(queue);

    }
}package BasicAlgorithms.MyGraph;

/**
 * Created by hadoop on 19/10/17.
 */
public class DepthFirstSearch {
    // first thing in dfs is marked
    boolean [] marked;
    // note dfs has always one starting point
    // inn all questions of dfs, u need to figure out the startting point
    int count;
    public DepthFirstSearch(Graph g, int s){
        // init the visited set
        marked = new boolean[g.getV()];
        dfs(g,s);
    }
// dfs from node v
    // two types of dfs possible
    // before you call mark it
    // after yuou call mark it

    // i prefer to mark befoe the call so always i need helper function to
    // mark the starting node before i make call to actual dfs funciton
    //
    private void dfs(Graph g, int s) {
        marked[s] = true;
        // count tells the number of vertex connected to source vertex
        count++;
        dfsHelper(g,s);
    }
    private void dfsHelper(Graph g, int v){
        for(int w:g.adj(v)){
            if(!marked[w]){
                marked[w] = true;
                count++;
                dfsHelper(g,w);
            }
        }
    }

    public int getCount() {
        return count;
    }
}
package BasicAlgorithms.MyGraph;

/**
 * Created by hadoop on 19/10/17.
 */
// we can use dfs to count connected components
    // also size in reach connected component
    // remember no. of nodes in DFS application
    // just use that strait forward
    // in short we need to perform DFS from nodes one by one
public class ConnectedComponents {
    boolean [] marked;
    int [] id ; // all nodes will assigned to either of connected component id[node] = connectedcomponenstid
    int [] size; // size[connectedCoponent] will return size of each component
    int connectedComponents; // at the end it will return no. of connected componesnts
    // note dfs has always one starting point
    // inn all questions of dfs, u need to figure out the startting point
    public ConnectedComponents(Graph g){

        marked = new boolean[g.getV()];
        /// assign different id to each of the node int he beginning
        id = new int[g.getV()];
        size = new int[g.getV()];
        for(int i=0;i<g.getV();i++){

            marked[i] = false;
            id[i] = i;
            size[i] = 0;
        }
        for(int i=0;i<g.getV();i++) {
            if(!marked[i]) {
                dfs(g, i);
                connectedComponents++;
            }
        }
    }
// dfs from node v
    // two types of dfs possible
    // before you call mark it
    // after yuou call mark it

    // i prefer to mark befoe the call so always i need helper function to
    // mark the starting node before i make call to actual dfs funciton

    private void dfs(Graph g, int s) {
        marked[s] = true;
        // count tells the number of vertex connected to source vertex
        id[s] = connectedComponents;
        size[connectedComponents] = size[connectedComponents] +1;
        dfsHelper(g,s);
    }
    private void dfsHelper(Graph g, int v){
        for(int w:g.adj(v)){
            if(!marked[w]){
                marked[w] = true;
                id[w] = connectedComponents;
                size[connectedComponents] = size[connectedComponents] +1;
                dfsHelper(g,w);
            }
        }
    }

    public int getConnectedComponents() {
        return connectedComponents;
    }
}
package BasicAlgorithms.MyGraph;


import java.util.*;

/**
 * Created_By: stefanie
 * Date: 14-12-16
 * Time: 3:04
 */
public class TQ33_DAGTopologySorter {

    public List<GraphNode> sort(List<GraphNode> nodes){
        List<GraphNode> sorted = new ArrayList<GraphNode>();
        HashMap<GraphNode, Integer> indegree = new HashMap<>();
        for(GraphNode node : nodes){
            for(GraphNode neighbor : node.neighbors){
                if(indegree.containsKey(neighbor)) indegree.put(neighbor, indegree.get(neighbor) + 1);
                else indegree.put(neighbor, 1);
            }
        }
        //put 0-in-degree node in queue
        LinkedList<GraphNode> queue = new LinkedList();
        for(GraphNode node : nodes){
            if(!indegree.containsKey(node)) {
                queue.offer(node);
            }
        }

        while(!queue.isEmpty()){
            GraphNode node = queue.poll();
            sorted.add(node);
            for(GraphNode neighbor : node.neighbors){
                indegree.put(neighbor, indegree.get(neighbor) - 1);
                if(indegree.get(neighbor) == 0) queue.offer(neighbor);
            }
        }

        return sorted;
    }

    public static void main(String[] args){
        TQ33_DAGTopologySorter sorter = new TQ33_DAGTopologySorter();
        List<GraphNode> nodes = new ArrayList<>();
        for(int i = 0; i < 6; i++){
            nodes.add(new GraphNode(i));
        }

        nodes.get(1).neighbors.add(nodes.get(2));
        nodes.get(1).neighbors.add(nodes.get(4));
        nodes.get(2).neighbors.add(nodes.get(3));
        nodes.get(2).neighbors.add(nodes.get(5));
        nodes.get(3).neighbors.add(nodes.get(4));

        List<GraphNode> sorted = sorter.sort(nodes);
        for(int i = 0; i < sorted.size(); i++){
            System.out.print(sorted.get(i).label + ", ");
        }
        //0, 1, 2, 3, 5, 4,
    }
}
package BasicAlgorithms.MyGraph;

/**
 * Created by hadoop on 19/10/17.
 */
public class ArticulationPoint {
    boolean []marked;
    int []pre;
    int counter;
    int []low;
    boolean[] isarticulationpoint;
    int children;
    ArticulationPoint(Graph g){
        marked = new boolean[g.getV()];
        pre = new int[g.getV()];
        low = new int[g.getV()];
        isarticulationpoint = new boolean[g.getV()];
        for(int i=0;i<g.getV();i++){
            if(!marked[i]){
                dfs(g,i,i);
            }
        }
    }

    private void dfs(Graph g, int u, int v) {
        marked[v] = true;
        pre[v] = counter++;
        low[v] = pre[v];
        for(int w:g.adj(v)){
            if(!marked[w]){
                children++;
                dfs(g,v,w);
                low[v] = Math.min(low[v],low[w]);

                if(low[w]<pre[v] && u!=v){
                    System.out.println("all okay v is not artculationpiint");
                }

                else {
                    isarticulationpoint[v] = true;
                }

            }
            else if(w!=u){
                low[v] = Math.min(low[v],pre[w]);
            }
        }
        if(u == v && children>1){
            isarticulationpoint[u] = true;
        }


    }

}
package BasicAlgorithms.MyGraph;

/**
 * Created by hadoop on 20/10/17.
 */


// A Java program to print topological sorting of a DAG
import java.io.*;
        import java.util.*;

// This class represents a directed graph using adjacency
// list representation
class TopSort
{
    private int V;   // No. of vertices
    private LinkedList<Integer> adj[]; // Adjacency List

    //Constructor
    TopSort(int v)
    {
        V = v;
        adj = new LinkedList[v];
        for (int i=0; i<v; ++i)
            adj[i] = new LinkedList();
    }

    // Function to add an edge into the graph
    void addEdge(int v,int w) { adj[v].add(w); }

    // A recursive function used by topologicalSort
    void topologicalSortUtil(int v, boolean visited[],
                             Stack stack)
    {
        // Mark the current node as visited.
        visited[v] = true;
        Integer i;

        // Recur for all the vertices adjacent to this
        // vertex
        Iterator<Integer> it = adj[v].iterator();
        while (it.hasNext())
        {
            i = it.next();
            if (!visited[i])
                topologicalSortUtil(i, visited, stack);
        }

        // Push current vertex to stack which stores result
        stack.push(new Integer(v));
    }

    // The function to do Topological Sort. It uses
    // recursive topologicalSortUtil()
    void topologicalSort()
    {
        Stack stack = new Stack();

        // Mark all the vertices as not visited
        boolean visited[] = new boolean[V];
        for (int i = 0; i < V; i++)
            visited[i] = false;

        // Call the recursive helper function to store
        // Topological Sort starting from all vertices
        // one by one
        for (int i = 0; i < V; i++)
            if (visited[i] == false)
                topologicalSortUtil(i, visited, stack);

        // Print contents of stack
        while (stack.empty()==false)
            System.out.print(stack.pop() + " ");
    }

    // Driver method
    public static void main(String args[])
    {
        // Create a graph given in the above diagram
        TopSort g = new TopSort(6);
        g.addEdge(5, 2);
        g.addEdge(5, 0);
        g.addEdge(4, 0);
        g.addEdge(4, 1);
        g.addEdge(2, 3);
        g.addEdge(3, 1);

        System.out.println("Following is a Topological " +
                "sort of the given graph");
        g.topologicalSort();
    }
}
// This code is contributed by Aakash Hasija/******************************************************************************
 *  Compilation:  javac In.java
 *  Execution:    java In   (basic test --- see source for required files)
 *  Dependencies: none
 *
 *  Reads in data of various types from standard input, files, and URLs.
 *
 ******************************************************************************/

package BasicAlgorithms.MyGraph;

import BasicAlgorithms.Graph.StdIn;

import java.io.*;
import java.net.Socket;
import java.net.URL;
import java.net.URLConnection;
import java.util.*;
import java.util.regex.Pattern;

// import java.net.HttpURLConnection;

/**
 *  <i>Input</i>. This class provides methods for reading strings
 *  and numbers from standard input, file input, URLs, and sockets. 
 *  <p>
 *  The Locale used is: language = English, country = US. This is consistent
 *  with the formatting conventions with Java floating-Point literals,
 *  command-line arguments (via {@link Double#parseDouble(String)})
 *  and standard output. 
 *  <p>
 *  For additional documentation, see 
 *  <a href="http://introcs.cs.princeton.edu/31datatype">Section 3.1</a> of
 *  <i>Computer Science: An Interdisciplinary Approach</i> 
 *  by Robert Sedgewick and Kevin Wayne.
 *  <p>
 *  Like {@link Scanner}, reading a token also consumes preceding Java
 *  whitespace, reading a full line consumes
 *  the following end-of-line delimeter, while reading a character consumes
 *  nothing extra. 
 *  <p>
 *  Whitespace is defined in {@link Character#isWhitespace(char)}. Newlines
 *  consist of \n, \r, \r\n, and Unicode hex code points 0x2028, 0x2029, 0x0085;
 *  see <a href="http://www.docjar.com/html/api/java/util/Scanner.java.html">
 *  Scanner.java</a> (NB: Java 6u23 and earlier uses only \r, \r, \r\n).
 *
 *  @author David Pritchard
 *  @author Robert Sedgewick
 *  @author Kevin Wayne
 */
public final class In {
    
    ///// begin: section (1 of 2) of code duplicated from In to StdIn.
    
    // assume Unicode UTF-8 encoding
    private static final String CHARSET_NAME = "UTF-8";

    // assume language = English, country = US for consistency with System.out.
    private static final Locale LOCALE = Locale.US;

    // the default token separator; we maintain the invariant that this value 
    // is held by the scanner's delimiter between calls
    private static final Pattern WHITESPACE_PATTERN = Pattern.compile("\\p{javaWhitespace}+");

    // makes whitespace characters significant 
    private static final Pattern EMPTY_PATTERN = Pattern.compile("");

    // used to read the entire input. source:
    // http://weblogs.java.net/blog/pat/archive/2004/10/stupid_scanner_1.html
    private static final Pattern EVERYTHING_PATTERN = Pattern.compile("\\A");

    //// end: section (1 of 2) of code duplicated from In to StdIn.

    private Scanner scanner;

   /**
     * Initializes an input stream from standard input.
     */
    public In() {
        scanner = new Scanner(new BufferedInputStream(System.in), CHARSET_NAME);
        scanner.useLocale(LOCALE);
    }

   /**
     * Initializes an input stream from a socket.
     *
     * @param  socket the socket
     * @throws IllegalArgumentException if cannot open {@code socket}
     * @throws IllegalArgumentException if {@code socket} is {@code null}
     */
    public In(Socket socket) {
        if (socket == null) throw new IllegalArgumentException("socket argument is null");
        try {
            InputStream is = socket.getInputStream();
            scanner = new Scanner(new BufferedInputStream(is), CHARSET_NAME);
            scanner.useLocale(LOCALE);
        }
        catch (IOException ioe) {
            throw new IllegalArgumentException("Could not open " + socket, ioe);
        }
    }

   /**
     * Initializes an input stream from a URL.
     *
     * @param  url the URL
     * @throws IllegalArgumentException if cannot open {@code url}
     * @throws IllegalArgumentException if {@code url} is {@code null}
     */
    public In(URL url) {
        if (url == null) throw new IllegalArgumentException("url argument is null");
        try {
            URLConnection site = url.openConnection();
            InputStream is     = site.getInputStream();
            scanner            = new Scanner(new BufferedInputStream(is), CHARSET_NAME);
            scanner.useLocale(LOCALE);
        }
        catch (IOException ioe) {
            throw new IllegalArgumentException("Could not open " + url, ioe);
        }
    }

   /**
     * Initializes an input stream from a file.
     *
     * @param  file the file
     * @throws IllegalArgumentException if cannot open {@code file}
     * @throws IllegalArgumentException if {@code file} is {@code null}
     */
    public In(File file) {
        if (file == null) throw new IllegalArgumentException("file argument is null");
        try {
            // for consistency with StdIn, wrap with BufferedInputStream instead of use
            // file as argument to Scanner
            FileInputStream fis = new FileInputStream(file);
            scanner = new Scanner(new BufferedInputStream(fis), CHARSET_NAME);
            scanner.useLocale(LOCALE);
        }
        catch (IOException ioe) {
            throw new IllegalArgumentException("Could not open " + file, ioe);
        }
    }


   /**
     * Initializes an input stream from a filename or web page databaseName.
     *
     * @param  databaseName the filename or web page databaseName
     * @throws IllegalArgumentException if cannot open {@code databaseName} as
     *         a file or URL
     * @throws IllegalArgumentException if {@code databaseName} is {@code null}
     */
    public In(String databaseName) {
        if (databaseName == null) throw new IllegalArgumentException("argument is null");
        try {
            // first try to read file from local file system
            File file = new File(databaseName);
            if (file.exists()) {
                // for consistency with StdIn, wrap with BufferedInputStream instead of use
                // file as argument to Scanner
                FileInputStream fis = new FileInputStream(file);
                scanner = new Scanner(new BufferedInputStream(fis), CHARSET_NAME);
                scanner.useLocale(LOCALE);
                return;
            }

            // next try for files included in jar
            URL url = getClass().getResource(databaseName);

            // try this as well
            if (url == null) {
                url = getClass().getClassLoader().getResource(databaseName);
            }

            // or URL from web
            if (url == null) {
                url = new URL(databaseName);
            }

            URLConnection site = url.openConnection();

            // in order to set User-Agent, replace above line with these two
            // HttpURLConnection site = (HttpURLConnection) url.openConnection();
            // site.addRequestProperty("User-Agent", "Mozilla/4.76");

            InputStream is     = site.getInputStream();
            scanner            = new Scanner(new BufferedInputStream(is), CHARSET_NAME);
            scanner.useLocale(LOCALE);
        }
        catch (IOException ioe) {
            throw new IllegalArgumentException("Could not open " + databaseName, ioe);
        }
    }

    /**
     * Initializes an input stream from a given {@link Scanner} source; use with 
     * {@code new Scanner(String)} to read from a string.
     * <p>
     * Note that this does not create a defensive copy, so the
     * scanner will be mutated as you read on. 
     *
     * @param  scanner the scanner
     * @throws IllegalArgumentException if {@code scanner} is {@code null}
     */
    public In(Scanner scanner) {
        if (scanner == null) throw new IllegalArgumentException("scanner argument is null");
        this.scanner = scanner;
    }

    /**
     * Returns true if this input stream exists.
     *
     * @return {@code true} if this input stream exists; {@code false} otherwise
     */
    public boolean exists()  {
        return scanner != null;
    }
    
    ////  begin: section (2 of 2) of code duplicated from In to StdIn,
    ////  with all methods changed from "public" to "public static".

   /**
     * Returns true if input stream is empty (except possibly whitespace).
     * Use this to know whether the next call to {@link #readString()}, 
     * {@link #readDouble()}, etc will succeed.
     *
     * @return {@code true} if this input stream is empty (except possibly whitespace);
     *         {@code false} otherwise
     */
    public boolean isEmpty() {
        return !scanner.hasNext();
    }

   /** 
     * Returns true if this input stream has a next line.
     * Use this method to know whether the
     * next call to {@link #readLine()} will succeed.
     * This method is functionally equivalent to {@link #hasNextChar()}.
     *
     * @return {@code true} if this input stream has more input (including whitespace);
     *         {@code false} otherwise
     */
    public boolean hasNextLine() {
        return scanner.hasNextLine();
    }

    /**
     * Returns true if this input stream has more input (including whitespace).
     * Use this method to know whether the next call to {@link #readChar()} will succeed.
     * This method is functionally equivalent to {@link #hasNextLine()}.
     * 
     * @return {@code true} if this input stream has more input (including whitespace);
     *         {@code false} otherwise   
     */
    public boolean hasNextChar() {
        scanner.useDelimiter(EMPTY_PATTERN);
        boolean result = scanner.hasNext();
        scanner.useDelimiter(WHITESPACE_PATTERN);
        return result;
    }


   /**
     * Reads and returns the next line in this input stream.
     *
     * @return the next line in this input stream; {@code null} if no such line
     */
    public String readLine() {
        String line;
        try {
            line = scanner.nextLine();
        }
        catch (NoSuchElementException e) {
            line = null;
        }
        return line;
    }

    /**
     * Reads and returns the next character in this input stream.
     *
     * @return the next {@code char} in this input stream
     * @throws NoSuchElementException if the input stream is empty
     */
    public char readChar() {
        scanner.useDelimiter(EMPTY_PATTERN);
        try {
            String ch = scanner.next();
            assert ch.length() == 1 : "Internal (Std)In.readChar() error!"
                + " Please contact the authors.";
            scanner.useDelimiter(WHITESPACE_PATTERN);
            return ch.charAt(0);
        }
        catch (NoSuchElementException e) {
            throw new NoSuchElementException("attempts to read a 'char' value from input stream, but there are no more tokens available");
        }
    }  


   /**
     * Reads and returns the remainder of this input stream, as a string.
     *
     * @return the remainder of this input stream, as a string
     */
    public String readAll() {
        if (!scanner.hasNextLine())
            return "";

        String result = scanner.useDelimiter(EVERYTHING_PATTERN).next();
        // not that important to reset delimeter, since now scanner is empty
        scanner.useDelimiter(WHITESPACE_PATTERN); // but let's do it anyway
        return result;
    }


   /**
     * Reads the next token from this input stream and returns it as a {@code String}.
     *
     * @return the next {@code String} in this input stream
     * @throws NoSuchElementException if the input stream is empty
     */
    public String readString() {
        try {
            return scanner.next();
        }
        catch (NoSuchElementException e) {
            throw new NoSuchElementException("attempts to read a 'String' value from input stream, but there are no more tokens available");
        }
    }

   /**
     * Reads the next token from this input stream, parses it as a {@code int},
     * and returns the {@code int}.
     *
     * @return the next {@code int} in this input stream
     * @throws NoSuchElementException if the input stream is empty
     * @throws InputMismatchException if the next token cannot be parsed as an {@code int}
     */
    public int readInt() {
        try {
            return scanner.nextInt();
        }
        catch (InputMismatchException e) {
            String token = scanner.next();
            throw new InputMismatchException("attempts to read an 'int' value from input stream, but the next token is \"" + token + "\"");
        }
        catch (NoSuchElementException e) {
            throw new NoSuchElementException("attemps to read an 'int' value from input stream, but there are no more tokens available");
        }
    }

   /**
     * Reads the next token from this input stream, parses it as a {@code double},
     * and returns the {@code double}.
     *
     * @return the next {@code double} in this input stream
     * @throws NoSuchElementException if the input stream is empty
     * @throws InputMismatchException if the next token cannot be parsed as a {@code double}
     */
    public double readDouble() {
        try {
            return scanner.nextDouble();
        }
        catch (InputMismatchException e) {
            String token = scanner.next();
            throw new InputMismatchException("attempts to read a 'double' value from input stream, but the next token is \"" + token + "\"");
        }
        catch (NoSuchElementException e) {
            throw new NoSuchElementException("attemps to read a 'double' value from input stream, but there are no more tokens available");
        }
    }

   /**
     * Reads the next token from this input stream, parses it as a {@code float},
     * and returns the {@code float}.
     *
     * @return the next {@code float} in this input stream
     * @throws NoSuchElementException if the input stream is empty
     * @throws InputMismatchException if the next token cannot be parsed as a {@code float}
     */
    public float readFloat() {
        try {
            return scanner.nextFloat();
        }
        catch (InputMismatchException e) {
            String token = scanner.next();
            throw new InputMismatchException("attempts to read a 'float' value from input stream, but the next token is \"" + token + "\"");
        }
        catch (NoSuchElementException e) {
            throw new NoSuchElementException("attemps to read a 'float' value from input stream, but there are no more tokens available");
        }
    }

   /**
     * Reads the next token from this input stream, parses it as a {@code long},
     * and returns the {@code long}.
     *
     * @return the next {@code long} in this input stream
     * @throws NoSuchElementException if the input stream is empty
     * @throws InputMismatchException if the next token cannot be parsed as a {@code long}
     */
    public long readLong() {
        try {
            return scanner.nextLong();
        }
        catch (InputMismatchException e) {
            String token = scanner.next();
            throw new InputMismatchException("attempts to read a 'long' value from input stream, but the next token is \"" + token + "\"");
        }
        catch (NoSuchElementException e) {
            throw new NoSuchElementException("attemps to read a 'long' value from input stream, but there are no more tokens available");
        }
    }

   /**
     * Reads the next token from this input stream, parses it as a {@code short},
     * and returns the {@code short}.
     *
     * @return the next {@code short} in this input stream
     * @throws NoSuchElementException if the input stream is empty
     * @throws InputMismatchException if the next token cannot be parsed as a {@code short}
     */
    public short readShort() {
        try {
            return scanner.nextShort();
        }
        catch (InputMismatchException e) {
            String token = scanner.next();
            throw new InputMismatchException("attempts to read a 'short' value from input stream, but the next token is \"" + token + "\"");
        }
        catch (NoSuchElementException e) {
            throw new NoSuchElementException("attemps to read a 'short' value from input stream, but there are no more tokens available");
        }
    }

   /**
     * Reads the next token from this input stream, parses it as a {@code byte},
     * and returns the {@code byte}.
     * <p>
     * To read binary data, use {@link BinaryIn}.
     *
     * @return the next {@code byte} in this input stream
     * @throws NoSuchElementException if the input stream is empty
     * @throws InputMismatchException if the next token cannot be parsed as a {@code byte}
     */
    public byte readByte() {
        try {
            return scanner.nextByte();
        }
        catch (InputMismatchException e) {
            String token = scanner.next();
            throw new InputMismatchException("attempts to read a 'byte' value from input stream, but the next token is \"" + token + "\"");
        }
        catch (NoSuchElementException e) {
            throw new NoSuchElementException("attemps to read a 'byte' value from input stream, but there are no more tokens available");
        }
    }

    /**
     * Reads the next token from this input stream, parses it as a {@code boolean}
     * (interpreting either {@code "true"} or {@code "1"} as {@code true},
     * and either {@code "false"} or {@code "0"} as {@code false}).
     *
     * @return the next {@code boolean} in this input stream
     * @throws NoSuchElementException if the input stream is empty
     * @throws InputMismatchException if the next token cannot be parsed as a {@code boolean}
     */
    public boolean readBoolean() {
        try {
            String token = readString();
            if ("true".equalsIgnoreCase(token))  return true;
            if ("false".equalsIgnoreCase(token)) return false;
            if ("1".equals(token))               return true;
            if ("0".equals(token))               return false;
            throw new InputMismatchException("attempts to read a 'boolean' value from input stream, but the next token is \"" + token + "\"");
        }
        catch (NoSuchElementException e) {
            throw new NoSuchElementException("attempts to read a 'boolean' value from input stream, but there are no more tokens available");
        }
    }

    /**
     * Reads all remaining tokens from this input stream and returns them as
     * an array of strings.
     *
     * @return all remaining tokens in this input stream, as an array of strings
     */
    public String[] readAllStrings() {
        // we could use readAll.trim().split(), but that's not consistent
        // since trim() uses characters 0x00..0x20 as whitespace
        String[] tokens = WHITESPACE_PATTERN.split(readAll());
        if (tokens.length == 0 || tokens[0].length() > 0)
            return tokens;
        String[] decapitokens = new String[tokens.length-1];
        for (int i = 0; i < tokens.length-1; i++)
            decapitokens[i] = tokens[i+1];
        return decapitokens;
    }

    /**
     * Reads all remaining lines from this input stream and returns them as
     * an array of strings.
     *
     * @return all remaining lines in this input stream, as an array of strings
     */
    public String[] readAllLines() {
        ArrayList<String> lines = new ArrayList<String>();
        while (hasNextLine()) {
            lines.add(readLine());
        }
        return lines.toArray(new String[lines.size()]);
    }


    /**
     * Reads all remaining tokens from this input stream, parses them as integers,
     * and returns them as an array of integers.
     *
     * @return all remaining lines in this input stream, as an array of integers
     */
    public int[] readAllInts() {
        String[] fields = readAllStrings();
        int[] vals = new int[fields.length];
        for (int i = 0; i < fields.length; i++)
            vals[i] = Integer.parseInt(fields[i]);
        return vals;
    }

    /**
     * Reads all remaining tokens from this input stream, parses them as longs,
     * and returns them as an array of longs.
     *
     * @return all remaining lines in this input stream, as an array of longs
     */
    public long[] readAllLongs() {
        String[] fields = readAllStrings();
        long[] vals = new long[fields.length];
        for (int i = 0; i < fields.length; i++)
            vals[i] = Long.parseLong(fields[i]);
        return vals;
    }

    /**
     * Reads all remaining tokens from this input stream, parses them as doubles,
     * and returns them as an array of doubles.
     *
     * @return all remaining lines in this input stream, as an array of doubles
     */
    public double[] readAllDoubles() {
        String[] fields = readAllStrings();
        double[] vals = new double[fields.length];
        for (int i = 0; i < fields.length; i++)
            vals[i] = Double.parseDouble(fields[i]);
        return vals;
    }
    
    ///// end: section (2 of 2) of code duplicated from In to StdIn */

   /**
     * Closes this input stream.
     */
    public void close() {
        scanner.close();  
    }

    /**
     * Reads all integers from a file and returns them as
     * an array of integers.
     *
     * @param      filename the databaseName of the file
     * @return     the integers in the file
     * @deprecated Replaced by {@code new In(filename)}.{@link #readAllInts()}.
     */
    @Deprecated
    public static int[] readInts(String filename) {
        return new In(filename).readAllInts();
    }

   /**
     * Reads all doubles from a file and returns them as
     * an array of doubles.
     *
     * @param      filename the databaseName of the file
     * @return     the doubles in the file
     * @deprecated Replaced by {@code new In(filename)}.{@link #readAllDoubles()}.
     */
    @Deprecated
    public static double[] readDoubles(String filename) {
        return new In(filename).readAllDoubles();
    }

   /**
     * Reads all strings from a file and returns them as
     * an array of strings.
     *
     * @param      filename the databaseName of the file
     * @return     the strings in the file
     * @deprecated Replaced by {@code new In(filename)}.{@link #readAllStrings()}.
     */
    @Deprecated
    public static String[] readStrings(String filename) {
        return new In(filename).readAllStrings();
    }

    /**
     * Reads all integers from standard input and returns them
     * an array of integers.
     *
     * @return     the integers on standard input
     * @deprecated Replaced by {@link StdIn#readAllInts()}.
     */
    @Deprecated
    public static int[] readInts() {
        return new In().readAllInts();
    }

   /**
     * Reads all doubles from standard input and returns them as
     * an array of doubles.
     *
     * @return     the doubles on standard input
     * @deprecated Replaced by {@link StdIn#readAllDoubles()}.
     */
    @Deprecated
    public static double[] readDoubles() {
        return new In().readAllDoubles();
    }

   /**
     * Reads all strings from standard input and returns them as
     *  an array of strings.
     *
     * @return     the strings on standard input
     * @deprecated Replaced by {@link StdIn#readAllStrings()}.
     */
    @Deprecated
    public static String[] readStrings() {
        return new In().readAllStrings();
    }
    
   /**
     * Unit tests the {@code In} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        In in;
        String urlName = "http://introcs.cs.princeton.edu/stdlib/InTest.txt";

        // read from a URL
        System.out.println("readAll() from URL " + urlName);
        System.out.println("---------------------------------------------------------------------------");
        try {
            in = new In(urlName);
            System.out.println(in.readAll());
        }
        catch (IllegalArgumentException e) {
            System.out.println(e);
        }
        System.out.println();

        // read one line at a time from URL
        System.out.println("readLine() from URL " + urlName);
        System.out.println("---------------------------------------------------------------------------");
        try {
            in = new In(urlName);
            while (!in.isEmpty()) {
                String s = in.readLine();
                System.out.println(s);
            }
        }
        catch (IllegalArgumentException e) {
            System.out.println(e);
        }
        System.out.println();

        // read one string at a time from URL
        System.out.println("readString() from URL " + urlName);
        System.out.println("---------------------------------------------------------------------------");
        try {
            in = new In(urlName);
            while (!in.isEmpty()) {
                String s = in.readString();
                System.out.println(s);
            }
        }
        catch (IllegalArgumentException e) {
            System.out.println(e);
        }
        System.out.println();


        // read one line at a time from file in current directory
        System.out.println("readLine() from current directory");
        System.out.println("---------------------------------------------------------------------------");
        try {
            in = new In("./InTest.txt");
            while (!in.isEmpty()) {
                String s = in.readLine();
                System.out.println(s);
            }
        }
        catch (IllegalArgumentException e) {
            System.out.println(e);
        }
        System.out.println();


        // read one line at a time from file using relative path
        System.out.println("readLine() from relative path");
        System.out.println("---------------------------------------------------------------------------");
        try {
            in = new In("../stdlib/InTest.txt");
            while (!in.isEmpty()) {
                String s = in.readLine();
                System.out.println(s);
            }
        }
        catch (IllegalArgumentException e) {
            System.out.println(e);
        }
        System.out.println();

        // read one char at a time
        System.out.println("readChar() from file");
        System.out.println("---------------------------------------------------------------------------");
        try {
            in = new In("InTest.txt");
            while (!in.isEmpty()) {
                char c = in.readChar();
                System.out.print(c);
            }
        }
        catch (IllegalArgumentException e) {
            System.out.println(e);
        }
        System.out.println();
        System.out.println();

        // read one line at a time from absolute OS X / Linux path
        System.out.println("readLine() from absolute OS X / Linux path");
        System.out.println("---------------------------------------------------------------------------");
        in = new In("/n/fs/introcs/www/java/stdlib/InTest.txt");
        try {
            while (!in.isEmpty()) {
                String s = in.readLine();
                System.out.println(s);
            }
        }
        catch (IllegalArgumentException e) {
            System.out.println(e);
        }
        System.out.println();


        // read one line at a time from absolute Windows path
        System.out.println("readLine() from absolute Windows path");
        System.out.println("---------------------------------------------------------------------------");
        try {
            in = new In("G:\\www\\introcs\\stdlib\\InTest.txt");
            while (!in.isEmpty()) {
                String s = in.readLine();
                System.out.println(s);
            }
            System.out.println();
        }
        catch (IllegalArgumentException e) {
            System.out.println(e);
        }
        System.out.println();

    }

}

/******************************************************************************
 *  Copyright 2002-2016, Robert Sedgewick and Kevin Wayne.
 *
 *  This file is part of algs4.jar, which accompanies the textbook
 *
 *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
 *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
 *      http://algs4.cs.princeton.edu
 *
 *
 *  algs4.jar is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  algs4.jar is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
 ******************************************************************************/package BasicAlgorithms.MyGraph;

import java.util.*;

/**
 * Created by hadoop on 21/10/17.
 */
public class AlienDictionary {
    public String alienOrder(String[] words) {
        HashMap<Character,HashSet<Character>> graph = new HashMap<>();
        // add nodes
        HashMap<Character,Integer> indegreeMap = new HashMap<>();
        for(int i=0;i<words.length;i++){
            for(int j=0;j<words[i].length();j++){
                if(!graph.containsKey(words[i].charAt(j))){
                    graph.put(words[i].charAt(j),new HashSet<>());
                    indegreeMap.put(words[i].charAt(j),0);
                }
            }
        }
        // add edges and indegree
        for(int i=1;i<words.length;i++){
            addEdges(words[i-1],words[i],graph,indegreeMap);
        }
//        08041116706
        // 89249488

        java.util.Queue<Character> queue = new LinkedList();
        for(Character c:graph.keySet()){
            if(indegreeMap.get(c) ==0){
                queue.add(c);
            }
        }
        List<Character> topsort = new LinkedList<>();
        while (!queue.isEmpty()){
            Character polled = queue.poll();
            topsort.add(polled);
            for(Character v:graph.get(polled)){
                Integer indegree = indegreeMap.get(v);
                indegree = indegree-1;
                if(indegree == 0){
                    queue.add(v);
                }
                else {
                    indegreeMap.put(v,indegree);
                }
            }
        }
        String ans = "";
        for(Character c:topsort){
            ans = ans+c;
        }
        return ans;
    }

    private void addEdges(String word, String word1, HashMap<Character, HashSet<Character>> graph, HashMap<Character, Integer> indegreeMap) {
        for(int i=0;i<Math.min(word.length(),word1.length());i++){
            if(word.charAt(i)!=word1.charAt(i)){
                graph.get(word.charAt(i)).add(word1.charAt(i));
                indegreeMap.put(word1.charAt(i),indegreeMap.get(word1.charAt(i))+1);
                break;
            }
        }
    }
    public static void main(String []args){
        String words []={
                "wrt",
                "wrf",
                "er",
                "ett",
                "rftt"
        };
        AlienDictionary alienDictionary = new AlienDictionary();
        System.out.println(alienDictionary.alienOrder(words));
    }
}package BasicAlgorithms.MyGraph;
import java.util.*;

public class AllPaths {
    private boolean[] marked;        // vertices in current path
    private Stack<Integer> path;     // the current path
    private int numberOfPaths;       // number of simple path

    // show all simple paths from s to t - use DFS
    public AllPaths(Graph g, int s, int t) {
        marked = new boolean[g.getV()];
        path   = new Stack<Integer>();
        dfs(g, s, t);
    }


    // use DFS
    // parent usage is not required in this case
    private void dfs(Graph G, int v, int t) {

        // add v to current path
        path.push(v);
        marked[v] = true;

        // found path from s to t
        if (v == t) {
            processCurrentPath();
            numberOfPaths++;
            // with dfs we can calcultae number of paths as well print all paths as well
            // we could have choosen to return this value as well
        }

        // consider all neighbors that would continue path with repeating a node
        else {
            for (int w : G.adj(v)) {
                if (!marked[w])
                    dfs(G, w, t);
            }
        }

        // done exploring from v, so remove from path
        path.pop();
        marked[v] = false;
        // backtracking at parent level
        // usually i prefet backtracking at child level
        // check if child is valid go ahead apply recursion
        // and post recusion backtracking
    }

    // this implementation just prints the path to standard output
    private void processCurrentPath() {
        Stack<Integer> reverse = new Stack<Integer>();
        for (int v : path)
            reverse.push(v);
        if (reverse.size() >= 1)
            System.out.println(reverse.pop());
        while (!reverse.isEmpty())
            System.out.println("-" + reverse.pop());
        System.out.println();
    }

    // return number of simple paths between s and t
    public int numberOfPaths() {
        return numberOfPaths;
    }




}
//package BasicAlgorithms.MyGraph;
//
///**
// * Created by hadoop on 19/10/17.
// */
//
//public class TransitiveClosure {
//    private DepthFirstSearch[] tc;  // tc[v] = reachable from v
//
//    /**
//     * Computes the transitive closure of the digraph {@code G}.
//     *
//     * @param G the digraph
//     */
//    public TransitiveClosure(Digraph G) {
//        tc = new DepthFirstSearch[G.getV()];
//        for (int v = 0; v < G.V(); v++)
//            tc[v] = new DepthFirstSearch(G, v);
//    }
//
//    /**
//     * Is there a directed path from vertex {@code v} to vertex {@code w} in the digraph?
//     *
//     * @param v the source vertex
//     * @param w the target vertex
//     * @return {@code true} if there is a directed path from {@code v} to {@code w},
//     * {@code false} otherwise
//     * @throws IllegalArgumentException unless {@code 0 <= v < V}
//     * @throws IllegalArgumentException unless {@code 0 <= w < V}
//     */
//    public boolean reachable(int v, int w) {
//        validateVertex(v);
//        validateVertex(w);
//        return tc[v].marked(w);
//    }
//
//    // throw an IllegalArgumentException unless {@code 0 <= v < V}
//    private void validateVertex(int v) {
//        int V = tc.length;
//        if (v < 0 || v >= V)
//            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V - 1));
//    }
//}package BasicAlgorithms.MyGraph;


import java.util.Stack;
import BasicAlgorithms.MyGraph.WeightedGraph.Edge;

/**
 * Dijkstra Algorithm: Dynamic Programming
 * Can represent the SPT with two vertex-indexed arrays:
 * distTo[v] is length of shortest path from s to v.
 * edgeTo[v] is last edge on shortest path from s to v.
 * <p/>
 * dist(s, t) = min(dist(s, t') + weight(t', t))
 *
 * @author stefanie
 *
 * skeleton:
 *      DIJKSTRA(G, w, s)  //O((V+E)logE)
 *         INITIALIZE-SINGLE-SOURCE(G, s)
 *         S
 *         Q  V[G]   //V*O(1)
 *         while Q  
 *              do u  EXTRACT-MIN(Q)    //EXTRACT-MIN,V*O(V),V*O(lgV)
 *              S  S {u}
 *              for each vertex v  Adj[u]
 *                  do RELAX(u, v, w)    //,E*O(1),E*O(lgV)
 */
public class C6_5_ShortestPath_Dijkstra2 {
    WeightedGraph g;
    double[] distTo;
    Edge[] edgeTo;
    IndexedPriorityQueue<Integer, Double> pq;


    public C6_5_ShortestPath_Dijkstra2(WeightedGraph g) {
        this.g = g;
        init();
    }

    public void init() {
        distTo = new double[g.V];
        edgeTo = new Edge[g.V];
        pq = new IndexedPriorityQueue<Integer, Double>();
        for (int i = 0; i < g.V; i++) {
            distTo[i] = Double.POSITIVE_INFINITY;
        }
    }

    public void solve(int s) {
        distTo[s] = 0.0;
        pq.add(s, 0.0);
        while (!pq.isEmpty()) {
            int u = pq.poll();
            if (g.adj[u] != null) {
                for (Edge e : g.adj[u]) relax(e);
            }
        }
    }

    private void relax(Edge e) {
        if (distTo[e.t] > distTo[e.s] + e.w) {
            distTo[e.t] = distTo[e.s] + e.w;
            edgeTo[e.t] = e;
            if (pq.contains(e.t)) pq.update(e.t, distTo[e.t]);
            else pq.add(e.t, distTo[e.t]);
        }
    }

    public double distTo(int v) {
        return distTo[v];
    }

    public boolean hasPathTo(int v) {
        return distTo[v] < Double.POSITIVE_INFINITY;
    }

    public Iterable<Edge> pathTo(int v) {
        if (!hasPathTo(v)) return null;
        Stack<Edge> path = new Stack<Edge>();
        for (Edge edge = edgeTo[v]; edge != null; edge = edgeTo[edge.s]) {
            path.push(edge);
        }
        return path;
    }
}
package BasicAlgorithms.MyGraph;

/**
 * Created by hadoop on 19/10/17.
 */

/*
Bridge: A bridge (or cut-edge) is an edge whose deletion increases the number of connected components.
Equivalently, an edge is a bridge if and only if it is not contained in any cycle
. Bridge.java uses depth-first search to find time the bridges in a graph
. It takes time proportional to V + E in the worst case.
 */
public class Bridge {
    int bridges;
    int counter=0;
    boolean []marked;
    int []pre;
    int []low;
    Bridge(Graph g){
        marked = new boolean[g.getV()];
        pre = new int[g.getV()];
        low = new int[g.getV()];
        for(int i=0;i<g.getV();i++){
            if(!marked[i]){
                dfs(g,i,i);
            }
        }
    }

    private void dfs(Graph g, int u, int v) {
        marked[v] = true;
        pre[v]= counter++;
        low[v] = counter;

        for(int w:g.adj(v)){
            if(!marked[w]){
                dfs(g,v,w);
                low[v] = Math.min(low[v],low[w]);
                if(low[w]<=pre[v]){
                    System.out.println("all okay ");
                }

                // in simply terms low[w]==pre[w] there is a bridge
                else {
                    bridges++;
                    System.out.println("w to v there is bridge");
                }
            }
            else if(w!=u){
                low[v] = Math.min(low[v],pre[w]);
            }
        }
    }
}
package BasicAlgorithms.MyGraph;

import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Queue;

/**
 * Created by hadoop on 21/10/17.
 */
public class CourseSchedule {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        HashMap<Integer,HashSet<Integer>> graph = new HashMap<>();
        HashMap<Integer,Integer> indegreeMap = new HashMap<>();
        for(int i=0;i<numCourses;i++){
            graph.put(i,new HashSet<>());
            indegreeMap.put(i,0);
        }
        for(int i=0;i<prerequisites.length;i++){

            // take care of pre-requisite array
            graph.get(prerequisites[i][1]).add(prerequisites[i][0]);
            indegreeMap.put(prerequisites[i][0],indegreeMap.get(prerequisites[i][0])+1);
        }
        Queue<Integer> queue = new LinkedList<Integer>();
        for(int key:indegreeMap.keySet()){
            if(indegreeMap.get(key) == 0){
                queue.add(key);
            }
        }

        LinkedList<Integer> topOrder = new LinkedList<>();
        while (!queue.isEmpty()){
               int polled = queue.poll();
               topOrder.add(polled);
               for(int v:graph.get(polled)){
                   int indegree = indegreeMap.get(v);
                   indegree = indegree-1;
                   if(indegree == 0){
                       queue.add(v);
                       indegreeMap.remove(v);
                   }
                   else {
                       indegreeMap.put(v,indegree);
                   }
               }
        }
        return topOrder.size() == numCourses;
    }
}package BasicAlgorithms.MyGraph;


import java.util.Stack;

/**
 * Created with IntelliJ IDEA.
 * User: stefanie
 * Date: 10/15/14
 * Time: 11:34 AM
 *
 * Skeleton:
 *  BELLMAN-FORD(G, w, s)   //O(EV)
 *      INITIALIZE-SINGLE-SOURCE(G, s) // ,O(V)
 *      for i  1 to |V[G]| - 1
 *          do for each edge (u, v)  E[G]
 *              do RELAX(u, v, w) //(V-1 ), O(E), O((v-1)*E))
 *      for each edge (u, v)  E[G]
 *          do if d[v] > d[u] + w(u, v)
 *              then return FALSE   //,,  d[v]>d[u]+w(u,v),, FALSE,
 *      return TRUE //, TRUE
 */
public class C6_5_ShortestPath_BellmanFord {
    WeightedGraph g;
    double[] distTo;
    WeightedGraph.Edge[] edgeTo;

    public C6_5_ShortestPath_BellmanFord(WeightedGraph g) {
        this.g = g;
        init();
    }

    public void init() {
        distTo = new double[g.V];
        edgeTo = new WeightedGraph.Edge[g.V];
    }

    private void relax(WeightedGraph.Edge e) {
        if(distTo[e.t] > distTo[e.s] + e.w){
            distTo[e.t] = distTo[e.s] + e.w;
            edgeTo[e.t] = edgeTo[e.s];
        }
    }

    public boolean solve(int s) {
        distTo[s] = 0.0;
        for(int i = 0; i < g.V; i++){
            if(i != s) distTo[i] = Double.POSITIVE_INFINITY;
        }
        for(int i = 0; i < g.V; i++){
            for(WeightedGraph.Edge edge : g.edges()) relax(edge);
        }
        for(WeightedGraph.Edge edge : g.edges()){
            if(distTo[edge.t] > distTo[edge.s] + edge.w) return false;
        }
        return true;
    }

    public double distTo(int v) {
        return distTo[v];
    }

    public boolean hasPathTo(int v) {
        return distTo[v] < Double.POSITIVE_INFINITY;
    }

    public Iterable<WeightedGraph.Edge> pathTo(int s, int v) {
        if (!hasPathTo(v)) return null;
        Stack<WeightedGraph.Edge> path = new Stack<>();
        for (WeightedGraph.Edge edge = edgeTo[v]; edge != null && edge.s != s; edge = edgeTo[edge.s]) {
            path.push(edge);
        }
        return path;
    }
}
package BasicAlgorithms.MyGraph;
import java.util.*;

/**
 * Created by hadoop on 21/10/17.
 */
public class CloneGraph {
    public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {
        HashMap<UndirectedGraphNode,UndirectedGraphNode> hashMap = new HashMap<>();
        UndirectedGraphNode root = new UndirectedGraphNode(node.label);
        hashMap.put(node,root);
        dfsHelper(hashMap,root);
        return root;
    }

    private void dfsHelper(HashMap<UndirectedGraphNode, UndirectedGraphNode> hashMap, UndirectedGraphNode u) {

        for(UndirectedGraphNode v:u.neighbors){
            if(!hashMap.containsKey(v)){
                hashMap.put(v,new UndirectedGraphNode(v.label));
                dfsHelper(hashMap,v);
            }
            hashMap.get(u).neighbors.add(v);
        }
    }

    private class UndirectedGraphNode {
			      int label;
			      List<UndirectedGraphNode> neighbors;
			      UndirectedGraphNode(int x) {
			          label = x;
                      neighbors = new ArrayList<UndirectedGraphNode>();
			      }
    };
}
package BasicAlgorithms.MyGraph;

import java.util.Comparator;
import java.util.HashMap;
import java.util.PriorityQueue;

/**
 * Created by hadoop on 25/10/17.
 */
public class MazeAgainWithVisitedWithoutVisited {
    private class Point {
        int x;
        int y;

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;

            Point point = (Point) o;

            if (x != point.x) return false;
            return y == point.y;
        }

        @Override
        public int hashCode() {
            int result = x;
            result = 31 * result + y;
            return result;
        }

        public Point(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }

    static int[] dirx = {1, 0, -1, 0};
    static int[] diry = {0, -1, 0, 1};
    int m;
    int n;

    private class IndexedNode{
        Point point;
        Integer distance;
        IndexedNode(Point p,Integer distance){
            this.distance = distance;
            this.point = p;
        }
    }
    public int shortDistance(int[][] maze, int[] start, int[] destination) {
        m = maze.length;
        n = maze[0].length;
        PriorityQueue<IndexedNode>pq = new PriorityQueue<>(new Comparator<IndexedNode>() {
            @Override
            public int compare(IndexedNode o1, IndexedNode o2) {
                return o1.distance-o2.distance;
            }
        });
        HashMap<Point,Integer> distance = new HashMap<>();
        HashMap<Point,Point> edgeTo = new HashMap<>();
        Point startPoint = new Point(start[0],start[1]);
        pq.add(new IndexedNode(startPoint,0));
        distance.put(startPoint,0);
        edgeTo.put(startPoint,null);

        while (!pq.isEmpty()){
            IndexedNode polled = pq.poll();
            int dist = polled.distance;
            if (isEndConfiguration(polled.point, destination)) {
                return dist;
            }
            for(int i=0;i<4;i++){
                Object neighbour[] = getNextValid(polled.point, dirx[i], diry[i], maze);
                if(neighbour == null){
                    continue;
                }
                Integer neighBourDistance = distance.get(neighbour[0]);
                if(neighBourDistance == null){
                    distance.put((Point)neighbour[0],dist+(Integer)neighbour[1]);
                    edgeTo.put((Point)neighbour[0],polled.point);
                    pq.add(new IndexedNode((Point)neighbour[0],dist+(Integer)neighbour[1]));
                }
                else if(neighBourDistance >dist+(Integer)neighbour[1]){
                    distance.put((Point)neighbour[0],dist+(Integer)neighbour[1]);
                    edgeTo.put((Point)neighbour[0],polled.point);
                    pq.add(new IndexedNode((Point)neighbour[0],dist+(Integer)neighbour[1]));
                }
            }
        }
        return -1;
    }
    private boolean isEndConfiguration(Point point, int[] destination) {
        if (point.x == destination[0] && point.y == destination[1]) {
            return true;
        }
        return false;
    }
    private Object[] getNextValid(Point p, int xdir, int ydir, int[][] maze) {
        int counter = 0;
        int savex = p.x;
        int savey = p.y;
        int x = p.x;
        int y = p.y;
        int dis = 0;
        while (isValid(x + xdir, y + ydir) && maze[x + xdir][y + ydir] != 1) {
            counter++;
            x = x + xdir;
            y = y + ydir;
            dis++;
            if (counter > 10000) System.exit(1);

        }
        if (savex == x && savey == y) {
            return null;
        }
        return new Object[]{new Point(x, y),dis};
    }
    private boolean isValid(int newx, int newy) {
        if (newx >= 0 && newx < m && newy >= 0 && newy < n) {
            return true;
        }
        return false;
    }
    public static void main(String[] args) {
        MazeAgainWithVisitedWithoutVisited mazeCheck = new MazeAgainWithVisitedWithoutVisited();
        int matrix[][] = {{0, 0, 1, 0, 0}, {0, 0, 0, 0, 0}, {0, 0, 0, 1, 0}, {1, 1, 0, 1, 1}, {0, 0, 0, 0, 0}};
        System.out.println(mazeCheck.shortDistance(matrix, new int[]{0, 4}, new int[]{4, 4}));

        //mazeCheck.check();

    }
    
}package BasicAlgorithms.MyGraph;

import java.util.Stack;

/**
 * Created by hadoop on 19/10/17.
 */
/*
Finding paths. It is easy to modify depth-first search to not only determine whether there exists a path between two given vertices but to find such a path (if one exists)
 */
public class DepthFirstSearchFindPaths {
    private boolean marked[];
    int[] edgeTo;
    int sourcevertex;

    // gIVEN GRAPH AND SOURCE VERTEX
    // the whole point is to find paths from source vertex
    //
    DepthFirstSearchFindPaths(Graph g, int s) {
        this.sourcevertex = s;
        marked = new boolean[g.getV()];
        edgeTo = new int[g.getV()];

    }

    private void dfs(Graph g, int v) {
        marked[v] = true;
        dfsHelper(g,v);
    }

    private void dfsHelper(Graph g, int v) {
        for(int w:g.adj(v)){
            if(!marked[w]){
                edgeTo[w] = v;
                marked[w] = true;
                dfsHelper(g,w);
            }
        }
    }
    // refeence point source vertex
    public boolean hasPathto(int v){
        return marked[v];
    }
    // asume it has path . kindly return that collection

    Iterable<Integer> pathTo(int v){
        Stack<Integer> path = new Stack<>();
        path.add(v);
        pathToHelper(v,path);
        path.add(this.sourcevertex);
        return path;
    }

    private void pathToHelper(int v,Stack<Integer> path) {
        if(edgeTo[v]!= this.sourcevertex){
            path.add(edgeTo[v]);
            pathToHelper(edgeTo[v],path);
        }
    }
    // rule of thumb if child is valid apply recursion
    // as we use this rechinique in dfs a lot // so why not dfs done this way only
    // makes thing easier
}package BasicAlgorithms.MyGraph;

import java.util.Stack;

/**
 * Created by hadoop on 19/10/17.
 */
// we found a cycle and return that cycle
    /*
    Cycle detection: Is a given graph acyclic? Cycle.java uses depth-first search to determine whether a graph has a cycle, and if so return one. It takes time proportional to V + E in the worst case.
     */
public class CycleUndirected {
    boolean []marked;
    int edgeTo[];
    Stack<Integer> cycle ; // we will initilize when we will find cycle until tata remain nulll

    CycleUndirected(Graph g){
        marked = new boolean[g.getV()];
        edgeTo = new int[g.getV()];
        for(int i=0;i<g.getV();i++){
            if(!marked[i]){
                // dfs ( grph,parent,startinnode
                dfs(g,-1,i);
            }
        }
    }

    private void dfs(Graph g, int parent, int start) {
        marked[start] = true;
        edgeTo[start] = parent;
        dfsHelper(g,parent,start);
    }

    private void dfsHelper(Graph g, int parent, int start) {
        for(int w:g.adj(start)){
            if(!marked[w]){
                edgeTo[w] = start;
                marked[w] = true;
                // shortcurcuit if have found the cycle
                if(cycle == null) return;
                dfsHelper(g,start,w);
            }
            // w parent is start
            // so when we try to fetch the adjency list of start we will get parent  of start as well also we need to exclude that case

            else if(w!=parent) {
            // bingo we found cycle lets get that path
                cycle = new Stack<>();
                // get path from start node to w
                //
                for(int x=start;x!=w;x=edgeTo[x]){
                    cycle.add(x);
                }
                cycle.add(w);
                //getPath()
            }

        }
    }
    public boolean isCycle(){
        return cycle!=null;
    }

    Iterable<Integer> getCycle(){
        return cycle;
    }
}
// when we need to find cycle here we need to perform DFS from all possible coonnected
//components

package BasicAlgorithms.MyGraph;

import java.util.HashMap;
import java.util.Map;
import java.util.PriorityQueue;

public class IndexedPriorityQueue<Key extends Comparable<Key>, Value extends Comparable<Value>> {
	PriorityQueue<IndexedNode> pq;
	Map<Key, IndexedNode> map;
	
	public IndexedPriorityQueue(){
		pq = new PriorityQueue<IndexedNode>();
		map = new HashMap<Key, IndexedNode>();
	}
	
	class IndexedNode implements Comparable<IndexedNode>{
		Key index;
		Value obj;
		public IndexedNode(Key index, Value obj){
			this.index = index;
			this.obj = obj;
		}
		@Override
		public int compareTo(IndexedNode node) {
			return this.obj.compareTo(node.obj);
		}
	}

	public void add(Key k, Value v) {
		IndexedNode node = new IndexedNode(k, v);
		pq.add(node);
		map.put(k, node);
	}

	public boolean isEmpty() {
		return pq.isEmpty();
	}

	public Key poll() {
		Key key = pq.poll().index;
		map.remove(key);
		return key;
	}

	public void update(Key k, Value v) {
		IndexedNode node = map.get(k);
		if(node != null){
			node.obj = v;
		}
	}

	public boolean contains(Key k) {
		return map.containsKey(k);
	}
}
package BasicAlgorithms.MyGraph;

import java.util.*;

/**
 * @author Baofeng Xue at 2016/5/13 18:18.
 *         Suppose you are an engineer on the Amazon Student team.Your team want to launch new feature called "Courses your social network have attended",
 *         that lists all the courses your social network are taking, sorted by popularity.
 *         A social network is defined as all direct friends and all direct friends of direct friends.
 *         People 3 level deep are not part of the social circle.
 *         <p>
 *         The recommendation logic is based on the following rules:
 *         <p>
 *         1. A user should only be recommended a course that their social network have attended but they have not attended.
 *         <p>
 *         2. The recommendation priority is driven by how many people have attended the same course -
 *         if multiple people attended the same course it should be higher in the recommendations than a course that only one person attended.
 **/
public class SocialNetworkTraversal {

    private Map<String, Integer> coursesMap = new HashMap<>();

    public List<String> getDirectFriendsForUser(String user) {
        ArrayList<String> strings = new ArrayList<>();
        strings.add("Sue");
        strings.add("Amy");
        return strings;
    }

    public List<String> getAttendedCoursesForUser(String user) {
        ArrayList<String> strings = new ArrayList<>();
        strings.add("A");
        strings.add("B");
        return strings;
    }

    public List<String> getRankedCourses(String user) {
        List<String> directFriendsForUser = getDirectFriendsForUser(user);
        for (String friend : directFriendsForUser) {
            List<String> coursesForUser = getAttendedCoursesForUser(friend);
            for (String course : coursesForUser) {
                if (coursesMap.get(course) == null) {
                    coursesMap.put(course, 1);
                } else {
                    coursesMap.put(course, coursesMap.get(course) + 1);
                }
            }
        }

        List<String> recommendation = new ArrayList<>();
        List<String> attendedCoursesForUser = getAttendedCoursesForUser(user);
        for (String course : coursesMap.keySet()) {
            if (!attendedCoursesForUser.contains(course)) {
                recommendation.add(course);
            }
        }

        Collections.sort(recommendation, new Comparator<String>() {
            @Override
            public int compare(String o1, String o2) {
                return coursesMap.get(o2) - coursesMap.get(o1);
            }
        });

        return recommendation;
    }
}package BasicAlgorithms.MyGraph;

import java.util.LinkedList;
import java.util.Stack;

/**
 * Created by hadoop on 19/10/17.
 */
public class DepthFirstSearchOrders{
    boolean [] marked;
    private int []pre;
    private int []post;
    private LinkedList<Integer> preorder;
    private LinkedList<Integer> postorder;
    private int precounter;
    private int postcounter;

    DepthFirstSearchOrders(Digraph g){
        marked = new boolean[g.getV()];
        pre = new int[g.getV()];
        post = new int[g.getV()];
        preorder = new LinkedList<Integer>();
        postorder = new LinkedList<>();
        for(int i=0;i<g.getV();i++){
            if(!marked[i]){
                dfs(g,i);
            }
        }

    }

    private void dfs(Digraph g, int v) {
        preorder.add(v);
        pre[v]=precounter++;
        marked[v] = true;

        for(int w:g.adj(v)){
            if(!marked[w]){
                dfs(g,w);
            }
        }
        postorder.add(v);
        post[v] = postcounter++;
    }
    public Iterable<Integer> post(){
        return postorder;
    }
    public Iterable<Integer> pre(){
        return preorder;
    }
    // decreasing finish times means Topological sort
    public Iterable<Integer> reversePostOrder(){
        Stack<Integer> stack = new Stack<>();
        for(int v:postorder){
            stack.push(v);
        }
        return stack;
    }
}
package BasicAlgorithms.BackTracking;

import java.util.ArrayList;
import java.util.List;
class Solution {
    public String getPermutation(int n, int k) {
        List<Integer> list = new ArrayList<Integer>();
        for(int i=1;i<=n;i++){
            list.add(i);
        }
        k = k-1;
        return perHelper(list,k);
    }
    String perHelper(List<Integer> list,int k){
        String out ="";
        if(list.size()==0){
            return out;
        }
        int size = list.size();
        int item = (k)/fact(size-1);
        out = out +list.get(item);
        list.remove(item);
        k = k%fact(size-1);
        out = out + perHelper(list,k);
        return out;
    }
    private int fact(int i) {
        if(i ==0){
            return 1;
        }
        if(i ==1){
            return 1;
        }
        return i*fact(i-1);
    }
}package BasicAlgorithms.BackTracking;

/**
 * Created by hadoop on 22/10/17.
 */
import java.util.*;
public class Combination {

/*
	Combinations
	Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.
	For example,
	If n = 4 and k = 2, a solution is:
	[
  		[2,4],
  		[3,4],
  		[2,3],
  		[1,2],
  		[1,3],
  		[1,4],
	]
	Tags: Backtracking
*/

 /*
        n: n = 4 1,2,3,4
        k: k = 2 1..n k(2)
 */


    /*

    */
    //Recursive
    public ArrayList<ArrayList<Integer>> combine(int n, int k) {
        ArrayList<ArrayList<Integer>> res = new ArrayList<ArrayList<Integer>>();
        ArrayList<Integer> item = new ArrayList<Integer>();
        if (n < k)
            return res;
        dfs(n, k ,res, item, 1);
        return res;
    }

    public void dfs(int n, int k, ArrayList<ArrayList<Integer>> res, ArrayList<Integer> item, int start) {
        // one possible combinition constructured
        //itemsize == k 
        if (item.size() == k) {
            res.add(new ArrayList<Integer>(item));
            return;
        }

        //1--n 0--n-1
        // try each possibility number in current position
        for (int i = start; i <= n; i++) {
            item.add(i);
            // the new start should be after the next number after i
            dfs(n, k, res, item, i + 1);// after selecting number for current position, process next position
            item.remove(item.size() - 1);// clear the current position to try next possible number
        }
    }
}
package BasicAlgorithms.BackTracking;

/**
 * Created by hadoop on 23/10/17.
 */
import java.util.*;
public class WordPattern2 {
    public boolean wordPatternMatch(String pattern, String str) {
        if (pattern.isEmpty()) {
            return str.isEmpty();
        }
        HashMap<Character,String> hashMap = new HashMap<>();
        HashSet<String> hashSet = new HashSet<>();
        return wordPatternMatchHelper(pattern,0,str,0,hashMap,hashSet);
    }

    public boolean wordPatternMatchHelper(String pattern, int patindex, String str,int strindex,HashMap<Character,String> hashMap,HashSet<String> hashSet) {
       // System.out.println("pat"+patindex);
        //System.out.println("str"+strindex);
        //System.out.println("pat l"+pattern.length());
        //System.out.println("str l"+str.length());
        if(patindex == pattern.length()){
            if(strindex == str.length()){
                return true;
            }
        }
        if(patindex >= pattern.length()){
            return false;
        }
        if(strindex >= str.length()){
            return false;
        }

        Character patChar = pattern.charAt(patindex);
        if(hashMap.containsKey(patChar)){
            String matchedWord = hashMap.get(patChar);
            if(str.indexOf(matchedWord,strindex)==-1){
                return false;
            }
            if(str.length()<strindex+matchedWord.length()){
                return false;
            }
            String sub = str.substring(strindex,strindex+matchedWord.length());
            if(!sub.equals(matchedWord)){
                return false;
            }
            System.out.println("matched"+matchedWord);
            return wordPatternMatchHelper(pattern,patindex+1,str,strindex+matchedWord.length(),hashMap,hashSet);
        }
        else {
            for(int i=strindex;i<str.length();i++){
                String substring =str.substring(strindex,i+1);
                if(!hashSet.contains(substring)) {
                    hashMap.put(patChar, substring);
                    hashSet.add(substring);
                    System.out.println("sub "+substring);
                    if(wordPatternMatchHelper(pattern, patindex + 1, str, i + 1, hashMap, hashSet)){
                        System.out.println("here");
                        System.out.println(pattern.substring(patindex));
                        System.out.println(str.substring(i+1));
                        return true;
                    }
                    hashMap.remove(patChar);
                    hashSet.remove(substring);
                }
            }
        }
        return false;
    }
    public static void main(String args[]){
        WordPattern2 wordPattern2 = new WordPattern2();
     //   "abab"
      //  "redblueredblue"
        System.out.println(wordPattern2.wordPatternMatch("abab","redblueredblue"));
    }
}package BasicAlgorithms.BackTracking;

/**
 * Created by hadoop on 22/10/17.
 */
import java.util.*;
public class Subset {
    public List<List<Integer>> subsets(int[] S) {

        ArrayList<Integer> path = new ArrayList<Integer>();
        List<List<Integer>> result = new ArrayList<>();
        if (S == null || S.length == 0) {
            return result;
        }
        Arrays.sort(S);
        subsetsHelper(0, path, result, S);
        return result;
    }

    public void subsetsHelper(int start, ArrayList<Integer> path, List<List<Integer>> result, int[] S) {
            result.add(new ArrayList<>(path));
            for (int i = start; i < S.length; i++) {
            path.add(S[i]);
           // System.out.println(path);
            subsetsHelper(i + 1, path, result, S);
            path.remove(path.size() - 1);
            while (i<S.length-1 && S[i] == S[i+1]) i++;
        }
    }

    public static void main(String[] args) {
        Subset subset = new Subset();
        System.out.println(subset.subsets(new int[]{1,2,3}));
    }
}
package BasicAlgorithms.BackTracking;

/**
 * Created by hadoop on 23/10/17.
 */
import java.util.*;
public class WordBreak {
    public boolean wordBreak(String s, Set<String> dict) {
        if (s == null || dict.contains(s)) {
            return true;
        }
        boolean isreachable[] = new boolean[s.length()+1];
        isreachable[0] = true;
        for(int end=1;end<=s.length();end++){
            for(int i=0;i<end;i++){
                String substring = s.substring(i,end);
                if(dict.contains(substring) && isreachable[i]){
                    isreachable[end] = true;
                }
            }
        }
        return isreachable[s.length()];
    }

    public static void main(String[] args) {
        WordBreak wordBreak = new WordBreak();
        HashSet<String> set = new HashSet<>();
        set.add("ra");
        set.add("jat");
        System.out.println(wordBreak.wordBreak("rajat",set));
    }
}
package BasicAlgorithms.BackTracking;

import java.util.ArrayList;
import java.util.List;

/**
 * Created by hadoop on 22/10/17.
 */
public class FIndKthPermutation {
    String kthPermutation(List<Character> list ,int k){
        String out="";
        if(list.size() ==0){
            return out;
        }
        int size = list.size();
        int factValue = fact(size-1);

        int selectedValue = (k-1)/factValue;
        out = out +list.get(selectedValue);
        k = k -selectedValue*factValue;
        list.remove(selectedValue);
        return  out = out +kthPermutation(list,k);
    }

    private int fact(int i) {
        if(i ==0){
            return 1;
        }
        if(i ==1){
            return 1;
        }
        return i*fact(i-1);
    }
  //  public void nextPermutation(int [] nums){
//        for(int i=nums.length-2;i>=0;i--) {
//            if (nums[i] < nums[i + 1]) {
//                int j;
//                for(j=nums.length-1;j>i;j--){
//                    if(nums[j]>nums[i]){
//                        break;
//                    }
//                }
//                swap(nums,i,j);
//                reverse(nums,i+1,nums.length-1);
//                return;
//            }
//        }
//    }
//    public void nextPermutationAgain(int [] nums) {
//
//    }
        public static void main(String args[]){
        FIndKthPermutation kthPermutation  = new FIndKthPermutation();
        List<Character> list = new ArrayList<>();
        list.add('a');
        list.add('b');
        list.add('c');
        System.out.println(kthPermutation.kthPermutation(list,5));
    }

}
package BasicAlgorithms.BackTracking;

import BasicAlgorithms.utils.ConsoleWriter;

/**
 * Created by hadoop on 23/10/17.
 */
public class SolveSudoku {
    int count = 0;
    public void solveSudoku(char[][] board) {
        int emptySlot = 0;
        for(int i=0;i<board.length;i++){
            for(int j=0;j<board[0].length;j++){
                if(board[i][j]=='.'){
                    emptySlot++;
                }
            }
        }
        boolean solveit = dfs(board,emptySlot);
    }

    private boolean dfs(char[][] board,int emptySlot) {
        count++;
        if(count>100000){
            System.exit(1);
        }
        if(emptySlot == 0){
            System.out.println("Entring here");
            return true;
        }
        System.out.println("em "+emptySlot);
        System.out.println("em "+count);

        for(int i=0;i<9;i++){
            for(int j=0;j<9;j++){
                if(board[i][j] =='.'){
                    for(char c='1';c<='9';c++){
                        if(isValid(board,c,i,j)){
                            System.out.println("i "+i);
                            System.out.println("j "+j );
                            board[i][j] = c;
                            emptySlot--;
                            if(dfs(board,emptySlot)){
                                return true;
                            }
                            board[i][j] = '.';
                            emptySlot++;
                        }
                    }
                    return false;
                }
                else {
                    continue;
                }
            }
        }
        return false;
    }

    private boolean isValid(char[][] board, char c, int row, int col) {
        for(int i=0;i<9;i++){
            if(board[i][col] == c ){
                return false;
            }
        }
        for(int j=0;j<9;j++){
            if(board[row][j] == c){
                return false;
            }
        }
        for(int i=(row/3)*3;i<(row/3)*3+3;i++){
            for(int j=(col/3)*3 ;j<(col/3)*3 +3;j++){
                if(board[i][j] == c){
                    return false;
                }
            }
        }
        return true;
    }

    public static void main(String[] args) {
        char [][]board = {{'.','.','9','7','4','8','.','.','.'},{'7','.','.','.','.','.','.','.','.'},{'.','2','.','1','.','9','.','.','.'},{'.','.','7','.','.','.','2','4','.'},{'.','6','4','.','1','.','5','9','.'},{'.','9','8','.','.','.','3','.','.'},{'.','.','.','8','.','3','.','2','.'},{'.','.','.','.','.','.','.','.','6'},{'.','.','.','2','7','5','9','.','.'}};
        ConsoleWriter.printIntArray(board);
        SolveSudoku solveSudoku = new SolveSudoku();
        solveSudoku.solveSudoku(board);
        ConsoleWriter.printIntArray(board);

    }
}package BasicAlgorithms.BackTracking;

/**
 * Created by hadoop on 22/10/17.
 */
import java.util.*;
public class CombinationSum {
        public List<List<Integer>> combinationSum(int[] nums, int target) {
            Arrays.sort(nums);
            List<Integer> path = new ArrayList<>();
            List<List<Integer>> list = new ArrayList<>();
            helper(nums,path,list,0,target);
            return list;
        }
        private void helper(int[] nums, List<Integer> path, List<List<Integer>> list, int index, int target) {
            if(target<0) return ;
            if(target == 0){
                list.add(new ArrayList<>(path));
                return;
            }
            for(int i=index;i<nums.length;i++){
                path.add(nums[i]);
                helper(nums,path,list,i,target-nums[i]);
                path.remove(path.size()-1);
                while (i<nums.length-1 && nums[i] == nums[i+1])i++;
            }
        }

    public static void main(String[] args) {
        int nums[] = {2, 3, 6, 7};
        int target = 7;
        CombinationSum combinationSum = new CombinationSum();
        System.out.println(combinationSum.combinationSum(nums,target));
    }
}
package BasicAlgorithms.BackTracking;
import java.util.*;
public class Permutation {
    public List<List<Integer>> permuteUnique(int[] nums) {
        boolean [] visited = new boolean[nums.length];

        List<Integer> path = new ArrayList<>();
        List<List<Integer>> result = new ArrayList<>();
        helper(nums,path,result,visited);
       // System.out.println(result);
        return result;
    }

    private void helper(int[] nums, List<Integer> path, List<List<Integer>> result, boolean[] visited) {
        if(path.size() == nums.length){
            result.add(new ArrayList<>(path));
        }
        for(int i=0;i<nums.length;i++){
            if(visited[i]) continue;
           // if(i>0 && nums[i] == nums[i-1] ) continue;
            visited[i] = true;
            path.add(nums[i]);
            helper(nums,path,result,visited);
            visited[i]= false;
            path.remove(path.size()-1);
            while (i < nums.length - 1 && nums[i] == nums[i + 1]) i++;
        }
    }
}package BasicAlgorithms.BackTracking;

/**
 * Created by hadoop on 22/10/17.
 */
import java.util.*;
public class CombinationSum2 {
    List<List<Integer>> combinationSum2(int []nums, int target){
        Arrays.sort(nums);
        List<Integer> path = new ArrayList<>();
        List<List<Integer>> list = new ArrayList<>();
        helper(nums,path,list,0,target);
        return list;
    }

    private void helper(int[] nums, List<Integer> path, List<List<Integer>> list, int index, int target) {
        if(target<0) return ;
        if(target == 0){
            list.add(new ArrayList<>(path));
            return;
        }
        for(int i=index;i<nums.length;i++){
            path.add(nums[i]);
            helper(nums,path,list,i+1,target-nums[i]);
            path.remove(path.size()-1);
            while (i<nums.length-1 && nums[i] == nums[i+1])i++;
        }
    }
}
package BasicAlgorithms.BackTracking;

/**
 * Created by hadoop on 22/10/17.
 */
import java.util.*;
public class Queens {
    Set<Integer> sameColumn = new HashSet<>();
    Set<Integer> sameRow = new HashSet<>();
    Set<Integer> sameDiagonalRow = new HashSet<>();
    int n;
    char board[][];
    List<List<String>> result = new ArrayList<>();
    List<String> path = new ArrayList<>();

    public List<List<String>> solveNQueens(int n) {
        this.n = n;
        board = new char[n][n];
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                board[i][j] = '.';
            }
        }
        int count = solveNQueensHelper(0,n);
        return result;
    }
    int solveNQueensHelper(int row,int length){
        path.clear();
        if(row == n){
            for(int i=0;i<row;i++){
                path.add(String.valueOf(board[i]));
            }
            result.add(new ArrayList<>(path));
            return 1;
        }
        int count =0;
        for(int column=0;column<n;column++){
            if(valid(row,column)){
                makeMove(row,column);
                count +=solveNQueensHelper(row+1,length);
                unmakeMove(row,column);
            }
        }
        return count;

    }

    private void unmakeMove(int row, int column) {
        board[row][column] ='.';
        sameColumn.remove(column);
        sameRow.remove(row-column+n);
        sameDiagonalRow.remove(row+column);
    }

    private void makeMove(int row, int column) {
        board[row][column] = 'Q';
        sameColumn.add(column);
        sameRow.add(row-column+n);
        sameDiagonalRow.add(row+column);
    }

    private boolean valid(int row, int column) {
        if(sameColumn.contains(column))
            return false;
        if(sameDiagonalRow.contains(row+column)){
            return false;
        }
        if(sameRow.contains(row-column+n)){
            return false;
        }
        return true;
    }
    public static void main(String args[]){
        Queens queens = new Queens();
        System.out.println(queens.solveNQueens(4));
    }

}package BasicAlgorithms.BackTracking;

import java.util.HashSet;

/**
 * Created by hadoop on 22/10/17.
 */
public class IsValidSudoku {
    public boolean isValid(char[][] board, int row, int col, char c) {
        for (int i = 0; i < board.length; i++) {
            if (i != row && board[i][col] == c) {
                return false;
            }
        }
        for (int j = 0; j < board[0].length; j++) {
            if (j != col && board[row][j] == c) {
                return false;
            }
        }
        for (int i = (row / 3) * 3; i < (row / 3) * 3 + 3; i++) {
            for (int j = (col / 3) * 3; j < (col / 3) * 3 + 3; j++) {
                if (i != row && j != col && board[i][j] == c) {
                    return false;
                }
            }
        }
        return true;
    }

    public boolean isValidSudoku(char[][] board) {
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[0].length; j++) {
                if (board[i][j] != '.' && !isValid(board, i, j, board[i][j])) {
                    return false;
                }
            }
        }
        return true;
    }

    public boolean isValidSudokuFaster(char[][] board) {
        for(int i=0;i<9;i++){
            if(!validrange(board,0,8,i,i)){
                return false;
            }
            if(!validrange(board,i,i,0,8)){
                return false;
            }
        }
        for(int i=0;i<9;i=i+3){
            for(int j=0;j<9;j=j+3){
                if(!validrange(board,i,i+2,j,j+2)){
                    return false;
                }
            }
        }
        return true;
    }

    private boolean validrange(char board[][],int xstart, int xend, int ystart, int yend) {
        HashSet<Character> hashSet = new HashSet<>();
        for(int i=xstart;i<=xend;i++){
            for(int j=ystart;j<=yend;j++){
                if(board[i][j] == '.'){
                    continue;
                }
                if(hashSet.contains(board[i][j])){
                    return false;
                }
                hashSet.add(board[i][j]);
            }
        }
        return true;
    }
}package BasicAlgorithms.BackTracking;

/**
 * Created by hadoop on 22/10/17.
 */
import java.util.*;
public class FactorCombinations {
    public List<List<Integer>> getFactors(int n) {
        List<Integer> path = new LinkedList<>();
        List<List<Integer>> result = new LinkedList<>();

        getFactorsHelper(2,n,path,result);
        return result;
    }

    private void getFactorsHelper(int start, int n, List<Integer> path, List<List<Integer>> result) {
        if(n == 1){
            if(path.size()>1) {
                result.add(new ArrayList<>(path));
            }
            return;
        }
        for(int i=start;i<=n;i++){
            if(n%i ==0){
                path.add(i);
                System.out.println(n/i);
                getFactorsHelper(i,n/i,path,result);
                path.remove(path.size()-1);
            }
        }
    }

    public static void main(String[] args) {
        FactorCombinations factorCombinations = new FactorCombinations();
        System.out.println(factorCombinations.getFactors(12));
    }
}package BasicAlgorithms.kth;

/**
 * Created by hadoop on 24/10/17.
 */
import java.util.*;
public class KthClosePoints {
    public List<Integer> findClosestElements(List<Integer> arr, int k, int x) {
        Collections.sort(arr, new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return Math.abs(o1-x) - Math.abs(o2-x);
            }
        });
        int index = 0;
        List<Integer> ans = new ArrayList<>();
        for(int a:arr){
            if(index == k){
                break;
            }
            index++;
            ans.add(a);
        }
        return ans;
    }
}package BasicAlgorithms.kth;

import java.util.Comparator;
import java.util.PriorityQueue;

/**
 * Created by hadoop on 24/10/17.
 */
public class KthSmallest {
    public int kthSmallest(int[][] matrix, int k){
        PriorityQueue<Entry> priorityQueue = new PriorityQueue<>(new Comparator<Entry>() {
            @Override
            public int compare(Entry o1, Entry o2) {
                return o1.value-o2.value;
            }
        });
        int m = matrix.length;
        int n = matrix[0].length;
        boolean visited[][] = new boolean[m][n];
        k =k-1;
        visited[0][0] = true;
        priorityQueue.add(new Entry(0,0,matrix[0][0]));
        int kthelement = -1;
        while (k-->0){
            Entry polled = priorityQueue.poll();
            if(isValid(polled.row +1,polled.column,visited)){
                priorityQueue.add(new Entry(polled.row+1,polled.column,matrix[polled.row+1][polled.column]));
                visited[polled.row+1][polled.column] = true;
            }

            if(isValid(polled.row,polled.column+1,visited)){
                priorityQueue.add(new Entry(polled.row,polled.column+1,matrix[polled.row][polled.column+1]));
                visited[polled.row][polled.column+1] = true;
            }
            kthelement = polled.value;
        }
        return kthelement;
    }

    private boolean isValid(int row, int column, boolean[][] visited) {
        int m = visited.length;
        int n = visited[0].length;
        if(row>=0 && row<m && column>=0 && column<n && !visited[row][column])
            return true;
        return false;
    }

    private class Entry{
        int row;
        int column;
        int value;

        public Entry(int row, int column, int value) {
            this.row = row;
            this.column = column;
            this.value = value;
        }
    }
}
package BasicAlgorithms.utils;

//import com.interview.basics.model.collection.list.LinkedList;
//import com.interview.basics.model.collection.list.Node;

import java.util.Collection;
import java.util.List;

public class ConsoleWriter {

	public static void printIntArray(int[] array){
		for(int i = 0; i < array.length; i++){
			System.out.print(array[i] + ", ");
		}
		System.out.println();
	}

    public static void printIntArray(Integer[] array){
        for(int i = 0; i < array.length; i++){
            System.out.print(array[i] + ", ");
        }
        System.out.println();
    }

    public static void printIntArray(int[][] array) {
        for(int i = 0; i < array.length; i++){
            for(int j = 0; j< array[0].length; j ++)
                System.out.print("\t" + (array[i][j] != Integer.MAX_VALUE? array[i][j] : "~"));
            System.out.println();
        }
    }

    public static void printIntArray(char[][] array) {
        for(int i = 0; i < array.length; i++){
            for(int j = 0; j< array[0].length; j ++)
                System.out.print("\t" + array[i][j]);
            System.out.println();
        }
    }

    public static void print(List<List<Integer>> cols){
        for(List<Integer> item : cols){
            for(Integer number : item){
                System.out.print(number + " ");
            }
            System.out.println();
        }
    }

    public static void printStringList(List<List<String>> cols){
        for(List<String> item : cols){
            for(String number : item){
                System.out.print(number + " ");
            }
            System.out.println();
        }
    }
    
    public static void printCollection(Collection col){
    	for(Object i : col){
			System.out.print(i.toString() + " ");
		}
		System.out.println();
    }

//    public static void printLinkedList(LinkedList list){
//        Node node = list.getHead();
//        while(node != null){
//            System.out.print(node.item.toString() + " ");
//            node = node.next;
//        }
//        System.out.println();
//    }

    public static void printBooleanArray(boolean[] array){
        for(int i = 0; i < array.length; i++){
            System.out.print(array[i] + " ");
        }
        System.out.println();
    }
    public static void printCharacterArray(Character[] array){
        for(int i = 0; i < array.length; i++){
            System.out.print(array[i]);
        }
        System.out.println();
    }

    public static void printListOfList(List<List<Integer>> cols){
        for(List<Integer> item : cols){
            for(Integer number : item){
                System.out.print(number + " ");
            }
            System.out.println();
        }
    }

    public static void printList(Collection list){
        for(Object obj : list) {
            System.out.println(obj.toString());
        }
    }
    
}
package BasicAlgorithms.Graph;

/*************************************************************************
 *  Compilation:  javac KosarajuSharirSCC.java
 *  Execution:    java KosarajuSharirSCC filename.txt
 *  Dependencies: Digraph.java TransitiveClosure.java StdOut.java In.java
 *  Data files:   http://algs4.cs.princeton.edu/42directed/tinyDG.txt
 *
 *  Compute the strongly-connected components of a digraph using the
 *  Kosaraju-Sharir algorithm.
 *
 *  Runs in O(E + V) time.
 *
 *  % java KosarajuSCC tinyDG.txt
 *  5 components
 *  1 
 *  0 2 3 4 5 
 *  9 10 11 12 
 *  6 
 *  7 8 
 *
 *  % java KosarajuSharirSCC mediumDG.txt 
 *  10 components
 *  21 
 *  2 5 6 8 9 11 12 13 15 16 18 19 22 23 25 26 28 29 30 31 32 33 34 35 37 38 39 40 42 43 44 46 47 48 49 
 *  14 
 *  3 4 17 20 24 27 36 
 *  41 
 *  7 
 *  45 
 *  1 
 *  0 
 *  10 
 *
 *************************************************************************/
import java.util.*;
public class KosarajuSharirSCC {
    private boolean[] marked;     // marked[v] = has vertex v been visited?
    private int[] id;             // id[v] = id of strong component containing v
    private int count;            // number of strongly-connected components


    public KosarajuSharirSCC(Digraph G) {

        // compute reverse postorder of reverse graph
        DepthFirstOrder dfs = new DepthFirstOrder(G.reverse());

        // run DFS on G, using reverse postorder to guide calculation
        marked = new boolean[G.V()];
        id = new int[G.V()];
        for (int v : dfs.reversePost()) {
            if (!marked[v]) {
                dfs(G, v);
                count++;
            }
        }

        // check that id[] gives strong components
        //assert check(G);
    }

    // DFS on graph G
    private void dfs(Digraph G, int v) { 
        marked[v] = true;
        id[v] = count;
        for (int w : G.adj(v)) {
            if (!marked[w]) dfs(G, w);
        }
    }

    // return the number of strongly connected components
    public int count() { return count; }

    // are v and w strongly connected?
    public boolean stronglyConnected(int v, int w) {
        return id[v] == id[w];
    }

    // id of strong component containing v
    public int id(int v) {
        return id[v];
    }

    // does the id[] array contain the strongly connected components?
//    private boolean check(Digraph G) {
//        TransitiveClosure tc = new TransitiveClosure(G);
//        for (int v = 0; v < G.V(); v++) {
//            for (int w = 0; w < G.V(); w++) {
//                if (stronglyConnected(v, w) != (tc.reachable(v, w) && tc.reachable(w, v)))
//                    return false;
//            }
//        }
//        return true;
//    }

    public static void main(String[] args) {
        In in = new In(args[0]);
        Digraph G = new Digraph(in);
        KosarajuSharirSCC scc = new KosarajuSharirSCC(G);

        // number of connected components
        int M = scc.count();
        StdOut.println(M + " components");

        // compute list of vertices in each strong component
        Queue<Integer>[] components = (Queue<Integer>[]) new Queue[M];
        for (int i = 0; i < M; i++) {
            components[i] = new Queue<Integer>();
        }
        for (int v = 0; v < G.V(); v++) {
            components[scc.id(v)].enqueue(v);
        }

        // print results
        for (int i = 0; i < M; i++) {
            for (int v : components[i]) {
                StdOut.print(v + " ");
            }
            StdOut.println();
        }

    }

}package BasicAlgorithms.Graph;

/**
 * Created by hadoop on 19/10/17.
 */
//public class GraphDefintionsImp {
//}
///A self-loop is an edge that connects a vertex to itself.
//Two edges are parallel if they connect the same pair of vertices.
//When an edge connects two vertices, we say that the vertices are adjacent to one another and that the edge is incident on both vertices.
//The degree of a vertex is the number of edges incident on it.
//The degree of a vertex is the number of edges incident on it.

//A path in a graph is a sequence of vertices connected by edges. A simple path is one with no repeated vertices.

//A cycle is a path (with at least one edge) whose first and last vertices are the same. A simple cycle is a cycle with no repeated edges or vertices (except the requisite repetition of the first and last vertices).
//The length of a path or a cycle is its number of edges.

//We say that one vertex is connected to another if there exists a path that contains both of them.

//A graph is connected if there is a path from every vertex to every other vertex.
//A graph that is not connected consists of a set of connected components, which are maximal connected subgraphs.
//An acyclic graph is a graph with no cycles.

//A tree is an acyclic connected graph.
//A spanning tree of a connected graph is a subgraph that contains all of that graph's vertices
// and is a single tree. A spanning forest of a graph is the union of the spanning trees of its connected components.
//A bipartite graph is a graph whose vertices we can divide into two sets such that all edges connect a vertex in one set with a vertex in the other set.

// accylic means no. of edges will be 1 less than nodes
//number of edges wil lbe one less than no. of nodes
//


// spanning tree contains all the verticesssss the most imp thing and is connected
//The degree of a vertex is the number of edges incident on it.
// degree of a vertex is the number of elemtns in the adjacency list ....
///******************************************************************************
 *  Compilation:  javac Bag.java
 *  Execution:    java Bag < input.txt
 *  Dependencies: StdIn.java StdOut.java
 *
 *  A generic bag or multiset, implemented using a singly-linked list.
 *
 *  % more tobe.txt 
 *  to be or not to - be - - that - - - is
 *
 *  % java Bag < tobe.txt
 *  size of bag = 14
 *  is
 *  -
 *  -
 *  -
 *  that
 *  -
 *  -
 *  be
 *  -
 *  to
 *  not
 *  or
 *  be
 *  to
 *
 ******************************************************************************/

package BasicAlgorithms.Graph;

import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 *  The {@code Bag} class represents a bag (or multiset) of 
 *  generic items. It supports insertion and iterating over the 
 *  items in arbitrary order.
 *  <p>
 *  This implementation uses a singly-linked list with a static nested class Node.
 *  textbook that uses a non-static nested class.
 *  The <em>add</em>, <em>isEmpty</em>, and <em>size</em> operations
 *  take constant time. Iteration takes time proportional to the number of items.
 *  <p>
 *  For additional documentation, see <a href="http://algs4.cs.princeton.edu/13stacks">Section 1.3</a> of
 *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
 *
 *  @author Robert Sedgewick
 *  @author Kevin Wayne
 *
 *  @param <Item> the generic type of an item in this bag
 */
public class Bag<Item> implements Iterable<Item> {
    private Node<Item> first;    // beginning of bag
    private int n;               // number of elements in bag

    // helper linked list class
    private static class Node<Item> {
        private Item item;
        private Node<Item> next;
    }

    /**
     * Initializes an empty bag.
     */
    public Bag() {
        first = null;
        n = 0;
    }

    /**
     * Returns true if this bag is empty.
     *
     * @return {@code true} if this bag is empty;
     *         {@code false} otherwise
     */
    public boolean isEmpty() {
        return first == null;
    }

    /**
     * Returns the number of items in this bag.
     *
     * @return the number of items in this bag
     */
    public int size() {
        return n;
    }

    /**
     * Adds the item to this bag.
     *
     * @param  item the item to add to this bag
     */
    public void add(Item item) {
        Node<Item> oldfirst = first;
        first = new Node<Item>();
        first.item = item;
        first.next = oldfirst;
        n++;
    }


    /**
     * Returns an iterator that iterates over the items in this bag in arbitrary order.
     *
     * @return an iterator that iterates over the items in this bag in arbitrary order
     */
    public Iterator<Item> iterator()  {
        return new ListIterator<Item>(first);  
    }

    // an iterator, doesn't implement remove() since it's optional
    private class ListIterator<Item> implements Iterator<Item> {
        private Node<Item> current;

        public ListIterator(Node<Item> first) {
            current = first;
        }

        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }

        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }

    /**
     * Unit tests the {@code Bag} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        Bag<String> bag = new Bag<String>();
        while (!StdIn.isEmpty()) {
            String item = StdIn.readString();
            bag.add(item);
        }

        StdOut.println("size of bag = " + bag.size());
        for (String s : bag) {
            StdOut.println(s);
        }
    }

}

/******************************************************************************
 *  Copyright 2002-2016, Robert Sedgewick and Kevin Wayne.
 *
 *  This file is part of algs4.jar, which accompanies the textbook
 *
 *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
 *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
 *      http://algs4.cs.princeton.edu
 *
 *
 *  algs4.jar is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  algs4.jar is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
 ******************************************************************************/package BasicAlgorithms.Graph;

import java.util.Iterator;

/**
 * Created by hadoop on 19/10/17.
 */
public class Queue<Item> implements Iterable<Item> {

    Node<Item> first;
    Node<Item> last;
    int n=0;
    private class Node<Item>{
        Node<Item> next;
        Item item;
    }

    Queue(){
        first = null;
        last = null;
        n =0;
    }
    boolean isEmpty(){
       return first == null;
    }
    int size(){
        return n;
    }
    public void enqueue(Item item) {
        Node<Item> node = new Node<>();
        node.item = item;
        if(first == null){
            first = last = node;
        }
        else {
            last.next = node;
            last = node;
        }
        n++;
    }
    public Item dequeue(){
        if(isEmpty()){
            return null;
        }
        Item returned = first.item;
        n--;
        if(first.next == null){
            last = first = null;
        }
        else {
            first = first.next;
        }
        return returned;
    }

        @Override
    public Iterator<Item> iterator() {
        return new ListIterator<>(first,last);
    }
    private class ListIterator<Item> implements Iterator<Item>{
        Node<Item> current;
        ListIterator(Node<Item> first,Node<Item> last){
            current = first;
        }
        @Override
        public boolean hasNext() {
            return current!=null;
        }

        @Override
        public Item next() {

            Item ans = current.item;
            current = current.next;
            return ans;
        }
    }
}
/******************************************************************************
 *  Compilation:  javac Graph.java        
 *  Execution:    java Graph input.txt
 *  Dependencies: Bag.java Stack.java In.java StdOut.java
 *  Data files:   http://algs4.cs.princeton.edu/41graph/tinyG.txt
 *                http://algs4.cs.princeton.edu/41graph/mediumG.txt
 *                http://algs4.cs.princeton.edu/41graph/largeG.txt
 *
 *  A graph, implemented using an array of sets.
 *  Parallel edges and self-loops allowed.
 *
 *  % java Graph tinyG.txt
 *  13 vertices, 13 edges 
 *  0: 6 2 1 5 
 *  1: 0 
 *  2: 0 
 *  3: 5 4 
 *  4: 5 6 3 
 *  5: 3 4 0 
 *  6: 0 4 
 *  7: 8 
 *  8: 7 
 *  9: 11 10 12 
 *  10: 9 
 *  11: 9 12 
 *  12: 11 9 
 *
 *  % java Graph mediumG.txt
 *  250 vertices, 1273 edges 
 *  0: 225 222 211 209 204 202 191 176 163 160 149 114 97 80 68 59 58 49 44 24 15 
 *  1: 220 203 200 194 189 164 150 130 107 72 
 *  2: 141 110 108 86 79 51 42 18 14 
 *  ...
 *  
 ******************************************************************************/

package BasicAlgorithms.Graph;

import java.util.NoSuchElementException;
import java.util.*;

/**
 *  The {@code Graph} class represents an undirected graph of vertices
 *  named 0 through <em>V</em>  1.
 *  It supports the following two primary operations: add an edge to the graph,
 *  iterate over all of the vertices adjacent to a vertex. It also provides
 *  methods for returning the number of vertices <em>V</em> and the number
 *  of edges <em>E</em>. Parallel edges and self-loops are permitted.
 *  By convention, a self-loop <em>v</em>-<em>v</em> appears in the
 *  adjacency list of <em>v</em> twice and contributes two to the degree
 *  of <em>v</em>.
 *  <p>
 *  This implementation uses an adjacency-lists representation, which 
 *  is a vertex-indexed array of {@link Bag} objects.
 *  All operations take constant time (in the worst case) except
 *  iterating over the vertices adjacent to a given vertex, which takes
 *  time proportional to the number of such vertices.
 *  <p>
 *  For additional documentation, see <a href="http://algs4.cs.princeton.edu/41graph">Section 4.1</a>
 *  of <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
 *
 *  @author Robert Sedgewick
 *  @author Kevin Wayne
 */
public class Graph {
    private static final String NEWLINE = System.getProperty("line.separator");

    // number of nodes which is v

    private final int V;
    // number of edges which is e
    private int E;
    /// array of list of interes
    // List<Integer> []array;
    //
    private Bag<Integer>[] adj;
    
    /**
     * Initializes an empty graph with {@code V} vertices and 0 edges.
     * param V the number of vertices
     *
     * @param  V number of vertices
     * @throws IllegalArgumentException if {@code V < 0}
     */
    // we are t
    public Graph(int V) {
        if (V < 0) throw new IllegalArgumentException("Number of vertices must be nonnegative");
        this.V = V;
        this.E = 0;
        adj = (Bag<Integer>[]) new Bag[V];
        for (int v = 0; v < V; v++) {
            adj[v] = new Bag<Integer>();
        }
    }

    /**  
     * Initializes a graph from the specified input stream.
     * The format is the number of vertices <em>V</em>,
     * followed by the number of edges <em>E</em>,
     * followed by <em>E</em> pairs of vertices, with each entry separated by whitespace.
     *
     * @param  in the input stream
     * @throws IllegalArgumentException if the endpoints of any edge are not in prescribed range
     * @throws IllegalArgumentException if the number of vertices or edges is negative
     * @throws IllegalArgumentException if the input stream is in the wrong format
     */
    public Graph(In in) {
        try {
            this.V = in.readInt();
            if (V < 0) throw new IllegalArgumentException("number of vertices in a Graph must be nonnegative");
            adj = (Bag<Integer>[]) new Bag[V];
            for (int v = 0; v < V; v++) {
                adj[v] = new Bag<Integer>();
            }
            int E = in.readInt();
            if (E < 0) throw new IllegalArgumentException("number of edges in a Graph must be nonnegative");
            for (int i = 0; i < E; i++) {
                int v = in.readInt();
                int w = in.readInt();
                validateVertex(v);
                validateVertex(w);
                addEdge(v, w); 
            }
        }
        catch (NoSuchElementException e) {
            throw new IllegalArgumentException("invalid input format in Graph constructor", e);
        }
    }


    /**
     * Initializes a new graph that is a deep copy of {@code G}.
     *
     * @param  G the graph to copy
     */
    public Graph(Graph G) {
        this(G.V());
        this.E = G.E();
        for (int v = 0; v < G.V(); v++) {
            // reverse so that adjacency list is in same order as original
            Stack<Integer> reverse = new Stack<Integer>();
            for (int w : G.adj[v]) {
                reverse.push(w);
            }
            for (int w : reverse) {
                adj[v].add(w);
            }
        }
    }

    /**
     * Returns the number of vertices in this graph.
     *
     * @return the number of vertices in this graph
     */
    public int V() {
        return V;
    }

    /**
     * Returns the number of edges in this graph.
     *
     * @return the number of edges in this graph
     */
    public int E() {
        return E;
    }

    // throw an IllegalArgumentException unless {@code 0 <= v < V}
    private void validateVertex(int v) {
        if (v < 0 || v >= V)
            throw new IllegalArgumentException("vertex " + v + " is not between 0 and " + (V-1));
    }

    /**
     * Adds the undirected edge v-w to this graph.
     *
     * @param  v one vertex in the edge
     * @param  w the other vertex in the edge
     * @throws IllegalArgumentException unless both {@code 0 <= v < V} and {@code 0 <= w < V}
     */
    public void addEdge(int v, int w) {
        validateVertex(v);
        validateVertex(w);
        E++;
        adj[v].add(w);
        adj[w].add(v);
    }


    /**
     * Returns the vertices adjacent to vertex {@code v}.
     *
     * @param  v the vertex
     * @return the vertices adjacent to vertex {@code v}, as an iterable
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public Iterable<Integer> adj(int v) {
        validateVertex(v);
        return adj[v];
    }

    /**
     * Returns the degree of vertex {@code v}.
     *
     * @param  v the vertex
     * @return the degree of vertex {@code v}
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public int degree(int v) {
        validateVertex(v);
        return adj[v].size();
    }


    /**
     * Returns a string representation of this graph.
     *
     * @return the number of vertices <em>V</em>, followed by the number of edges <em>E</em>,
     *         followed by the <em>V</em> adjacency lists
     */
    public String toString() {
        StringBuilder s = new StringBuilder();
        s.append(V + " vertices, " + E + " edges " + NEWLINE);
        for (int v = 0; v < V; v++) {
            s.append(v + ": ");
            for (int w : adj[v]) {
                s.append(w + " ");
            }
            s.append(NEWLINE);
        }
        return s.toString();
    }


    /**
     * Unit tests the {@code Graph} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        In in = new In(args[0]);
        Graph G = new Graph(in);
        StdOut.println(G);
    }

}

/******************************************************************************
 *  Copyright 2002-2016, Robert Sedgewick and Kevin Wayne.
 *
 *  This file is part of algs4.jar, which accompanies the textbook
 *
 *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
 *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
 *      http://algs4.cs.princeton.edu
 *
 *
 *  algs4.jar is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  algs4.jar is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
 ******************************************************************************/package BasicAlgorithms.Graph; /*************************************************************************
 *  Compilation:  javac Digraph.java
 *  Execution:    java Digraph filename.txt
 *  Dependencies: Bag.java In.java StdOut.java
 *  Data files:   http://algs4.cs.princeton.edu/42directed/tinyDG.txt
 *
 *  A graph, implemented using an array of lists.
 *  Parallel edges and self-loops are permitted.
 *
 *  % java Digraph tinyDG.txt
 *  13 22
 *  0: 5 1 
 *  1: 
 *  2: 0 3 
 *  3: 5 2 
 *  4: 3 2 
 *  5: 4 
 *  6: 9 4 0 
 *  7: 6 8 
 *  8: 7 9 
 *  9: 11 10 
 *  10: 12 
 *  11: 4 12 
 *  12: 9 
 *  
 *************************************************************************/



/**
 *  The <tt>Digraph</tt> class represents an directed graph of vertices
 *  named 0 through V-1.
 *  It supports the following operations: add an edge to the graph,
 *  iterate over all of the neighbors incident to a vertex.
 *  Parallel edges and self-loops are permitted.
 *  <p>
 *  For additional documentation,
 *  see <a href="http://algs4.cs.princeton.edu/42directed">Section 4.2</a> of
 *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
 */

import java.util.*;
public class Digraph {
    private final int V;
    private int E;
    private Bag<Integer>[] adj;
    
   /**
     * Create an empty digraph with V vertices.
     * @throws java.lang.IllegalArgumentException if V < 0
     */
    public Digraph(int V) {
        if (V < 0) throw new IllegalArgumentException("Number of vertices must be nonnegative");
        this.V = V;
        this.E = 0;
        adj = (Bag<Integer>[]) new Bag[V];
        for (int v = 0; v < V; v++) {
            adj[v] = new Bag<Integer>();
        }
    }

   /**
     * Create a digraph from input stream.
     */  
    public Digraph(In in) {
        this(in.readInt()); 
        int E = in.readInt();
        for (int i = 0; i < E; i++) {
            int v = in.readInt();
            int w = in.readInt();
            addEdge(v, w); 
        }
    }

   /**
     * Copy constructor.
     */
    public Digraph(Digraph G) {
        this(G.V());
        this.E = G.E();
        for (int v = 0; v < G.V(); v++) {
            // reverse so that adjacency list is in same order as original
            Stack<Integer> reverse = new Stack<Integer>();
            for (int w : G.adj[v]) {
                reverse.push(w);
            }
            for (int w : reverse) {
                adj[v].add(w);
            }
        }
    }
        
   /**
     * Return the number of vertices in the digraph.
     */
    public int V() {
        return V;
    }

   /**
     * Return the number of edges in the digraph.
     */
    public int E() {
        return E;
    }

   /**
     * Add the directed edge v->w to the digraph.
     * @throws java.lang.IndexOutOfBoundsException unless both 0 <= v < V and 0 <= w < V
     */
    public void addEdge(int v, int w) {
        if (v < 0 || v >= V) throw new IndexOutOfBoundsException();
        if (w < 0 || w >= V) throw new IndexOutOfBoundsException();
        adj[v].add(w);
        E++;
    }

   /**
     * Return the list of vertices pointed to from vertex v as an Iterable.
     * @throws java.lang.IndexOutOfBoundsException unless 0 <= v < V
     */
    public Iterable<Integer> adj(int v) {
        if (v < 0 || v >= V) throw new IndexOutOfBoundsException();
        return adj[v];
    }

   /**
     * Return the reverse of the digraph.
     */
    public Digraph reverse() {
        Digraph R = new Digraph(V);
        for (int v = 0; v < V; v++) {
            for (int w : adj(v)) {
                R.addEdge(w, v);
            }
        }
        return R;
    }

   /**
     * Return a string representation of the digraph.
     */
    public String toString() {
        StringBuilder s = new StringBuilder();
        String NEWLINE = System.getProperty("line.separator");
        s.append(V + " " + E + NEWLINE);
        for (int v = 0; v < V; v++) {
            s.append(String.format("%d: ", v));
            for (int w : adj[v]) {
                s.append(String.format("%d ", w));
            }
            s.append(NEWLINE);
        }
        return s.toString();
    }

   /**
     * Test client.
     */
    public static void main(String[] args) {
        In in = new In(args[0]);
        Digraph G = new Digraph(in);
        StdOut.println(G);

        StdOut.println();
        for (int v = 0; v < G.V(); v++)
            for (int w : G.adj(v))
                StdOut.println(v + "->" + w);
    }

}/******************************************************************************
 *  Compilation:  javac StdIn.java
 *  Execution:    java StdIn   (interactive test of basic functionality)
 *  Dependencies: none
 *
 *  Reads in data of various types from standard input.
 *
 ******************************************************************************/

package BasicAlgorithms.Graph;

import java.util.ArrayList;
import java.util.InputMismatchException;
import java.util.Locale;
import java.util.NoSuchElementException;
import java.util.Scanner;
import java.util.regex.Pattern;

/**
 *  The {@code StdIn} class provides static methods for reading strings
 *  and numbers from standard input.
 *  These functions fall into one of four categories:
 *  <ul>
 *  <li>those for reading individual tokens from standard input, one at a time,
 *      and converting each to a number, string, or boolean
 *  <li>those for reading characters from standard input, one at a time
 *  <li>those for reading lines from standard input, one at a time
 *  <li>those for reading a sequence of values of the same type from standard input,
 *      and returning the values in an array
 *  </ul>
 *  <p>
 *  Generally, it is best not to mix functions from the different
 *  categories in the same program. 
 *  <p>
 *  <b>Reading tokens from standard input and converting to numbers and strings.</b>
 *  You can use the following methods to read numbers, strings, and booleans
 *  from standard input one at a time:
 *  <ul>
 *  <li> {@link #isEmpty()}
 *  <li> {@link #readInt()}
 *  <li> {@link #readDouble()}
 *  <li> {@link #readString()}
 *  <li> {@link #readShort()}
 *  <li> {@link #readLong()}
 *  <li> {@link #readFloat()}
 *  <li> {@link #readByte()}
 *  <li> {@link #readBoolean()}
 *  </ul>
 *  <p>
 *  The first method returns true if standard input has more tokens.
 *  Each other method skips over any input that is whitespace. Then, it reads
 *  the next token and attempts to convert it into a value of the specified
 *  type. If it succeeds, it returns that value; otherwise, it
 *  throws an {@link InputMismatchException}.
 *  <p>
 *  <em>Whitespace</em> includes spaces, tabs, and newlines; the full definition
 *  is inherited from {@link Character#isWhitespace(char)}.
 *  A <em>token</em> is a maximal sequence of non-whitespace characters.
 *  The precise rules for describing which tokens can be converted to
 *  integers and floating-Point numbers are inherited from
 *  <a href = "http://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html#number-syntax">Scanner</a>,
 *  using the locale {@link Locale#US}; the rules
 *  for floating-Point numbers are slightly different
 *  from those in {@link Double#valueOf(String)},
 *  but unlikely to be of concern to most programmers.
 *  <p>
 *  As an example, the following code fragment reads integers from standard input,
 *  one at a time, and prints them one per line.
 *  <pre>
 *  while (!StdIn.isEmpty()) {
 *      double value = StdIn.readDouble();
 *      StdOut.println(value);
 *  }
 *  StdOut.println(sum);
 *  </pre>
 *  <p>
 *  <b>Reading characters from standard input.</b>
 *  You can use the following two methods to read characters from standard input one at a time:
 *  <ul>
 *  <li> {@link #hasNextChar()}
 *  <li> {@link #readChar()}
 *  </ul>
 *  <p>
 *  The first method returns true if standard input has more input (including whitespace).
 *  The second method reads and returns the next character of input on standard 
 *  input (possibly a whitespace character).
 *  <p>
 *  As an example, the following code fragment reads characters from standard input,
 *  one character at a time, and prints it to standard output.
 *  <pre>
 *  while (StdIn.hasNextChar()) {
 *      char c = StdIn.readChar();
 *      StdOut.print(c);
 *  }
 *  </pre>
 *  <p>
 *  <b>Reading lines from standard input.</b>
 *  You can use the following two methods to read lines from standard input:
 *  <ul>
 *  <li> {@link #hasNextLine()}
 *  <li> {@link #readLine()}
 *  </ul>
 *  <p>
 *  The first method returns true if standard input has more input (including whitespace).
 *  The second method reads and returns the remaining portion of 
 *  the next line of input on standard input (possibly whitespace),
 *  discarding the trailing line separator.
 *  <p>
 *  A <em>line separator</em> is defined to be one of the following strings:
 *  {@code \n} (Linux), {@code \r} (old Macintosh),
 *  {@code \r\n} (Windows),
 *  {@code \}{@code u2028}, {@code \}{@code u2029}, or {@code \}{@code u0085}.
 *  <p>
 *  As an example, the following code fragment reads text from standard input,
 *  one line at a time, and prints it to standard output.
 *  <pre>
 *  while (StdIn.hasNextLine()) {
 *      String line = StdIn.readLine();
 *      StdOut.println(line);
 *  }
 *  </pre>
 *  <p>
 *  <b>Reading a sequence of values of the same type from standard input.</b>
 *  You can use the following methods to read a sequence numbers, strings,
 *  or booleans (all of the same type) from standard input:
 *  <ul>
 *  <li> {@link #readAllDoubles()}
 *  <li> {@link #readAllInts()}
 *  <li> {@link #readAllLongs()}
 *  <li> {@link #readAllStrings()}
 *  <li> {@link #readAllLines()}
 *  <li> {@link #readAll()}
 *  </ul>
 *  <p>
 *  The first three methods read of all of remaining token on standard input
 *  and converts the tokens to values of
 *  the specified type, as in the corresponding
 *  {@code readDouble}, {@code readInt}, and {@code readString()} methods.
 *  The {@code readAllLines()} method reads all remaining lines on standard
 *  input and returns them as an array of strings.
 *  The {@code readAll()} method reads all remaining input on standard
 *  input and returns it as a string.
 *  <p>
 *  As an example, the following code fragment reads all of the remaining
 *  tokens from standard input and returns them as an array of strings.
 *  <pre>
 *  String[] words = StdIn.readAllStrings();
 *  </pre>
 *  <p>
 *  <b>Differences with Scanner.</b>
 *  {@code StdIn} and {@link Scanner} are both designed to parse 
 *  tokens and convert them to primitive types and strings.
 *  The main differences are summarized below:
 *  <ul>
 *  <li> {@code StdIn} is a set of static methods and reads 
 *       reads input from only standard input. It is suitable for use before
 *       a programmer knows about objects.
 *       See {@link In} for an object-oriented version that handles
 *       input from files, URLs,
 *       and sockets.
 *  <li> {@code StdIn} uses whitespace as the delimiter pattern
 *       that separates tokens.
 *       {@link Scanner} supports arbitrary delimiter patterns.
 *  <li> {@code StdIn} coerces the character-set encoding to UTF-8,
 *       which is the most widely used character encoding for Unicode.
 *  <li> {@code StdIn} coerces the locale to {@link Locale#US},
 *       for consistency with {@link StdOut}, {@link Double#parseDouble(String)},
 *       and floating-Point literals.
 *  <li> {@code StdIn} has convenient methods for reading a single
 *       character; reading in sequences of integers, doubles, or strings;
 *       and reading in all of the remaining input.
 *  </ul>
 *  <p>
 *  Historical note: {@code StdIn} preceded {@code Scanner}; when
 *  {@code Scanner} was introduced, this class was re-implemented to use {@code Scanner}.
 *  <p>
 *  <b>Using standard input.</b>
 *  Standard input is fundamental operating system abstraction, on Mac OS X,
 *  Windows, and Linux.
 *  The methods in {@code StdIn} are <em>blocking</em>, which means that they
 *  will wait until you enter input on standard input.
 *  If your program has a loop that repeats until standard input is empty,
 *  you must signal that the input is finished.
 *  To do so, depending on your operating system and IDE, 
 *  use either {@code <Ctrl-d>} or {@code <Ctrl-z>}, on its own line.
 *  If you are redirecting standard input from a file, you will not need
 *  to do anything to signal that the input is finished.
 *  <p>
 *  <b>Known bugs.</b>
 *  Java's UTF-8 encoding does not recognize the optional 
 *  <a href = "http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058">byte-order mask</a>.
 *  If the input begins with the optional byte-order mask, {@code StdIn}
 *  will have an extra character {@code \}{@code uFEFF} at the beginning.
 *  <p>
 *  <b>Reference.</b> 
 *  For additional documentation,
 *  see <a href="http://introcs.cs.princeton.edu/15inout">Section 1.5</a> of   
 *  <em>Computer Science: An Interdisciplinary Approach</em>
 *  by Robert Sedgewick and Kevin Wayne.
 *
 *  @author Robert Sedgewick
 *  @author Kevin Wayne
 *  @author David Pritchard
 */
public final class StdIn {

    /*** begin: section (1 of 2) of code duplicated from In to StdIn. */
    
    // assume Unicode UTF-8 encoding
    private static final String CHARSET_NAME = "UTF-8";

    // assume language = English, country = US for consistency with System.out.
    private static final Locale LOCALE = Locale.US;

    // the default token separator; we maintain the invariant that this value
    // is held by the scanner's delimiter between calls
    private static final Pattern WHITESPACE_PATTERN = Pattern.compile("\\p{javaWhitespace}+");

    // makes whitespace significant
    private static final Pattern EMPTY_PATTERN = Pattern.compile("");

    // used to read the entire input
    private static final Pattern EVERYTHING_PATTERN = Pattern.compile("\\A");

    /*** end: section (1 of 2) of code duplicated from In to StdIn. */

    private static Scanner scanner;
 
    // it doesn't make sense to instantiate this class
    private StdIn() { }

    //// begin: section (2 of 2) of code duplicated from In to StdIn,
    //// with all methods changed from "public" to "public static"

   /**
     * Returns true if standard input is empty (except possibly for whitespace).
     * Use this method to know whether the next call to {@link #readString()}, 
     * {@link #readDouble()}, etc will succeed.
     *
     * @return {@code true} if standard input is empty (except possibly
     *         for whitespace); {@code false} otherwise
     */
    public static boolean isEmpty() {
        return !scanner.hasNext();
    }

   /**
     * Returns true if standard input has a next line.
     * Use this method to know whether the
     * next call to {@link #readLine()} will succeed.
     * This method is functionally equivalent to {@link #hasNextChar()}.
     *
     * @return {@code true} if standard input has more input (including whitespace);
     *         {@code false} otherwise
     */
    public static boolean hasNextLine() {
        return scanner.hasNextLine();
    }

    /**
     * Returns true if standard input has more input (including whitespace).
     * Use this method to know whether the next call to {@link #readChar()} will succeed.
     * This method is functionally equivalent to {@link #hasNextLine()}.
     *
     * @return {@code true} if standard input has more input (including whitespace);
     *         {@code false} otherwise
     */
    public static boolean hasNextChar() {
        scanner.useDelimiter(EMPTY_PATTERN);
        boolean result = scanner.hasNext();
        scanner.useDelimiter(WHITESPACE_PATTERN);
        return result;
    }


   /**
     * Reads and returns the next line, excluding the line separator if present.
     *
     * @return the next line, excluding the line separator if present;
     *         {@code null} if no such line
     */
    public static String readLine() {
        String line;
        try {
            line = scanner.nextLine();
        }
        catch (NoSuchElementException e) {
            line = null;
        }
        return line;
    }

    /**
     * Reads and returns the next character.
     *
     * @return the next {@code char}
     * @throws NoSuchElementException if standard input is empty
     */
    public static char readChar() {
        try {
            scanner.useDelimiter(EMPTY_PATTERN);
            String ch = scanner.next();
            assert ch.length() == 1 : "Internal (Std)In.readChar() error!"
                + " Please contact the authors.";
            scanner.useDelimiter(WHITESPACE_PATTERN);
            return ch.charAt(0);
        }
        catch (NoSuchElementException e) {
            throw new NoSuchElementException("attempts to read a 'char' value from standard input, but there are no more tokens available");
        }
    }  


   /**
     * Reads and returns the remainder of the input, as a string.
     *
     * @return the remainder of the input, as a string
     * @throws NoSuchElementException if standard input is empty
     */
    public static String readAll() {
        if (!scanner.hasNextLine())
            return "";

        String result = scanner.useDelimiter(EVERYTHING_PATTERN).next();
        // not that important to reset delimeter, since now scanner is empty
        scanner.useDelimiter(WHITESPACE_PATTERN); // but let's do it anyway
        return result;
    }


   /**
     * Reads the next token  and returns the {@code String}.
     *
     * @return the next {@code String}
     * @throws NoSuchElementException if standard input is empty
     */
    public static String readString() {
        try {
            return scanner.next();
        }
        catch (NoSuchElementException e) {
            throw new NoSuchElementException("attempts to read a 'String' value from standard input, but there are no more tokens available");
        }
    }

   /**
     * Reads the next token from standard input, parses it as an integer, and returns the integer.
     *
     * @return the next integer on standard input
     * @throws NoSuchElementException if standard input is empty
     * @throws InputMismatchException if the next token cannot be parsed as an {@code int}
     */
    public static int readInt() {
        try {
            return scanner.nextInt();
        }
        catch (InputMismatchException e) {
            String token = scanner.next();
            throw new InputMismatchException("attempts to read an 'int' value from standard input, but the next token is \"" + token + "\"");
        }
        catch (NoSuchElementException e) {
            throw new NoSuchElementException("attemps to read an 'int' value from standard input, but there are no more tokens available");
        }

    }

   /**
     * Reads the next token from standard input, parses it as a double, and returns the double.
     *
     * @return the next double on standard input
     * @throws NoSuchElementException if standard input is empty
     * @throws InputMismatchException if the next token cannot be parsed as a {@code double}
     */
    public static double readDouble() {
        try {
            return scanner.nextDouble();
        }
        catch (InputMismatchException e) {
            String token = scanner.next();
            throw new InputMismatchException("attempts to read a 'double' value from standard input, but the next token is \"" + token + "\"");
        }
        catch (NoSuchElementException e) {
            throw new NoSuchElementException("attempts to read a 'double' value from standard input, but there are no more tokens available");
        }
    }

   /**
     * Reads the next token from standard input, parses it as a float, and returns the float.
     *
     * @return the next float on standard input
     * @throws NoSuchElementException if standard input is empty
     * @throws InputMismatchException if the next token cannot be parsed as a {@code float}
     */
    public static float readFloat() {
        try {
            return scanner.nextFloat();
        }
        catch (InputMismatchException e) {
            String token = scanner.next();
            throw new InputMismatchException("attempts to read a 'float' value from standard input, but the next token is \"" + token + "\"");
        }
        catch (NoSuchElementException e) {
            throw new NoSuchElementException("attempts to read a 'float' value from standard input, but there are no more tokens available");
        }
    }

   /**
     * Reads the next token from standard input, parses it as a long integer, and returns the long integer.
     *
     * @return the next long integer on standard input
     * @throws NoSuchElementException if standard input is empty
     * @throws InputMismatchException if the next token cannot be parsed as a {@code long}
     */
    public static long readLong() {
        try {
            return scanner.nextLong();
        }
        catch (InputMismatchException e) {
            String token = scanner.next();
            throw new InputMismatchException("attempts to read a 'long' value from standard input, but the next token is \"" + token + "\"");
        }
        catch (NoSuchElementException e) {
            throw new NoSuchElementException("attempts to read a 'long' value from standard input, but there are no more tokens available");
        }
    }

   /**
     * Reads the next token from standard input, parses it as a short integer, and returns the short integer.
     *
     * @return the next short integer on standard input
     * @throws NoSuchElementException if standard input is empty
     * @throws InputMismatchException if the next token cannot be parsed as a {@code short}
     */
    public static short readShort() {
        try {
            return scanner.nextShort();
        }
        catch (InputMismatchException e) {
            String token = scanner.next();
            throw new InputMismatchException("attempts to read a 'short' value from standard input, but the next token is \"" + token + "\"");
        }
        catch (NoSuchElementException e) {
            throw new NoSuchElementException("attempts to read a 'short' value from standard input, but there are no more tokens available");
        }
    }

   /**
     * Reads the next token from standard input, parses it as a byte, and returns the byte.
     *
     * @return the next byte on standard input
     * @throws NoSuchElementException if standard input is empty
     * @throws InputMismatchException if the next token cannot be parsed as a {@code byte}
     */
    public static byte readByte() {
        try {
            return scanner.nextByte();
        }
        catch (InputMismatchException e) {
            String token = scanner.next();
            throw new InputMismatchException("attempts to read a 'byte' value from standard input, but the next token is \"" + token + "\"");
        }
        catch (NoSuchElementException e) {
            throw new NoSuchElementException("attempts to read a 'byte' value from standard input, but there are no more tokens available");
        }
    }

    /**
     * Reads the next token from standard input, parses it as a boolean,
     * and returns the boolean.
     *
     * @return the next boolean on standard input
     * @throws NoSuchElementException if standard input is empty
     * @throws InputMismatchException if the next token cannot be parsed as a {@code boolean}:
     *    {@code true} or {@code 1} for true, and {@code false} or {@code 0} for false,
     *    ignoring case
     */
    public static boolean readBoolean() {
        try {
            String token = readString();
            if ("true".equalsIgnoreCase(token))  return true;
            if ("false".equalsIgnoreCase(token)) return false;
            if ("1".equals(token))               return true;
            if ("0".equals(token))               return false;
            throw new InputMismatchException("attempts to read a 'boolean' value from standard input, but the next token is \"" + token + "\"");
        }
        catch (NoSuchElementException e) {
            throw new NoSuchElementException("attempts to read a 'boolean' value from standard input, but there are no more tokens available");
        }

    }

    /**
     * Reads all remaining tokens from standard input and returns them as an array of strings.
     *
     * @return all remaining tokens on standard input, as an array of strings
     */
    public static String[] readAllStrings() {
        // we could use readAll.trim().split(), but that's not consistent
        // because trim() uses characters 0x00..0x20 as whitespace
        String[] tokens = WHITESPACE_PATTERN.split(readAll());
        if (tokens.length == 0 || tokens[0].length() > 0)
            return tokens;

        // don't include first token if it is leading whitespace
        String[] decapitokens = new String[tokens.length-1];
        for (int i = 0; i < tokens.length - 1; i++)
            decapitokens[i] = tokens[i+1];
        return decapitokens;
    }

    /**
     * Reads all remaining lines from standard input and returns them as an array of strings.
     * @return all remaining lines on standard input, as an array of strings
     */
    public static String[] readAllLines() {
        ArrayList<String> lines = new ArrayList<String>();
        while (hasNextLine()) {
            lines.add(readLine());
        }
        return lines.toArray(new String[lines.size()]);
    }

    /**
     * Reads all remaining tokens from standard input, parses them as integers, and returns
     * them as an array of integers.
     * @return all remaining integers on standard input, as an array
     * @throws InputMismatchException if any token cannot be parsed as an {@code int}
     */
    public static int[] readAllInts() {
        String[] fields = readAllStrings();
        int[] vals = new int[fields.length];
        for (int i = 0; i < fields.length; i++)
            vals[i] = Integer.parseInt(fields[i]);
        return vals;
    }

    /**
     * Reads all remaining tokens from standard input, parses them as longs, and returns
     * them as an array of longs.
     * @return all remaining longs on standard input, as an array
     * @throws InputMismatchException if any token cannot be parsed as a {@code long}
     */
    public static long[] readAllLongs() {
        String[] fields = readAllStrings();
        long[] vals = new long[fields.length];
        for (int i = 0; i < fields.length; i++)
            vals[i] = Long.parseLong(fields[i]);
        return vals;
    }

    /**
     * Reads all remaining tokens from standard input, parses them as doubles, and returns
     * them as an array of doubles.
     * @return all remaining doubles on standard input, as an array
     * @throws InputMismatchException if any token cannot be parsed as a {@code double}
     */
    public static double[] readAllDoubles() {
        String[] fields = readAllStrings();
        double[] vals = new double[fields.length];
        for (int i = 0; i < fields.length; i++)
            vals[i] = Double.parseDouble(fields[i]);
        return vals;
    }
    
    //// end: section (2 of 2) of code duplicated from In to StdIn
    
    
    // do this once when StdIn is initialized
    static {
        resync();
    }

    /**
     * If StdIn changes, use this to reinitialize the scanner.
     */
    private static void resync() {
        setScanner(new Scanner(new java.io.BufferedInputStream(System.in), CHARSET_NAME));
    }
    
    private static void setScanner(Scanner scanner) {
        StdIn.scanner = scanner;
        StdIn.scanner.useLocale(LOCALE);
    }

   /**
     * Reads all remaining tokens, parses them as integers, and returns
     * them as an array of integers.
     * @return all remaining integers, as an array
     * @throws InputMismatchException if any token cannot be parsed as an {@code int}
     * @deprecated Replaced by {@link #readAllInts()}.
     */
    @Deprecated
    public static int[] readInts() {
        return readAllInts();
    }

   /**
     * Reads all remaining tokens, parses them as doubles, and returns
     * them as an array of doubles.
     * @return all remaining doubles, as an array
     * @throws InputMismatchException if any token cannot be parsed as a {@code double}
     * @deprecated Replaced by {@link #readAllDoubles()}.
     */
    @Deprecated
    public static double[] readDoubles() {
        return readAllDoubles();
    }

   /**
     * Reads all remaining tokens and returns them as an array of strings.
     * @return all remaining tokens, as an array of strings
     * @deprecated Replaced by {@link #readAllStrings()}.
     */
    @Deprecated
    public static String[] readStrings() {
        return readAllStrings();
    }


    /**
     * Interactive test of basic functionality.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {

        StdOut.print("Type a string: ");
        String s = StdIn.readString();
        StdOut.println("Your string was: " + s);
        StdOut.println();

        StdOut.print("Type an int: ");
        int a = StdIn.readInt();
        StdOut.println("Your int was: " + a);
        StdOut.println();

        StdOut.print("Type a boolean: ");
        boolean b = StdIn.readBoolean();
        StdOut.println("Your boolean was: " + b);
        StdOut.println();

        StdOut.print("Type a double: ");
        double c = StdIn.readDouble();
        StdOut.println("Your double was: " + c);
        StdOut.println();
    }

}

/******************************************************************************
 *  Copyright 2002-2016, Robert Sedgewick and Kevin Wayne.
 *
 *  This file is part of algs4.jar, which accompanies the textbook
 *
 *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
 *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
 *      http://algs4.cs.princeton.edu
 *
 *
 *  algs4.jar is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  algs4.jar is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
 ******************************************************************************//******************************************************************************
 *  Compilation:  javac StdOut.java
 *  Execution:    java StdOut
 *  Dependencies: none
 *
 *  Writes data of various types to standard output.
 *
 ******************************************************************************/

package BasicAlgorithms.Graph;

import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.UnsupportedEncodingException;
import java.util.Locale;

/**
 *  This class provides methods for printing strings and numbers to standard output.
 *  <p>
 *  <b>Getting started.</b>
 *  To use this class, you must have {@code StdOut.class} in your
 *  Java classpath. If you used our autoinstaller, you should be all set.
 *  Otherwise, download
 *  <a href = "http://introcs.cs.princeton.edu/java/stdlib/StdOut.java">StdOut.java</a>
 *  and put a copy in your working directory.
 *  <p>
 *  Here is an example program that uses {@code StdOut}:
 *  <pre>
 *   public class TestStdOut {
 *       public static void main(String[] args) {
 *           int a = 17;
 *           int b = 23;
 *           int sum = a + b;
 *           StdOut.println("Hello, World");
 *           StdOut.printf("%d + %d = %d\n", a, b, sum);
 *       }
 *   }
 *  </pre>
 *  <p>
 *  <b>Differences with System.out.</b>
 *  The behavior of {@code StdOut} is similar to that of {@link System#out},
 *  but there are a few subtle differences:
 *  <ul>
 *  <li> {@code StdOut} coerces the character-set encoding to UTF-8,
 *       which is a standard character encoding for Unicode.
 *  <li> {@code StdOut} coerces the locale to {@link Locale#US},
 *       for consistency with {@link StdIn}, {@link Double#parseDouble(String)},
 *       and floating-Point literals.
 *  <li> {@code StdOut} <em>flushes</em> standard output after each call to
 *       {@code print()} so that text will appear immediately in the terminal.
 *  </ul>
 *  <p>
 *  <b>Reference.</b>
 *  For additional documentation,
 *  see <a href="http://introcs.cs.princeton.edu/15inout">Section 1.5</a> of
 *  <em>Computer Science: An Interdisciplinary Approach</em>
 *  by Robert Sedgewick and Kevin Wayne.
 *
 *  @author Robert Sedgewick
 *  @author Kevin Wayne
 */
public final class StdOut {

    // force Unicode UTF-8 encoding; otherwise it's system dependent
    private static final String CHARSET_NAME = "UTF-8";

    // assume language = English, country = US for consistency with StdIn
    private static final Locale LOCALE = Locale.US;

    // send output here
    private static PrintWriter out;

    // this is called before invoking any methods
    static {
        try {
            out = new PrintWriter(new OutputStreamWriter(System.out, CHARSET_NAME), true);
        }
        catch (UnsupportedEncodingException e) {
            System.out.println(e);
        }
    }

    // don't instantiate
    private StdOut() { }

   /**
     * Closes standard output.
     */
    public static void close() {
        out.close();
    }

   /**
     * Terminates the current line by printing the line-separator string.
     */
    public static void println() {
        out.println();
    }

   /**
     * Prints an object to this output stream and then terminates the line.
     *
     * @param x the object to print
     */
    public static void println(Object x) {
        out.println(x);
    }

   /**
     * Prints a boolean to standard output and then terminates the line.
     *
     * @param x the boolean to print
     */
    public static void println(boolean x) {
        out.println(x);
    }

   /**
     * Prints a character to standard output and then terminates the line.
     *
     * @param x the character to print
     */
    public static void println(char x) {
        out.println(x);
    }

   /**
     * Prints a double to standard output and then terminates the line.
     *
     * @param x the double to print
     */
    public static void println(double x) {
        out.println(x);
    }

   /**
     * Prints an integer to standard output and then terminates the line.
     *
     * @param x the integer to print
     */
    public static void println(float x) {
        out.println(x);
    }

   /**
     * Prints an integer to standard output and then terminates the line.
     *
     * @param x the integer to print
     */
    public static void println(int x) {
        out.println(x);
    }

   /**
     * Prints a long to standard output and then terminates the line.
     *
     * @param x the long to print
     */
    public static void println(long x) {
        out.println(x);
    }

   /**
     * Prints a short integer to standard output and then terminates the line.
     *
     * @param x the short to print
     */
    public static void println(short x) {
        out.println(x);
    }

   /**
     * Prints a byte to standard output and then terminates the line.
     * <p>
     * To write binary data, see {@link BinaryStdOut}.
     *
     * @param x the byte to print
     */
    public static void println(byte x) {
        out.println(x);
    }

   /**
     * Flushes standard output.
     */
    public static void print() {
        out.flush();
    }

   /**
     * Prints an object to standard output and flushes standard output.
     * 
     * @param x the object to print
     */
    public static void print(Object x) {
        out.print(x);
        out.flush();
    }

   /**
     * Prints a boolean to standard output and flushes standard output.
     * 
     * @param x the boolean to print
     */
    public static void print(boolean x) {
        out.print(x);
        out.flush();
    }

   /**
     * Prints a character to standard output and flushes standard output.
     * 
     * @param x the character to print
     */
    public static void print(char x) {
        out.print(x);
        out.flush();
    }

   /**
     * Prints a double to standard output and flushes standard output.
     * 
     * @param x the double to print
     */
    public static void print(double x) {
        out.print(x);
        out.flush();
    }

   /**
     * Prints a float to standard output and flushes standard output.
     * 
     * @param x the float to print
     */
    public static void print(float x) {
        out.print(x);
        out.flush();
    }

   /**
     * Prints an integer to standard output and flushes standard output.
     * 
     * @param x the integer to print
     */
    public static void print(int x) {
        out.print(x);
        out.flush();
    }

   /**
     * Prints a long integer to standard output and flushes standard output.
     * 
     * @param x the long integer to print
     */
    public static void print(long x) {
        out.print(x);
        out.flush();
    }

   /**
     * Prints a short integer to standard output and flushes standard output.
     * 
     * @param x the short integer to print
     */
    public static void print(short x) {
        out.print(x);
        out.flush();
    }

   /**
     * Prints a byte to standard output and flushes standard output.
     *
     * @param x the byte to print
     */
    public static void print(byte x) {
        out.print(x);
        out.flush();
    }

   /**
     * Prints a formatted string to standard output, using the specified format
     * string and arguments, and then flushes standard output.
     *
     *
     * @param format the <a href = "http://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html#syntax">format string</a>
     * @param args   the arguments accompanying the format string
     */
    public static void printf(String format, Object... args) {
        out.printf(LOCALE, format, args);
        out.flush();
    }

   /**
     * Prints a formatted string to standard output, using the locale and
     * the specified format string and arguments; then flushes standard output.
     *
     * @param locale the locale
     * @param format the <a href = "http://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html#syntax">format string</a>
     * @param args   the arguments accompanying the format string
     */
    public static void printf(Locale locale, String format, Object... args) {
        out.printf(locale, format, args);
        out.flush();
    }

   /**
     * Unit tests some of the methods in {@code StdOut}.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {

        // write to stdout
        StdOut.println("Test");
        StdOut.println(17);
        StdOut.println(true);
        StdOut.printf("%.6f\n", 1.0/7.0);
    }

}

/******************************************************************************
 *  Copyright 2002-2016, Robert Sedgewick and Kevin Wayne.
 *
 *  This file is part of algs4.jar, which accompanies the textbook
 *
 *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
 *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
 *      http://algs4.cs.princeton.edu
 *
 *
 *  algs4.jar is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  algs4.jar is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
 ******************************************************************************//******************************************************************************
 *  Compilation:  javac In.java
 *  Execution:    java In   (basic test --- see source for required files)
 *  Dependencies: none
 *
 *  Reads in data of various types from standard input, files, and URLs.
 *
 ******************************************************************************/

package BasicAlgorithms.Graph;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.net.Socket;
// import java.net.HttpURLConnection;
import java.net.URLConnection;
import java.util.ArrayList;
import java.util.InputMismatchException;
import java.util.Locale;
import java.util.NoSuchElementException;
import java.util.Scanner;
import java.util.regex.Pattern;

/**
 *  <i>Input</i>. This class provides methods for reading strings
 *  and numbers from standard input, file input, URLs, and sockets. 
 *  <p>
 *  The Locale used is: language = English, country = US. This is consistent
 *  with the formatting conventions with Java floating-Point literals,
 *  command-line arguments (via {@link Double#parseDouble(String)})
 *  and standard output. 
 *  <p>
 *  For additional documentation, see 
 *  <a href="http://introcs.cs.princeton.edu/31datatype">Section 3.1</a> of
 *  <i>Computer Science: An Interdisciplinary Approach</i> 
 *  by Robert Sedgewick and Kevin Wayne.
 *  <p>
 *  Like {@link Scanner}, reading a token also consumes preceding Java
 *  whitespace, reading a full line consumes
 *  the following end-of-line delimeter, while reading a character consumes
 *  nothing extra. 
 *  <p>
 *  Whitespace is defined in {@link Character#isWhitespace(char)}. Newlines
 *  consist of \n, \r, \r\n, and Unicode hex code points 0x2028, 0x2029, 0x0085;
 *  see <a href="http://www.docjar.com/html/api/java/util/Scanner.java.html">
 *  Scanner.java</a> (NB: Java 6u23 and earlier uses only \r, \r, \r\n).
 *
 *  @author David Pritchard
 *  @author Robert Sedgewick
 *  @author Kevin Wayne
 */
public final class In {
    
    ///// begin: section (1 of 2) of code duplicated from In to StdIn.
    
    // assume Unicode UTF-8 encoding
    private static final String CHARSET_NAME = "UTF-8";

    // assume language = English, country = US for consistency with System.out.
    private static final Locale LOCALE = Locale.US;

    // the default token separator; we maintain the invariant that this value 
    // is held by the scanner's delimiter between calls
    private static final Pattern WHITESPACE_PATTERN = Pattern.compile("\\p{javaWhitespace}+");

    // makes whitespace characters significant 
    private static final Pattern EMPTY_PATTERN = Pattern.compile("");

    // used to read the entire input. source:
    // http://weblogs.java.net/blog/pat/archive/2004/10/stupid_scanner_1.html
    private static final Pattern EVERYTHING_PATTERN = Pattern.compile("\\A");

    //// end: section (1 of 2) of code duplicated from In to StdIn.

    private Scanner scanner;

   /**
     * Initializes an input stream from standard input.
     */
    public In() {
        scanner = new Scanner(new BufferedInputStream(System.in), CHARSET_NAME);
        scanner.useLocale(LOCALE);
    }

   /**
     * Initializes an input stream from a socket.
     *
     * @param  socket the socket
     * @throws IllegalArgumentException if cannot open {@code socket}
     * @throws IllegalArgumentException if {@code socket} is {@code null}
     */
    public In(Socket socket) {
        if (socket == null) throw new IllegalArgumentException("socket argument is null");
        try {
            InputStream is = socket.getInputStream();
            scanner = new Scanner(new BufferedInputStream(is), CHARSET_NAME);
            scanner.useLocale(LOCALE);
        }
        catch (IOException ioe) {
            throw new IllegalArgumentException("Could not open " + socket, ioe);
        }
    }

   /**
     * Initializes an input stream from a URL.
     *
     * @param  url the URL
     * @throws IllegalArgumentException if cannot open {@code url}
     * @throws IllegalArgumentException if {@code url} is {@code null}
     */
    public In(URL url) {
        if (url == null) throw new IllegalArgumentException("url argument is null");
        try {
            URLConnection site = url.openConnection();
            InputStream is     = site.getInputStream();
            scanner            = new Scanner(new BufferedInputStream(is), CHARSET_NAME);
            scanner.useLocale(LOCALE);
        }
        catch (IOException ioe) {
            throw new IllegalArgumentException("Could not open " + url, ioe);
        }
    }

   /**
     * Initializes an input stream from a file.
     *
     * @param  file the file
     * @throws IllegalArgumentException if cannot open {@code file}
     * @throws IllegalArgumentException if {@code file} is {@code null}
     */
    public In(File file) {
        if (file == null) throw new IllegalArgumentException("file argument is null");
        try {
            // for consistency with StdIn, wrap with BufferedInputStream instead of use
            // file as argument to Scanner
            FileInputStream fis = new FileInputStream(file);
            scanner = new Scanner(new BufferedInputStream(fis), CHARSET_NAME);
            scanner.useLocale(LOCALE);
        }
        catch (IOException ioe) {
            throw new IllegalArgumentException("Could not open " + file, ioe);
        }
    }


   /**
     * Initializes an input stream from a filename or web page databaseName.
     *
     * @param  databaseName the filename or web page databaseName
     * @throws IllegalArgumentException if cannot open {@code databaseName} as
     *         a file or URL
     * @throws IllegalArgumentException if {@code databaseName} is {@code null}
     */
    public In(String databaseName) {
        if (databaseName == null) throw new IllegalArgumentException("argument is null");
        try {
            // first try to read file from local file system
            File file = new File(databaseName);
            if (file.exists()) {
                // for consistency with StdIn, wrap with BufferedInputStream instead of use
                // file as argument to Scanner
                FileInputStream fis = new FileInputStream(file);
                scanner = new Scanner(new BufferedInputStream(fis), CHARSET_NAME);
                scanner.useLocale(LOCALE);
                return;
            }

            // next try for files included in jar
            URL url = getClass().getResource(databaseName);

            // try this as well
            if (url == null) {
                url = getClass().getClassLoader().getResource(databaseName);
            }

            // or URL from web
            if (url == null) {
                url = new URL(databaseName);
            }

            URLConnection site = url.openConnection();

            // in order to set User-Agent, replace above line with these two
            // HttpURLConnection site = (HttpURLConnection) url.openConnection();
            // site.addRequestProperty("User-Agent", "Mozilla/4.76");

            InputStream is     = site.getInputStream();
            scanner            = new Scanner(new BufferedInputStream(is), CHARSET_NAME);
            scanner.useLocale(LOCALE);
        }
        catch (IOException ioe) {
            throw new IllegalArgumentException("Could not open " + databaseName, ioe);
        }
    }

    /**
     * Initializes an input stream from a given {@link Scanner} source; use with 
     * {@code new Scanner(String)} to read from a string.
     * <p>
     * Note that this does not create a defensive copy, so the
     * scanner will be mutated as you read on. 
     *
     * @param  scanner the scanner
     * @throws IllegalArgumentException if {@code scanner} is {@code null}
     */
    public In(Scanner scanner) {
        if (scanner == null) throw new IllegalArgumentException("scanner argument is null");
        this.scanner = scanner;
    }

    /**
     * Returns true if this input stream exists.
     *
     * @return {@code true} if this input stream exists; {@code false} otherwise
     */
    public boolean exists()  {
        return scanner != null;
    }
    
    ////  begin: section (2 of 2) of code duplicated from In to StdIn,
    ////  with all methods changed from "public" to "public static".

   /**
     * Returns true if input stream is empty (except possibly whitespace).
     * Use this to know whether the next call to {@link #readString()}, 
     * {@link #readDouble()}, etc will succeed.
     *
     * @return {@code true} if this input stream is empty (except possibly whitespace);
     *         {@code false} otherwise
     */
    public boolean isEmpty() {
        return !scanner.hasNext();
    }

   /** 
     * Returns true if this input stream has a next line.
     * Use this method to know whether the
     * next call to {@link #readLine()} will succeed.
     * This method is functionally equivalent to {@link #hasNextChar()}.
     *
     * @return {@code true} if this input stream has more input (including whitespace);
     *         {@code false} otherwise
     */
    public boolean hasNextLine() {
        return scanner.hasNextLine();
    }

    /**
     * Returns true if this input stream has more input (including whitespace).
     * Use this method to know whether the next call to {@link #readChar()} will succeed.
     * This method is functionally equivalent to {@link #hasNextLine()}.
     * 
     * @return {@code true} if this input stream has more input (including whitespace);
     *         {@code false} otherwise   
     */
    public boolean hasNextChar() {
        scanner.useDelimiter(EMPTY_PATTERN);
        boolean result = scanner.hasNext();
        scanner.useDelimiter(WHITESPACE_PATTERN);
        return result;
    }


   /**
     * Reads and returns the next line in this input stream.
     *
     * @return the next line in this input stream; {@code null} if no such line
     */
    public String readLine() {
        String line;
        try {
            line = scanner.nextLine();
        }
        catch (NoSuchElementException e) {
            line = null;
        }
        return line;
    }

    /**
     * Reads and returns the next character in this input stream.
     *
     * @return the next {@code char} in this input stream
     * @throws NoSuchElementException if the input stream is empty
     */
    public char readChar() {
        scanner.useDelimiter(EMPTY_PATTERN);
        try {
            String ch = scanner.next();
            assert ch.length() == 1 : "Internal (Std)In.readChar() error!"
                + " Please contact the authors.";
            scanner.useDelimiter(WHITESPACE_PATTERN);
            return ch.charAt(0);
        }
        catch (NoSuchElementException e) {
            throw new NoSuchElementException("attempts to read a 'char' value from input stream, but there are no more tokens available");
        }
    }  


   /**
     * Reads and returns the remainder of this input stream, as a string.
     *
     * @return the remainder of this input stream, as a string
     */
    public String readAll() {
        if (!scanner.hasNextLine())
            return "";

        String result = scanner.useDelimiter(EVERYTHING_PATTERN).next();
        // not that important to reset delimeter, since now scanner is empty
        scanner.useDelimiter(WHITESPACE_PATTERN); // but let's do it anyway
        return result;
    }


   /**
     * Reads the next token from this input stream and returns it as a {@code String}.
     *
     * @return the next {@code String} in this input stream
     * @throws NoSuchElementException if the input stream is empty
     */
    public String readString() {
        try {
            return scanner.next();
        }
        catch (NoSuchElementException e) {
            throw new NoSuchElementException("attempts to read a 'String' value from input stream, but there are no more tokens available");
        }
    }

   /**
     * Reads the next token from this input stream, parses it as a {@code int},
     * and returns the {@code int}.
     *
     * @return the next {@code int} in this input stream
     * @throws NoSuchElementException if the input stream is empty
     * @throws InputMismatchException if the next token cannot be parsed as an {@code int}
     */
    public int readInt() {
        try {
            return scanner.nextInt();
        }
        catch (InputMismatchException e) {
            String token = scanner.next();
            throw new InputMismatchException("attempts to read an 'int' value from input stream, but the next token is \"" + token + "\"");
        }
        catch (NoSuchElementException e) {
            throw new NoSuchElementException("attemps to read an 'int' value from input stream, but there are no more tokens available");
        }
    }

   /**
     * Reads the next token from this input stream, parses it as a {@code double},
     * and returns the {@code double}.
     *
     * @return the next {@code double} in this input stream
     * @throws NoSuchElementException if the input stream is empty
     * @throws InputMismatchException if the next token cannot be parsed as a {@code double}
     */
    public double readDouble() {
        try {
            return scanner.nextDouble();
        }
        catch (InputMismatchException e) {
            String token = scanner.next();
            throw new InputMismatchException("attempts to read a 'double' value from input stream, but the next token is \"" + token + "\"");
        }
        catch (NoSuchElementException e) {
            throw new NoSuchElementException("attemps to read a 'double' value from input stream, but there are no more tokens available");
        }
    }

   /**
     * Reads the next token from this input stream, parses it as a {@code float},
     * and returns the {@code float}.
     *
     * @return the next {@code float} in this input stream
     * @throws NoSuchElementException if the input stream is empty
     * @throws InputMismatchException if the next token cannot be parsed as a {@code float}
     */
    public float readFloat() {
        try {
            return scanner.nextFloat();
        }
        catch (InputMismatchException e) {
            String token = scanner.next();
            throw new InputMismatchException("attempts to read a 'float' value from input stream, but the next token is \"" + token + "\"");
        }
        catch (NoSuchElementException e) {
            throw new NoSuchElementException("attemps to read a 'float' value from input stream, but there are no more tokens available");
        }
    }

   /**
     * Reads the next token from this input stream, parses it as a {@code long},
     * and returns the {@code long}.
     *
     * @return the next {@code long} in this input stream
     * @throws NoSuchElementException if the input stream is empty
     * @throws InputMismatchException if the next token cannot be parsed as a {@code long}
     */
    public long readLong() {
        try {
            return scanner.nextLong();
        }
        catch (InputMismatchException e) {
            String token = scanner.next();
            throw new InputMismatchException("attempts to read a 'long' value from input stream, but the next token is \"" + token + "\"");
        }
        catch (NoSuchElementException e) {
            throw new NoSuchElementException("attemps to read a 'long' value from input stream, but there are no more tokens available");
        }
    }

   /**
     * Reads the next token from this input stream, parses it as a {@code short},
     * and returns the {@code short}.
     *
     * @return the next {@code short} in this input stream
     * @throws NoSuchElementException if the input stream is empty
     * @throws InputMismatchException if the next token cannot be parsed as a {@code short}
     */
    public short readShort() {
        try {
            return scanner.nextShort();
        }
        catch (InputMismatchException e) {
            String token = scanner.next();
            throw new InputMismatchException("attempts to read a 'short' value from input stream, but the next token is \"" + token + "\"");
        }
        catch (NoSuchElementException e) {
            throw new NoSuchElementException("attemps to read a 'short' value from input stream, but there are no more tokens available");
        }
    }

   /**
     * Reads the next token from this input stream, parses it as a {@code byte},
     * and returns the {@code byte}.
     * <p>
     * To read binary data, use {@link BinaryIn}.
     *
     * @return the next {@code byte} in this input stream
     * @throws NoSuchElementException if the input stream is empty
     * @throws InputMismatchException if the next token cannot be parsed as a {@code byte}
     */
    public byte readByte() {
        try {
            return scanner.nextByte();
        }
        catch (InputMismatchException e) {
            String token = scanner.next();
            throw new InputMismatchException("attempts to read a 'byte' value from input stream, but the next token is \"" + token + "\"");
        }
        catch (NoSuchElementException e) {
            throw new NoSuchElementException("attemps to read a 'byte' value from input stream, but there are no more tokens available");
        }
    }

    /**
     * Reads the next token from this input stream, parses it as a {@code boolean}
     * (interpreting either {@code "true"} or {@code "1"} as {@code true},
     * and either {@code "false"} or {@code "0"} as {@code false}).
     *
     * @return the next {@code boolean} in this input stream
     * @throws NoSuchElementException if the input stream is empty
     * @throws InputMismatchException if the next token cannot be parsed as a {@code boolean}
     */
    public boolean readBoolean() {
        try {
            String token = readString();
            if ("true".equalsIgnoreCase(token))  return true;
            if ("false".equalsIgnoreCase(token)) return false;
            if ("1".equals(token))               return true;
            if ("0".equals(token))               return false;
            throw new InputMismatchException("attempts to read a 'boolean' value from input stream, but the next token is \"" + token + "\"");
        }
        catch (NoSuchElementException e) {
            throw new NoSuchElementException("attempts to read a 'boolean' value from input stream, but there are no more tokens available");
        }
    }

    /**
     * Reads all remaining tokens from this input stream and returns them as
     * an array of strings.
     *
     * @return all remaining tokens in this input stream, as an array of strings
     */
    public String[] readAllStrings() {
        // we could use readAll.trim().split(), but that's not consistent
        // since trim() uses characters 0x00..0x20 as whitespace
        String[] tokens = WHITESPACE_PATTERN.split(readAll());
        if (tokens.length == 0 || tokens[0].length() > 0)
            return tokens;
        String[] decapitokens = new String[tokens.length-1];
        for (int i = 0; i < tokens.length-1; i++)
            decapitokens[i] = tokens[i+1];
        return decapitokens;
    }

    /**
     * Reads all remaining lines from this input stream and returns them as
     * an array of strings.
     *
     * @return all remaining lines in this input stream, as an array of strings
     */
    public String[] readAllLines() {
        ArrayList<String> lines = new ArrayList<String>();
        while (hasNextLine()) {
            lines.add(readLine());
        }
        return lines.toArray(new String[lines.size()]);
    }


    /**
     * Reads all remaining tokens from this input stream, parses them as integers,
     * and returns them as an array of integers.
     *
     * @return all remaining lines in this input stream, as an array of integers
     */
    public int[] readAllInts() {
        String[] fields = readAllStrings();
        int[] vals = new int[fields.length];
        for (int i = 0; i < fields.length; i++)
            vals[i] = Integer.parseInt(fields[i]);
        return vals;
    }

    /**
     * Reads all remaining tokens from this input stream, parses them as longs,
     * and returns them as an array of longs.
     *
     * @return all remaining lines in this input stream, as an array of longs
     */
    public long[] readAllLongs() {
        String[] fields = readAllStrings();
        long[] vals = new long[fields.length];
        for (int i = 0; i < fields.length; i++)
            vals[i] = Long.parseLong(fields[i]);
        return vals;
    }

    /**
     * Reads all remaining tokens from this input stream, parses them as doubles,
     * and returns them as an array of doubles.
     *
     * @return all remaining lines in this input stream, as an array of doubles
     */
    public double[] readAllDoubles() {
        String[] fields = readAllStrings();
        double[] vals = new double[fields.length];
        for (int i = 0; i < fields.length; i++)
            vals[i] = Double.parseDouble(fields[i]);
        return vals;
    }
    
    ///// end: section (2 of 2) of code duplicated from In to StdIn */

   /**
     * Closes this input stream.
     */
    public void close() {
        scanner.close();  
    }

    /**
     * Reads all integers from a file and returns them as
     * an array of integers.
     *
     * @param      filename the databaseName of the file
     * @return     the integers in the file
     * @deprecated Replaced by {@code new In(filename)}.{@link #readAllInts()}.
     */
    @Deprecated
    public static int[] readInts(String filename) {
        return new In(filename).readAllInts();
    }

   /**
     * Reads all doubles from a file and returns them as
     * an array of doubles.
     *
     * @param      filename the databaseName of the file
     * @return     the doubles in the file
     * @deprecated Replaced by {@code new In(filename)}.{@link #readAllDoubles()}.
     */
    @Deprecated
    public static double[] readDoubles(String filename) {
        return new In(filename).readAllDoubles();
    }

   /**
     * Reads all strings from a file and returns them as
     * an array of strings.
     *
     * @param      filename the databaseName of the file
     * @return     the strings in the file
     * @deprecated Replaced by {@code new In(filename)}.{@link #readAllStrings()}.
     */
    @Deprecated
    public static String[] readStrings(String filename) {
        return new In(filename).readAllStrings();
    }

    /**
     * Reads all integers from standard input and returns them
     * an array of integers.
     *
     * @return     the integers on standard input
     * @deprecated Replaced by {@link StdIn#readAllInts()}.
     */
    @Deprecated
    public static int[] readInts() {
        return new In().readAllInts();
    }

   /**
     * Reads all doubles from standard input and returns them as
     * an array of doubles.
     *
     * @return     the doubles on standard input
     * @deprecated Replaced by {@link StdIn#readAllDoubles()}.
     */
    @Deprecated
    public static double[] readDoubles() {
        return new In().readAllDoubles();
    }

   /**
     * Reads all strings from standard input and returns them as
     *  an array of strings.
     *
     * @return     the strings on standard input
     * @deprecated Replaced by {@link StdIn#readAllStrings()}.
     */
    @Deprecated
    public static String[] readStrings() {
        return new In().readAllStrings();
    }
    
   /**
     * Unit tests the {@code In} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) {
        In in;
        String urlName = "http://introcs.cs.princeton.edu/stdlib/InTest.txt";

        // read from a URL
        System.out.println("readAll() from URL " + urlName);
        System.out.println("---------------------------------------------------------------------------");
        try {
            in = new In(urlName);
            System.out.println(in.readAll());
        }
        catch (IllegalArgumentException e) {
            System.out.println(e);
        }
        System.out.println();

        // read one line at a time from URL
        System.out.println("readLine() from URL " + urlName);
        System.out.println("---------------------------------------------------------------------------");
        try {
            in = new In(urlName);
            while (!in.isEmpty()) {
                String s = in.readLine();
                System.out.println(s);
            }
        }
        catch (IllegalArgumentException e) {
            System.out.println(e);
        }
        System.out.println();

        // read one string at a time from URL
        System.out.println("readString() from URL " + urlName);
        System.out.println("---------------------------------------------------------------------------");
        try {
            in = new In(urlName);
            while (!in.isEmpty()) {
                String s = in.readString();
                System.out.println(s);
            }
        }
        catch (IllegalArgumentException e) {
            System.out.println(e);
        }
        System.out.println();


        // read one line at a time from file in current directory
        System.out.println("readLine() from current directory");
        System.out.println("---------------------------------------------------------------------------");
        try {
            in = new In("./InTest.txt");
            while (!in.isEmpty()) {
                String s = in.readLine();
                System.out.println(s);
            }
        }
        catch (IllegalArgumentException e) {
            System.out.println(e);
        }
        System.out.println();


        // read one line at a time from file using relative path
        System.out.println("readLine() from relative path");
        System.out.println("---------------------------------------------------------------------------");
        try {
            in = new In("../stdlib/InTest.txt");
            while (!in.isEmpty()) {
                String s = in.readLine();
                System.out.println(s);
            }
        }
        catch (IllegalArgumentException e) {
            System.out.println(e);
        }
        System.out.println();

        // read one char at a time
        System.out.println("readChar() from file");
        System.out.println("---------------------------------------------------------------------------");
        try {
            in = new In("InTest.txt");
            while (!in.isEmpty()) {
                char c = in.readChar();
                System.out.print(c);
            }
        }
        catch (IllegalArgumentException e) {
            System.out.println(e);
        }
        System.out.println();
        System.out.println();

        // read one line at a time from absolute OS X / Linux path
        System.out.println("readLine() from absolute OS X / Linux path");
        System.out.println("---------------------------------------------------------------------------");
        in = new In("/n/fs/introcs/www/java/stdlib/InTest.txt");
        try {
            while (!in.isEmpty()) {
                String s = in.readLine();
                System.out.println(s);
            }
        }
        catch (IllegalArgumentException e) {
            System.out.println(e);
        }
        System.out.println();


        // read one line at a time from absolute Windows path
        System.out.println("readLine() from absolute Windows path");
        System.out.println("---------------------------------------------------------------------------");
        try {
            in = new In("G:\\www\\introcs\\stdlib\\InTest.txt");
            while (!in.isEmpty()) {
                String s = in.readLine();
                System.out.println(s);
            }
            System.out.println();
        }
        catch (IllegalArgumentException e) {
            System.out.println(e);
        }
        System.out.println();

    }

}

/******************************************************************************
 *  Copyright 2002-2016, Robert Sedgewick and Kevin Wayne.
 *
 *  This file is part of algs4.jar, which accompanies the textbook
 *
 *      Algorithms, 4th edition by Robert Sedgewick and Kevin Wayne,
 *      Addison-Wesley Professional, 2011, ISBN 0-321-57351-X.
 *      http://algs4.cs.princeton.edu
 *
 *
 *  algs4.jar is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  algs4.jar is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with algs4.jar.  If not, see http://www.gnu.org/licenses.
 ******************************************************************************/package BasicAlgorithms.Graph;

/*************************************************************************
 *  Compilation:  javac DepthFirstOrder.java
 *  Execution:    java DepthFirstOrder filename.txt
 *  Dependencies: Digraph.java Queue.java Stack.java StdOut.java
 *                EdgeWeightedDigraph.java DirectedEdge.java
 *  Data files:   http://algs4.cs.princeton.edu/42directed/tinyDAG.txt
 *                http://algs4.cs.princeton.edu/42directed/tinyDG.txt
 *
 *  Compute preorder and postorder for a digraph or edge-weighted digraph.
 *  Runs in O(E + V) time.
 *
 *  % java DepthFirstOrder tinyDAG.txt
 *     v  pre post
 *  --------------
 *     0    0    8
 *     1    3    2
 *     2    9   10
 *     3   10    9
 *     4    2    0
 *     5    1    1
 *     6    4    7
 *     7   11   11
 *     8   12   12
 *     9    5    6
 *    10    8    5
 *    11    6    4
 *    12    7    3
 *  Preorder:  0 5 4 1 6 9 11 12 10 2 3 7 8 
 *  Postorder: 4 5 1 12 11 10 9 6 0 3 2 7 8 
 *  Reverse postorder: 8 7 2 3 0 6 9 10 11 12 1 5 4 
 *
 *************************************************************************/
import java.util.*;
public class DepthFirstOrder {
    private boolean[] marked;          // marked[v] = has v been marked in dfs?
    private int[] pre;                 // pre[v]    = preorder  number of v
    private int[] post;                // post[v]   = postorder number of v
    private Queue<Integer> preorder;   // vertices in preorder
    private Queue<Integer> postorder;  // vertices in postorder
    private int preCounter;            // counter or preorder numbering
    private int postCounter;           // counter for postorder numbering

    // depth-first search preorder and postorder in a digraph
    public DepthFirstOrder(Digraph G) {
        pre    = new int[G.V()];
        post   = new int[G.V()];
        postorder = new Queue<Integer>();
        preorder  = new Queue<Integer>();
        marked    = new boolean[G.V()];
        for (int v = 0; v < G.V(); v++)
            if (!marked[v]) dfs(G, v);
    }

    // depth-first search preorder and postorder in an edge-weighted digraph
//    public DepthFirstOrder(EdgeWeightedDigraph G) {
//        pre    = new int[G.V()];
//        post   = new int[G.V()];
//        postorder = new Queue<Integer>();
//        preorder  = new Queue<Integer>();
//        marked    = new boolean[G.V()];
//        for (int v = 0; v < G.V(); v++)
//            if (!marked[v]) dfs(G, v);
//    }

    // run DFS in digraph G from vertex v and compute preorder/postorder
    private void dfs(Digraph G, int v) {
        marked[v] = true;
        pre[v] = preCounter++;
        preorder.enqueue(v);
        for (int w : G.adj(v)) {
            if (!marked[w]) {
                dfs(G, w);
            }
        }
        postorder.enqueue(v);
        post[v] = postCounter++;
    }

    // run DFS in edge-weighted digraph G from vertex v and compute preorder/postorder
//    private void dfs(EdgeWeightedDigraph G, int v) {
//        marked[v] = true;
//        pre[v] = preCounter++;
//        preorder.enqueue(v);
//        for (DirectedEdge e : G.adj(v)) {
//            int w = e.to();
//            if (!marked[w]) {
//                dfs(G, w);
//            }
//        }
//        postorder.enqueue(v);
//        post[v] = postCounter++;
//    }

    public int pre(int v) {
        return pre[v];
    }

    public int post(int v) {
        return post[v];
    }

    // return vertices in postorder as an Iterable
    public Iterable<Integer> post() {
        return postorder;
    }

    // return vertices in postorder as an Iterable
    public Iterable<Integer> pre() {
        return preorder;
    }

    // return vertices in reverse postorder as an Iterable
    public Iterable<Integer> reversePost() {
        Stack<Integer> reverse = new Stack<Integer>();
        for (int v : postorder)
            reverse.push(v);
        return reverse;
    }


    // certify that digraph is either acyclic or has a directed cycle
    private boolean check(Digraph G) {

        // check that post(v) is consistent with post()
        int r = 0;
        for (int v : post()) {
            if (post(v) != r) {
                StdOut.println("post(v) and post() inconsistent");
                return false;
            }
            r++;
        }

        // check that pre(v) is consistent with pre()
        r = 0;
        for (int v : pre()) {
            if (pre(v) != r) {
                StdOut.println("pre(v) and pre() inconsistent");
                return false;
            }
            r++;
        }


        return true;
    }

    public static void main(String[] args) {
        In in = new In(args[0]);
        Digraph G = new Digraph(in);

        DepthFirstOrder dfs = new DepthFirstOrder(G);
        StdOut.println("   v  pre post");
        StdOut.println("--------------");
        for (int v = 0; v < G.V(); v++) {
            StdOut.printf("%4d %4d %4d\n", v, dfs.pre(v), dfs.post(v));
        }

        StdOut.print("Preorder:  ");
        for (int v : dfs.pre()) {
            StdOut.print(v + " ");
        }
        StdOut.println();

        StdOut.print("Postorder: ");
        for (int v : dfs.post()) {
            StdOut.print(v + " ");
        }
        StdOut.println();

        StdOut.print("Reverse postorder: ");
        for (int v : dfs.reversePost()) {
            StdOut.print(v + " ");
        }
        StdOut.println();


    }

}package BasicAlgorithms.Graph;

import java.util.ArrayDeque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Queue;

/**
 * Created by hadoop on 16/10/17.
 */
public class LongestChain {
    public static int FindLongestChain(String[] words) {
        int len = words.length;
        HashSet<String> set = new HashSet<>();
        for(String word: words){
            set.add(word);
        }
        int res = 0;
        for(String s:words){
            res = Math.max(res,BFS(s,set));
        }
        return res;
    }

    private static int BFS(String s, HashSet<String> set) {
        Queue<String> queue = new ArrayDeque<>();
        HashMap<String,Integer> dis = new HashMap<>();
        queue.add(s);
        dis.put(s,0);
        while (!queue.isEmpty()){
            String polled = queue.poll();
            for(int i=0;i<polled.length();i++){
                StringBuilder sb = new StringBuilder(polled);
                sb.deleteCharAt(i);
                String temp = sb.toString();
                if(set.contains(temp)){
                    if(temp.length() == 1){
                        return dis.get(temp)+1;
                    }
                    dis.put(temp,dis.get(polled)+1);
                    queue.add(temp);
                }
            }
        }
        // if unable to find
        return -1;
    }
}package BasicAlgorithms.Graph;

/*************************************************************************
 *  Compilation:  javac DepthFirstPaths.java
 *  Execution:    java DepthFirstPaths G s
 *  Dependencies: Graph.java Stack.java StdOut.java
 *  Data files:   http://algs4.cs.princeton.edu/41undirected/tinyCG.txt
 *
 *  Run depth first search on an undirected graph.
 *  Runs in O(E + V) time.
 *
 *  %  java Graph tinyCG.txt
 *  6 8
 *  0: 2 1 5 
 *  1: 0 2 
 *  2: 0 1 3 4 
 *  3: 5 4 2 
 *  4: 3 2 
 *  5: 3 0 
 *
 *  % java DepthFirstPaths tinyCG.txt 0
 *  0 to 0:  0
 *  0 to 1:  0-2-1
 *  0 to 2:  0-2
 *  0 to 3:  0-2-3
 *  0 to 4:  0-2-3-4
 *  0 to 5:  0-2-3-5
 *
 *************************************************************************/
import java.util.*;
public class DepthFirstPaths {
    private boolean[] marked;    // marked[v] = is there an s-v path?
    private int[] edgeTo;        // edgeTo[v] = last edge on s-v path
    private final int s;         // source vertex

    public DepthFirstPaths(Graph G, int s) {
        this.s = s;
        edgeTo = new int[G.V()];
        marked = new boolean[G.V()];
        dfs(G, s);
    }

    // depth first search from v
    private void dfs(Graph G, int v) {
        marked[v] = true;
        for (int w : G.adj(v)) {
            if (!marked[w]) {
                edgeTo[w] = v;
                dfs(G, w);
            }
        }
    }

    // is there a path between s and v?
    public boolean hasPathTo(int v) {
        return marked[v];
    }

    // return a path between s to v; null if no such path
    public Iterable<Integer> pathTo(int v) {
        if (!hasPathTo(v)) return null;
        Stack<Integer> path = new Stack<Integer>();
        for (int x = v; x != s; x = edgeTo[x])
            path.push(x);
        path.push(s);
        return path;
    }

    public static void main(String[] args) {
        In in = new In(args[0]);
        Graph G = new Graph(in);
        int s = Integer.parseInt(args[1]);
        DepthFirstPaths dfs = new DepthFirstPaths(G, s);

        for (int v = 0; v < G.V(); v++) {
            if (dfs.hasPathTo(v)) {
                StdOut.printf("%d to %d:  ", s, v);
                for (int x : dfs.pathTo(v)) {
                    if (x == s) StdOut.print(x);
                    else        StdOut.print("-" + x);
                }
                StdOut.println();
            }

            else {
                StdOut.printf("%d to %d:  not connected\n", s, v);
            }

        }
    }

}package BasicAlgorithms.Graph;

import java.util.List;
import java.util.Queue;

import java.util.*;
/**
 * Created by hadoop on 16/10/17.
 */
public class BfsGeneralTemplate {
    int INFINITY = Integer.MAX_VALUE;
    boolean [] marked ;
    int []edgeTo;
    int []distTo;
    private List<Integer>[] adj;
    int source ;

    public BfsGeneralTemplate(Graph graph,int s){
        marked = new boolean[graph.V()];
        distTo = new int[graph.V()];
        edgeTo = new int[graph.V()];
        source = s;
        bfs(graph,s);
    }

    private void bfs(Graph graph, int s) {
        Queue<Integer> queue = new LinkedList<>();
        for(int v=0;v<graph.V();v++){
            distTo[v] = INFINITY;
        }
        distTo[s] = 0;
        marked[s] =true;
        queue.add(s);
        while (!queue.isEmpty()){
            int v = queue.poll();
            for(int w:graph.adj(v)){
                if(!marked[w]){
                    edgeTo[w] = v;
                    marked[w] = true;
                    distTo[w] = distTo[v]+1;
                    queue.add(w);
                }
            }
        }
    }
    public boolean hasPathTo(int v){
        return marked[v];
    }
    public int distTo(int v){
        return distTo[v];
    }
    public Iterable<Integer> path(int v){
        if(!hasPathTo(v)){
            return null;
        }
        Stack<Integer> stack = new Stack<>();
        int x = v;
        while (x!=source){
            stack.add(x);
            x = edgeTo[x];
        }
        stack.push(x);
        return stack;
    }
}
package BasicAlgorithms.Dfs;

/**
 * Created by hadoop on 24/10/17.
 */
import java.util.*;
public class TreeDfsTemplate {
    private class Solution {
        public List<List<Integer>> levelOrder(TreeNode root) {
            List<List<Integer>> res = new ArrayList<>();
            traverse(root, res, 0);
            return res;
        }

        private void traverse(TreeNode root, List<List<Integer>> res, int level) {
            if (root == null) return;
            if (res.size() - 1 < level) {
                res.add(new ArrayList<>());
            }

            res.get(level).add(root.val);

            level++;
            traverse(root.left, res, level);
            traverse(root.right, res, level);

        }
    }
    private class TreeNode{
        int val;
        TreeNode left;
        TreeNode right;
    }
    private class SolutionA {
        public List<List<Integer>> findLeaves(TreeNode root) {
            List<List<Integer>> res = new ArrayList<>();
            if(root!=null)
                findLeaves(res, root);
            return res;
        }

        private int findLeaves(List<List<Integer>> res, TreeNode root) {
            int left = -1;
            int right = -1;
            if(root.left != null) {
                left = findLeaves(res, root.left);
            }
            if(root.right != null) {
                right = findLeaves(res, root.right);
            }
            int depth = Math.max(left, right) + 1;
            if(res.size() < depth + 1) {
                res.add(new ArrayList<>());
            }
            res.get(depth).add(root.val);
            return depth;
        }
        private int findLeavesMine(List<List<Integer>> res ,TreeNode node){
            if(node == null){
                return 0;
            }

            int leftHeight = findLeavesMine(res,node.left);
            int rightHeight = findLeavesMine(res,node.right);

            int currentHeight = Math.max(leftHeight,rightHeight)+1;
            if(res.size() < currentHeight){
                res.add(new ArrayList<>());
            }
            res.get(currentHeight-1).add(node.val);
            return currentHeight;
        }
    }
    public List<Integer> maxInEachLevel(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        List<Integer> ans = new ArrayList<>();
        dfsintree(root, res, 1);
        for(List<Integer> it:res){
            ans.add(Collections.max(it));
        }
        return ans;
    }

    private void dfsintree(TreeNode root, List<List<Integer>> res, int level) {
        if(root == null){
            return;
        }
        if(res.size()<level){
            res.add(new ArrayList<>());
        }
        res.get(level-1).add(root.val);
        dfsintree(root.left,res,level+1);
        dfsintree(root.right,res,level+1);

    }
}
package BasicAlgorithms.Dfs;/*
	Nested List Weight Sum

	Given a nested list of integers, return the sum of all integers in the list weighted by their depth.

	Each element is either an integer, or a list -- whose elements may also be integers or other lists.

	Example 1:
	Given the list [[1,1],2,[1,1]], return 10. (four 1's at depth 2, one 2 at depth 1)

	Example 2:
	Given the list [1,[4,[6]]], return 27. (one 1 at depth 1, one 4 at depth 2, and one 6 at depth 3; 1 + 4*2 + 6*3 = 27)
 */

import java.util.*;
 // This is the interface that allows for creating nested lists.
  // You should not implement it, or speculate about its implementation
 interface NestedInteger {

      // @return true if this NestedInteger holds a single integer, rather than a nested list.
     public boolean isInteger();

      // @return the single integer that this NestedInteger holds, if it holds a single integer
      // Return null if this NestedInteger holds a nested list
      public Integer getInteger();

      // @return the nested list that this NestedInteger holds, if it holds a nested list
      // Return null if this NestedInteger holds a single integer
      public List<NestedInteger> getList();
  }

public class NestedWeightDFS {
    public int depthSum(List<NestedInteger> nestedList) {
        if (nestedList == null || nestedList.size() == 0) {
            return 0;
        }
        return dfs(nestedList, 1);

    }
    
    public int dfs(List<NestedInteger> nestedList, int level) {
        if (nestedList == null || nestedList.size() == 0) {
            return 0;
        }
        int res = 0;
        for (NestedInteger i1 : nestedList) {
            if (i1.isInteger()) {
                res += i1.getInteger() * level;
            } else {
                res += dfs(i1.getList(), level + 1);
            }
        } 
        return res;
    }
}package SystemDesignNodes.ConcurrentConnections;
//https://stackoverflow.com/questions/9497987/how-many-requests-can-handle-a-port-at-a-time

import java.net.ServerSocket;
import java.net.Socket;
import java.io.IOException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.net.Socket;
public class ThreadPooledServer implements Runnable{

    protected int          serverPort   = 8080;
    protected ServerSocket serverSocket = null;
    protected boolean      isStopped    = false;
    protected Thread       runningThread= null;
    protected ExecutorService threadPool =
        Executors.newFixedThreadPool(10);

    public ThreadPooledServer(int port){
        this.serverPort = port;
    }

    public void run(){
        synchronized(this){
            this.runningThread = Thread.currentThread();
        }
        openServerSocket();
        while(! isStopped()){
            Socket clientSocket = null;
            try {
                clientSocket = this.serverSocket.accept();
            } catch (IOException e) {
                if(isStopped()) {
                    System.out.println("Server Stopped.") ;
                    break;
                }
                throw new RuntimeException(
                    "Error accepting client connection", e);
            }
            this.threadPool.execute(
                new WorkerRunnable(clientSocket,
                    "Thread Pooled Server"));
        }
        this.threadPool.shutdown();
        System.out.println("Server Stopped.") ;
    }


    private synchronized boolean isStopped() {
        return this.isStopped;
    }

    public synchronized void stop(){
        this.isStopped = true;
        try {
            this.serverSocket.close();
        } catch (IOException e) {
            throw new RuntimeException("Error closing server", e);
        }
    }

    private void openServerSocket() {
        try {
            this.serverSocket = new ServerSocket(this.serverPort);
        } catch (IOException e) {
            throw new RuntimeException("Cannot open port 8080", e);
        }
    }

    public static void main(String[] args) {
        ThreadPooledServer server = new ThreadPooledServer(9000);
        new Thread(server).start();

        try {
            Thread.sleep(20 * 1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("Stopping Server");
       // server.stop();
    }
}


class WorkerRunnable implements Runnable{

    protected Socket clientSocket = null;
    protected String serverText   = null;

    public WorkerRunnable(Socket clientSocket, String serverText) {
        this.clientSocket = clientSocket;
        this.serverText   = serverText;
    }

    public void run() {
        try {
            InputStream input  = clientSocket.getInputStream();
            OutputStream output = clientSocket.getOutputStream();
            long time = System.currentTimeMillis();
            System.out.println(input.read());
            output.write(("HTTP/1.1 200 OK\n\nWorkerRunnable: " +
                    this.serverText + " - " +
                    time +
                    "").getBytes());
            output.close();
            input.close();
            System.out.println("Request processed: " + time);
        } catch (IOException e) {
            //report exception somewhere.
            e.printStackTrace();
        }
    }
}
/*
This text describes a simple thread pooled server implemented in Java. The code is based on the multithreaded server desbribed in the text on Multithreaded Servers. The main difference is the server loop. Rather than starting a new thread per incoming connection, the connection is wrapped in a Runnable and handed off to a thread poool with a fixed number of threads. The Runnable's are kept in a queue in the thread pool. When a thread in the thread pool is idle it will take a Runnable from the queue and execute it.

Note: Thread pools are discussed in more detail in the text Thread Pools.

Here is how the server loop looks in the thread pooled edition (the full code is shown at the bottom of this text):

    while(! isStopped()){
         Socket clientSocket = null;
         try {
             clientSocket = this.serverSocket.accept();
         } catch (IOException e) {
             if(isStopped()) {
                 System.out.println("Server Stopped.") ;
                 break;
             }
             throw new RuntimeException(
                "Error accepting client connection", e);
         }

            this.threadPool.execute(
            new WorkerRunnable(clientSocket, "Thread Pooled Server"));

     }

The only change in the loop from the multithreaded server to here is the code in bold:

this.threadPool.execute(
   new WorkerRunnable(clientSocket, "Thread Pooled Server"));
Rather than starting a new thread per incoming connection, the WorkerRunnable is passed to the thread pool for execution when a thread in the pool becomes idle.

Here is the code for the WorkerRunnable class, which is passed to the worker thread constructor:
 Apache MINA is a network application framework which helps users develop high performance and high scalability network applications easily. It provides an abstract event-driven  asynchronous API over various transports such as TCP/IP and UDP/IP via Java NIO.
 100,000 concurrent connections should be easily possible in Java if you use something like Netty.

You need to be able to:

Accept incoming connections fast enough. The NIO framework helps enormously here, which is what Netty uses internally. There is a smallish queue for incoming requests, so you need to be able to handle these faster than the queue can fill up.
Create connections for each client (this implies some memory overhead for things like connection info, buffers etc.) - you may need to tweak your VM settings to have enough free memory for all the connections
See this article from 2009 where they discuss achieving 100,000 concurrent connections with about 20% CPU usage on a quad-core server.




I am creating a web application having a login page , where number of users can tries to login at same time. so here I need to handle number of requests at a time.

I know this is already implemented for number of popular sites like G talk.

So I have some questions in my mind.

"How many requests can a port handle at a time ?"

How many sockets can I(server) create ? is there any limitations?

For e.g . As we know when we implement client server communication using Socket programming(TCP), we pass 'a port number(unreserved port number)to server for creating a socket .

So I mean to say if 100000 requests came at a single time then what will be approach of port to these all requests.

Is he manitains some queue for all these requests , or he just accepts number of requests as per his limit? if yes what is handling request limit size of port ?

Summary: I want to know how server serves multiple requests simultaneously?I don't know any thing about it. I know we are connection to a server via its ip address and port number that's it. So I thought there is only one port and many request come to that port only via different clients so how server manages all the requests?

This is all I want to know. If you explain this concept in detail it would be very helpful. Thanks any way.







A port doesn't handle requests, it receives packets. Depending on the implementation of the server this packets may be handled by one or more processes / threads, so this is unlimited theoretically. But you'll always be limited by bandwith and processing performance.

If lots of packets arrive at one port and cannot be handled in a timely manner they will be buffered (by the server, the operating system or hardware). If those buffers are full, the congestion maybe handled by network components (routers, switches) and the protocols the network traffic is based on. TCP for example has some methods to avoid or control congestion: http://en.wikipedia.org/wiki/Transmission_Control_Protocol#Congestion_control




This is typically configured in the application/web server you are using. How you limit the number of concurrent requests is by limiting the number of parallel worker threads you allow the server to spawn to serve requests. If more requests come in than there are available threads to handle them, they will start to queue up. This is the second thing you typically configure, the socket back-log size. When the back-log is full, the server will start responding with "connection refused" when new requests come in.



Then you'll probably be restricted by number of File Descriptors your os supports (in case of *nix) or the number of simultaneous connections your webserver supports. The OS maximum on my machine seems to be 75000.
https://stackoverflow.com/questions/9497987/how-many-requests-can-handle-a-port-at-a-time
 */

/*
A limit on the number of open sockets is configurable in the /proc file system

cat /proc/sys/fs/file-max
Max for incoming connections in the OS defined by integer limits.

Linux itself allows billions of open sockets.

To use the sockets you need an application listening, e.g. a web server, and that will use a certain amount of RAM per socket.

RAM and CPU will introduce the real limits. (modern 2017, think millions not billions)

1 millions is possible, not easy. Expect to use X Gigabytes of RAM to manage 1 million sockets.

Outgoing TCP connections are limited by port numbers ~65000 per IP. You can have multiple IP addresses, but not unlimited IP addresses. This is a limit in TCP not Linux.


72
down vote
I achieved 1600k concurrent idle socket connections, and at the same time 57k req/s on a Linux desktop (16G RAM, I7 2600 CPU). It's a single thread http server written in C with epoll. Source code is on github, a blog here.

Edit:

I did 600k concurrent HTTP connections (client & server) on both the same computer, with JAVA/Clojure . detail info post, HN discussion: http://news.ycombinator.com/item?id=5127251

The cost of a connection(with epoll):

application need some RAM per connection
TCP buffer 2 * 4k ~ 10k, or more
epoll need some memory for a file descriptor, from epoll(7)
Each registered file descriptor costs roughly 90 bytes on a 32-bit kernel, and roughly 160 bytes on a 64-bit kernel.
https://stackoverflow.com/questions/651665/how-many-socket-connections-possible
 */package SystemDesignNodes.ConcurrentConnections;

import java.net.ServerSocket;
import java.net.Socket;
import java.nio.*;
import java.io.*;
public class MyServerThread implements Runnable {

  private InputStream in = null;
  private OutputStream out = null;

  public MyServerThread(Socket s) throws Exception{

    in = s.getInputStream();
    out = s.getOutputStream();

    (new Thread(this)).start();
  }

  public void run() {
    //do stuff with **in** and **out** to interact with client
  }
}
class MyServer {

  private static int PORT = 12345;

  public static void main(String args[]) throws Exception {

    ServerSocket s = new ServerSocket(PORT);
    while (true) new MyServerThread(s.accept());

  }
}import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;

/**
 * Created by hadoop on 4/9/17.
 */
public class BfsTemplate {


    public static void main(String[] args) {

    }
    ArrayList<ArrayList<Integer>>levelOrderTraversalTemplate(TreeNode root){
        ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();
        if( root == null){
            return null;
        }
        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        queue.offer(root);
        while(!queue.isEmpty()){
            int size = queue.size();
            ArrayList<Integer> level = new ArrayList<Integer>();
            for(int i=0;i<size;i++){
                TreeNode head = queue.poll();
                level.add(head.data);
                if(head.left!=null){
                    queue.add(head.left);
                }
                if(head.right!=null){
                    queue.add(head.right);
                }
            }
            result.add(level);
        }
        return result;
    }
    private class TreeNode{
        int data;
        TreeNode left;
        TreeNode right;

        public TreeNode(int data) {
            this.data = data;
        }
    }
}
package ObjectOrientedDesign;

/**
 * Created by hadoop on 26/10/17.
 */
public class ParkingLot {
}
/*
Here is a quick start to get the gears turning...

ParkingLot is a class.

ParkingSpace is a class.

ParkingSpace has an Entrance.

Entrance has a location or more specifically, distance from Entrance.

ParkingLotSign is a class.

ParkingLot has a ParkingLotSign.

ParkingLot has a finite number of ParkingSpaces.

HandicappedParkingSpace is a subclass of ParkingSpace.

RegularParkingSpace is a subclass of ParkingSpace.

CompactParkingSpace is a subclass of ParkingSpace.

ParkingLot keeps array of ParkingSpaces, and a separate array of vacant ParkingSpaces in order of distance from its Entrance.

ParkingLotSign can be told to display "full", or "empty", or "blank/normal/partially occupied" by calling .Full(), .Empty() or .Normal()

Parker is a class.

Parker can Park().

Parker can Unpark().

Valet is a subclass of Parker that can call ParkingLot.FindVacantSpaceNearestEntrance(), which returns a ParkingSpace.

Parker has a ParkingSpace.

Parker can call ParkingSpace.Take() and ParkingSpace.Vacate().

Parker calls Entrance.Entering() and Entrance.Exiting() and ParkingSpace notifies ParkingLot when it is taken or vacated so that ParkingLot can determine if it is full or not. If it is newly full or newly empty or newly not full or empty, it should change the ParkingLotSign.Full() or ParkingLotSign.Empty() or ParkingLotSign.Normal().

HandicappedParker could be a subclass of Parker and CompactParker a subclass of Parker and RegularParker a subclass of Parker. (might be overkill, actually.)

In this solution, it is possible that Parker should be renamed to be Car.



 */
/*
public class ParkingLotAgain
{
    Vector<ParkingSpace> vacantParkingSpaces = null;
    Vector<ParkingSpace> fullParkingSpaces = null;

    int parkingSpaceCount = 0;

    boolean isFull;
    boolean isEmpty;

    ParkingSpace findNearestVacant(ParkingType type)
    {
        Iterator<ParkingSpace> itr = vacantParkingSpaces.iterator();

        while(itr.hasNext())
        {
            ParkingSpace parkingSpace = itr.next();

            if(parkingSpace.parkingType == type)
            {
                return parkingSpace;
            }
        }
        return null;
    }

    void parkVehicle(ParkingType type, Vehicle vehicle)
    {
        if(!isFull())
        {
            ParkingSpace parkingSpace = findNearestVacant(type);

            if(parkingSpace != null)
            {
                parkingSpace.vehicle = vehicle;
                parkingSpace.isVacant = false;

                vacantParkingSpaces.remove(parkingSpace);
                fullParkingSpaces.add(parkingSpace);

                if(fullParkingSpaces.size() == parkingSpaceCount)
                    isFull = true;

                isEmpty = false;
            }
        }
    }

    void releaseVehicle(Vehicle vehicle)
    {
        if(!isEmpty())
        {
            Iterator<ParkingSpace> itr = fullParkingSpaces.iterator();

            while(itr.hasNext())
            {
                ParkingSpace parkingSpace = itr.next();

                if(parkingSpace.vehicle.equals(vehicle))
                {
                    fullParkingSpaces.remove(parkingSpace);
                    vacantParkingSpaces.add(parkingSpace);

                    parkingSpace.isVacant = true;
                    parkingSpace.vehicle = null;

                    if(vacantParkingSpaces.size() == parkingSpaceCount)
                        isEmpty = true;

                    isFull = false;
                }
            }
        }
    }

    boolean isFull()
    {
        return isFull;
    }

    boolean isEmpty()
    {
        return isEmpty;
    }
}

public class ParkingSpace
{
    boolean isVacant;
    Vehicle vehicle;
    ParkingType parkingType;
    int distance;
}

public class Vehicle
{
    int num;
}

public enum ParkingType
{
    REGULAR,
    HANDICAPPED,
    COMPACT,
    MAX_PARKING_TYPE,
}




 */package ObjectOrientedDesign;

/**
 * Created by hadoop on 26/10/17.
 */
public class Elevator {
}
/*
Elevator
First there is an elevator class.
It has a direction (up, down, stand, maintenance),
a current floor and
a list of floor requests sorted in the direction.
It receives request from this elevator.
ElevatorState
doors
Passenger it has boarded, also we need to have addPassenger function, and load it can take
Bank or ElevatorController
Then there is a bank. It contains the elevators and receives the requests from the floors. These are scheduled to all active elevators (not in maintenance).
The scheduling will be like:
if available pick a standing elevator for this floor.
else pick an elevator moving to this floor.
else pick a standing elevator on an other floor.
else pick the elevator with the lowest load.

Each elevator has a set of states.
Maintenance: the elevator does not react to external signals (only to its own signals).
Stand: the elevator is fixed on a floor. If it receives a call. And the elevator is on that floor, the doors open. If it is on another floor, it moves in that direction.
Up: the elevator moves up. Each time it reaches a floor, it checks if it needs to stop. If so it stops and opens the doors. It waits for a certain amount of time and closes the door (unless someting is moving through them. Then it removes the floor from the request list and checks if there is another request. If so the elevator starts moving again. If not it enters the state stand.
Down: like up but in reverse direction.
 *///package ObjectOrientedDesign;
//
//import java.util.*;
//public class Player {
//    private class Pair<T>{
//
//    }
//    private final char label;
//    private Set<Pair<Integer>> pieces = new HashSet<Pair<Integer>>();
//
//    public Player(char label) {
//        this.label = label;
//    }
//
//    public void addOnePiece(Pair<Integer> piece) {
//        pieces.add(piece);
//    }
//
//    public void removeOnePiece(Pair<Integer> piece) {
//        pieces.remove(piece);
//    }
//
//    public Set<Pair<Integer>> getPieces() {
//        return pieces;
//    }
//
//    public char getLabel() {
//        return label;
//    }
//
//}
//
//public class Board {
//    private final char BLACK = '*';
//    private final char WHITE = '^';
//    private Player black;
//    private Player white;
//
//    private char[][] board = new char[8][8];
//
//    public Board() {
//        for (int i = 0; i < board.length; ++i) {
//            for (int j = 0; j < board[0].length; ++j) {
//                board[i][j] = '.';
//            }
//        }
//        black = new Player(BLACK);
//        black.addOnePiece(new Pair<Integer>(3, 4));
//        board[3][4] = BLACK;
//        black.addOnePiece(new Pair<Integer>(4, 3));
//        board[4][3] = BLACK;
//
//        white = new Player(WHITE);
//        white.addOnePiece(new Pair<Integer>(3, 3));
//        board[3][3] = WHITE;
//        white.addOnePiece(new Pair<Integer>(4, 4));
//        board[4][4] = WHITE;
//    }
//
//    public boolean checkMove(Player player, Player opponent,
//            Pair<Integer> piece) {
//        if (piece.getX() < 0 || piece.getX() >= 7)
//            return false;
//        if (piece.getY() < 0 || piece.getY() >= 7)
//            return false;
//        char label = player.getLabel();
//        char backup = board[piece.getX()][piece.getY()];
//        board[piece.getX()][piece.getY()] = label;
//        for (Pair<Integer> pos : opponent.getPieces()) {
//            if (capturedLeftAndRight(pos) || capturedUpAndDown(pos))
//                return true;
//        }
//        board[piece.getX()][piece.getY()] = backup;
//        return false;
//    }
//
//    public boolean capturedLeftAndRight(Pair<Integer> piece) {
//        int row = piece.getX();
//        int col = piece.getY();
//        int leftCol = col - 1 < 0 ? col : col - 1;
//        int rightCol = col + 1 >= 8 ? col : col + 1;
//        char left = board[row][leftCol];
//        char right = board[row][rightCol];
//        return left == right && left != board[row][col] && left != '.';
//    }
//
//    public boolean capturedUpAndDown(Pair<Integer> piece) {
//        int row = piece.getX();
//        int col = piece.getY();
//        int upRow = row - 1 < 0 ? row : row - 1;
//        int downRow = row + 1 >= 8 ? row : row + 1;
//        char up = board[upRow][col];
//        char down = board[downRow][col];
//        return up == down && up != board[row][col] && up != '.';
//    }
//
//    public void flip(Pair<Integer> piece) {
//        if (board[piece.getX()][piece.getY()] == BLACK)
//            board[piece.getX()][piece.getY()] = WHITE;
//        else if (board[piece.getX()][piece.getY()] == WHITE)
//            board[piece.getX()][piece.getY()] = BLACK;
//    }
//
//    @Override
//    public String toString() {
//        String result = new String();
//        result += ' ';
//        for (int i = 0; i < board.length; ++i) {
//            result += i;
//        }
//        result += '\n';
//        for (int i = 0; i < board.length; ++i) {
//            result += i;
//            for (int j = 0; j < board[0].length; ++j) {
//                result += board[i][j];
//            }
//            result += '\n';
//        }
//        return result;
//    }
//
//    public void step() {
//        // System.out.println(this);
//
//        String input = new String();
//        int x = 0;
//        int y = 0;
//        do {
//            System.out.println("White's turn: ");
//            InputStreamReader converter = new InputStreamReader(System.in);
//            BufferedReader in = new BufferedReader(converter);
//            try {
//                input = in.readLine();
//                char[] inputs = input.toCharArray();
//                x = Integer.parseInt("" + inputs[0]);
//                y = Integer.parseInt("" + inputs[1]);
//            } catch (IOException e) {
//                e.printStackTrace();
//            }
//        } while (!checkMove(white, black, new Pair<Integer>(x, y)));
//        board[x][y] = WHITE;
//        white.addOnePiece(new Pair<Integer>(x, y));
//
//        boolean blackWin = true;
//        List<Pair<Integer>> posToBeRemoved = new LinkedList<Pair<Integer>>();
//        for (Pair<Integer> pos : black.getPieces()) {
//            if (capturedLeftAndRight(pos) || capturedUpAndDown(pos)) {
//                flip(pos);
//                // black.removeOnePiece(pos);
//                posToBeRemoved.add(pos);
//                white.addOnePiece(pos);
//                blackWin = false;
//            }
//        }
//        for (Pair<Integer> pos : posToBeRemoved) {
//            black.removeOnePiece(pos);
//        }
//        posToBeRemoved.clear();
//        System.out.println(this);
//        if (blackWin) {
//            System.out.println("Black has won!");
//            System.exit(0);
//        }
//
//        do {
//            System.out.println("Black's turn: ");
//            InputStreamReader converter = new InputStreamReader(System.in);
//            BufferedReader in = new BufferedReader(converter);
//            try {
//                input = in.readLine();
//                char[] inputs = input.toCharArray();
//                x = Integer.parseInt("" + inputs[0]);
//                y = Integer.parseInt("" + inputs[1]);
//            } catch (IOException e) {
//                e.printStackTrace();
//            }
//        } while (!checkMove(black, white, new Pair<Integer>(x, y)));
//        board[x][y] = BLACK;
//        black.addOnePiece(new Pair<Integer>(x, y));
//
//        boolean whiteWin = true;
//        for (Pair<Integer> pos : white.getPieces()) {
//            if (capturedLeftAndRight(pos) || capturedUpAndDown(pos)) {
//                flip(pos);
//                // white.removeOnePiece(pos);
//                posToBeRemoved.add(pos);
//                black.addOnePiece(pos);
//                whiteWin = false;
//            }
//        }
//        for (Pair<Integer> pos : posToBeRemoved) {
//            white.removeOnePiece(pos);
//        }
//        posToBeRemoved.clear();
//        System.out.println(this);
//        if (whiteWin) {
//            System.out.println("White has won!");
//            System.exit(0);
//        }
//    }
//}package ObjectOrientedDesign;

import java.util.*;
public class ParkingLotAgain
{
    Vector<ParkingSpace> vacantParkingSpaces = null;
    Vector<ParkingSpace> fullParkingSpaces = null;

    int parkingSpaceCount = 0;

    boolean isFull;
    boolean isEmpty;

    ParkingSpace findNearestVacant(ParkingType type)
    {
        Iterator<ParkingSpace> itr = vacantParkingSpaces.iterator();

        while(itr.hasNext())
        {
            ParkingSpace parkingSpace = itr.next();

            if(parkingSpace.parkingType == type)
            {
                return parkingSpace;
            }
        }
        return null;
    }

    void parkVehicle(ParkingType type, Vehicle vehicle)
    {
        if(!isFull())
        {
            ParkingSpace parkingSpace = findNearestVacant(type);

            if(parkingSpace != null)
            {
                parkingSpace.vehicle = vehicle;
                parkingSpace.isVacant = false;

                vacantParkingSpaces.remove(parkingSpace);
                fullParkingSpaces.add(parkingSpace);

                if(fullParkingSpaces.size() == parkingSpaceCount)
                    isFull = true;

                isEmpty = false;
            }
        }
    }

    void releaseVehicle(Vehicle vehicle)
    {
        if(!isEmpty())
        {
            Iterator<ParkingSpace> itr = fullParkingSpaces.iterator();

            while(itr.hasNext())
            {
                ParkingSpace parkingSpace = itr.next();

                if(parkingSpace.vehicle.equals(vehicle))
                {
                    fullParkingSpaces.remove(parkingSpace);
                    vacantParkingSpaces.add(parkingSpace);

                    parkingSpace.isVacant = true;
                    parkingSpace.vehicle = null;

                    if(vacantParkingSpaces.size() == parkingSpaceCount)
                        isEmpty = true;

                    isFull = false;
                }
            }
        }
    }

    boolean isFull()
    {
        return isFull;
    }

    boolean isEmpty()
    {
        return isEmpty;
    }
}

class ParkingSpace
{
    boolean isVacant;
    Vehicle vehicle;
    ParkingType parkingType;
    int distance;
}

class Vehicle
{
    int num;
}

enum ParkingType
{
    REGULAR,
    HANDICAPPED,
    COMPACT,
    MAX_PARKING_TYPE,
}
package ObjectOrientedDesign;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

/**
 * Created by hadoop on 26/10/17.
 */

public class ObjectOrientedDesign {
    public class File {
        String fileName = new String();
        String extension = new String();
        long size = 0;
        Calendar createdTime = Calendar.getInstance();
        Calendar modifiedTime = Calendar.getInstance();
        Calendar lastAccessTime = Calendar.getInstance();
        boolean readOnly = false;
        boolean hidden = false;
        boolean isExecutable = false;

        boolean isFolder = false;
        File upperLevel = null;
        Set<File> children = new HashSet<File>();

        public String getName() {
            if (isFolder)
                return fileName;
            else
                return fileName + "." + extension;
        }

        @Override
        public String toString() {
            // String prefix = isFolder ? "/" : "";
            String appendix = isFolder ? "/" : "." + extension;
            return fileName + appendix;
        }
    }

    public class FileSystem {
        File root = new File();
        File current = root;

        public FileSystem() {
            root.fileName = "~";
            root.isFolder = true;
        }

        public boolean create(String databaseName, boolean isFolder) {
            if (current.isFolder) {
                File newFile = new File();
                if (isFolder) {
                    newFile.fileName = databaseName;
                } else {
                    String[] names = databaseName.split("\\.");
                    newFile.fileName = names[0];
                    newFile.extension = names[1];
                }
                newFile.isFolder = isFolder;
                newFile.upperLevel = current;
                current.children.add(newFile);
                return true;
            } else {
                System.out.println("Can only create a file under a directory");
                return false;
            }
        }

        public void list() {
            for (File file : current.children) {
                System.out.printf("%5d %40s\n", file.size, file);
            }
        }

        public boolean changeDirectory(String dir) {
            if (dir.equals("..") && current.upperLevel != null) {
                current = current.upperLevel;
                return true;
            }
            for (File file : current.children) {
                if (file.getName().equals(dir)) {
                    current = file;
                }
                return true;
            }
            return false;
        }

        public boolean remove(String[] names) {
            List<File> filesToRemove = new LinkedList<File>();
            boolean deleted = false;
            for (File file : current.children) {
                for (String databaseName : names) {
                    if (file.getName().equals(databaseName))
                        filesToRemove.add(file);
                }
            }
            for (File file : filesToRemove) {
                current.children.remove(file);
                deleted = true;
            }
            return deleted;
        }
    }

    public static String readCommand(File current) {
        System.out.println(current + "$ ");
        String input = new String();
        InputStreamReader converter = new InputStreamReader(System.in);
        BufferedReader in = new BufferedReader(converter);
        try {
            input = in.readLine();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return input;
    }

//    public static void main(String[] args) {
//        System.out.println("Bruce's file system starts.");
//        Q7_9 instance = new Q7_9();
//        FileSystem system = instance.system;
//        String input = readCommand(system.current);
//
//        while (!input.equals("exit")) {
//            if (input.contains("touch")) {
//                String[] commands = input.split(" ");
//                system.create(commands[1], false);
//            } else if (input.contains("mkdir")) {
//                String[] commands = input.split(" ");
//                system.create(commands[1], true);
//            } else if (input.contains("ls")) {
//                system.list();
//            } else if (input.contains("cd")) {
//                String[] commands = input.split(" ");
//                system.changeDirectory(commands[1]);
//            } else if (input.contains("rm")) {
//                String[] commands = input.split(" ");
//                String[] names = new String[commands.length - 1];
//                for (int i = 0; i < names.length; ++i)
//                    names[i] = commands[i + 1];
//                system.remove(names);
//            }
//            input = readCommand(system.current);
//        }
    //}
}
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Scanner;

class NewTestClass {
    static HashMap<String,Integer[]> hashMap = new HashMap<>();

    public static void main(String args[] ) throws Exception {

        Scanner s = new Scanner(System.in);
        int N = s.nextInt();
        String []sortedarray = new String[N];
        StringBuilder sb = new StringBuilder();
        HashSet<Integer> hashSet = new HashSet<>();
        for(int i=0;i<N;i++){
            String str = s.next();
            sortedarray[i] = str;
            Integer count []= new Integer[26];
            count = getCountArray(count,str.toCharArray());
            hashMap.put(str,count);
        }
        int ans = 0;
        for(int i=0;i<N;i++){
            for(int j=i+1;j<N;j++){
                if(comparestring(sortedarray[i],sortedarray[j])){
                    ans++;
                }
            }
        }
        System.out.println(ans);
    }
    private static boolean comparestring(String one, String two) {
        Integer count1[] = hashMap.get(one);
        Integer count2[] = hashMap.get(two);



        HashSet<Character> hashSet = new HashSet<>();
        int i=0;
        while (i<one.length() ){
            hashSet.add(one.charAt(i));
            if(hashSet.size()>9){
                break;
            }
            i++;
        }
        int j=0;
        while (j<two.length()){
            if(hashSet.contains(two.charAt(j))){
                return false;
            }
            j++;
        }

        return true;
    }
    private static int gethashcode(int[] count) {
        int hash = 0;
        int a = 31;
        for(int ch:count){
            hash = hash*a + ch;
        }
        return hash;
    }

    private static Integer[] getCountArray(Integer[] count, char[] chars) {
        for(int i=0;i<chars.length;i++){
            count[chars[i]-'a']++;
        }
        return count;
    }
}//package SystemDesign;
//
//import java.util.ArrayList;
//import org.apache.commons.collections.MapIterator;
//import org.apache.commons.collections.map.LRUMap;
//
///**
// * @author Crunchify.com
// */
//
//public class CrunchifyInMemoryCache<K, T> {
//
//    private long timeToLive;
//    private LRUMap crunchifyCacheMap;
//
//    protected class CrunchifyCacheObject {
//        public long lastAccessed = System.currentTimeMillis();
//        public T value;
//
//        protected CrunchifyCacheObject(T value) {
//            this.value = value;
//        }
//    }
//
//    public CrunchifyInMemoryCache(long crunchifyTimeToLive, final long crunchifyTimerInterval, int maxItems) {
//        this.timeToLive = crunchifyTimeToLive * 1000;
//
//        crunchifyCacheMap = new LRUMap(maxItems);
//
//        if (timeToLive > 0 && crunchifyTimerInterval > 0) {
//
//            Thread t = new Thread(new Runnable() {
//                public void run() {
//                    while (true) {
//                        try {
//                            Thread.sleep(crunchifyTimerInterval * 1000);
//                        } catch (InterruptedException ex) {
//                        }
//                        cleanup();
//                    }
//                }
//            });
//
//            t.setDaemon(true);
//            t.start();
//        }
//    }
//
//    public void put(K key, T value) {
//        synchronized (crunchifyCacheMap) {
//            crunchifyCacheMap.put(key, new CrunchifyCacheObject(value));
//        }
//    }
//
//    @SuppressWarnings("unchecked")
//    public T get(K key) {
//        synchronized (crunchifyCacheMap) {
//            CrunchifyCacheObject c = (CrunchifyCacheObject) crunchifyCacheMap.get(key);
//
//            if (c == null)
//                return null;
//            else {
//                c.lastAccessed = System.currentTimeMillis();
//                return c.value;
//            }
//        }
//    }
//
//    public void remove(K key) {
//        synchronized (crunchifyCacheMap) {
//            crunchifyCacheMap.remove(key);
//        }
//    }
//
//    public int size() {
//        synchronized (crunchifyCacheMap) {
//            return crunchifyCacheMap.size();
//        }
//    }
//
//    @SuppressWarnings("unchecked")
//    public void cleanup() {
//
//        long now = System.currentTimeMillis();
//        ArrayList<K> deleteKey = null;
//
//        synchronized (crunchifyCacheMap) {
//            MapIterator itr = crunchifyCacheMap.mapIterator();
//
//            deleteKey = new ArrayList<K>((crunchifyCacheMap.size() / 2) + 1);
//            K key = null;
//            CrunchifyCacheObject c = null;
//
//            while (itr.hasNext()) {
//                key = (K) itr.next();
//                c = (CrunchifyCacheObject) itr.getValue();
//
//                if (c != null && (now > (timeToLive + c.lastAccessed))) {
//                    deleteKey.add(key);
//                }
//            }
//        }
//
//        for (K key : deleteKey) {
//            synchronized (crunchifyCacheMap) {
//                crunchifyCacheMap.remove(key);
//            }
//
//            Thread.yield();
//        }
//    }
//}package SystemDesign;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

/**
 * Created_By: stefanie
 * Date: 15-2-3
 * Time: 11:56
 */
public class G50_RPSChecker {

    static class RPSChecker{
        private int limitation;
        private AtomicInteger count = new AtomicInteger(0);
        private AtomicLong startTimestamp = new AtomicLong(-1);

        public void setRPS(int count){
            this.limitation = count;
        }

        public boolean process(long timestamp){
            if (timestamp - startTimestamp.get() >= 1000) {
                count.set(1);
                startTimestamp.set(timestamp);
                return true;
            } else if(count.incrementAndGet() <= limitation) {
                return true;
            }
            return false;
        }

    }

    static class RequestSender implements Runnable{
        RPSChecker checker;
        int id;
        RequestSender(int id, RPSChecker checker){
            this.id = id;
            this.checker = checker;
        }
        @Override
        public void run() {
            while(true){
               if(checker.process(System.currentTimeMillis())){
                   System.out.printf("Sender %d sent a request\n", id);
               } else {
                   System.out.printf("Sender %d request rejected \n", id);
               }
                try {
                    TimeUnit.MILLISECONDS.sleep(400);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        RPSChecker checker = new RPSChecker();
        checker.setRPS(7);
        ExecutorService executor = Executors.newCachedThreadPool();
        for(int i = 0; i < 5; i++){
            executor.execute(new RequestSender(i, checker));
        }
        TimeUnit.SECONDS.sleep(5);
        System.out.println("Adapt RPS to 15");
        checker.setRPS(15);
        TimeUnit.SECONDS.sleep(5);
        System.exit(0);
    }
}
//package SystemDesign;
//
//import com.google.common.hash.HashFunction;
//
//import java.util.Collection;
//import java.util.SortedMap;
//import java.util.TreeMap;
//
//public class ConsistentHash<T> {
//
//  private final HashFunction hashFunction;
//  private final int numberOfReplicas;
//  private final SortedMap<Integer, T> circle =
//    new TreeMap<Integer, T>();
//
//  public ConsistentHash(HashFunction hashFunction,
//    int numberOfReplicas, Collection<T> nodes) {
//
//    this.hashFunction = hashFunction;
//    this.numberOfReplicas = numberOfReplicas;
//
//    for (T node : nodes) {
//      add(node);
//    }
//  }
//
//  public void add(T node) {
//    for (int i = 0; i < numberOfReplicas; i++) {
//      circle.put(hashFunction.hashString(node.toString() + i).asInt(),
//        node);
//    }
//  }
//
//  public void remove(T node) {
//    for (int i = 0; i < numberOfReplicas; i++) {
//
//      circle.remove(hashFunction.hashString(node.toString() + i));
//    }
//  }
//
//  public T get(Object key) {
//    if (circle.isEmpty()) {
//      return null;
//    }
//    int hash = hashFunction.hashString(key.toString()).asInt();
//    if (!circle.containsKey(hash)) {
//      SortedMap<Integer, T> tailMap =
//        circle.tailMap(hash);
//      hash = tailMap.isEmpty() ?
//             circle.firstKey() : tailMap.firstKey();
//    }
//    return circle.get(hash);
//  }
//
//}package SystemDesign;

/**
 *Exception to indicate that Stack is full.
 */
class StackFullException extends RuntimeException {
     
    public StackFullException(){
        super();
    }
    
    public StackFullException(String message){
        super(message);
    }
    
}
 
/**
 *Exception to indicate that Stack is empty.
 */
class StackEmptyException extends RuntimeException {
     
    public StackEmptyException(){
        super();
    }
    
    public StackEmptyException(String message){
        super(message);
    }
    
}
 
 
 
/**
 * Stack class(generic type)
 */
class Stack<T> {
    private int size;
    private T[] stackAr;
    private int top; // top of stack
 
    /**
     * Constructor for initializing Array.
     */
    @SuppressWarnings("unchecked")
    public Stack(int size) {
           this.size = size;
           stackAr = (T[])new Object[size]; //Creation of Generic Stack Array
           top = -1; // initialize Stack to with -1
    }
 
    /**
     * Push items in stack, it will put items on top of Stack.
     */
    public void push(T value){
           if(isFull()){
                  throw new StackFullException("Cannot push "+value+", Stack is full");
           }
           stackAr[++top] = value;
    }
 
    /**
     * Pop items in stack, it will remove items from top of Stack.
     */
    public T pop() {
           if(isEmpty()){
                  throw new StackEmptyException("Stack is empty");
           }
           return stackAr[top--]; // remove item and decrement top as well.
    }
 
    /**
     * @return true if Stack is empty
     */
    public boolean isEmpty(){
           return (top == -1);
    }
 
    /**
     * @return true if stack is full
     */
    
    public boolean isFull(){
           return (top == size - 1);
    }
 
}
  
/** Copyright (c), AnkitMittal JavaMadeSoEasy.com */
/**
 * Main class - StackExampleGeneric 
 */
public class StackExampleGeneric {
    public static void main(String[] args) {
           Stack<Integer> stack = new Stack<Integer>(10); // Creation of Generic Stack
           stack.push(11);
           stack.push(21);
           stack.push(31);
           stack.push(41);
           stack.push(51);
           
           System.out.print("Popped items: ");
           System.out.print(stack.pop()+" ");
           System.out.print(stack.pop()+" ");
           System.out.print(stack.pop()+" ");
           System.out.print(stack.pop()+" ");
           System.out.print(stack.pop()+" ");
 
           
    }
 
}
 package SystemDesign;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.util.Iterator;
import java.util.Set;
 
/**
 * @author Crunchify.com
 *
 */
 
public class CrunchifyNIOServer {
 
	@SuppressWarnings("unused")
    public static void main(String[] args) throws IOException {
 
		// Selector: multiplexor of SelectableChannel objects
		Selector selector = Selector.open(); // selector is open here
 
		// ServerSocketChannel: selectable channel for stream-oriented listening sockets
		ServerSocketChannel crunchifySocket = ServerSocketChannel.open();
		InetSocketAddress crunchifyAddr = new InetSocketAddress("localhost", 1111);
 
		// Binds the channel's socket to a local address and configures the socket to listen for connections
		crunchifySocket.bind(crunchifyAddr);
 
		// Adjusts this channel's blocking mode.
		crunchifySocket.configureBlocking(false);
 
		int ops = crunchifySocket.validOps();
		SelectionKey selectKy = crunchifySocket.register(selector, ops, null);
 
		// Infinite loop..
		// Keep server running
		while (true) {
 
			log("i'm a server and i'm waiting for new connection and buffer select...");
			// Selects a set of keys whose corresponding channels are ready for I/O operations
			selector.select();
 
			// token representing the registration of a SelectableChannel with a Selector
			Set<SelectionKey> crunchifyKeys = selector.selectedKeys();
			Iterator<SelectionKey> crunchifyIterator = crunchifyKeys.iterator();
 
			while (crunchifyIterator.hasNext()) {
				SelectionKey myKey = crunchifyIterator.next();
 
				// Tests whether this key's channel is ready to accept a new socket connection
				if (myKey.isAcceptable()) {
					SocketChannel crunchifyClient = crunchifySocket.accept();
 
					// Adjusts this channel's blocking mode to false
					crunchifyClient.configureBlocking(false);
 
					// Operation-set bit for read operations
					crunchifyClient.register(selector, SelectionKey.OP_READ);
					log("Connection Accepted: " + crunchifyClient.getLocalAddress() + "\n");
 
					// Tests whether this key's channel is ready for reading
				} else if (myKey.isReadable()) {
					
					SocketChannel crunchifyClient = (SocketChannel) myKey.channel();
					ByteBuffer crunchifyBuffer = ByteBuffer.allocate(256);
					crunchifyClient.read(crunchifyBuffer);
					String result = new String(crunchifyBuffer.array()).trim();
 
					log("Message received: " + result);
 
					if (result.equals("Crunchify")) {
						crunchifyClient.close();
						log("\nIt's time to close connection as we got last company databaseName 'Crunchify'");
						log("\nServer will keep running. Try running client again to establish new connection");
					}
				}
				crunchifyIterator.remove();
			}
		}
	}
 
	private static void log(String str) {
		System.out.println(str);
	}
}package SystemDesign;

import java.util.Calendar;
import java.util.Comparator;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.PriorityBlockingQueue;

public class Scheduler {
    /**
     * Interface that defines a task to be run by this scheduler.
     */
    public interface Task {
        /**
         * Run the task.
         */
        void run();
    }

    private static final int CAPACITY = 10;

    private final BlockingQueue<TimedTask> queue = new PriorityBlockingQueue<>(CAPACITY,
            new Comparator<TimedTask>() {
                @Override
                public int compare(TimedTask s, TimedTask t) {
                    return s.getScheduledTime().compareTo(t.getScheduledTime());
                }
            });

    private final Object lock = new Object();
    private volatile boolean running = true;

    public void start() throws InterruptedException {
        while (running) {
            TimedTask task = queue.take();
            if (task != null) {
                task.run(); // Ideally this should be run in a separate thread.
            }
            waitForNextTask();
        }
    }

    private void waitForNextTask() throws InterruptedException {
        synchronized (lock) {
            TimedTask nextTask = queue.peek();
            while (nextTask == null || !nextTask.shouldRunNow()) {
                if (nextTask == null) {
                    lock.wait();
                } else {
                    lock.wait(nextTask.runFromNow());
                }
                nextTask = queue.peek();
            }
        }
    }

    public void add(Task task) {
        add(task, 0);
    }

    public void add(Task task, long delayMs) {
        synchronized (lock) {
            queue.offer(TimedTask.fromTask(task, delayMs));
            lock.notify();
        }
    }

    public void stop() {
        this.running = false;
    }

    private static class TimedTask {
        private Task task;
        private Calendar scheduledTime;

        public TimedTask(Task task, Calendar scheduledTime) {
            this.task = task;
            this.scheduledTime = scheduledTime;
        }

        public static TimedTask fromTask(Task task, long delayMs) {
            Calendar now = Calendar.getInstance();
            now.setTimeInMillis(now.getTimeInMillis() + delayMs);
            return new TimedTask(task, now);
        }

        public Calendar getScheduledTime() {
            return scheduledTime;
        }

        public long runFromNow() {
            return scheduledTime.getTimeInMillis() - Calendar.getInstance().getTimeInMillis();
        }

        public boolean shouldRunNow() {
            return runFromNow() <= 0;
        }

        public void run() {
            task.run();
        }
    }

    public static void main(String[] argv) throws InterruptedException {
        class MyTask implements Task {
            private String databaseName;

            public MyTask(String databaseName) {
                this.databaseName = databaseName;
            }

            @Override
            public void run() {
                System.out.println(databaseName + ": " + Calendar.getInstance().getTimeInMillis());
            }
        }

        final Scheduler scheduler =  new Scheduler();
        scheduler.add(new MyTask("No. 1"));
        scheduler.add(new MyTask("No. 2"), 10000);
        new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    scheduler.start();
                } catch (InterruptedException e) {

                }
            }
        }).start();

        new Thread(new Runnable() {
            @Override
            public void run() {
                scheduler.add(new MyTask("No. 3"), 200);
                scheduler.add(new MyTask("No. 4"), 1000);
                scheduler.add(new MyTask("No. 5"), 300);
                scheduler.add(new MyTask("No. 6"), 700);
                scheduler.add(new MyTask("No. 7"), 100);
            }
        }).start();
    }
}package SystemDesign;

import static java.util.Collections.*;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;

/**
 * A hash map that expires and removes items if they are older than a given
 * time-to-live.
 * <p>
 * The expiry is a passive process, items aren't removed until they are
 * retrieved and deemed to be expired by {@link #get(Object)}.
 */
public class TtlHashMap<K, V> implements Map<K, V> {

    private final HashMap<K, V> store = new HashMap<>();
    private final HashMap<K, Long> timestamps = new HashMap<>();
    private final long ttl;

    public TtlHashMap(TimeUnit ttlUnit, long ttlValue) {
        this.ttl = ttlUnit.toNanos(ttlValue);
    }

    @Override
    public V get(Object key) {
        V value = this.store.get(key);

        if (value != null && expired(key, value)) {
            store.remove(key);
            timestamps.remove(key);
            return null;
        } else {
            return value;
        }
    }

    private boolean expired(Object key, V value) {
        return (System.nanoTime() - timestamps.get(key)) > this.ttl;
    }

    @Override
    public V put(K key, V value) {
        timestamps.put(key, System.nanoTime());
        return store.put(key, value);
    }

    @Override
    public int size() {
        return store.size();
    }

    @Override
    public boolean isEmpty() {
        return store.isEmpty();
    }

    @Override
    public boolean containsKey(Object key) {
        return store.containsKey(key);
    }

    @Override
    public boolean containsValue(Object value) {
        return store.containsValue(value);
    }

    @Override
    public V remove(Object key) {
        timestamps.remove(key);
        return store.remove(key);
    }

    @Override
    public void putAll(Map<? extends K, ? extends V> m) {
        for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {
            this.put(e.getKey(), e.getValue());
        }
    }

    @Override
    public void clear() {
        timestamps.clear();
        store.clear();
    }

    @Override
    public Set<K> keySet() {
        clearExpired();
        return unmodifiableSet(store.keySet());
    }

    @Override
    public Collection<V> values() {
        clearExpired();
        return unmodifiableCollection(store.values());
    }

    @Override
    public Set<java.util.Map.Entry<K, V>> entrySet() {
        clearExpired();
        return unmodifiableSet(store.entrySet());
    }

    private void clearExpired() {
        for (K k : store.keySet()) {
            this.get(k);
        }
    }

}package SystemDesign;
 
import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SocketChannel;
import java.util.ArrayList;
 
/**
 * @author Crunchify.com
 *
 */
 
public class CrunchifyNIOClient {
 
	public static void main(String[] args) throws IOException, InterruptedException {
 
		InetSocketAddress crunchifyAddr = new InetSocketAddress("localhost", 1111);
		SocketChannel crunchifyClient = SocketChannel.open(crunchifyAddr);
 
		log("Connecting to Server on port 1111...");
 
		ArrayList<String> companyDetails = new ArrayList<String>();
 
		// create a ArrayList with companyName list
		companyDetails.add("Facebook");
		companyDetails.add("Twitter");
		companyDetails.add("IBM");
		companyDetails.add("Google");
		companyDetails.add("Crunchify");
 
		for (String companyName : companyDetails) {
 
			byte[] message = new String(companyName).getBytes();
			ByteBuffer buffer = ByteBuffer.wrap(message);
			crunchifyClient.write(buffer);
 
			log("sending: " + companyName);
			buffer.clear();
 
			// wait for 2 seconds before sending next message
			Thread.sleep(2000);
		}
		crunchifyClient.close();
	}
 
	private static void log(String str) {
		System.out.println(str);
	}
}package SystemDesign;

/**
 * Created by hadoop on 9/10/17.
 */


interface ReadWriteLock{
    public ReentrantReadWriteLock.ReadLock readLock();
    public ReentrantReadWriteLock.WriteLock writeLock();
}
class ReentrantReadWriteLock implements ReadWriteLock{
    public int readLockCount;
    public int writeLockCount;
    public ReadLock readLock;
    public WriteLock writeLock;
    public ReentrantReadWriteLock() {
        super();
    }

    @Override
    public ReadLock readLock() {
        return readLock;
    }

    @Override
    public WriteLock writeLock() {
        return writeLock;
    }

    public class ReadLock{
        public synchronized void lock (){
            if(writeLockCount == 0 ){
                readLockCount++;
            }
            try {
                wait();
            }
            catch (Exception e){

            }
        }
        public synchronized void release(){
            readLockCount--;
            if(readLockCount == 0) {
                notifyAll();
            }
        }
    }
    public class WriteLock{
        public synchronized void lock(){
            if(writeLockCount == 0 && readLockCount == 0){
                writeLockCount++;
            }
            else {
                try {
                    wait();
                } catch (Exception e) {

                }
            }
        }
        public synchronized void release(){
            writeLockCount--;
            if(writeLockCount ==0){
                notifyAll();
            }
        }

    }
}package SystemDesign;

/**
 * Created by hadoop on 8/10/17.
 */
public class TokenBucketApiLimit {
    long capacity;
    double refillTokensPerMilliSeconds;
    long availableTokens;
    long lastRefillTimeStamp;
    // max capacity
    TokenBucketApiLimit(long capacity,long refillTokens,long refillPeriodTimeInMills){
        this.capacity = capacity;
        this.availableTokens =capacity;
        lastRefillTimeStamp = System.currentTimeMillis();
        this.refillTokensPerMilliSeconds = (double)refillTokens/(double)refillPeriodTimeInMills;
    }
    synchronized public  boolean tryConsume(int numberOfTokens){
        refill();
        if(availableTokens>=numberOfTokens){
            availableTokens-=numberOfTokens;
            return true;
        }
        else {
            return false;
        }
    }

    private void refill() {
        long currentTimeStamp = System.currentTimeMillis();
        if(currentTimeStamp > lastRefillTimeStamp){
            long missedTimeStamp = currentTimeStamp-lastRefillTimeStamp;
            long totaltokenstobeadded = (long)(missedTimeStamp*this.refillTokensPerMilliSeconds);
            availableTokens = Math.min(capacity,availableTokens+totaltokenstobeadded);
            this.lastRefillTimeStamp = currentTimeStamp;
        }
    }
}
package SystemDesign;
import java.util.*;

public class LFUCache {
    
    private int min;

    private final int capacity;
    private final HashMap<Integer, Integer> keyToVal;
    private final HashMap<Integer, Integer> keyToCount;
    private final HashMap<Integer, LinkedHashSet<Integer>> countToLRUKeys;
    
    public LFUCache(int capacity) {
        this.min = -1;
        this.capacity = capacity;
        this.keyToVal = new HashMap<>();
        this.keyToCount = new HashMap<>();
        this.countToLRUKeys = new HashMap<>();
    }
    
    public int get(int key) {
        if (!keyToVal.containsKey(key)) return -1;
        
        int count = keyToCount.get(key);
        countToLRUKeys.get(count).remove(key); // remove key from current count (since we will inc count)
        if (count == min && countToLRUKeys.get(count).size() == 0) min++; // nothing in the current min bucket
        
        putCount(key, count + 1);
        return keyToVal.get(key);
    }
    
    public void put(int key, int value) {
        if (capacity <= 0) return;
        
        if (keyToVal.containsKey(key)) {
            keyToVal.put(key, value); // update key's value
            get(key); // update key's count
            return;
        } 
        
        if (keyToVal.size() >= capacity)
            evict(countToLRUKeys.get(min).iterator().next()); // evict LRU from this min count bucket
        
        min = 1;
        putCount(key, min); // adding new key and count
        keyToVal.put(key, value); // adding new key and value
    }
    
    private void evict(int key) {
        countToLRUKeys.get(min).remove(key);
        keyToVal.remove(key);
    }
    
    private void putCount(int key, int count) {
        keyToCount.put(key, count);
        countToLRUKeys.computeIfAbsent(count, ignore -> new LinkedHashSet<>());
        countToLRUKeys.get(count).add(key);
    }
}
/*
public class LFUCache {
    HashMap<Integer, LinkedHashSet<Integer>> keys;
    HashMap<Integer, Integer> counts;
    HashMap<Integer, Integer> keyValue;
    int capacity;
    int minCount;
    public LFUCache(int capacity) {
        keys = new HashMap<>();
        counts = new HashMap<>();
        keyValue = new HashMap<>();
        this.capacity = capacity;
        minCount = 0;
    }

    public int get(int key) {
        if(capacity <=0) return -1;
        if (!keyValue.containsKey(key)) return -1;
        int count = counts.get(key);
        counts.put(key,count+1); // Update the count of this key
        Set<Integer> lhs = keys.get(count);
        lhs.remove(key);
        if(count == minCount && lhs.isEmpty()) {
            minCount++;
        }
        if(!keys.containsKey(count+1)) {
            keys.put(count+1, new LinkedHashSet<Integer>());
        }
        keys.get(count+1).add(key);
        return keyValue.get(key);
    }

    public void put(int key, int value) {
        if(capacity <= 0) return;
        if(keyValue.containsKey(key)) {
            keyValue.put(key,value);
            get(key);
            return;
        } else {
            if(keyValue.size() >= capacity) { // Eviction
                int evictionKey = keys.get(minCount).iterator().next();
                keys.get(minCount).remove(evictionKey);
                keyValue.remove(evictionKey);
                counts.remove(evictionKey);
            }
            keyValue.put(key, value); // Put the entry in the HashMap
            LinkedHashSet<Integer> lhs;
            if(keys.containsKey(1)){
                lhs = keys.get(1);
            } else {
                lhs = new LinkedHashSet<Integer>();
            }
            lhs.add(key);
            counts.put(key,1);
            keys.put(1,lhs);
            minCount = 1;
        }
    }
}
 */package SystemDesign;/* from wikipedia, solution for multiple producers and consumers

semaphore mutex = 1;
semaphore fillCount = 0;
semaphore emptyCount = BUFFER_SIZE;

procedure producer() {
    while (true) {
        item = produceItem();
        down(emptyCount);
            down(mutex);
                putItemIntoBuffer(item);
            up(mutex);
        up(fillCount);
    }
}

procedure consumer() {
    while (true) {
        down(fillCount);
            down(mutex);
                item = removeItemFromBuffer();
            up(mutex);
        up(emptyCount);
        consumeItem(item);
    }
}
*/

// package com.epi;

import java.util.concurrent.Semaphore;
import java.util.Date;
import java.util.Deque;
import java.util.LinkedList;

public class ProducerConsumer {
  static final int BUFFER_SIZE = 10;
  static Semaphore emptyCount = new Semaphore(BUFFER_SIZE);
  static Semaphore fillCount = new Semaphore(0);
  static Semaphore mutex = new Semaphore(1);
  static Deque<String> buffer = new LinkedList<>();
  static int globalId = 0;

  static class Producer {
    String databaseName;
    Producer(String databaseName) { this.databaseName = databaseName; }
    void producer() throws InterruptedException {
      while (true) {
        String item = databaseName + ":" + globalId++;
        emptyCount.acquire();
        mutex.acquire();
        buffer.addLast(item + " " + buffer.size());
        System.out.println(databaseName + " wrote " + item + " buffer size now "
                           + buffer.size());
        mutex.release();
        fillCount.release();
      }
    }
  }

  static class Consumer {
    String databaseName;
    Consumer(String databaseName) { this.databaseName = databaseName; }
    void consumer() throws InterruptedException {
      while (true) {
        fillCount.acquire();
        mutex.acquire();
        String item = buffer.removeFirst();
        mutex.release();
        emptyCount.release();
        System.out.println(databaseName + " read " + item);
      }
    }
  }

  static class ProducerRunnable implements Runnable {
    Producer p;

    ProducerRunnable(Producer p) { this.p = p; }

    public void run() {
      try {
        p.producer();
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
    }
  }

  static class ConsumerRunnable implements Runnable {
    Consumer c;

    ConsumerRunnable(Consumer c) { this.c = c; }

    public void run() {
      try {
        c.consumer();
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
    };
  }

  public static void main(String[] args) {
    Producer p1 = new Producer("p1");
    Producer p2 = new Producer("p2");
    Consumer c1 = new Consumer("c1");
    Consumer c2 = new Consumer("c2");

    Thread tp1 = new Thread(new ProducerRunnable(p1));
    Thread tp2 = new Thread(new ProducerRunnable(p2));
    Thread tc1 = new Thread(new ConsumerRunnable(c1));
    Thread tc2 = new Thread(new ConsumerRunnable(c2));

    tp1.start();
    tp2.start();
    tc1.start();
    tc2.start();
    try {
      Thread.sleep(1000);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
  }
}
package SystemDesign;

import java.util.*;
public class MyDataStrucutre{
List<Integer> nums;
Map<Integer, Integer> locs;
java.util.Random rand = new java.util.Random();
public MyDataStrucutre() {
nums = new ArrayList<>();
locs = new HashMap<Integer, Integer>();
}

boolean insert(int val) {
boolean contain = locs.containsKey(val);
if ( contain ) return false;
locs.put( val, nums.size());
nums.add(val);
return true;
}

boolean remove(int val) {
boolean contain = locs.containsKey(val);
if ( ! contain ) return false;
int loc = locs.get(val);
if (loc < nums.size() - 1 ) { 
int lastone = nums.get(nums.size() - 1 );
nums.set( loc , lastone );
locs.put(lastone, loc);
}
locs.remove(val);
nums.remove(nums.size() - 1);
return true;
}

int getRandom() {
return nums.get( rand.nextInt(nums.size()) );
}
}package SystemDesign;

/**
 *Exception to indicate that Queue is full.
 */
class QueueFullException extends RuntimeException {
     
    public QueueFullException(){
        super();
    }
    
    public QueueFullException(String message){
        super(message);
    }
    
}
 
/**
 *Exception to indicate that Queue is empty.
 */
class QueueEmptyException extends RuntimeException {
     
    public QueueEmptyException(){
        super();
    }
    
    public QueueEmptyException(String message){
        super(message);
    }
    
}
 
/** Copyright (c), AnkitMittal JavaMadeSoEasy.com */ 
/**
 * Queue class
 */
class Queue {
    
    private int[] queueAr;
    private int size; //Size of Queue
    
    private int rear; //elements will be added at rear.
    private int front;   //elements will be removed from front
    private int number;  //holds number of elements in Queue, initialized with 0 by default
 
    /**
     * Constructor
     */
    public Queue(int size) {
           this.size = size;
           queueAr = new int[this.size];         
           rear = 0;
           front = 0;
    }
 
    /**
     * Insert element at rear in Queue
     */
    public void insert(int value){
           
           if(isFull()){
                  throw new QueueFullException("Cannot insert "+value+", Queue is full");
           }          
           if (rear == size ) // means we are at last position (deal with wrapAround)
                  rear = 0;
           queueAr[rear++] = value; // Insert element and increment rear
           number++; //increase number of elements in Queue
    }
 
    
    /**
     * Removes elements from front of Queue 
     */
    public int remove(){
           if(isEmpty()){
                  throw new QueueEmptyException("Queue is empty");
           }
           
           int deletedValue = queueAr[front++]; // get value at front and than increment front
           if (front == size) // deal with wrapAround
                  front = 0;
           number--; //reduce number of elements in Queue
           return deletedValue;
    }
 
    /**
     * @return true if Queue is empty
     */
    public boolean isEmpty() {
           return (number == 0);
    }
    
    /**
     * @return true if Queue is full
     */
    public boolean isFull() {
           return (number == size);
    }
    
}
 
 
/**
 * QueueExample - Main class
 */
public class QueueExample {
    public static void main(String[] args) {
           Queue queue = new Queue(10); // queue holds 10 elements
           
           queue.insert(31);
           queue.insert(49);
 
           queue.remove();
           queue.remove();
 
           queue.insert(90);
           queue.insert(81);
           queue.insert(72);
           queue.insert(22); // At this Point we got to deal with wrapAround, because rear must be pointing to last position.
           
           System.out.print("Deleted elements from queue: ");
           System.out.print(queue.remove()+ " ");
           System.out.print(queue.remove()+ " ");
           System.out.print(queue.remove()+ " ");
           System.out.print(queue.remove()+ " ");
           
    }
}
 package SystemDesign;

import java.util.*;

/**
 * @author Baofeng Xue at 2016/5/13 18:18.
 *         Suppose you are an engineer on the Amazon Student team.Your team want to launch new feature called "Courses your social network have attended",
 *         that lists all the courses your social network are taking, sorted by popularity.
 *         A social network is defined as all direct friends and all direct friends of direct friends.
 *         People 3 level deep are not part of the social circle.
 *         <p>
 *         The recommendation logic is based on the following rules:
 *         <p>
 *         1. A user should only be recommended a course that their social network have attended but they have not attended.
 *         <p>
 *         2. The recommendation priority is driven by how many people have attended the same course -
 *         if multiple people attended the same course it should be higher in the recommendations than a course that only one person attended.
 **/
public class SocialNetworkTraversal {

    private Map<String, Integer> coursesMap = new HashMap<>();

    public List<String> getDirectFriendsForUser(String user) {
        ArrayList<String> strings = new ArrayList<>();
        strings.add("Sue");
        strings.add("Amy");
        return strings;
    }

    public List<String> getAttendedCoursesForUser(String user) {
        ArrayList<String> strings = new ArrayList<>();
        strings.add("A");
        strings.add("B");
        return strings;
    }

    public List<String> getRankedCourses(String user) {
        List<String> directFriendsForUser = getDirectFriendsForUser(user);
        for (String friend : directFriendsForUser) {
            List<String> coursesForUser = getAttendedCoursesForUser(friend);
            for (String course : coursesForUser) {
                if (coursesMap.get(course) == null) {
                    coursesMap.put(course, 1);
                } else {
                    coursesMap.put(course, coursesMap.get(course) + 1);
                }
            }
        }

        List<String> recommendation = new ArrayList<>();
        List<String> attendedCoursesForUser = getAttendedCoursesForUser(user);
        for (String course : coursesMap.keySet()) {
            if (!attendedCoursesForUser.contains(course)) {
                recommendation.add(course);
            }
        }

        Collections.sort(recommendation, new Comparator<String>() {
            @Override
            public int compare(String o1, String o2) {
                return coursesMap.get(o2) - coursesMap.get(o1);
            }
        });

        return recommendation;
    }
}package OldAttemptLearning.DisjointDatastructure;

/**
 * Created by hadoop on 26/8/17.
 */
public class DisjointUnionSets {
    int [] rank,parent;
    int n;

    public DisjointUnionSets(int n){
        rank = new int[n];
        parent = new int[n];
        this.n = n;
        makeset();
    }

    private void makeset() {
        for ( int i=0;i<n;i++){
            parent[i] = i;
        }
    }

    int find (int x){
        if(parent[x]!=x){
            parent[x] = find(x);
        }
        return parent[x];
    }


}
package OldAttemptLearning.dynamicprogramming;

public class Solution {
    public static Integer cache[] ;

    public int numDecodings(String s) {

        cache= new Integer[s.length()+1];
        for(int i=0;i<s.length()+1;i++){
            cache[i]=-1;
        }
        if(s.equals(""))
            return 0;
        return topdp(s.toCharArray(),s.length()-1);

    }

    private static int topdp(char[] s, int i) {
        int numberofways = 0;

        if(i==0  && s[i]=='0'){
            return 0;
        }
        if(i==0 && s[i]!='0'){
            return 1;
        }
        if(i<0) return 1;

        if(cache[i] !=-1) return cache[i];
        if(s[i] !='0') {
            numberofways = numberofways+topdp(s, i - 1);
        }

        if(i-1>=0) {
            int value = Integer.parseInt(String.valueOf(s).substring(i - 1, i+1));
            if(value<=26 && value>=10){
                numberofways = numberofways + topdp(s,i-2);
            }
        }
        cache[i] = numberofways;
        return numberofways;
    }
}package OldAttemptLearning.dynamicprogramming;

import java.util.concurrent.atomic.AtomicInteger;

/**
 * Created by hadoop on 3/8/17.
 */
public class MaxSubArray {
    public static void main(String[] args) {
        int [] array = {-2,1,-3,4,-1,2,1,-5,4};
        AtomicInteger integer = new AtomicInteger();
        integer.set(Integer.MIN_VALUE);
        int maxsubarray = maxsubrecursive(array,array.length-1,integer);
        System.out.println(integer.get());
    }

    private static int maxsubrecursive(int[] array, int i, AtomicInteger integer) {
        if(i==0 ){
            return Math.max(0,array[0]);
        }
        else{
            integer.set(Math.max(integer.get(),Math.max(0,array[i]+maxsubrecursive(array,i-1, integer))));
            return Math.max(0,array[i]+maxsubrecursive(array,i-1, integer));
        }
    }
}
package OldAttemptLearning.dynamicprogramming;

/**
 * Created by hadoop on 3/8/17.
 */
public class Robber {
    public static void main(String[] args) {
        Integer array[] = new Integer[4];
        array[0] = 1;
                array[1] = 2;
        array[2] =100;
        array[3] = 5;
        int rob = robbery(array,array.length-1);
        System.out.println(rob);
    }

    private static int robbery(Integer nums[],int index) {
        if(index == 0){
            return nums[index];
        }
        if(index <0) return 0;

        int returned = Math.max(robbery(nums,index-1),nums[index]+robbery(nums,index-2));

        return returned;
    }
}
package OldAttemptLearning.dynamicprogramming;


import java.util.HashMap;
import java.util.Map;

/**
 * Created by hadoop on 5/8/17.
 */
public class WildCardMatching {
    static Map<Pair, Boolean> cache = new HashMap<Pair, Boolean>();

    public static void main(String[] args) {

//        "abefcdgiescdfimde"
//        "ab*cd?i*de"
        String s = "abefcdgiescdfimde";
        String p = "ab*cd?i*de";

        Map<Pair, Boolean> cache = new HashMap<Pair, Boolean>();
//        Boolean cache [][] = new Boolean[s.length()+1][p.length()+1];
        //   Arrays.fill(cache,false);
        boolean result = ismatchingagainbottomup(s, p);
        System.out.println("rasule" + result);
    }

    private static boolean isMatch(String s, String p) {


        p ="**ho";
        char[] pattern = p.toCharArray();
        int writeIndex = 0;
        boolean isFirst = true;
        for ( int i = 0 ; i < pattern.length; i++) {
            if (pattern[i] == '*') {
                if (isFirst) {
                    pattern[writeIndex++] = pattern[i];
                    isFirst = false;
                }
            } else {
                pattern[writeIndex++] = pattern[i];
                isFirst = true;
            }
        }

        for(int i=0;i<pattern.length-1;i++){
            System.out.println(pattern[i]);
        }
        boolean returnvalue = isMatchHelper(s.toCharArray(), pattern, s.length() - 1, pattern.length - 2);
        return returnvalue;
    }

    private static boolean isMatchHelper(char[] s, char[] p, int sindex, int pindex) {

        if (sindex == -1) {
            for (int i = 0; i <= pindex; i++) {
                if (p[i] != '*') {
                    return false;
                }
            }
            return true;
        }
        if (cache.containsKey(new Pair<Integer, Integer>(sindex, pindex))) {
            return cache.get(new Pair<Integer, Integer>(sindex, pindex));
        }

        if (sindex == -1 && pindex == -1) {
            return true;
        }
        if (sindex == -1 && pindex != -1) {
            return false;
        }
        if (sindex != -1 && pindex == -1) {
            return false;
        }

        if (s[sindex] == p[pindex]) {
            Boolean value = isMatchHelper(s, p, sindex - 1, pindex - 1);
            cache.put(new Pair<Integer, Integer>(sindex, pindex), value);
            return value;
        }

        if (p[pindex] == '?') {
            Boolean value = isMatchHelper(s, p, sindex - 1, pindex - 1);
            cache.put(new Pair<Integer, Integer>(sindex, pindex), value);
            return value;
        }

        if (p[pindex] == '*') {
            Boolean value = isMatchHelper(s, p, sindex, pindex - 1) || isMatchHelper(s, p, sindex - 1, pindex) || isMatchHelper(s, p, sindex - 1, pindex - 1);
            cache.put(new Pair<Integer, Integer>(sindex, pindex), value);
            return value;
        }

        cache.put(new Pair<Integer, Integer>(sindex, pindex), false);
        return false;
    }
    public static boolean ismatchingagainbottomup(String s, String p){
        if(p==null || p.length() == 0){
            return s== null || s.length() ==0;
        }
        int rows = s.length();
        int cols = p.length();

        boolean dp [][] = new boolean[rows+1][cols+1];
        dp[0][0] = true;


        for(int j=1;j<=p.length();j++){
            if(p.charAt(j-1)=='*'){
                dp[0][j] = dp[0][j-1];
            }
            else{
                dp[0][j] = false;
            }
        }

        for(int i=1;i<=s.length();i++){
            dp[i][0] = false;
        }
        for(int i=1;i<=s.length();i++){
            for(int j=1;j<=p.length();j++){
                if(p.charAt(j-1) !='*'){
                    if(s.charAt(i-1)==p.charAt(j-1) || p.charAt(j-1) =='?')
                    dp[i][j] = dp[i-1][j-1];
                }
                else{
                    dp[i][j] = dp[i-1][j-1]||dp[i][j-1]||dp[i-1][j];
                }
            }
        }
        return dp[s.length()][p.length()];
    }
}


class Pair<K,V>  {

    /**
     * Key of this <code>Pair</code>.
     */
    public K key;

    /**
     * Gets the key for this pair.
     * @return key for this pair
     */
    public K getKey() { return key; }

    /**
     * Value of this this <code>Pair</code>.
     */
    public V value;

    /**
     * Gets the value for this pair.
     * @return value for this pair
     */
    public V getValue() { return value; }

    /**
     * Creates a new pair
     * @param key The key for this pair
     * @param value The value to use for this pair
     */
    public Pair( K key, V value) {
        this.key = key;
        this.value = value;
    }

    /**
     * <p><code>String</code> representation of this
     * <code>Pair</code>.</p>
     *
     * <p>The default databaseName/value delimiter '=' is always used.</p>
     *
     *  @return <code>String</code> representation of this <code>Pair</code>
     */
    @Override
    public String toString() {
        return key + "=" + value;
    }

    /**
     * <p>Generate a hash code for this <code>Pair</code>.</p>
     *
     * <p>The hash code is calculated using both the databaseName and
     * the value of the <code>Pair</code>.</p>
     *
     * @return hash code for this <code>Pair</code>
     */
    @Override
    public int hashCode() {
        // databaseName's hashCode is multiplied by an arbitrary prime number (13)
        // in order to make sure there is a difference in the hashCode between
        // these two parameters:
        //  databaseName: a  value: aa
        //  databaseName: aa value: a
        return key.hashCode() * 13 + (value == null ? 0 : value.hashCode());
    }

    /**
     * <p>Test this <code>Pair</code> for equality with another
     * <code>Object</code>.</p>
     *
     * <p>If the <code>Object</code> to be tested is not a
     * <code>Pair</code> or is <code>null</code>, then this method
     * returns <code>false</code>.</p>
     *
     * <p>Two <code>Pair</code>s are considered equal if and only if
     * both the names and values are equal.</p>
     *
     * @param o the <code>Object</code> to test for
     * equality with this <code>Pair</code>
     * @return <code>true</code> if the given <code>Object</code> is
     * equal to this <code>Pair</code> else <code>false</code>
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o instanceof javafx.util.Pair) {
            javafx.util.Pair pair = (javafx.util.Pair) o;
            if (key != null ? !key.equals(pair.getKey()) : pair.getKey() != null) return false;
            if (value != null ? !value.equals(pair.getValue()) : pair.getValue() != null) return false;
            return true;
        }
        return false;
    }
}package OldAttemptLearning.dynamicprogramming;

import java.util.Scanner;

/**
 * Created by hadoop on 4/8/17.
 */
public class twins{
    public static void main(String[] args) {
        Scanner sc = new Scanner( System.in);
        String line = sc.nextLine();

        int odd= 1;
        int even = 0;
        int i=0;

        while(odd<line.length() && even<line.length()){
            if(odd +2<line.length()) {
                if (line.charAt(odd) == line.charAt(odd + 2)) {
                    i++;
                }
            }
            if(even +2<line.length()) {
                if (line.charAt(even) == line.charAt(even + 2)) {
                    i++;
                }
            }
            odd= odd+2;
            even= even+2;
        }
        System.out.println(i);
    }
}
package OldAttemptLearning.dynamicprogramming;

import java.util.Iterator;
import java.util.Set;
import java.util.TreeSet;

/**
 * Created by hadoop on 5/8/17.
 */
public class NthUglyNumber {

    public static void main(String[] args) {
        int index2 = 1;
        int index3 = 1;
        int index5 = 1;
       // int x = nthUglyNUmber(5,index2,index3,index5);
        //System.out.println(x);
    }

//    private static int nthUglyNUmber(int i, int index2, int index3, int index5) {
//        if(i==1){
//            return 1;
//        }
//        int number = Integer.MAX_VALUE;
//
//        Math.min(number,Math.min(Math.min(2*nthUglyNUmber(i-1,index2,index3,index5),3*nthUglyNUmber(i-1,index2,index3,index5)),5*nthUglyNUmber(i-1,index2,index3,index5)));
//
//
//
//
//
//        for(int i = Math.min(nthUglyNUmber(5, index2, index3, n-1)/2,; i<n; i++){
//            number = Math.min(number,Math.min(Math.min(nthUglyNUmber(5, index2, index3, i)*2,nthUglyNUmber(5, index2, index3, i)*3),nthUglyNUmber(5, index2, index3, i)*5));
//        }
//        return number;
//    }

        public int nthugly(int n, int [] primes){
            if(primes == null || primes.length ==0 || n<=0){
                return 0;
            }
            Set<Long> hashset= new TreeSet<Long>();
            hashset.add(1l);

            for(int i=1;i<n;i++){
                Long current =0l;
                Iterator<Long>itr = hashset.iterator();
                if(itr.hasNext()){
                    current = itr.next();
                    itr.remove();
                }

                for(int j=0;j<primes.length;j++){
                    Long value = current*primes[j];
                    if(!hashset.contains(value)){
                        hashset.add(value);
                    }
                }
            }

            Long current =0l;
            Iterator<Long>itr = hashset.iterator();
            if(itr.hasNext()){
                current = itr.next();
                itr.remove();
            }
            return current.intValue();
        }
    }package OldAttemptLearning.dynamicprogramming;

/**
 * Created by hadoop on 3/8/17.
 */
public class Climb {
    public static void main(String[] args) {
        int stairs = 5;
        int n = steps(stairs);
        System.out.println("n"+n);
    }

    private static int steps(int stairs) {
        if(stairs ==1){
            return 1;
        }
        if(stairs ==0){
            return 1;
        }
        int totalways = 0;
        totalways = totalways+ steps(stairs-1);
        totalways = totalways + steps(stairs -2);
        return totalways;
    }
}
package OldAttemptLearning.dynamicprogramming;

import java.util.Scanner;

/**
 * Created by hadoop on 4/8/17.
 */
public class RotatedSearch {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int noofelements = scanner.nextInt();
        Integer array[] = new Integer[noofelements];
        for(int i=0;i<noofelements;i++){
            array[i] = scanner.nextInt();
        }
        int element = scanner.nextInt();
        int search = searcharray(array,element);
        System.out.println(search);
    }

    private static int searcharray(Integer[] array,int element) {

        int low = 0;
        int high = array.length -1;

        while(low<high){
            int mid = low + (high-low)/2;
            if(array[mid] == element){
                return mid;
            }
            if(array[mid]<array[high] ){
                if(element>=array[high]){
                    high = mid;
                    
                }
                else{
                    low = mid+1;
                }
            }
            else{
                if(element>=array[low]){
                    high = mid;
                }
                else{
                    low = mid +1;
                }
            }
        }
            if(array[low] == element ){
            return low;
            }
            else{
                return -1;
            }
    }
}
package OldAttemptLearning.dynamicprogramming;

/**
 * Created by hadoop on 3/8/17.
 */
public class BinaryTrees {
    public static void main(String[] args) {
        BinaryTrees binaryTrees = new BinaryTrees();
        System.out.println(binaryTrees.numTrees(3));
    }
    public int numTrees(int n){
        return dfsCache(0,n-1);
    }

    private int dfsCache(int L, int R) {

        if(L>=R) {
            return 1;
        }
        int total = 0;
        for(int i=L;i<=R;i++){
            total = total + dfsCache(L,i-1)*dfsCache(i+1,R);
        }
        return total;
    }
}package OldAttemptLearning.dynamicprogramming;

import java.util.Arrays;

/**
 * Created by hadoop on 3/8/17.
 */
public class BuySell {
    public static void main(String[] args) {
        int[] yourArray = { 7, 1, 5, 3, 6, 4 };
        Integer[] data = new Integer[20];
        Arrays.fill(data,new Integer(-1));
        int max = maxprofit(data);
    }

    private static int maxprofit(Integer[] data) {
        int min = Integer.MAX_VALUE;
        int diff = 0;
        for( int i=0 ;i<data.length;i++){
            if(data[0]<min){
                min = data[i];
            }
            if(data[i]-min >diff){
                diff = data[i]-min;
            }
        }
        return diff;
    }
}
package OldAttemptLearning.dynamicprogramming;

/**
 * Created by hadoop on 1/9/17.
 */
public class KadaneAlgo {
    public static void main(String args[]) {
        int num[] = {10, -3, -4, 7, 6, 5, -4, -1};
        int ans = find_sum(num);
    }

    private static int find_sum(int[] num) {
        int i=0;
        int total = 0;
        int maxlocal = 0;
        int minlocal = 0;
        int maxglobal=0;
        int minglobal=0;
        while(i<num.length){
            maxlocal = maxlocal+ num[i];
            minlocal = minlocal + num[i];
            total = total + num[i];

            if(maxlocal >maxglobal){
                maxglobal = maxlocal;
            }
            if(minlocal<minglobal){
                minglobal = minlocal;
            }
            if(minlocal>=0){
                minlocal =0;
            }
            if(maxlocal<0){
                maxglobal = 0;
            }
        }
        if(total - minglobal>maxglobal){
            return total-minglobal;
        }
        else {
            return maxglobal;
        }
    }
}
package OldAttemptLearning.dynamicprogramming;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Created by hadoop on 7/8/17.
 */
public class CoinPath {

    public static void main(String[] args) {


        CoinPath coinPath = new CoinPath();

        int array[] = {1, 2, 4, -1, 2};
        int arrayagain[] ={1,2,4,-1,2};
        //System.out.println(coinPath.cheapestJump(array,2));


        int basearray[] ={1,-1,3,4};
        int index[] = new int[array.length+1];

        int B = 2;

        index[1] =0;
        System.out.println();
        int mincoint = mincoin(0, array, B,index);
        System.out.println("co"+mincoint);

       // System.out.println(cheapestJump(array,B));
        System.out.println("try");

        printpath(index,array.length);

        System.exit(1);
        int pathagain = array.length;
        System.out.println(pathagain);

        while (pathagain!=-1){
            pathagain = index[pathagain];
            System.out.println(pathagain);
        }
        for( int i=0;i<index.length;i++){
            System.out.println("final index atrray "+i+" is "+index[i]);
        }

    }

    private static int mincoin(int i, int[] array, int b,int []index) {
        if(i == array.length-1 && array[i]!=-1){
            return array[i];
        }
        int min = Integer.MAX_VALUE;
        int minindex=-1;
        for(int path = i+1;path<=array.length-1  && path<=i+b;path++){
            if(array[path] == -1){
                continue;
            }
            if(min>array[i]+mincoin(path,array,b,index)){
                minindex = path;
                min = array[i]+mincoin(path,array,b,index);
            }
        }
        if(minindex != -1) {
            System.out.println("path is and min value ");
            index[minindex + 1] = i+1;
        }
        return min;
    }
    public static List<Integer> cheapestJump(int[] A, int B) {
        int []index = new int[A.length+1];
        int [] memo = new int [A.length+1];
        Arrays.fill(memo,-1);
        List<Integer> returnedList = new ArrayList<Integer>();
        if(A==null || A.length == 0){
            return returnedList;
        }
        index[0] = -1;
        int mincost = cheapestJumpHelper(0,A,B,index,memo);
        System.out.println("min cost "+mincost);
        if(mincost ==0){
            return returnedList;
        }
        else{
            int pathagain = index[A.length];
            returnedList.add(pathagain);
           // System.out.println(pathagain);
            while (pathagain!=-1){
                System.out.println(A[pathagain]);
                pathagain = index[pathagain];
                returnedList.add(pathagain);
            }
            return returnedList;
        }
    }

    private static int cheapestJumpHelper(int i,int[] array, int b, int[] index, int []memo) {
        if(i == array.length-1 && array[i]!=-1){
            return array[i];
        }
        if(memo[i]!=-1){
            return memo[i];
        }
        int min = Integer.MAX_VALUE;
        int minindex=-1;
        for(int path = i+1;path<=array.length-1  && path<=i+b;path++){
            if(array[path] == -1){
                continue;
            }
            if(min>array[i]+cheapestJumpHelper(path,array,b,index,memo)){
                minindex = path;
                min = array[i]+cheapestJumpHelper(path,array,b,index,memo);
            }
        }
        if(minindex != -1) {
            index[minindex + 1] = i+1;
        }
        memo[i] = min;
        return min;
    }
    static void printpath(int []array,int startindex){
        if(startindex == 0){
            return;
        }
        printpath(array,array[startindex]);
        System.out.println(startindex);
    }
}
package OldAttemptLearning.dynamicprogramming;

import java.util.Scanner;

/**
 * Created by hadoop on 4/8/17.
 */
public class KthRoot {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int testcase = Integer.parseInt(scanner.nextLine());
        while (testcase>0){
            long n = scanner.nextLong();
            long k = scanner.nextLong();

            //x^k <= n

            long startrange = 1;
            for(long i=1;Math.pow(i,k)<=n;i=i*2){

                startrange = i;
            }
            long endrange = 2*startrange;

            while(startrange < endrange){
                long mid = startrange + (endrange-startrange)/2;

                if(Math.pow(mid,k)>=n){
                    endrange = mid;
                }

                else if (Math.pow(mid,k)<n) {
                    startrange = mid + 1;
                }

            }

            if(Math.pow(startrange,k)<=n) {
                System.out.println(startrange);
            }
            else {
                System.out.println(startrange-1);
            }
            testcase--;
        }

    }
}
package OldAttemptLearning.dynamicprogramming;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Created by hadoop on 3/8/17.
 */
public class wordbreak {
    public static void main(String[] args) {
        String s = "eetcode";
        List<String> dict = new ArrayList<String>();
        dict.add("eet");
        dict.add("co");
        dict.add("d");
        Map<String,Boolean> set = new HashMap<String,Boolean>();
        System.out.println(wordBreak("eetcode",dict,set));
    }
    public static boolean wordBreak(String s, List<String> dict,Map<String,Boolean> set){

        System.out.println("string is "+s);
        if(dict.contains(s)){
            return true;
        }
        if(s.length() == 1) return false;

        if(set.containsKey(s)) return set.get(s);
        for(int i=0;i<s.length();i++){

            if(!set.containsKey(s.substring(0,i+1))){
                set.put(s.substring(0,i+1),wordBreak(s.substring(0,i+1),dict,set));
            }
            if(!set.containsKey(s.substring(i+1,s.length()))){
                set.put(s.substring(i+1,s.length()),wordBreak(s.substring(i+1,s.length()),dict,set));
            }

            if(wordBreak(s.substring(0,i+1),dict,set) && wordBreak(s.substring(i+1,s.length()),dict,set)){
                set.put(s,true);
                return true;
            }
            else {
                set.put(s,false);
            }
        }
        return false;
    }
}
package OldAttemptLearning.dynamicprogramming;

/**
 * Created by hadoop on 5/8/17.
 */
public class KeysBoard {
    static int copy = 0;
    public static void main(String[] args) {

        //int n = 7;
        //int x = maxAs(n,0);
        //System.out.println(f(n));
        for(int n = 1;n<20;n++){
            System.out.println("ques"+n);
            System.out.println("ans1  "+f(n));
            System.out.println("ans2  "+findoptimal(n));
            System.out.println("ans3 "+maxA(n));
           // System.out.println("ans3  "+solve(n));
            System.out.println("==============");
        }
    }

//    private static int maxAs(int n,int cv) {
//        if(n==0){
//            return 0;
//        }
//        if(n ==1){
//            return 1;
//        }
//        if ( n ==2){
//            return 2;
//        }
//        if(cv ==1){
//            copy = Math.max(copy,)
//        }
//        int x =  Integer.MIN_VALUE;
//
//        x= Math.max(x,Math.max(Math.max(Math.max(maxAs(n-1,0)+1,maxAs(n-1,0)),maxAs(n-2,0)),2*maxAs(n-3,1)));
//        if(x ==1){
//            x = Math.max(x,maxAs(n-1,1)+copy;
//        }
//    }

    static int f( int n )
    {
        int DP[] = new int[n+1];

        if(n<=3)return n;
        DP[1]=1;
        DP[2]=2;
        DP[3]=3;

        int copied=0,i,val;

        for( i=4;i<=n;i++ )
        {
            val= Math.max( DP[i-3]*2 , DP[i-1]+1 );

            if( copied > 0 )
                val=Math.max( val , DP[i-1] + copied );

            if( val == DP[i-3]*2 )
                copied=Math.max( copied , DP[i-3] );

            DP[i]=val ;

        }

        return DP[n] ;

    }
    static int  findoptimal(int N)
    {
        // The optimal string length is N when N is smaller than 7
        if (N <= 6)
            return N;

        // Initialize result
        int max = 0;

        // TRY ALL POSSIBLE BREAK-POINTS
        // For any keystroke N, we need to loop from N-3 keystrokes
        // back to 1 keystroke to find a breakpoint 'b' after which we
        // will have Ctrl-A, Ctrl-C and then only Ctrl-V all the way.
        int b;
        for (b=N-3; b>=1; b--)
        {
            // If the breakpoint is s at kb'th keystroke then
            // the optimal string would have length
            // (n-b-1)*screen[b-1];
            int curr = (N-b-1)*findoptimal(b);
            if (curr > max)
                max = curr;
        }
        return max;
    }
    static int solve(int n) {
        int f[][] = new int[100][4];
        f[0][0] = 1;
        for(int i = 1; i < n; i++)
            for(int j = 0; j < 4; j++)
                for(int k = 0; k < 4; k++)
                {
                    if (j == 0) // add A
                    {
                        f[i][j] = Math.max(f[i][j], f[i-1][k] + 1);
                    }
                    else if (j == 1) // ctrl+A
                    {
                        f[i][j] = Math.max(f[i][j], f[i-1][k]);
                    }
                    else if (j == 2) // ctrl+C
                    {
                        if (k == 1) // only previous is ctrl+A makes ctrl+C available
                            f[i][j] = Math.max(f[i][j], f[i-1][k]);
                    }
                    else if (j == 3) //ctrl+V
                    {
                        if (k == 2)
                            f[i][j] = Math.max(f[i][j], f[i-1][k] * 2);
                    }
                }

        return Math.max(f[n-1][3], f[n-1][0]);
    }
    public static int maxA(int N) {
        int[] dp = new int[N+1];
        for(int i=1;i<=N;i++){
            dp[i] = i;
            for(int j=3;j<i;j++){
                dp[i] = Math.max(dp[i], dp[i-j] * (j-1));
            }   
        }
        return dp[N];
    }
}
package OldAttemptLearning.dynamicprogramming;

/**
 * Created by hadoop on 3/8/17.
 */
public class NumberOf1s {
    public static void main(String args[]){
        //System.out.println(number(7));
        Integer cache [] = new Integer[7];
        for (int i=0;i<7;i++){
            cache[i] = -1;
        }
        number(7,cache);
        int array[] = new int[7];
        for(int i=0;i<7;i++){
            array[i] = cache[i];
        }
    }

   private static int number(int x,Integer [] cache){

        if(x == 0){
            System.out.println("0");
            return 0;
        }
        if(x == 1){
            System.out.println("1");
            return 1;
        }
        if(cache[x]!=-1) return cache[x];
        cache[x] = (number(x/2,cache)) + (x&1);
        return (number(x/2,cache)) + (x&1);
    }
    private class Solution {
        public int[] countBits(int num) {
            Integer cache [] = new Integer[num+1];
            for (int i=0;i<=num;i++){
                cache[i] = -1;
            }
            for(int i=num;i>=0;i--){
                number(i,cache);
            }
            int array[] = new int[num+1];
            for(int i=0;i<=num;i++){
                array[i] = cache[i];
            }
            return array;
        }


        private  int number(int x,Integer [] cache){
            if(x == 0){
                cache[x] =0;
                return 0;
            }
            if(x == 1){
                cache[x] = 1;
                return 1;
            }
            if(cache[x]!=-1) return cache[x];
            cache[x] = (number(x/2,cache)) + (x&1);
            return (number(x/2,cache)) + (x&1);
        }
    }
}
package OldAttemptLearning.VideoLecturesAll;

/**
 * Created by hadoop on 31/8/17.
 */
public class Juggling {
    public static void main(String args[]){
        int []array = {1,2,3,4,5,6,7,8,9};
        int n = 9;
        int k = 3;
        for( int i=0;i<gcd(n,k);i++){
            int temp = array[i];
            int j = i;
            while(true){
                int pos = (j+k)%n;
                if(pos == i)
                    break;
                array[j] = array[pos];
                j = pos;
            }
            array[j] = temp;
        }
        for(int i=0;i<array.length;i++){
            System.out.println("ans is "+array[i]);
        }
    }
    static int gcd(int a, int b ){
        if(a>b){
            return gcd(b,a);
        }
        else{
            if(b%a==0){
                return a;
            }
            else return gcd(a,b%a);
        }
    }

}
package OldAttemptLearning.VideoLectures;//package VideoLectures;
//
//import java.util.HashMap;
//import java.util.HashSet;
//import java.util.Map;
//import java.util.Set;
//
//public class AdjListGraph extends Graph {
//
//	private Map<Vertex, Set<Vertex>> adj = new HashMap<Vertex, Set<Vertex>>();
//
//    public AdjListGraph(int type) {
//        super(type);
//    }
//
//	@Override
//	public void addEdge(Vertex source, Vertex target) {
//		this._addEage(source, target);
//		if(this.type == UNDIRECTED){
//			this._addEage(target, source);
//		}
//		this.edgeNum++;
//	}
//
//	private void _addEage(Vertex source, Vertex target){
//		Set<Vertex> bag = adj.get(source);
//		if(bag == null){
//			bag = new HashSet<Vertex>();
//			adj.put(source, bag);
//			this.vertexNum++;
//		}
//		bag.add(target);
//	}
//
//	@Override
//	public Iterable<Vertex> adj(Vertex v) {
//		return adj.get(v);
//	}
//
//	@Override
//	public Iterable<Vertex> vertexs() {
//		return adj.keySet();
//	}
//
//
//
//}
package OldAttemptLearning.VideoLectures;//package VideoLectures;
//
//import java.util.LinkedList;
//import java.util.Queue;
//
///**
// * Created by hadoop on 28/8/17.
// */
//public class BreadthSearchPaths {
//    private static final int INFINITY = Integer.MAX_VALUE;
//    private boolean [] marked;
//    private  int [] edgeTo; // previous edge on shortest path from s to v
//    private int []distTo;
//
//    public BreadthSearchPaths(Graph<Integer> g,int s){
//        marked = new boolean[g.vertexes.size()];
//        distTo = new int[g.vertexes.size()];
//        edgeTo = new int[g.vertexes.size()];
//        bfs(g,s);
//    }
//
//    private void bfs(Graph<Integer> g, int s) {
//        Queue<Integer> queue = new LinkedList<>();
//        for( int v=0;v<g.vertexes.size();v++){
//            distTo[v] = INFINITY;
//        }
//        distTo[s] = 0;
//        marked[s] = true;
//        queue.add(s);
//        while (!queue.isEmpty()){
//            int v = queue.poll();
//            for( int w:)
//        }
//
//    }
//
//}
package OldAttemptLearning.VideoLectures;//package VideoLectures;
//
//public abstract class Graph {
//	public static int UNDIRECTED = 1;
//	public static int DIRECTED = 2;
//
//	public int type;
//	public int vertexNum;
//	public int edgeNum;
//
//    public Graph() {
//        this.type = UNDIRECTED;
//    }
//
//    public Graph(int type) {
//        this.type = UNDIRECTED;
//        if(type == DIRECTED)
//            this.type = type;
//    }
//	public int V(){
//		return vertexNum;
//	}
//
//	public int E(){
//		return edgeNum;
//	}
//
//    public Vertex getVertex(int value){
//        for(Vertex v : this.vertexs())
//            if((int)v.value == value)
//                return v;
//        return null;
//    }
//
//	public abstract void addEdge(Vertex source, Vertex target);
//
//	public abstract Iterable<Vertex> adj(Vertex v);
//
//	public abstract Iterable<Vertex> vertexs();
//
//}
package OldAttemptLearning.VideoLectures;//package VideoLectures;
//
///**
// * Created_By: zouzhile
// * Date: 3/16/14
// * Time: 9:34 AM
// */
//public class Edge {
//    private Vertex source;
//    private Vertex target;
//    int weight = 1;
//
//    public Edge(Vertex source, Vertex target, int weight) {
//        this.source = source;
//        this.target = target;
//        this.weight = weight;
//    }
//
//    public Vertex getSource(){
//        return this.source;
//    }
//
//    public Vertex getTarget(){
//        return this.target;
//    }
//
//    public int getWeight() {
//        return this.weight;
//    }
//
//}
package OldAttemptLearning.VideoLectures;

import java.util.Arrays;
import java.util.Comparator;
import java.util.PriorityQueue;

/**
 * Created by hadoop on 28/8/17.
 */
public class MinimumMeetingRooms {
    private static class Interval{
        int start;
        int end;
    }

    public static void main(String[] args) {

    }
    public int minmeetingrooms(Interval [] intervals){
        if(intervals == null || intervals.length ==0){
            return 0;
        }
        Comparator<Interval> comparator = new Comparator<Interval>() {
            @Override
            public int compare(Interval o1, Interval o2) {
                return o1.start-o2.start;
            }
        };
        Arrays.sort(intervals,comparator);
        PriorityQueue<Interval> queue = new PriorityQueue<Interval>(new Comparator<Interval>() {
            @Override
            public int compare(Interval o1, Interval o2) {
                return o1.end-o2.end;
            }
        });
        for ( int i=0;i<intervals.length;i++){
            if(queue.isEmpty()) {
                queue.add(intervals[i]);
            }
            else{
                Interval finishedMeetingTime = queue.poll();
                if(intervals[i].start <finishedMeetingTime.end){
                    queue.add(intervals[i]);
                }
                else{
                    finishedMeetingTime.end = intervals[i].end;
                }
                queue.add(finishedMeetingTime);
            }
        }
        return queue.size();
    }
}
package OldAttemptLearning.VideoLectures;

import java.util.LinkedList;
import java.util.List;

/**
 * Created by hadoop on 28/8/17.
 */
public class Backtrack {

    public static List<List<Object>> backtrack(int []A){
         List<List<Object>> result = new LinkedList<List<Object>>();
        if(A == null || A.length ==0){
            return result;
        }

        List<Object> solution = new LinkedList<Object>();

        dfs(result,solution,A,0);
        return result;
    }

    private static void dfs(List<List<Object>> result, List<Object> solution, int[] A, int pos) {

        if(isASolution(A,pos)){
            processSolution(result,solution);
        }
        for(int i=pos;i<A.length;i++){
            if(!isValid(A,i)){
                continue;
            }

            makemove(solution,A[i]);
            dfs(result,solution,A,i+1);
            unmakemove(solution,A[i]);
        }
    }

    private static void unmakemove(List<Object> solution, int i) {
        solution.remove(solution.size()-1);
    }

    private static void makemove(List<Object> solution, int i) {
        solution.add(i);
    }

    private static boolean isValid(int[] a, int i) {
        // check if I th position is valid
        // return true;
        return true;
    }

    private static void processSolution(List<List<Object>> result, List<Object> solution) {
        result.add(solution);
    }

    private static boolean isASolution(int[] a, int pos) {
        if(pos ==a.length){
            return true;
        }
        return false;
    }


}
package OldAttemptLearning.VideoLectures;//package VideoLectures;
//
//import java.util.UUID;
//
///**
// * Created_By: zouzhile
// * Date: 10/16/13
// * Time: 10:24 AM
// */
//
//
//public class Vertex<T> implements Comparable<Vertex> {
//
//    VertexColor color;
//    int distance = -1;
//    T value = null;
//    String id;
//    Vertex parent;
//
//    public Vertex(T value) {
//        this(VertexColor.WHITE, value);
//    }
//
//    public Vertex(VertexColor color, T value) {
//        this.id = UUID.randomUUID().toString();
//        this.color = color;
//        this.value = value;
//    }
//
//    public void setParent(Vertex parent) {
//        this.parent = parent;
//    }
//
//    public Vertex getParent(){
//        return this.parent;
//    }
//
//    public VertexColor getColor() {
//        return color;
//    }
//
//    public void setColor(VertexColor color) {
//        this.color = color;
//    }
//
//    public int getDistance() {
//        return distance;
//    }
//
//    public void setDistance(int distance) {
//        this.distance = distance;
//    }
//
//    public T getValue() {
//        return value;
//    }
//
//    public String getInternalId() {
//        return this.id;
//    }
//
//    @Override
//    public int compareTo(Vertex o) {
//        return this.id.compareTo(o.getInternalId());
//    }
//
//    @Override
//    public boolean equals(Object o) {
//        if(! (o instanceof Vertex))
//            return false;
//        return this.value  == ((Vertex)o).getValue();
//    }
//
//    @Override
//    public int hashCode() {
//        return this.value.hashCode();
//    }
//}
package OldAttemptLearning.VideoLectures;

/**
 * Created by hadoop on 28/8/17.
 */
public class RearrangeString {
    private static class point{
        int x;
        int y;

        public point(int x, int y) {
            this.x = x;
            this.y = y;
        }

        double distance(point p2, point p1){
            return Math.sqrt((p1.x -p2.x) * (p1.x-p2.x) +(p1.y-p2.y)*(p1.y-p2.y));
        }
        double cost(point p1,point p2){
            return distance(this,p1) + distance(this,p2)+distance(p1,p2);
        }
    }


    public static void main(String[] args) {
        point points [] = {
                new point(0,0),
        new point(1,0),new point(2,1),new point(1,2),new point(0,2)
        };

        double ans = mtc(points,0,points.length-1);
        System.out.println(ans);

}

    private static double mtc(point[] points, int i, int i1) {
        if(i1-i+1<=2){
            return 0;
        }
        double cost = Integer.MAX_VALUE;
        for( int k=i+1;k<i1;k++){
            cost = Math.min(cost,mtc(points,i,k)+mtc(points,k,i1)+points[k].cost(points[i],points[i1]));
            System.out.println("cost"+cost);
        }
        return cost;
    }
}
package OldAttemptLearning.VideoLectures;

/**
 * Created by hadoop on 27/8/17.
 */
public class TraingleMinCost {
    // No
    public static void main(String[] args) {

    }
}
package OldAttemptLearning.pimponuser.CF477C;

import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        Task solver = new Task();
        solver.solve(1, in, out);
        out.close();
    }
}

class Task {
    
    public void solve(int testNumber, InputReader in, OutputWriter out) {
        char[] S=in.readString().toCharArray(), T=in.readString().toCharArray();
        int n=S.length, m=T.length, INF=n+1000;
        int[][] dp=new int[INF][INF];
        Arrays.fill(dp[0], INF);
        dp[0][0]=0;
        for (int i=1; i<=n; i++) for (int j=1; j<=n/m*m; j++) dp[i][j]=Math.min(S[i-1]==T[(j-1)%m]?dp[i-1][j-1]:INF, dp[i-1][j]+(j%m==0?0:1));
        int to=0;
        for (int qnt=0; ; qnt++) {
            if (dp[n][qnt*m]==INF || qnt>n/m) break;
            if (dp[n][(qnt+1)*m]==INF || qnt==n/m) to=n-qnt*m;
            else to=dp[n][(qnt+1)*m]-1;
            for (int i=dp[n][qnt*m]; i<=to; i++) out.print(qnt, "");
        }
        for (int i=to+1; i<=n; i++) out.print((n-i)/m, "");
    }
}

class Graph {
    public static final int REMOVED_BIT = 0;

    protected int vertexCount;
    protected int edgeCount;

    private int[] firstOutbound;
    private int[] firstInbound;

    private Edge[] edges;
    private int[] nextInbound;
    private int[] nextOutbound;
    private int[] from;
    private int[] to;
    private long[] weight;
    public long[] capacity;
    private int[] reverseEdge;
    private int[] flags;

    public Graph(int vertexCount) {
        this(vertexCount, vertexCount);
    }

    public Graph(int vertexCount, int edgeCapacity) {
        this.vertexCount = vertexCount;
        firstOutbound = new int[vertexCount];
        Arrays.fill(firstOutbound, -1);

        from = new int[edgeCapacity];
        to = new int[edgeCapacity];
        nextOutbound = new int[edgeCapacity];
        flags = new int[edgeCapacity];
    }

    public static Graph createGraph(int vertexCount, int[] from, int[] to) {
        Graph graph = new Graph(vertexCount, from.length);
        for (int i = 0; i < from.length; i++)
            graph.addSimpleEdge(from[i], to[i]);
        return graph;
    }

    public static Graph createWeightedGraph(int vertexCount, int[] from,
            int[] to, long[] weight) {
        Graph graph = new Graph(vertexCount, from.length);
        for (int i = 0; i < from.length; i++)
            graph.addWeightedEdge(from[i], to[i], weight[i]);
        return graph;
    }

    public static Graph createFlowGraph(int vertexCount, int[] from, int[] to,
            long[] capacity) {
        Graph graph = new Graph(vertexCount, from.length * 2);
        for (int i = 0; i < from.length; i++)
            graph.addFlowEdge(from[i], to[i], capacity[i]);
        return graph;
    }

    public static Graph createFlowWeightedGraph(int vertexCount, int[] from,
            int[] to, long[] weight, long[] capacity) {
        Graph graph = new Graph(vertexCount, from.length * 2);
        for (int i = 0; i < from.length; i++)
            graph.addFlowWeightedEdge(from[i], to[i], weight[i], capacity[i]);
        return graph;
    }

    public static Graph createTree(int[] parent) {
        Graph graph = new Graph(parent.length + 1, parent.length);
        for (int i = 0; i < parent.length; i++)
            graph.addSimpleEdge(parent[i], i + 1);
        return graph;
    }

    public int addEdge(int fromID, int toID, long weight, long capacity,
            int reverseEdge) {
        ensureEdgeCapacity(edgeCount + 1);
        if (firstOutbound[fromID] != -1)
            nextOutbound[edgeCount] = firstOutbound[fromID];
        else
            nextOutbound[edgeCount] = -1;
        firstOutbound[fromID] = edgeCount;
        if (firstInbound != null) {
            if (firstInbound[toID] != -1)
                nextInbound[edgeCount] = firstInbound[toID];
            else
                nextInbound[edgeCount] = -1;
            firstInbound[toID] = edgeCount;
        }
        this.from[edgeCount] = fromID;
        this.to[edgeCount] = toID;
        if (capacity != 0) {
            if (this.capacity == null)
                this.capacity = new long[from.length];
            this.capacity[edgeCount] = capacity;
        }
        if (weight != 0) {
            if (this.weight == null)
                this.weight = new long[from.length];
            this.weight[edgeCount] = weight;
        }
        if (reverseEdge != -1) {
            if (this.reverseEdge == null) {
                this.reverseEdge = new int[from.length];
                Arrays.fill(this.reverseEdge, 0, edgeCount, -1);
            }
            this.reverseEdge[edgeCount] = reverseEdge;
        }
        if (edges != null)
            edges[edgeCount] = createEdge(edgeCount);
        return edgeCount++;
    }

    protected final GraphEdge createEdge(int id) {
        return new GraphEdge(id);
    }

    public final int addFlowWeightedEdge(int from, int to, long weight,
            long capacity) {
        if (capacity == 0) {
            return addEdge(from, to, weight, 0, -1);
        } else {
            int lastEdgeCount = edgeCount;
            addEdge(to, from, -weight, 0, lastEdgeCount + entriesPerEdge());
            return addEdge(from, to, weight, capacity, lastEdgeCount);
        }
    }

    protected int entriesPerEdge() {
        return 1;
    }

    public final int addFlowEdge(int from, int to, long capacity) {
        return addFlowWeightedEdge(from, to, 0, capacity);
    }

    public final int addWeightedEdge(int from, int to, long weight) {
        return addFlowWeightedEdge(from, to, weight, 0);
    }

    public final int addSimpleEdge(int from, int to) {
        return addWeightedEdge(from, to, 0);
    }

    public final int vertexCount() {
        return vertexCount;
    }

    public final int edgeCount() {
        return edgeCount;
    }

    protected final int edgeCapacity() {
        return from.length;
    }

    public final Edge edge(int id) {
        initEdges();
        return edges[id];
    }

    public final int firstOutbound(int vertex) {
        int id = firstOutbound[vertex];
        while (id != -1 && isRemoved(id))
            id = nextOutbound[id];
        return id;
    }

    public final int nextOutbound(int id) {
        id = nextOutbound[id];
        while (id != -1 && isRemoved(id))
            id = nextOutbound[id];
        return id;
    }

    public final int firstInbound(int vertex) {
        initInbound();
        int id = firstInbound[vertex];
        while (id != -1 && isRemoved(id))
            id = nextInbound[id];
        return id;
    }

    public final int nextInbound(int id) {
        initInbound();
        id = nextInbound[id];
        while (id != -1 && isRemoved(id))
            id = nextInbound[id];
        return id;
    }

    public final int source(int id) {
        return from[id];
    }

    public final int destination(int id) {
        return to[id];
    }

    public final long weight(int id) {
        if (weight == null)
            return 0;
        return weight[id];
    }

    public final long capacity(int id) {
        if (capacity == null)
            return 0;
        return capacity[id];
    }

    public final long flow(int id) {
        if (reverseEdge == null)
            return 0;
        return capacity[reverseEdge[id]];
    }

    public final void pushFlow(int id, long flow) {
        if (flow == 0)
            return;
        if (flow > 0) {
            if (capacity(id) < flow)
                throw new IllegalArgumentException("Not enough capacity");
        } else {
            if (flow(id) < -flow)
                throw new IllegalArgumentException("Not enough capacity");
        }
        capacity[id] -= flow;
        capacity[reverseEdge[id]] += flow;
    }

    public int transposed(int id) {
        return -1;
    }

    public final int reverse(int id) {
        if (reverseEdge == null)
            return -1;
        return reverseEdge[id];
    }

    public final void addVertices(int count) {
        ensureVertexCapacity(vertexCount + count);
        Arrays.fill(firstOutbound, vertexCount, vertexCount + count, -1);
        if (firstInbound != null)
            Arrays.fill(firstInbound, vertexCount, vertexCount + count, -1);
        vertexCount += count;
    }

    protected final void initEdges() {
        if (edges == null) {
            edges = new Edge[from.length];
            for (int i = 0; i < edgeCount; i++)
                edges[i] = createEdge(i);
        }
    }

    public final void removeVertex(int vertex) {
        int id = firstOutbound[vertex];
        while (id != -1) {
            removeEdge(id);
            id = nextOutbound[id];
        }
        initInbound();
        id = firstInbound[vertex];
        while (id != -1) {
            removeEdge(id);
            id = nextInbound[id];
        }
    }

    private void initInbound() {
        if (firstInbound == null) {
            firstInbound = new int[firstOutbound.length];
            Arrays.fill(firstInbound, 0, vertexCount, -1);
            nextInbound = new int[from.length];
            for (int i = 0; i < edgeCount; i++) {
                nextInbound[i] = firstInbound[to[i]];
                firstInbound[to[i]] = i;
            }
        }
    }

    public final boolean flag(int id, int bit) {
        return (flags[id] >> bit & 1) != 0;
    }

    public final void setFlag(int id, int bit) {
        flags[id] |= 1 << bit;
    }

    public final void removeFlag(int id, int bit) {
        flags[id] &= -1 - (1 << bit);
    }

    public final void removeEdge(int id) {
        setFlag(id, REMOVED_BIT);
    }

    public final void restoreEdge(int id) {
        removeFlag(id, REMOVED_BIT);
    }

    public final boolean isRemoved(int id) {
        return flag(id, REMOVED_BIT);
    }

    public final Iterable<Edge> outbound(final int id) {
        initEdges();
        return new Iterable<Edge>() {
            public Iterator<Edge> iterator() {
                return new EdgeIterator(id, firstOutbound, nextOutbound);
            }
        };
    }

    public final Iterable<Edge> inbound(final int id) {
        initEdges();
        initInbound();
        return new Iterable<Edge>() {
            public Iterator<Edge> iterator() {
                return new EdgeIterator(id, firstInbound, nextInbound);
            }
        };
    }

    protected void ensureEdgeCapacity(int size) {
        if (from.length < size) {
            int newSize = Math.max(size, 2 * from.length);
            if (edges != null)
                edges = resize(edges, newSize);
            from = resize(from, newSize);
            to = resize(to, newSize);
            nextOutbound = resize(nextOutbound, newSize);
            if (nextInbound != null)
                nextInbound = resize(nextInbound, newSize);
            if (weight != null)
                weight = resize(weight, newSize);
            if (capacity != null)
                capacity = resize(capacity, newSize);
            if (reverseEdge != null)
                reverseEdge = resize(reverseEdge, newSize);
            flags = resize(flags, newSize);
        }
    }

    private void ensureVertexCapacity(int size) {
        if (firstOutbound.length < size) {
            int newSize = Math.max(size, 2 * from.length);
            firstOutbound = resize(firstOutbound, newSize);
            if (firstInbound != null)
                firstInbound = resize(firstInbound, newSize);
        }
    }

    protected final int[] resize(int[] array, int size) {
        int[] newArray = new int[size];
        System.arraycopy(array, 0, newArray, 0, array.length);
        return newArray;
    }

    private long[] resize(long[] array, int size) {
        long[] newArray = new long[size];
        System.arraycopy(array, 0, newArray, 0, array.length);
        return newArray;
    }

    private Edge[] resize(Edge[] array, int size) {
        Edge[] newArray = new Edge[size];
        System.arraycopy(array, 0, newArray, 0, array.length);
        return newArray;
    }

    public final boolean isSparse() {
        return vertexCount == 0 || edgeCount * 20 / vertexCount <= vertexCount;
    }

    protected class GraphEdge implements Edge {
        protected int id;

        protected GraphEdge(int id) {
            this.id = id;
        }

        public int getSource() {
            return source(id);
        }

        public int getDestination() {
            return destination(id);
        }

        public long getWeight() {
            return weight(id);
        }

        public long getCapacity() {
            return capacity(id);
        }

        public long getFlow() {
            return flow(id);
        }

        public void pushFlow(long flow) {
            Graph.this.pushFlow(id, flow);
        }

        public boolean getFlag(int bit) {
            return flag(id, bit);
        }

        public void setFlag(int bit) {
            Graph.this.setFlag(id, bit);
        }

        public void removeFlag(int bit) {
            Graph.this.removeFlag(id, bit);
        }

        public int getTransposedID() {
            return transposed(id);
        }

        public Edge getTransposedEdge() {
            int reverseID = getTransposedID();
            if (reverseID == -1)
                return null;
            initEdges();
            return edge(reverseID);
        }

        public int getReverseID() {
            return reverse(id);
        }

        public Edge getReverseEdge() {
            int reverseID = getReverseID();
            if (reverseID == -1)
                return null;
            initEdges();
            return edge(reverseID);
        }

        public int getID() {
            return id;
        }

        public void remove() {
            removeEdge(id);
        }

        public void restore() {
            restoreEdge(id);
        }
    }

    public class EdgeIterator implements Iterator<Edge> {
        private int edgeID;
        private final int[] next;
        private int lastID = -1;

        public EdgeIterator(int id, int[] first, int[] next) {
            this.next = next;
            edgeID = nextEdge(first[id]);
        }

        private int nextEdge(int id) {
            while (id != -1 && isRemoved(id))
                id = next[id];
            return id;
        }

        public boolean hasNext() {
            return edgeID != -1;
        }

        public Edge next() {
            if (edgeID == -1)
                throw new NoSuchElementException();
            lastID = edgeID;
            edgeID = nextEdge(next[lastID]);
            return edges[lastID];
        }

        public void remove() {
            if (lastID == -1)
                throw new IllegalStateException();
            removeEdge(lastID);
            lastID = -1;
        }
    }

}

interface Edge {
    public int getSource();

    public int getDestination();

    public long getWeight();

    public long getCapacity();

    public long getFlow();

    public void pushFlow(long flow);

    public boolean getFlag(int bit);

    public void setFlag(int bit);

    public void removeFlag(int bit);

    public int getTransposedID();

    public Edge getTransposedEdge();

    public int getReverseID();

    public Edge getReverseEdge();

    public int getID();

    public void remove();

    public void restore();
}

class BidirectionalGraph extends Graph {
    public int[] transposedEdge;

    public BidirectionalGraph(int vertexCount) {
        this(vertexCount, vertexCount);
    }

    public BidirectionalGraph(int vertexCount, int edgeCapacity) {
        super(vertexCount, 2 * edgeCapacity);
        transposedEdge = new int[2 * edgeCapacity];
    }

    public static BidirectionalGraph createGraph(int vertexCount, int[] from,
            int[] to) {
        BidirectionalGraph graph = new BidirectionalGraph(vertexCount,
                from.length);
        for (int i = 0; i < from.length; i++)
            graph.addSimpleEdge(from[i], to[i]);
        return graph;
    }

    public static BidirectionalGraph createWeightedGraph(int vertexCount,
            int[] from, int[] to, long[] weight) {
        BidirectionalGraph graph = new BidirectionalGraph(vertexCount,
                from.length);
        for (int i = 0; i < from.length; i++)
            graph.addWeightedEdge(from[i], to[i], weight[i]);
        return graph;
    }

    public static BidirectionalGraph createFlowGraph(int vertexCount,
            int[] from, int[] to, long[] capacity) {
        BidirectionalGraph graph = new BidirectionalGraph(vertexCount,
                from.length * 2);
        for (int i = 0; i < from.length; i++)
            graph.addFlowEdge(from[i], to[i], capacity[i]);
        return graph;
    }

    public static BidirectionalGraph createFlowWeightedGraph(int vertexCount,
            int[] from, int[] to, long[] weight, long[] capacity) {
        BidirectionalGraph graph = new BidirectionalGraph(vertexCount,
                from.length * 2);
        for (int i = 0; i < from.length; i++)
            graph.addFlowWeightedEdge(from[i], to[i], weight[i], capacity[i]);
        return graph;
    }

    @Override
    public int addEdge(int fromID, int toID, long weight, long capacity,
            int reverseEdge) {
        int lastEdgeCount = edgeCount;
        super.addEdge(fromID, toID, weight, capacity, reverseEdge);
        super.addEdge(toID, fromID, weight, capacity, reverseEdge == -1 ? -1
                : reverseEdge + 1);
        this.transposedEdge[lastEdgeCount] = lastEdgeCount + 1;
        this.transposedEdge[lastEdgeCount + 1] = lastEdgeCount;
        return lastEdgeCount;
    }

    @Override
    protected int entriesPerEdge() {
        return 2;
    }

    @Override
    public final int transposed(int id) {
        return transposedEdge[id];
    }

    @Override
    protected void ensureEdgeCapacity(int size) {
        if (size > edgeCapacity()) {
            super.ensureEdgeCapacity(size);
            transposedEdge = resize(transposedEdge, edgeCapacity());
        }
    }
}

class IOUtils {
    public static long[] readLongArray(InputReader in, int size) {
        long[] array = new long[size];
        for (int i = 0; i < size; i++)
            array[i] = in.readLong();
        return array;
    }

    public static int[] readIntArray(InputReader in, int size) {
        int[] array = new int[size];
        for (int i = 0; i < size; i++)
            array[i] = in.readInt();
        return array;
    }
}

interface Function<A, V> {
    public abstract V value(A argument);
}

class IntegerUtils {

    public static List<Pair<Long, Integer>> factorize(long number) {
        List<Pair<Long, Integer>> result = new ArrayList<Pair<Long, Integer>>();
        for (long i = 2; i * i <= number; i++) {
            if (number % i == 0) {
                int power = 0;
                do {
                    power++;
                    number /= i;
                } while (number % i == 0);
                result.add(Pair.makePair(i, power));
            }
        }
        if (number != 1)
            result.add(Pair.makePair(number, 1));
        return result;
    }

    public static List<Long> getDivisors(long number) {
        List<Pair<Long, Integer>> primeDivisors = factorize(number);
        return getDivisorsImpl(primeDivisors, 0, 1, new ArrayList<Long>());
    }

    private static List<Long> getDivisorsImpl(
            List<Pair<Long, Integer>> primeDivisors, int index, long current,
            List<Long> result) {
        if (index == primeDivisors.size()) {
            result.add(current);
            return result;
        }
        long p = primeDivisors.get(index).first;
        int power = primeDivisors.get(index).second;
        for (int i = 0; i <= power; i++) {
            getDivisorsImpl(primeDivisors, index + 1, current, result);
            current *= p;
        }
        return result;
    }
}

class Pair<U, V> implements Comparable<Pair<U, V>> {
    public final U first;
    public final V second;

    public static <U, V> Pair<U, V> makePair(U first, V second) {
        return new Pair<U, V>(first, second);
    }

    private Pair(U first, V second) {
        this.first = first;
        this.second = second;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;

        Pair pair = (Pair) o;

        return !(first != null ? !first.equals(pair.first) : pair.first != null)
                && !(second != null ? !second.equals(pair.second)
                        : pair.second != null);

    }

    @Override
    public int hashCode() {
        int result = first != null ? first.hashCode() : 0;
        result = 31 * result + (second != null ? second.hashCode() : 0);
        return result;
    }

    public Pair<V, U> swap() {
        return makePair(second, first);
    }

    @Override
    public String toString() {
        return "(" + first + "," + second + ")";
    }

    @SuppressWarnings({ "unchecked" })
    public int compareTo(Pair<U, V> o) {
        int value = ((Comparable<U>) first).compareTo(o.first);
        if (value != 0)
            return value;
        return ((Comparable<V>) second).compareTo(o.second);
    }
}

class InputReader {
    private boolean finished = false;

    private InputStream stream;
    private byte[] buf = new byte[1024];
    private int curChar;
    private int numChars;
    private SpaceCharFilter filter;

    public InputReader(InputStream stream) {
        this.stream = stream;
    }

    public int read() {
        if (numChars == -1)
            throw new InputMismatchException();
        if (curChar >= numChars) {
            curChar = 0;
            try {
                numChars = stream.read(buf);
            } catch (IOException e) {
                throw new InputMismatchException();
            }
            if (numChars <= 0)
                return -1;
        }
        return buf[curChar++];
    }

    public int peek() {
        if (numChars == -1)
            return -1;
        if (curChar >= numChars) {
            curChar = 0;
            try {
                numChars = stream.read(buf);
            } catch (IOException e) {
                return -1;
            }
            if (numChars <= 0)
                return -1;
        }
        return buf[curChar];
    }

    public int readInt() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        int res = 0;
        do {
            if (c < '0' || c > '9')
                throw new InputMismatchException();
            res *= 10;
            res += c - '0';
            c = read();
        } while (!isSpaceChar(c));
        return res * sgn;
    }

    public long readLong() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        long res = 0;
        do {
            if (c < '0' || c > '9')
                throw new InputMismatchException();
            res *= 10;
            res += c - '0';
            c = read();
        } while (!isSpaceChar(c));
        return res * sgn;
    }

    public String readString() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        StringBuilder res = new StringBuilder();
        do {
            if (Character.isValidCodePoint(c))
                res.appendCodePoint(c);
            c = read();
        } while (!isSpaceChar(c));
        return res.toString();
    }

    public boolean isSpaceChar(int c) {
        if (filter != null)
            return filter.isSpaceChar(c);
        return isWhitespace(c);
    }

    public static boolean isWhitespace(int c) {
        return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
    }

    private String readLine0() {
        StringBuilder buf = new StringBuilder();
        int c = read();
        while (c != '\n' && c != -1) {
            if (c != '\r')
                buf.appendCodePoint(c);
            c = read();
        }
        return buf.toString();
    }

    public String readLine() {
        String s = readLine0();
        while (s.trim().length() == 0)
            s = readLine0();
        return s;
    }

    public String readLine(boolean ignoreEmptyLines) {
        if (ignoreEmptyLines)
            return readLine();
        else
            return readLine0();
    }

    public BigInteger readBigInteger() {
        try {
            return new BigInteger(readString());
        } catch (NumberFormatException e) {
            throw new InputMismatchException();
        }
    }

    public char readCharacter() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        return (char) c;
    }

    public double readDouble() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        double res = 0;
        while (!isSpaceChar(c) && c != '.') {
            if (c == 'e' || c == 'E')
                return res * Math.pow(10, readInt());
            if (c < '0' || c > '9')
                throw new InputMismatchException();
            res *= 10;
            res += c - '0';
            c = read();
        }
        if (c == '.') {
            c = read();
            double m = 1;
            while (!isSpaceChar(c)) {
                if (c == 'e' || c == 'E')
                    return res * Math.pow(10, readInt());
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                m /= 10;
                res += (c - '0') * m;
                c = read();
            }
        }
        return res * sgn;
    }

    public boolean isExhausted() {
        int value;
        while (isSpaceChar(value = peek()) && value != -1)
            read();
        return value == -1;
    }

    public String next() {
        return readString();
    }

    public SpaceCharFilter getFilter() {
        return filter;
    }

    public void setFilter(SpaceCharFilter filter) {
        this.filter = filter;
    }

    public interface SpaceCharFilter {
        public boolean isSpaceChar(int ch);
    }
}

class OutputWriter {
    private final PrintWriter writer;

    public OutputWriter(OutputStream outputStream) {
        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(
                outputStream)));
    }

    public OutputWriter(Writer writer) {
        this.writer = new PrintWriter(writer);
    }

    public void print(char[] array) {
        writer.print(array);
    }

    public void print(Object... objects) {
        for (int i = 0; i < objects.length; i++) {
            if (i != 0)
                writer.print(' ');
            writer.print(objects[i]);
        }
    }

    public void print(int[] array) {
        for (int i = 0; i < array.length; i++) {
            if (i != 0)
                writer.print(' ');
            writer.print(array[i]);
        }
    }

    public void print(long[] array) {
        for (int i = 0; i < array.length; i++) {
            if (i != 0)
                writer.print(' ');
            writer.print(array[i]);
        }
    }

    public void printLine(int[] array) {
        print(array);
        writer.println();
    }

    public void printLine(long[] array) {
        print(array);
        writer.println();
    }

    public void printLine() {
        writer.println();
    }

    public void printLine(Object... objects) {
        print(objects);
        writer.println();
    }

    public void print(char i) {
        writer.print(i);
    }

    public void printLine(char i) {
        writer.println(i);
    }

    public void printLine(char[] array) {
        writer.println(array);
    }

    public void printFormat(String format, Object... objects) {
        writer.printf(format, objects);
    }

    public void close() {
        writer.close();
    }

    public void flush() {
        writer.flush();
    }

    public void print(long i) {
        writer.print(i);
    }

    public void printLine(long i) {
        writer.println(i);
    }

    public void print(int i) {
        writer.print(i);
    }

    public void printLine(int i) {
        writer.println(i);
    }
}

class ArrayUtils {

    public static int[] createOrder(int size) {
        int[] order = new int[size];
        for (int i = 0; i < size; i++)
            order[i] = i;
        return order;
    }

    public static int maxPosition(int[] array) {
        return maxPosition(array, 0, array.length);
    }

    public static int maxPosition(int[] array, int from, int to) {
        if (from >= to)
            return -1;
        int max = array[from];
        int result = from;
        for (int i = from + 1; i < to; i++) {
            if (array[i] > max) {
                max = array[i];
                result = i;
            }
        }
        return result;
    }

}package OldAttemptLearning.pimponuser.CF574B;

import java.io.*;
import java.util.HashSet;
import java.util.InputMismatchException;
import java.util.Set;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        TaskB solver = new TaskB();
        solver.solve(1, in, out);
        out.close();
    }
}

class TaskB {
    public void solve(int testNumber, InputReader in, OutputWriter out) {
        int n=in.readInt(), m=in.readInt();
        Set<IntPair> set=new HashSet<IntPair>();
        int[] degree=new int[n];
        while (m-->0) {
            int a=in.readInt()-1, b=in.readInt()-1;
            degree[a]++; degree[b]++; set.add(new IntPair(a, b)); set.add(new IntPair(b, a));
        }
        int ret=Integer.MAX_VALUE;
        for (IntPair pair: set) {
            int a=pair.first, b=pair.second;
            for (int c=0; c<n; c++) if (set.contains(new IntPair(a, c)) && set.contains(new IntPair(b, c))) ret=Math.min(ret, degree[a]+degree[b]+degree[c]-6);
        }
        out.printLine(ret==Integer.MAX_VALUE?-1:ret);
    }
}

class InputReader {

    private InputStream stream;
    private byte[] buf = new byte[1024];
    private int curChar;
    private int numChars;
    private SpaceCharFilter filter;

    public InputReader(InputStream stream) {
        this.stream = stream;
    }

    public int read() {
        if (numChars == -1)
            throw new InputMismatchException();
        if (curChar >= numChars) {
            curChar = 0;
            try {
                numChars = stream.read(buf);
            } catch (IOException e) {
                throw new InputMismatchException();
            }
            if (numChars <= 0)
                return -1;
        }
        return buf[curChar++];
    }

    public int readInt() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        int res = 0;
        do {
            if (c < '0' || c > '9')
                throw new InputMismatchException();
            res *= 10;
            res += c - '0';
            c = read();
        } while (!isSpaceChar(c));
        return res * sgn;
    }

    public boolean isSpaceChar(int c) {
        if (filter != null)
            return filter.isSpaceChar(c);
        return isWhitespace(c);
    }

    public static boolean isWhitespace(int c) {
        return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
    }

    public interface SpaceCharFilter {
        public boolean isSpaceChar(int ch);
    }
}

class OutputWriter {
    private final PrintWriter writer;

    public OutputWriter(OutputStream outputStream) {
        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
    }

    public void close() {
        writer.close();
    }

    public void printLine(int i) {
        writer.println(i);
    }
}

class IntPair implements Comparable<IntPair> {
    public final int first, second;

    public IntPair(int first, int second) {
        this.first = first;
        this.second = second;
    }

    public String toString() {
        return "(" + first + "," + second + ")";
    }

    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        IntPair intPair = (IntPair) o;

        return first == intPair.first && second == intPair.second;

    }

    public int hashCode() {
        int result = first;
        result = 31 * result + second;
        return result;
    }

    public int compareTo(IntPair o) {
        if (first < o.first)
            return -1;
        if (first > o.first)
            return 1;
        if (second < o.second)
            return -1;
        if (second > o.second)
            return 1;
        return 0;
    }
}package OldAttemptLearning.pimponuser.another1;

import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {
    public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		InputReader in = new InputReader(inputStream);
		OutputWriter out = new OutputWriter(outputStream);
		Task solver = new TaskC();
		solver.solve(1, in, out);
		out.close();
	}
}

interface Task {
	public void solve(int testNumber, InputReader in, OutputWriter out);
}

class TaskA implements Task {

	public void solve(int testNumber, InputReader in, OutputWriter out) {
		int n = in.readInt();
		out.printLine(2L * n * (n - 1) * (n - 1) + 1L * n * (n - 1) * (n - 2)
				+ 2L * n * (n - 1) * (n - 2) * (n - 2));
	}

}

class TaskB implements Task {

	ArrayList<Pair<Integer, Long>> list;
	
	public void solve(int testNumber, InputReader in, OutputWriter out) {
		long n=in.readLong(), m=in.readLong(), x=n*m, ret=0L;
		int h=in.readInt();
		list=new ArrayList<Pair<Integer, Long>>();
		for (int i=0; i<h; i++) {
			long t=in.readLong();
			int c=in.readInt();
			list.add(Pair.makePair(c, t));
		}
		Collections.sort(list);
		for (int i=0; i<h; i++) {
			long t=MiscUtils.min(x, list.get(i).second);
			ret+=t*list.get(i).first;
			x-=t;
		}
		out.printLine(x==0?ret:"Impossible");
	}

}

class TaskC implements Task {

	char[][] tab;
	int[] arr;
	
	public void solve(int testNumber, InputReader in, OutputWriter out) {
		int n=in.readInt();
		tab=IOUtils.readTable(in, n, n);
		arr=new int[n];
		boolean fullRow=false, fullColumn=false;
		for (int i=0; i<n; i++) {
			boolean val=true;
			for (int j=0; j<n && val; j++) if (tab[i][j]=='.') {
				val=false;
				arr[i]=j+1;
			}
			fullRow|=val;
		}
		if (!fullRow) {
			for (int i=0; i<n; i++) out.printLine(i+1, arr[i]);
			return;
		}
		for (int i=0; i<n; i++) {
			boolean val=true;
			for (int j=0; j<n && val; j++) if (tab[j][i]=='.') {
				val=false;
				arr[i]=j+1;
			}
			fullColumn|=val;
		}
		if (fullColumn) out.printLine(-1);
		else for (int i=0; i<n; i++) out.printLine(arr[i], i+1);
	}

}

class TaskD implements Task {

	public void solve(int testNumber, InputReader in, OutputWriter out) {
		
	}
}

class TaskE implements Task {

	public void solve(int testNumber, InputReader in, OutputWriter out) {
		int n=in.readInt(), MOD=1000000007;
		long D=1L, A=0L, B=0L, C=0L;
		while (n-->0) {
			long a=A, b=B, c=C, d=D;
			A=(b+c+d)%MOD;
			B=(a+c+d)%MOD;
			C=(a+b+d)%MOD;
			D=(a+b+c)%MOD;
		}
		out.printLine(D);
	}

}

class TaskF implements Task {

	public void solve(int testNumber, InputReader in, OutputWriter out) {

	}

}

class OutputWriter {
	private final PrintWriter writer;

	public OutputWriter(OutputStream outputStream) {
		writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(
				outputStream)));
	}

	public OutputWriter(Writer writer) {
		this.writer = new PrintWriter(writer);
	}

	public void print(char[] array) {
		writer.print(array);
	}

	public void print(Object... objects) {
		for (int i = 0; i < objects.length; i++) {
			if (i != 0)
				writer.print(' ');
			writer.print(objects[i]);
		}
	}

	public void print(int[] array) {
		for (int i = 0; i < array.length; i++) {
			if (i != 0)
				writer.print(' ');
			writer.print(array[i]);
		}
	}

	public void print(long[] array) {
		for (int i = 0; i < array.length; i++) {
			if (i != 0)
				writer.print(' ');
			writer.print(array[i]);
		}
	}

	public void print(Collection<Integer> collection) {
		boolean first = true;
		for (Integer iterator : collection) {
			if (first)
				first = false;
			else
				writer.print(' ');
			writer.print(iterator);
		}
	}

	public void printLine(int[] array) {
		print(array);
		writer.println();
	}

	public void printLine(long[] array) {
		print(array);
		writer.println();
	}

	public void printLine(Collection<Integer> collection) {
		print(collection);
		writer.println();
	}

	public void printLine() {
		writer.println();
	}

	public void printLine(Object... objects) {
		print(objects);
		writer.println();
	}

	public void print(char i) {
		writer.print(i);
	}

	public void printLine(char i) {
		writer.println(i);
	}

	public void printLine(char[] array) {
		writer.println(array);
	}

	public void printFormat(String format, Object... objects) {
		writer.printf(format, objects);
	}

	public void close() {
		writer.close();
	}

	public void flush() {
		writer.flush();
	}

	public void print(long i) {
		writer.print(i);
	}

	public void printLine(long i) {
		writer.println(i);
	}

	public void print(int i) {
		writer.print(i);
	}

	public void printLine(int i) {
		writer.println(i);
	}
}

class InputReader {

	private InputStream stream;
	private byte[] buf = new byte[1024];
	private int curChar;
	private int numChars;
	private SpaceCharFilter filter;

	public InputReader(InputStream stream) {
		this.stream = stream;
	}

	public int read() {
		if (numChars == -1)
			throw new InputMismatchException();
		if (curChar >= numChars) {
			curChar = 0;
			try {
				numChars = stream.read(buf);
			} catch (IOException e) {
				throw new InputMismatchException();
			}
			if (numChars <= 0)
				return -1;
		}
		return buf[curChar++];
	}

	public int peek() {
		if (numChars == -1)
			return -1;
		if (curChar >= numChars) {
			curChar = 0;
			try {
				numChars = stream.read(buf);
			} catch (IOException e) {
				return -1;
			}
			if (numChars <= 0)
				return -1;
		}
		return buf[curChar];
	}

	public int readInt() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		int sgn = 1;
		if (c == '-') {
			sgn = -1;
			c = read();
		}
		int res = 0;
		do {
			if (c < '0' || c > '9')
				throw new InputMismatchException();
			res *= 10;
			res += c - '0';
			c = read();
		} while (!isSpaceChar(c));
		return res * sgn;
	}

	public long readLong() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		int sgn = 1;
		if (c == '-') {
			sgn = -1;
			c = read();
		}
		long res = 0;
		do {
			if (c < '0' || c > '9')
				throw new InputMismatchException();
			res *= 10;
			res += c - '0';
			c = read();
		} while (!isSpaceChar(c));
		return res * sgn;
	}

	public String readString() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		StringBuilder res = new StringBuilder();
		do {
			if (Character.isValidCodePoint(c))
				res.appendCodePoint(c);
			c = read();
		} while (!isSpaceChar(c));
		return res.toString();
	}

	public boolean isSpaceChar(int c) {
		if (filter != null)
			return filter.isSpaceChar(c);
		return isWhitespace(c);
	}

	public static boolean isWhitespace(int c) {
		return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
	}

	private String readLine0() {
		StringBuilder buf = new StringBuilder();
		int c = read();
		while (c != '\n' && c != -1) {
			if (c != '\r')
				buf.appendCodePoint(c);
			c = read();
		}
		return buf.toString();
	}

	public String readLine() {
		String s = readLine0();
		while (s.trim().length() == 0)
			s = readLine0();
		return s;
	}

	public String readLine(boolean ignoreEmptyLines) {
		if (ignoreEmptyLines)
			return readLine();
		else
			return readLine0();
	}

	public BigInteger readBigInteger() {
		try {
			return new BigInteger(readString());
		} catch (NumberFormatException e) {
			throw new InputMismatchException();
		}
	}

	public char readCharacter() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		return (char) c;
	}

	public double readDouble() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		int sgn = 1;
		if (c == '-') {
			sgn = -1;
			c = read();
		}
		double res = 0;
		while (!isSpaceChar(c) && c != '.') {
			if (c == 'e' || c == 'E')
				return res * Math.pow(10, readInt());
			if (c < '0' || c > '9')
				throw new InputMismatchException();
			res *= 10;
			res += c - '0';
			c = read();
		}
		if (c == '.') {
			c = read();
			double m = 1;
			while (!isSpaceChar(c)) {
				if (c == 'e' || c == 'E')
					return res * Math.pow(10, readInt());
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				m /= 10;
				res += (c - '0') * m;
				c = read();
			}
		}
		return res * sgn;
	}

	public boolean isExhausted() {
		int value;
		while (isSpaceChar(value = peek()) && value != -1)
			read();
		return value == -1;
	}

	public String next() {
		return readString();
	}

	public SpaceCharFilter getFilter() {
		return filter;
	}

	public void setFilter(SpaceCharFilter filter) {
		this.filter = filter;
	}

	public interface SpaceCharFilter {
		public boolean isSpaceChar(int ch);
	}
}

class IOUtils {
	public static Pair<Integer, Integer> readIntPair(InputReader in) {
		int first = in.readInt();
		int second = in.readInt();
		return Pair.makePair(first, second);
	}

	public static Pair<Long, Long> readLongPair(InputReader in) {
		long first = in.readLong();
		long second = in.readLong();
		return Pair.makePair(first, second);
	}

	public static int[] readIntArray(InputReader in, int size) {
		int[] array = new int[size];
		for (int i = 0; i < size; i++)
			array[i] = in.readInt();
		return array;
	}

	public static long[] readLongArray(InputReader in, int size) {
		long[] array = new long[size];
		for (int i = 0; i < size; i++)
			array[i] = in.readLong();
		return array;
	}

	public static double[] readDoubleArray(InputReader in, int size) {
		double[] array = new double[size];
		for (int i = 0; i < size; i++)
			array[i] = in.readDouble();
		return array;
	}

	public static String[] readStringArray(InputReader in, int size) {
		String[] array = new String[size];
		for (int i = 0; i < size; i++)
			array[i] = in.readString();
		return array;
	}

	public static char[] readCharArray(InputReader in, int size) {
		char[] array = new char[size];
		for (int i = 0; i < size; i++)
			array[i] = in.readCharacter();
		return array;
	}

	public static Pair<Integer, Integer>[] readIntPairArray(InputReader in,
			int size) {
		@SuppressWarnings({ "unchecked" })
		Pair<Integer, Integer>[] result = new Pair[size];
		for (int i = 0; i < size; i++)
			result[i] = readIntPair(in);
		return result;
	}

	public static Pair<Long, Long>[] readLongPairArray(InputReader in, int size) {
		@SuppressWarnings({ "unchecked" })
		Pair<Long, Long>[] result = new Pair[size];
		for (int i = 0; i < size; i++)
			result[i] = readLongPair(in);
		return result;
	}

	public static void readIntArrays(InputReader in, int[]... arrays) {
		for (int i = 0; i < arrays[0].length; i++) {
			for (int j = 0; j < arrays.length; j++)
				arrays[j][i] = in.readInt();
		}
	}

	public static void readLongArrays(InputReader in, long[]... arrays) {
		for (int i = 0; i < arrays[0].length; i++) {
			for (int j = 0; j < arrays.length; j++)
				arrays[j][i] = in.readLong();
		}
	}

	public static void readDoubleArrays(InputReader in, double[]... arrays) {
		for (int i = 0; i < arrays[0].length; i++) {
			for (int j = 0; j < arrays.length; j++)
				arrays[j][i] = in.readDouble();
		}
	}

	public static char[][] readTable(InputReader in, int rowCount,
			int columnCount) {
		char[][] table = new char[rowCount][];
		for (int i = 0; i < rowCount; i++)
			table[i] = readCharArray(in, columnCount);
		return table;
	}

	public static int[][] readIntTable(InputReader in, int rowCount,
			int columnCount) {
		int[][] table = new int[rowCount][];
		for (int i = 0; i < rowCount; i++)
			table[i] = readIntArray(in, columnCount);
		return table;
	}

	public static double[][] readDoubleTable(InputReader in, int rowCount,
			int columnCount) {
		double[][] table = new double[rowCount][];
		for (int i = 0; i < rowCount; i++)
			table[i] = readDoubleArray(in, columnCount);
		return table;
	}

	public static long[][] readLongTable(InputReader in, int rowCount,
			int columnCount) {
		long[][] table = new long[rowCount][];
		for (int i = 0; i < rowCount; i++)
			table[i] = readLongArray(in, columnCount);
		return table;
	}

	public static String[][] readStringTable(InputReader in, int rowCount,
			int columnCount) {
		String[][] table = new String[rowCount][];
		for (int i = 0; i < rowCount; i++)
			table[i] = readStringArray(in, columnCount);
		return table;
	}

	public static String readText(InputReader in) {
		StringBuilder result = new StringBuilder();
		while (true) {
			int character = in.read();
			if (character == '\r')
				continue;
			if (character == -1)
				break;
			result.append((char) character);
		}
		return result.toString();
	}

	public static void readStringArrays(InputReader in, String[]... arrays) {
		for (int i = 0; i < arrays[0].length; i++) {
			for (int j = 0; j < arrays.length; j++)
				arrays[j][i] = in.readString();
		}
	}

	public static void printTable(OutputWriter out, char[][] table) {
		for (char[] row : table)
			out.printLine(new String(row));
	}
}

class Pair<U, V> implements Comparable<Pair<U, V>> {
	public final U first;
	public final V second;

	public static <U, V> Pair<U, V> makePair(U first, V second) {
		return new Pair<U, V>(first, second);
	}

	private Pair(U first, V second) {
		this.first = first;
		this.second = second;
	}

	@Override
	public boolean equals(Object o) {
		if (this == o)
			return true;
		if (o == null || getClass() != o.getClass())
			return false;

		Pair<?, ?> pair = (Pair<?, ?>) o;

		return !(first != null ? !first.equals(pair.first) : pair.first != null)
				&& !(second != null ? !second.equals(pair.second)
						: pair.second != null);

	}

	@Override
	public int hashCode() {
		int result = first != null ? first.hashCode() : 0;
		result = 31 * result + (second != null ? second.hashCode() : 0);
		return result;
	}

	public Pair<V, U> swap() {
		return makePair(second, first);
	}

	@Override
	public String toString() {
		return "(" + first + "," + second + ")";
	}

	@SuppressWarnings({ "unchecked" })
	public int compareTo(Pair<U, V> o) {
		int value = ((Comparable<U>) first).compareTo(o.first);
		if (value != 0)
			return value;
		return ((Comparable<V>) second).compareTo(o.second);
	}
}

class BidirectionalGraph extends Graph {
	public int[] transposedEdge;

	public BidirectionalGraph(int vertexCount) {
		this(vertexCount, vertexCount);
	}

	public BidirectionalGraph(int vertexCount, int edgeCapacity) {
		super(vertexCount, 2 * edgeCapacity);
		transposedEdge = new int[2 * edgeCapacity];
	}

	public static BidirectionalGraph createGraph(int vertexCount, int[] from,
			int[] to) {
		BidirectionalGraph graph = new BidirectionalGraph(vertexCount,
				from.length);
		for (int i = 0; i < from.length; i++)
			graph.addSimpleEdge(from[i], to[i]);
		return graph;
	}

	public static BidirectionalGraph createWeightedGraph(int vertexCount,
			int[] from, int[] to, long[] weight) {
		BidirectionalGraph graph = new BidirectionalGraph(vertexCount,
				from.length);
		for (int i = 0; i < from.length; i++)
			graph.addWeightedEdge(from[i], to[i], weight[i]);
		return graph;
	}

	public static BidirectionalGraph createFlowGraph(int vertexCount,
			int[] from, int[] to, long[] capacity) {
		BidirectionalGraph graph = new BidirectionalGraph(vertexCount,
				from.length * 2);
		for (int i = 0; i < from.length; i++)
			graph.addFlowEdge(from[i], to[i], capacity[i]);
		return graph;
	}

	public static BidirectionalGraph createFlowWeightedGraph(int vertexCount,
			int[] from, int[] to, long[] weight, long[] capacity) {
		BidirectionalGraph graph = new BidirectionalGraph(vertexCount,
				from.length * 2);
		for (int i = 0; i < from.length; i++)
			graph.addFlowWeightedEdge(from[i], to[i], weight[i], capacity[i]);
		return graph;
	}

	@Override
	public int addEdge(int fromID, int toID, long weight, long capacity,
			int reverseEdge) {
		int lastEdgeCount = edgeCount;
		super.addEdge(fromID, toID, weight, capacity, reverseEdge);
		super.addEdge(toID, fromID, weight, capacity, reverseEdge == -1 ? -1
				: reverseEdge + 1);
		this.transposedEdge[lastEdgeCount] = lastEdgeCount + 1;
		this.transposedEdge[lastEdgeCount + 1] = lastEdgeCount;
		return lastEdgeCount;
	}

	@Override
	protected int entriesPerEdge() {
		return 2;
	}

	@Override
	public final int transposed(int id) {
		return transposedEdge[id];
	}

	@Override
	protected void ensureEdgeCapacity(int size) {
		if (size > edgeCapacity()) {
			super.ensureEdgeCapacity(size);
			transposedEdge = resize(transposedEdge, edgeCapacity());
		}
	}
}

class Graph {
	public static final int REMOVED_BIT = 0;

	protected int vertexCount;
	protected int edgeCount;

	private int[] firstOutbound;
	private int[] firstInbound;

	private Edge[] edges;
	private int[] nextInbound;
	private int[] nextOutbound;
	private int[] from;
	private int[] to;
	private long[] weight;
	private long[] capacity;
	private int[] reverseEdge;
	private int[] flags;

	public Graph(int vertexCount) {
		this(vertexCount, vertexCount);
	}

	public Graph(int vertexCount, int edgeCapacity) {
		this.vertexCount = vertexCount;
		firstOutbound = new int[vertexCount];
		Arrays.fill(firstOutbound, -1);

		from = new int[edgeCapacity];
		to = new int[edgeCapacity];
		nextOutbound = new int[edgeCapacity];
		flags = new int[edgeCapacity];
	}

	public static Graph createGraph(int vertexCount, int[] from, int[] to) {
		Graph graph = new Graph(vertexCount, from.length);
		for (int i = 0; i < from.length; i++)
			graph.addSimpleEdge(from[i], to[i]);
		return graph;
	}

	public static Graph createWeightedGraph(int vertexCount, int[] from,
			int[] to, long[] weight) {
		Graph graph = new Graph(vertexCount, from.length);
		for (int i = 0; i < from.length; i++)
			graph.addWeightedEdge(from[i], to[i], weight[i]);
		return graph;
	}

	public static Graph createFlowGraph(int vertexCount, int[] from, int[] to,
			long[] capacity) {
		Graph graph = new Graph(vertexCount, from.length * 2);
		for (int i = 0; i < from.length; i++)
			graph.addFlowEdge(from[i], to[i], capacity[i]);
		return graph;
	}

	public static Graph createFlowWeightedGraph(int vertexCount, int[] from,
			int[] to, long[] weight, long[] capacity) {
		Graph graph = new Graph(vertexCount, from.length * 2);
		for (int i = 0; i < from.length; i++)
			graph.addFlowWeightedEdge(from[i], to[i], weight[i], capacity[i]);
		return graph;
	}

	public static Graph createTree(int[] parent) {
		Graph graph = new Graph(parent.length + 1, parent.length);
		for (int i = 0; i < parent.length; i++)
			graph.addSimpleEdge(parent[i], i + 1);
		return graph;
	}

	public int addEdge(int fromID, int toID, long weight, long capacity,
			int reverseEdge) {
		ensureEdgeCapacity(edgeCount + 1);
		if (firstOutbound[fromID] != -1)
			nextOutbound[edgeCount] = firstOutbound[fromID];
		else
			nextOutbound[edgeCount] = -1;
		firstOutbound[fromID] = edgeCount;
		if (firstInbound != null) {
			if (firstInbound[toID] != -1)
				nextInbound[edgeCount] = firstInbound[toID];
			else
				nextInbound[edgeCount] = -1;
			firstInbound[toID] = edgeCount;
		}
		this.from[edgeCount] = fromID;
		this.to[edgeCount] = toID;
		if (capacity != 0) {
			if (this.capacity == null)
				this.capacity = new long[from.length];
			this.capacity[edgeCount] = capacity;
		}
		if (weight != 0) {
			if (this.weight == null)
				this.weight = new long[from.length];
			this.weight[edgeCount] = weight;
		}
		if (reverseEdge != -1) {
			if (this.reverseEdge == null) {
				this.reverseEdge = new int[from.length];
				Arrays.fill(this.reverseEdge, 0, edgeCount, -1);
			}
			this.reverseEdge[edgeCount] = reverseEdge;
		}
		if (edges != null)
			edges[edgeCount] = createEdge(edgeCount);
		return edgeCount++;
	}

	protected final GraphEdge createEdge(int id) {
		return new GraphEdge(id);
	}

	public final int addFlowWeightedEdge(int from, int to, long weight,
			long capacity) {
		if (capacity == 0) {
			return addEdge(from, to, weight, 0, -1);
		} else {
			int lastEdgeCount = edgeCount;
			addEdge(to, from, -weight, 0, lastEdgeCount + entriesPerEdge());
			return addEdge(from, to, weight, capacity, lastEdgeCount);
		}
	}

	protected int entriesPerEdge() {
		return 1;
	}

	public final int addFlowEdge(int from, int to, long capacity) {
		return addFlowWeightedEdge(from, to, 0, capacity);
	}

	public final int addWeightedEdge(int from, int to, long weight) {
		return addFlowWeightedEdge(from, to, weight, 0);
	}

	public final int addSimpleEdge(int from, int to) {
		return addWeightedEdge(from, to, 0);
	}

	public final int vertexCount() {
		return vertexCount;
	}

	public final int edgeCount() {
		return edgeCount;
	}

	protected final int edgeCapacity() {
		return from.length;
	}

	public final Edge edge(int id) {
		initEdges();
		return edges[id];
	}

	public final int firstOutbound(int vertex) {
		int id = firstOutbound[vertex];
		while (id != -1 && isRemoved(id))
			id = nextOutbound[id];
		return id;
	}

	public final int nextOutbound(int id) {
		id = nextOutbound[id];
		while (id != -1 && isRemoved(id))
			id = nextOutbound[id];
		return id;
	}

	public final int firstInbound(int vertex) {
		initInbound();
		int id = firstInbound[vertex];
		while (id != -1 && isRemoved(id))
			id = nextInbound[id];
		return id;
	}

	public final int nextInbound(int id) {
		initInbound();
		id = nextInbound[id];
		while (id != -1 && isRemoved(id))
			id = nextInbound[id];
		return id;
	}

	public final int source(int id) {
		return from[id];
	}

	public final int destination(int id) {
		return to[id];
	}

	public final long weight(int id) {
		if (weight == null)
			return 0;
		return weight[id];
	}

	public final long capacity(int id) {
		if (capacity == null)
			return 0;
		return capacity[id];
	}

	public final long flow(int id) {
		if (reverseEdge == null)
			return 0;
		return capacity[reverseEdge[id]];
	}

	public final void pushFlow(int id, long flow) {
		if (flow == 0)
			return;
		if (flow > 0) {
			if (capacity(id) < flow)
				throw new IllegalArgumentException("Not enough capacity");
		} else {
			if (flow(id) < -flow)
				throw new IllegalArgumentException("Not enough capacity");
		}
		capacity[id] -= flow;
		capacity[reverseEdge[id]] += flow;
	}

	public int transposed(int id) {
		return -1;
	}

	public final int reverse(int id) {
		if (reverseEdge == null)
			return -1;
		return reverseEdge[id];
	}

	public final void addVertices(int count) {
		ensureVertexCapacity(vertexCount + count);
		Arrays.fill(firstOutbound, vertexCount, vertexCount + count, -1);
		if (firstInbound != null)
			Arrays.fill(firstInbound, vertexCount, vertexCount + count, -1);
		vertexCount += count;
	}

	protected final void initEdges() {
		if (edges == null) {
			edges = new Edge[from.length];
			for (int i = 0; i < edgeCount; i++)
				edges[i] = createEdge(i);
		}
	}

	public final void removeVertex(int vertex) {
		int id = firstOutbound[vertex];
		while (id != -1) {
			removeEdge(id);
			id = nextOutbound[id];
		}
		initInbound();
		id = firstInbound[vertex];
		while (id != -1) {
			removeEdge(id);
			id = nextInbound[id];
		}
	}

	private void initInbound() {
		if (firstInbound == null) {
			firstInbound = new int[firstOutbound.length];
			Arrays.fill(firstInbound, 0, vertexCount, -1);
			nextInbound = new int[from.length];
			for (int i = 0; i < edgeCount; i++) {
				nextInbound[i] = firstInbound[to[i]];
				firstInbound[to[i]] = i;
			}
		}
	}

	public final boolean flag(int id, int bit) {
		return (flags[id] >> bit & 1) != 0;
	}

	public final void setFlag(int id, int bit) {
		flags[id] |= 1 << bit;
	}

	public final void removeFlag(int id, int bit) {
		flags[id] &= -1 - (1 << bit);
	}

	public final void removeEdge(int id) {
		setFlag(id, REMOVED_BIT);
	}

	public final void restoreEdge(int id) {
		removeFlag(id, REMOVED_BIT);
	}

	public final boolean isRemoved(int id) {
		return flag(id, REMOVED_BIT);
	}

	public final Iterable<Edge> outbound(final int id) {
		initEdges();
		return new Iterable<Edge>() {
			public Iterator<Edge> iterator() {
				return new EdgeIterator(id, firstOutbound, nextOutbound);
			}
		};
	}

	public final Iterable<Edge> inbound(final int id) {
		initEdges();
		initInbound();
		return new Iterable<Edge>() {
			public Iterator<Edge> iterator() {
				return new EdgeIterator(id, firstInbound, nextInbound);
			}
		};
	}

	protected void ensureEdgeCapacity(int size) {
		if (from.length < size) {
			int newSize = Math.max(size, 2 * from.length);
			if (edges != null)
				edges = resize(edges, newSize);
			from = resize(from, newSize);
			to = resize(to, newSize);
			nextOutbound = resize(nextOutbound, newSize);
			if (nextInbound != null)
				nextInbound = resize(nextInbound, newSize);
			if (weight != null)
				weight = resize(weight, newSize);
			if (capacity != null)
				capacity = resize(capacity, newSize);
			if (reverseEdge != null)
				reverseEdge = resize(reverseEdge, newSize);
			flags = resize(flags, newSize);
		}
	}

	private void ensureVertexCapacity(int size) {
		if (firstOutbound.length < size) {
			int newSize = Math.max(size, 2 * from.length);
			firstOutbound = resize(firstOutbound, newSize);
			if (firstInbound != null)
				firstInbound = resize(firstInbound, newSize);
		}
	}

	protected final int[] resize(int[] array, int size) {
		int[] newArray = new int[size];
		System.arraycopy(array, 0, newArray, 0, array.length);
		return newArray;
	}

	private long[] resize(long[] array, int size) {
		long[] newArray = new long[size];
		System.arraycopy(array, 0, newArray, 0, array.length);
		return newArray;
	}

	private Edge[] resize(Edge[] array, int size) {
		Edge[] newArray = new Edge[size];
		System.arraycopy(array, 0, newArray, 0, array.length);
		return newArray;
	}

	public final boolean isSparse() {
		return vertexCount == 0 || edgeCount * 20 / vertexCount <= vertexCount;
	}

	protected class GraphEdge implements Edge {
		protected int id;

		protected GraphEdge(int id) {
			this.id = id;
		}

		public int getSource() {
			return source(id);
		}

		public int getDestination() {
			return destination(id);
		}

		public long getWeight() {
			return weight(id);
		}

		public long getCapacity() {
			return capacity(id);
		}

		public long getFlow() {
			return flow(id);
		}

		public void pushFlow(long flow) {
			Graph.this.pushFlow(id, flow);
		}

		public boolean getFlag(int bit) {
			return flag(id, bit);
		}

		public void setFlag(int bit) {
			Graph.this.setFlag(id, bit);
		}

		public void removeFlag(int bit) {
			Graph.this.removeFlag(id, bit);
		}

		public int getTransposedID() {
			return transposed(id);
		}

		public Edge getTransposedEdge() {
			int reverseID = getTransposedID();
			if (reverseID == -1)
				return null;
			initEdges();
			return edge(reverseID);
		}

		public int getReverseID() {
			return reverse(id);
		}

		public Edge getReverseEdge() {
			int reverseID = getReverseID();
			if (reverseID == -1)
				return null;
			initEdges();
			return edge(reverseID);
		}

		public int getID() {
			return id;
		}

		public void remove() {
			removeEdge(id);
		}

		public void restore() {
			restoreEdge(id);
		}
	}

	public class EdgeIterator implements Iterator<Edge> {
		private int edgeID;
		private final int[] next;
		private int lastID = -1;

		public EdgeIterator(int id, int[] first, int[] next) {
			this.next = next;
			edgeID = nextEdge(first[id]);
		}

		private int nextEdge(int id) {
			while (id != -1 && isRemoved(id))
				id = next[id];
			return id;
		}

		public boolean hasNext() {
			return edgeID != -1;
		}

		public Edge next() {
			if (edgeID == -1)
				throw new NoSuchElementException();
			lastID = edgeID;
			edgeID = nextEdge(next[lastID]);
			return edges[lastID];
		}

		public void remove() {
			if (lastID == -1)
				throw new IllegalStateException();
			removeEdge(lastID);
			lastID = -1;
		}
	}

}

interface Edge {
	public int getSource();

	public int getDestination();

	public long getWeight();

	public long getCapacity();

	public long getFlow();

	public void pushFlow(long flow);

	public boolean getFlag(int bit);

	public void setFlag(int bit);

	public void removeFlag(int bit);

	public int getTransposedID();

	public Edge getTransposedEdge();

	public int getReverseID();

	public Edge getReverseEdge();

	public int getID();

	public void remove();

	public void restore();
}

class MiscUtils {
	public static final int[] DX4 = { 1, 0, -1, 0 };
	public static final int[] DY4 = { 0, -1, 0, 1 };
	public static final int[] DX8 = { 1, 1, 1, 0, -1, -1, -1, 0 };
	public static final int[] DY8 = { -1, 0, 1, 1, 1, 0, -1, -1 };
	public static final int[] DX_KNIGHT = { 2, 1, -1, -2, -2, -1, 1, 2 };
	public static final int[] DY_KNIGHT = { 1, 2, 2, 1, -1, -2, -2, -1 };

	private static final String[] ROMAN_TOKENS = { "M", "CM", "D", "CD", "C",
			"XC", "L", "XL", "X", "IX", "V", "IV", "I" };
	private static final int[] ROMAN_VALUES = { 1000, 900, 500, 400, 100, 90,
			50, 40, 10, 9, 5, 4, 1 };

	public static long josephProblem(long n, int k) {
		if (n == 1)
			return 0;
		if (k == 1)
			return n - 1;
		if (k > n)
			return (josephProblem(n - 1, k) + k) % n;
		long count = n / k;
		long result = josephProblem(n - count, k);
		result -= n % k;
		if (result < 0)
			result += n;
		else
			result += result / (k - 1);
		return result;
	}

	public static boolean isValidCell(int row, int column, int rowCount,
			int columnCount) {
		return row >= 0 && row < rowCount && column >= 0
				&& column < columnCount;
	}

	public static List<Integer> getPath(int[] last, int destination) {
		List<Integer> path = new ArrayList<Integer>();
		while (destination != -1) {
			path.add(destination);
			destination = last[destination];
		}
		Collections.reverse(path);
		return path;
	}

	public static List<Integer> getPath(int[][] lastIndex,
			int[][] lastPathNumber, int destination, int pathNumber) {
		List<Integer> path = new ArrayList<Integer>();
		while (destination != -1 || pathNumber != 0) {
			path.add(destination);
			int nextDestination = lastIndex[destination][pathNumber];
			pathNumber = lastPathNumber[destination][pathNumber];
			destination = nextDestination;
		}
		Collections.reverse(path);
		return path;
	}

	public static long maximalRectangleSum(long[][] array) {
		int n = array.length;
		int m = array[0].length;
		long[][] partialSums = new long[n + 1][m + 1];
		for (int i = 0; i < n; i++) {
			long rowSum = 0;
			for (int j = 0; j < m; j++) {
				rowSum += array[i][j];
				partialSums[i + 1][j + 1] = partialSums[i][j + 1] + rowSum;
			}
		}
		long result = Long.MIN_VALUE;
		for (int i = 0; i < m; i++) {
			for (int j = i; j < m; j++) {
				long minPartialSum = 0;
				for (int k = 1; k <= n; k++) {
					long current = partialSums[k][j + 1] - partialSums[k][i];
					result = Math.max(result, current - minPartialSum);
					minPartialSum = Math.min(minPartialSum, current);
				}
			}
		}
		return result;
	}

	public static int parseIP(String ip) {
		String[] components = ip.split("[.]");
		int result = 0;
		for (int i = 0; i < 4; i++)
			result += (1 << (24 - 8 * i)) * Integer.parseInt(components[i]);
		return result;
	}

	public static String buildIP(int mask) {
		StringBuilder result = new StringBuilder();
		for (int i = 0; i < 4; i++) {
			if (i != 0)
				result.append('.');
			result.append(mask >> (24 - 8 * i) & 255);
		}
		return result.toString();
	}

	public static long binarySearch(long from, long to,
			Function<Long, Boolean> function) {
		while (from < to) {
			long argument = from + (to - from) / 2;
			if (function.value(argument))
				to = argument;
			else
				from = argument + 1;
		}
		return from;
	}

	public static <T> boolean equals(T first, T second) {
		return first == null && second == null || first != null
				&& first.equals(second);
	}

	public static boolean isVowel(char ch) {
		ch = Character.toUpperCase(ch);
		return ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U'
				|| ch == 'Y';
	}

	public static boolean isStrictVowel(char ch) {
		ch = Character.toUpperCase(ch);
		return ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U';
	}

	public static String convertToRoman(int number) {
		StringBuilder result = new StringBuilder();
		for (int i = 0; i < ROMAN_TOKENS.length; i++) {
			while (number >= ROMAN_VALUES[i]) {
				number -= ROMAN_VALUES[i];
				result.append(ROMAN_TOKENS[i]);
			}
		}
		return result.toString();
	}

	public static int convertFromRoman(String number) {
		int result = 0;
		for (int i = 0; i < ROMAN_TOKENS.length; i++) {
			while (number.startsWith(ROMAN_TOKENS[i])) {
				number = number.substring(ROMAN_TOKENS[i].length());
				result += ROMAN_VALUES[i];
			}
		}
		return result;
	}

	public static int distance(int x1, int y1, int x2, int y2) {
		int dx = x1 - x2;
		int dy = y1 - y2;
		return dx * dx + dy * dy;
	}

	public static <T extends Comparable<T>> T min(T first, T second) {
		if (first.compareTo(second) <= 0)
			return first;
		return second;
	}

	public static <T extends Comparable<T>> T max(T first, T second) {
		if (first.compareTo(second) <= 0)
			return second;
		return first;
	}

	public static void decreaseByOne(int[]... arrays) {
		for (int[] array : arrays) {
			for (int i = 0; i < array.length; i++)
				array[i]--;
		}
	}

	public static int[] getIntArray(String s) {
		String[] tokens = s.split(" ");
		int[] result = new int[tokens.length];
		for (int i = 0; i < result.length; i++)
			result[i] = Integer.parseInt(tokens[i]);
		return result;
	}
}

interface Function<A, V> {
	public abstract V value(A argument);
}

interface IntComparator {
	public static final IntComparator DEFAULT = new IntComparator() {
		public int compare(int first, int second) {
			if (first < second)
				return -1;
			if (first > second)
				return 1;
			return 0;
		}
	};

	public static final IntComparator REVERSE = new IntComparator() {
		public int compare(int first, int second) {
			if (first < second)
				return 1;
			if (first > second)
				return -1;
			return 0;
		}
	};

	public int compare(int first, int second);
}

class DFSOrder {
	public final int[] position;
	public final int[] end;

	public DFSOrder(Graph graph) {
		this(graph, 0);
	}

	public DFSOrder(Graph graph, int root) {
		int count = graph.vertexCount();
		position = new int[count];
		end = new int[count];
		int[] edge = new int[count];
		int[] stack = new int[count];
		for (int i = 0; i < count; i++)
			edge[i] = graph.firstOutbound(i);
		stack[0] = root;
		int size = 1;
		position[root] = 0;
		int index = 0;
		while (size > 0) {
			int current = stack[size - 1];
			if (edge[current] == -1) {
				end[current] = index;
				size--;
			} else {
				int next = graph.destination(edge[current]);
				edge[current] = graph.nextOutbound(edge[current]);
				position[next] = ++index;
				stack[size++] = next;
			}
		}
	}

	public DFSOrder(BidirectionalGraph graph) {
		this(graph, 0);
	}

	public DFSOrder(BidirectionalGraph graph, int root) {
		int count = graph.vertexCount();
		position = new int[count];
		end = new int[count];
		int[] edge = new int[count];
		int[] stack = new int[count];
		int[] last = new int[count];
		for (int i = 0; i < count; i++)
			edge[i] = graph.firstOutbound(i);
		stack[0] = root;
		last[root] = -1;
		int size = 1;
		position[root] = 0;
		int index = 0;
		while (size > 0) {
			int current = stack[size - 1];
			if (edge[current] == -1) {
				end[current] = index;
				size--;
			} else {
				int next = graph.destination(edge[current]);
				if (next == last[current]) {
					edge[current] = graph.nextOutbound(edge[current]);
					continue;
				}
				edge[current] = graph.nextOutbound(edge[current]);
				position[next] = ++index;
				last[next] = current;
				stack[size++] = next;
			}
		}
	}
}

abstract class IntervalTree {
	protected int size;

	protected IntervalTree(int size) {
		this(size, true);
	}

	public IntervalTree(int size, boolean shouldInit) {
		this.size = size;
		int nodeCount = Math.max(1, Integer.highestOneBit(size) << 2);
		initData(size, nodeCount);
		if (shouldInit)
			init();
	}

	protected abstract void initData(int size, int nodeCount);

	protected abstract void initAfter(int root, int left, int right, int middle);

	protected abstract void initBefore(int root, int left, int right, int middle);

	protected abstract void initLeaf(int root, int index);

	protected abstract void updatePostProcess(int root, int left, int right,
			int from, int to, long delta, int middle);

	protected abstract void updatePreProcess(int root, int left, int right,
			int from, int to, long delta, int middle);

	protected abstract void updateFull(int root, int left, int right, int from,
			int to, long delta);

	protected abstract long queryPostProcess(int root, int left, int right,
			int from, int to, int middle, long leftResult, long rightResult);

	protected abstract void queryPreProcess(int root, int left, int right,
			int from, int to, int middle);

	protected abstract long queryFull(int root, int left, int right, int from,
			int to);

	protected abstract long emptySegmentResult();

	public void init() {
		if (size == 0)
			return;
		init(0, 0, size - 1);
	}

	private void init(int root, int left, int right) {
		if (left == right) {
			initLeaf(root, left);
		} else {
			int middle = (left + right) >> 1;
			initBefore(root, left, right, middle);
			init(2 * root + 1, left, middle);
			init(2 * root + 2, middle + 1, right);
			initAfter(root, left, right, middle);
		}
	}

	public void update(int from, int to, long delta) {
		update(0, 0, size - 1, from, to, delta);
	}

	protected void update(int root, int left, int right, int from, int to,
			long delta) {
		if (left > to || right < from)
			return;
		if (left >= from && right <= to) {
			updateFull(root, left, right, from, to, delta);
			return;
		}
		int middle = (left + right) >> 1;
		updatePreProcess(root, left, right, from, to, delta, middle);
		update(2 * root + 1, left, middle, from, to, delta);
		update(2 * root + 2, middle + 1, right, from, to, delta);
		updatePostProcess(root, left, right, from, to, delta, middle);
	}

	public long query(int from, int to) {
		return query(0, 0, size - 1, from, to);
	}

	protected long query(int root, int left, int right, int from, int to) {
		if (left > to || right < from)
			return emptySegmentResult();
		if (left >= from && right <= to)
			return queryFull(root, left, right, from, to);
		int middle = (left + right) >> 1;
		queryPreProcess(root, left, right, from, to, middle);
		long leftResult = query(2 * root + 1, left, middle, from, to);
		long rightResult = query(2 * root + 2, middle + 1, right, from, to);
		return queryPostProcess(root, left, right, from, to, middle,
				leftResult, rightResult);
	}
}

class LCA {
	private final long[] order;
	private final int[] position;
	private final IntervalTree lcaTree;
	private final int[] level;

	public LCA(Graph graph) {
		this(graph, 0);
	}

	public LCA(Graph graph, int root) {
		order = new long[2 * graph.vertexCount() - 1];
		position = new int[graph.vertexCount()];
		level = new int[graph.vertexCount()];
		int[] index = new int[graph.vertexCount()];
		for (int i = 0; i < index.length; i++)
			index[i] = graph.firstOutbound(i);
		int[] last = new int[graph.vertexCount()];
		int[] stack = new int[graph.vertexCount()];
		stack[0] = root;
		int size = 1;
		int j = 0;
		last[root] = -1;
		Arrays.fill(position, -1);
		while (size > 0) {
			int vertex = stack[--size];
			if (position[vertex] == -1)
				position[vertex] = j;
			order[j++] = vertex;
			if (last[vertex] != -1)
				level[vertex] = level[last[vertex]] + 1;
			while (index[vertex] != -1
					&& last[vertex] == graph.destination(index[vertex]))
				index[vertex] = graph.nextOutbound(index[vertex]);
			if (index[vertex] != -1) {
				stack[size++] = vertex;
				stack[size++] = graph.destination(index[vertex]);
				last[graph.destination(index[vertex])] = vertex;
				index[vertex] = graph.nextOutbound(index[vertex]);
			}
		}
		lcaTree = new ReadOnlyIntervalTree(order) {
			@Override
			protected long joinValue(long left, long right) {
				if (left == -1)
					return right;
				if (right == -1)
					return left;
				if (level[((int) left)] < level[((int) right)])
					return left;
				return right;
			}

			@Override
			protected long neutralValue() {
				return -1;
			}
		};
		lcaTree.init();
	}

	public int getPosition(int vertex) {
		return position[vertex];
	}

	public int getLCA(int first, int second) {
		return (int) lcaTree.query(Math.min(position[first], position[second]),
				Math.max(position[first], position[second]));
	}

	public int getLevel(int vertex) {
		return level[vertex];
	}

	public int getPathLength(int first, int second) {
		return level[first] + level[second] - 2 * level[getLCA(first, second)];
	}
}

abstract class LongIntervalTree extends IntervalTree {
	protected long[] value;
	protected long[] delta;

	protected LongIntervalTree(int size) {
		this(size, true);
	}

	public LongIntervalTree(int size, boolean shouldInit) {
		super(size, shouldInit);
	}

	@Override
	protected void initData(int size, int nodeCount) {
		value = new long[nodeCount];
		delta = new long[nodeCount];
	}

	protected abstract long joinValue(long left, long right);

	protected abstract long joinDelta(long was, long delta);

	protected abstract long accumulate(long value, long delta, int length);

	protected abstract long neutralValue();

	protected abstract long neutralDelta();

	protected long initValue(int index) {
		return neutralValue();
	}

	@Override
	protected void initAfter(int root, int left, int right, int middle) {
		value[root] = joinValue(value[2 * root + 1], value[2 * root + 2]);
		delta[root] = neutralDelta();
	}

	@Override
	protected void initBefore(int root, int left, int right, int middle) {
	}

	@Override
	protected void initLeaf(int root, int index) {
		value[root] = initValue(index);
		delta[root] = neutralDelta();
	}

	@Override
	protected void updatePostProcess(int root, int left, int right, int from,
			int to, long delta, int middle) {
		value[root] = joinValue(value[2 * root + 1], value[2 * root + 2]);
	}

	@Override
	protected void updatePreProcess(int root, int left, int right, int from,
			int to, long delta, int middle) {
		pushDown(root, left, middle, right);
	}

	protected void pushDown(int root, int left, int middle, int right) {
		value[2 * root + 1] = accumulate(value[2 * root + 1], delta[root],
				middle - left + 1);
		value[2 * root + 2] = accumulate(value[2 * root + 2], delta[root],
				right - middle);
		delta[2 * root + 1] = joinDelta(delta[2 * root + 1], delta[root]);
		delta[2 * root + 2] = joinDelta(delta[2 * root + 2], delta[root]);
		delta[root] = neutralDelta();
	}

	@Override
	protected void updateFull(int root, int left, int right, int from, int to,
			long delta) {
		value[root] = accumulate(value[root], delta, right - left + 1);
		this.delta[root] = joinDelta(this.delta[root], delta);
	}

	@Override
	protected long queryPostProcess(int root, int left, int right, int from,
			int to, int middle, long leftResult, long rightResult) {
		return joinValue(leftResult, rightResult);
	}

	@Override
	protected void queryPreProcess(int root, int left, int right, int from,
			int to, int middle) {
		pushDown(root, left, middle, right);
	}

	@Override
	protected long queryFull(int root, int left, int right, int from, int to) {
		return value[root];
	}

	@Override
	protected long emptySegmentResult() {
		return neutralValue();
	}
}

class SumIntervalTree extends LongIntervalTree {
	public SumIntervalTree(int size) {
		super(size);
	}

	@Override
	protected long joinValue(long left, long right) {
		return left + right;
	}

	@Override
	protected long joinDelta(long was, long delta) {
		return was + delta;
	}

	@Override
	protected long accumulate(long value, long delta, int length) {
		return value + delta * length;
	}

	@Override
	protected long neutralValue() {
		return 0;
	}

	@Override
	protected long neutralDelta() {
		return 0;
	}
}

abstract class ReadOnlyIntervalTree extends IntervalTree {
	protected long[] value;
	protected long[] array;

	protected ReadOnlyIntervalTree(long[] array) {
		super(array.length, false);
		this.array = array;
		init();
	}

	@Override
	protected void initData(int size, int nodeCount) {
		value = new long[nodeCount];
	}

	@Override
	protected void initAfter(int root, int left, int right, int middle) {
		value[root] = joinValue(value[2 * root + 1], value[2 * root + 2]);
	}

	@Override
	protected void initBefore(int root, int left, int right, int middle) {
	}

	@Override
	protected void initLeaf(int root, int index) {
		value[root] = array[index];
	}

	@Override
	protected void updatePostProcess(int root, int left, int right, int from,
			int to, long delta, int middle) {
		throw new UnsupportedOperationException();
	}

	@Override
	protected void updatePreProcess(int root, int left, int right, int from,
			int to, long delta, int middle) {
		throw new UnsupportedOperationException();
	}

	@Override
	protected void updateFull(int root, int left, int right, int from, int to,
			long delta) {
		throw new UnsupportedOperationException();
	}

	@Override
	protected long queryPostProcess(int root, int left, int right, int from,
			int to, int middle, long leftResult, long rightResult) {
		return joinValue(leftResult, rightResult);
	}

	@Override
	protected void queryPreProcess(int root, int left, int right, int from,
			int to, int middle) {
	}

	@Override
	protected long queryFull(int root, int left, int right, int from, int to) {
		return value[root];
	}

	@Override
	protected long emptySegmentResult() {
		return neutralValue();
	}

	@Override
	public void update(int from, int to, long delta) {
		throw new UnsupportedOperationException();
	}

	@Override
	protected void update(int root, int left, int right, int from, int to,
			long delta) {
		throw new UnsupportedOperationException();
	}

	protected abstract long neutralValue();

	protected abstract long joinValue(long left, long right);
}package OldAttemptLearning.pimponuser.another3;

import java.io.*;
import java.lang.reflect.Array;
import java.math.BigInteger;
import java.util.*;

public class Main {
    public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		InputReader in = new InputReader(inputStream);
		OutputWriter out = new OutputWriter(outputStream);
		Task solver = new TaskB();
		solver.solve(1, in, out);
		out.close();
	}
}

interface Task {
	public void solve(int testNumber, InputReader in, OutputWriter out);
}

class TaskA implements Task {

	public void solve(int testNumber, InputReader in, OutputWriter out) {
		int p = Integer.MAX_VALUE;
		for (int i = 0; i < 4; i++)
			p = MiscUtils.min(p, in.readInt());
		int a = in.readInt(), b = in.readInt(), ret = 0;
		for (int i = a; i <= b; i++)
			if (i < p)
				ret++;
		out.printLine(ret);
	}

}

class TaskB implements Task {

	int[] array;
	
	public void solve(int testNumber, InputReader in, OutputWriter out) {
		int n = in.readInt(), x=Integer.MAX_VALUE;
		array=IOUtils.readIntArray(in, n);
		long ret=ArrayUtils.sumArray(array);
		if (ret%2==0) {
			for (int y: array) if (y%2==1) x=MiscUtils.min(x, y);
			ret-=x;
		}
		out.printLine(MiscUtils.max(ret, 0L));
	}

}

class TaskC implements Task {

	int[] arr;
	boolean[] prime;
	long[] sum;
	
	public void solve(int testNumber, InputReader in, OutputWriter out) {
		final int a=in.readInt(), b=in.readInt(), k=in.readInt();
		long ret=Long.MAX_VALUE;
		arr=new int[b];
		prime=IntegerUtils.generatePrimalityTable(b+1);
		for (int i=a; i<=b; i++) if (prime[i]) arr[i-1]=1;
		sum=ArrayUtils.partialSums(arr);
//		out.printLine(sum);
		out.printLine(sum[b]-sum[a-1]<k?-1:MiscUtils.binarySearch(1, b-a+1, new Function<Long, Boolean>() {
			public Boolean value(Long x) {
//				System.out.println(x);
				for (int i=a-1; i+x<=b; i++) {
//					if (x==2) System.out.println(sum[(int)(x+i)]+" "+sum[i]);
					if (sum[(int)(x+i)]-sum[i]<k) return false;
				}
				return true;
			}
		}));
	}

}

class TaskD implements Task {

	long[][] dp;
	List<List<Long>> list;

	public void solve(int testNumber, InputReader in, OutputWriter out) {
		int n = in.readInt(), k = in.readInt(), mod = 1000000007;
		dp = new long[k + 1][n + 1];
		Arrays.fill(dp[1], 1L);
		list = new ArrayList<List<Long>>();
		for (int i = 0; i <= n; i++)
			list.add(IntegerUtils.getDivisors(i));
		for (int i = 2; i <= k; i++)
			for (int j = 1; j <= n; j++)
				for (long x : list.get(j))
					dp[i][j] = (dp[i][j] + dp[i - 1][(int) x]) % mod;
		long ret = 0L;
		for (int i = 1; i <= n; i++)
			ret = (ret + dp[k][i]) % mod;
		out.printLine(ret);
	}
}

class TaskE implements Task {

	public void solve(int testNumber, InputReader in, OutputWriter out) {

	}

}

class TaskF implements Task {

	public void solve(int testNumber, InputReader in, OutputWriter out) {

	}

}

class OutputWriter {
	private final PrintWriter writer;

	public OutputWriter(OutputStream outputStream) {
		writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(
				outputStream)));
	}

	public OutputWriter(Writer writer) {
		this.writer = new PrintWriter(writer);
	}

	public void print(char[] array) {
		writer.print(array);
	}

	public void print(Object... objects) {
		for (int i = 0; i < objects.length; i++) {
			if (i != 0)
				writer.print(' ');
			writer.print(objects[i]);
		}
	}

	public void print(int[] array) {
		for (int i = 0; i < array.length; i++) {
			if (i != 0)
				writer.print(' ');
			writer.print(array[i]);
		}
	}

	public void print(long[] array) {
		for (int i = 0; i < array.length; i++) {
			if (i != 0)
				writer.print(' ');
			writer.print(array[i]);
		}
	}

	public void print(Collection<Integer> collection) {
		boolean first = true;
		for (int value : collection) {
			if (first)
				first = false;
			else
				writer.print(' ');
			writer.print(value);
		}
	}

	public void printLine(int[] array) {
		print(array);
		writer.println();
	}

	public void printLine(long[] array) {
		print(array);
		writer.println();
	}

	public void printLine(Collection<Integer> collection) {
		print(collection);
		writer.println();
	}

	public void printLine() {
		writer.println();
	}

	public void printLine(Object... objects) {
		print(objects);
		writer.println();
	}

	public void print(char i) {
		writer.print(i);
	}

	public void printLine(char i) {
		writer.println(i);
	}

	public void printLine(char[] array) {
		writer.println(array);
	}

	public void printFormat(String format, Object... objects) {
		writer.printf(format, objects);
	}

	public void close() {
		writer.close();
	}

	public void flush() {
		writer.flush();
	}

	public void print(long i) {
		writer.print(i);
	}

	public void printLine(long i) {
		writer.println(i);
	}

	public void print(int i) {
		writer.print(i);
	}

	public void printLine(int i) {
		writer.println(i);
	}
}

class InputReader {
	private boolean finished = false;

	private InputStream stream;
	private byte[] buf = new byte[1024];
	private int curChar;
	private int numChars;
	private SpaceCharFilter filter;

	public InputReader(InputStream stream) {
		this.stream = stream;
	}

	public int read() {
		if (numChars == -1)
			throw new InputMismatchException();
		if (curChar >= numChars) {
			curChar = 0;
			try {
				numChars = stream.read(buf);
			} catch (IOException e) {
				throw new InputMismatchException();
			}
			if (numChars <= 0)
				return -1;
		}
		return buf[curChar++];
	}

	public int peek() {
		if (numChars == -1)
			return -1;
		if (curChar >= numChars) {
			curChar = 0;
			try {
				numChars = stream.read(buf);
			} catch (IOException e) {
				return -1;
			}
			if (numChars <= 0)
				return -1;
		}
		return buf[curChar];
	}

	public int readInt() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		int sgn = 1;
		if (c == '-') {
			sgn = -1;
			c = read();
		}
		int res = 0;
		do {
			if (c < '0' || c > '9')
				throw new InputMismatchException();
			res *= 10;
			res += c - '0';
			c = read();
		} while (!isSpaceChar(c));
		return res * sgn;
	}

	public long readLong() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		int sgn = 1;
		if (c == '-') {
			sgn = -1;
			c = read();
		}
		long res = 0;
		do {
			if (c < '0' || c > '9')
				throw new InputMismatchException();
			res *= 10;
			res += c - '0';
			c = read();
		} while (!isSpaceChar(c));
		return res * sgn;
	}

	public String readString() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		StringBuilder res = new StringBuilder();
		do {
			if (Character.isValidCodePoint(c))
				res.appendCodePoint(c);
			c = read();
		} while (!isSpaceChar(c));
		return res.toString();
	}

	public boolean isSpaceChar(int c) {
		if (filter != null)
			return filter.isSpaceChar(c);
		return isWhitespace(c);
	}

	public static boolean isWhitespace(int c) {
		return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
	}

	private String readLine0() {
		StringBuilder buf = new StringBuilder();
		int c = read();
		while (c != '\n' && c != -1) {
			if (c != '\r')
				buf.appendCodePoint(c);
			c = read();
		}
		return buf.toString();
	}

	public String readLine() {
		String s = readLine0();
		while (s.trim().length() == 0)
			s = readLine0();
		return s;
	}

	public String readLine(boolean ignoreEmptyLines) {
		if (ignoreEmptyLines)
			return readLine();
		else
			return readLine0();
	}

	public BigInteger readBigInteger() {
		try {
			return new BigInteger(readString());
		} catch (NumberFormatException e) {
			throw new InputMismatchException();
		}
	}

	public char readCharacter() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		return (char) c;
	}

	public double readDouble() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		int sgn = 1;
		if (c == '-') {
			sgn = -1;
			c = read();
		}
		double res = 0;
		while (!isSpaceChar(c) && c != '.') {
			if (c == 'e' || c == 'E')
				return res * Math.pow(10, readInt());
			if (c < '0' || c > '9')
				throw new InputMismatchException();
			res *= 10;
			res += c - '0';
			c = read();
		}
		if (c == '.') {
			c = read();
			double m = 1;
			while (!isSpaceChar(c)) {
				if (c == 'e' || c == 'E')
					return res * Math.pow(10, readInt());
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				m /= 10;
				res += (c - '0') * m;
				c = read();
			}
		}
		return res * sgn;
	}

	public boolean isExhausted() {
		int value;
		while (isSpaceChar(value = peek()) && value != -1)
			read();
		return value == -1;
	}

	public String next() {
		return readString();
	}

	public SpaceCharFilter getFilter() {
		return filter;
	}

	public void setFilter(SpaceCharFilter filter) {
		this.filter = filter;
	}

	public interface SpaceCharFilter {
		public boolean isSpaceChar(int ch);
	}
}

class IOUtils {
	public static Pair<Integer, Integer> readIntPair(InputReader in) {
		int first = in.readInt();
		int second = in.readInt();
		return Pair.makePair(first, second);
	}

	public static Pair<Long, Long> readLongPair(InputReader in) {
		long first = in.readLong();
		long second = in.readLong();
		return Pair.makePair(first, second);
	}

	public static int[] readIntArray(InputReader in, int size) {
		int[] array = new int[size];
		for (int i = 0; i < size; i++)
			array[i] = in.readInt();
		return array;
	}

	public static long[] readLongArray(InputReader in, int size) {
		long[] array = new long[size];
		for (int i = 0; i < size; i++)
			array[i] = in.readLong();
		return array;
	}

	public static double[] readDoubleArray(InputReader in, int size) {
		double[] array = new double[size];
		for (int i = 0; i < size; i++)
			array[i] = in.readDouble();
		return array;
	}

	public static String[] readStringArray(InputReader in, int size) {
		String[] array = new String[size];
		for (int i = 0; i < size; i++)
			array[i] = in.readString();
		return array;
	}

	public static char[] readCharArray(InputReader in, int size) {
		char[] array = new char[size];
		for (int i = 0; i < size; i++)
			array[i] = in.readCharacter();
		return array;
	}

	public static Pair<Integer, Integer>[] readIntPairArray(InputReader in,
			int size) {
		@SuppressWarnings({ "unchecked" })
		Pair<Integer, Integer>[] result = new Pair[size];
		for (int i = 0; i < size; i++)
			result[i] = readIntPair(in);
		return result;
	}

	public static Pair<Long, Long>[] readLongPairArray(InputReader in, int size) {
		@SuppressWarnings({ "unchecked" })
		Pair<Long, Long>[] result = new Pair[size];
		for (int i = 0; i < size; i++)
			result[i] = readLongPair(in);
		return result;
	}

	public static void readIntArrays(InputReader in, int[]... arrays) {
		for (int i = 0; i < arrays[0].length; i++) {
			for (int j = 0; j < arrays.length; j++)
				arrays[j][i] = in.readInt();
		}
	}

	public static void readLongArrays(InputReader in, long[]... arrays) {
		for (int i = 0; i < arrays[0].length; i++) {
			for (int j = 0; j < arrays.length; j++)
				arrays[j][i] = in.readLong();
		}
	}

	public static void readDoubleArrays(InputReader in, double[]... arrays) {
		for (int i = 0; i < arrays[0].length; i++) {
			for (int j = 0; j < arrays.length; j++)
				arrays[j][i] = in.readDouble();
		}
	}

	public static char[][] readTable(InputReader in, int rowCount,
			int columnCount) {
		char[][] table = new char[rowCount][];
		for (int i = 0; i < rowCount; i++)
			table[i] = readCharArray(in, columnCount);
		return table;
	}

	public static int[][] readIntTable(InputReader in, int rowCount,
			int columnCount) {
		int[][] table = new int[rowCount][];
		for (int i = 0; i < rowCount; i++)
			table[i] = readIntArray(in, columnCount);
		return table;
	}

	public static double[][] readDoubleTable(InputReader in, int rowCount,
			int columnCount) {
		double[][] table = new double[rowCount][];
		for (int i = 0; i < rowCount; i++)
			table[i] = readDoubleArray(in, columnCount);
		return table;
	}

	public static long[][] readLongTable(InputReader in, int rowCount,
			int columnCount) {
		long[][] table = new long[rowCount][];
		for (int i = 0; i < rowCount; i++)
			table[i] = readLongArray(in, columnCount);
		return table;
	}

	public static String[][] readStringTable(InputReader in, int rowCount,
			int columnCount) {
		String[][] table = new String[rowCount][];
		for (int i = 0; i < rowCount; i++)
			table[i] = readStringArray(in, columnCount);
		return table;
	}

	public static String readText(InputReader in) {
		StringBuilder result = new StringBuilder();
		while (true) {
			int character = in.read();
			if (character == '\r')
				continue;
			if (character == -1)
				break;
			result.append((char) character);
		}
		return result.toString();
	}

	public static void readStringArrays(InputReader in, String[]... arrays) {
		for (int i = 0; i < arrays[0].length; i++) {
			for (int j = 0; j < arrays.length; j++)
				arrays[j][i] = in.readString();
		}
	}

	public static void printTable(OutputWriter out, char[][] table) {
		for (char[] row : table)
			out.printLine(new String(row));
	}
}

class ArrayUtils {
	private static int[] tempInt = new int[0];
	private static long[] tempLong = new long[0];

	public static Integer[] generateOrder(int size) {
		Integer[] order = new Integer[size];
		for (int i = 0; i < size; i++)
			order[i] = i;
		return order;
	}

	public static void fill(short[][] array, short value) {
		for (short[] row : array)
			Arrays.fill(row, value);
	}

	public static void fill(long[][] array, long value) {
		for (long[] row : array)
			Arrays.fill(row, value);
	}

	public static void fill(double[][] array, double value) {
		for (double[] row : array)
			Arrays.fill(row, value);
	}

	public static void fill(double[][][] array, double value) {
		for (double[][] row : array)
			fill(row, value);
	}

	public static void fill(double[][][][] array, double value) {
		for (double[][][] row : array)
			fill(row, value);
	}

	public static void fill(double[][][][][] array, double value) {
		for (double[][][][] row : array)
			fill(row, value);
	}

	public static void fill(long[][][] array, long value) {
		for (long[][] row : array)
			fill(row, value);
	}

	public static void fill(long[][][][] array, long value) {
		for (long[][][] row : array)
			fill(row, value);
	}

	public static void fill(long[][][][][] array, long value) {
		for (long[][][][] row : array)
			fill(row, value);
	}

	public static void fillColumn(long[][] array, int index, long value) {
		for (long[] row : array)
			row[index] = value;
	}

	public static void fillColumn(int[][] array, int index, int value) {
		for (int[] row : array)
			row[index] = value;
	}

	public static void fill(int[][] array, int value) {
		for (int[] row : array)
			Arrays.fill(row, value);
	}

	public static void fill(boolean[][] array, boolean value) {
		for (boolean[] row : array)
			Arrays.fill(row, value);
	}

	public static void fill(boolean[][][] array, boolean value) {
		for (boolean[][] row : array)
			fill(row, value);
	}

	public static long sumArray(int[] array) {
		long result = 0;
		for (int element : array)
			result += element;
		return result;
	}

	public static int[] range(int from, int to) {
		int[] result = new int[Math.max(from, to) - Math.min(from, to) + 1];
		int index = 0;
		if (to > from) {
			for (int i = from; i <= to; i++)
				result[index++] = i;
		} else {
			for (int i = from; i >= to; i--)
				result[index++] = i;
		}
		return result;
	}

	public static void fill(int[][][] array, int value) {
		for (int[][] subArray : array)
			fill(subArray, value);
	}

	public static void fill(short[][][] array, short value) {
		for (short[][] subArray : array)
			fill(subArray, value);
	}

	public static void fill(int[][][][] array, int value) {
		for (int[][][] subArray : array)
			fill(subArray, value);
	}

	public static void fill(short[][][][] array, short value) {
		for (short[][][] subArray : array)
			fill(subArray, value);
	}

	public static void fill(int[][][][][] array, int value) {
		for (int[][][][] subArray : array)
			fill(subArray, value);
	}

	public static void fill(short[][][][][] array, short value) {
		for (short[][][][] subArray : array)
			fill(subArray, value);
	}

	public static void fill(int[][][][][][] array, int value) {
		for (int[][][][][] subArray : array)
			fill(subArray, value);
	}

	public static void fill(short[][][][][][] array, short value) {
		for (short[][][][][] subArray : array)
			fill(subArray, value);
	}

	public static void fill(int[][][][][][][] array, int value) {
		for (int[][][][][][] subArray : array)
			fill(subArray, value);
	}

	public static void fill(short[][][][][][][] array, short value) {
		for (short[][][][][][] subArray : array)
			fill(subArray, value);
	}

	public static Integer[] order(int size, Comparator<Integer> comparator) {
		Integer[] order = generateOrder(size);
		Arrays.sort(order, comparator);
		return order;
	}

	public static <T> void fill(T[][] array, T value) {
		for (T[] row : array)
			Arrays.fill(row, value);
	}

	public static void fill(char[][] array, char value) {
		for (char[] row : array)
			Arrays.fill(row, value);
	}

	public static void fill(byte[][] array, byte value) {
		for (byte[] row : array)
			Arrays.fill(row, value);
	}

	public static void fill(byte[][][] array, byte value) {
		for (byte[][] row : array)
			fill(row, value);
	}

	public static void fill(byte[][][][] array, byte value) {
		for (byte[][][] row : array)
			fill(row, value);
	}

	public static long multiply(int[] first, int[] second) {
		long result = 0;
		for (int i = 0; i < first.length; i++)
			result += (long) first[i] * second[i];
		return result;
	}

	public static int[] createOrder(int size) {
		int[] order = new int[size];
		for (int i = 0; i < size; i++)
			order[i] = i;
		return order;
	}

	public static int[] sort(int[] array, IntComparator comparator) {
		return sort(array, 0, array.length, comparator);
	}

	public static int[] sort(int[] array, int from, int to,
			IntComparator comparator) {
		Integer[] intArray = new Integer[to - from];
		for (int i = from; i < to; i++)
			intArray[i - from] = array[i];
		Arrays.sort(intArray, comparator);
		for (int i = from; i < to; i++)
			array[i] = intArray[i - from];
		return array;
	}

	private static void ensureCapacityInt(int size) {
		if (tempInt.length >= size)
			return;
		size = Math.max(size, tempInt.length << 1);
		tempInt = new int[size];
	}

	private static void ensureCapacityLong(int size) {
		if (tempLong.length >= size)
			return;
		size = Math.max(size, tempLong.length << 1);
		tempLong = new long[size];
	}

	private static void sortImpl(int[] array, int from, int to, int[] temp,
			int fromTemp, int toTemp, IntComparator comparator) {
		if (to - from <= 1)
			return;
		int middle = (to - from) >> 1;
		int tempMiddle = fromTemp + middle;
		sortImpl(temp, fromTemp, tempMiddle, array, from, from + middle,
				comparator);
		sortImpl(temp, tempMiddle, toTemp, array, from + middle, to, comparator);
		int index = from;
		int index1 = fromTemp;
		int index2 = tempMiddle;
		while (index1 < tempMiddle && index2 < toTemp) {
			if (comparator.compare(temp[index1], temp[index2]) <= 0)
				array[index++] = temp[index1++];
			else
				array[index++] = temp[index2++];
		}
		if (index1 != tempMiddle)
			System.arraycopy(temp, index1, array, index, tempMiddle - index1);
		if (index2 != toTemp)
			System.arraycopy(temp, index2, array, index, toTemp - index2);
	}

	public static int[] order(final int[] array) {
		return sort(createOrder(array.length), new IntComparator() {
			public int compare(Integer first, Integer second) {
				if (array[first] < array[second])
					return -1;
				if (array[first] > array[second])
					return 1;
				return 0;
			}
		});
	}

	public static int[] order(final long[] array) {
		return sort(createOrder(array.length), new IntComparator() {
			public int compare(Integer first, Integer second) {
				if (array[first] < array[second])
					return -1;
				if (array[first] > array[second])
					return 1;
				return 0;
			}
		});
	}

	public static int[] unique(int[] array) {
		return unique(array, 0, array.length);
	}

	public static int[] unique(int[] array, int from, int to) {
		if (from == to)
			return new int[0];
		int count = 1;
		for (int i = from + 1; i < to; i++) {
			if (array[i] != array[i - 1])
				count++;
		}
		int[] result = new int[count];
		result[0] = array[from];
		int index = 1;
		for (int i = from + 1; i < to; i++) {
			if (array[i] != array[i - 1])
				result[index++] = array[i];
		}
		return result;
	}

	public static char[] unique(char[] array) {
		return unique(array, 0, array.length);
	}

	public static char[] unique(char[] array, int from, int to) {
		if (from == to)
			return new char[0];
		int count = 1;
		for (int i = from + 1; i < to; i++) {
			if (array[i] != array[i - 1])
				count++;
		}
		char[] result = new char[count];
		result[0] = array[from];
		int index = 1;
		for (int i = from + 1; i < to; i++) {
			if (array[i] != array[i - 1])
				result[index++] = array[i];
		}
		return result;
	}

	public static int maxElement(int[] array) {
		return maxElement(array, 0, array.length);
	}

	public static int maxElement(int[] array, int from, int to) {
		int result = Integer.MIN_VALUE;
		for (int i = from; i < to; i++)
			result = Math.max(result, array[i]);
		return result;
	}

	public static int[] order(final double[] array) {
		return sort(createOrder(array.length), new IntComparator() {
			public int compare(Integer first, Integer second) {
				return Double.compare(array[first], array[second]);
			}
		});
	}

	public static int[] reversePermutation(int[] permutation) {
		int[] result = new int[permutation.length];
		for (int i = 0; i < permutation.length; i++)
			result[permutation[i]] = i;
		return result;
	}

	public static void reverse(int[] array) {
		for (int i = 0, j = array.length - 1; i < j; i++, j--) {
			int temp = array[i];
			array[i] = array[j];
			array[j] = temp;
		}
	}

	public static void reverse(char[] array) {
		for (int i = 0, j = array.length - 1; i < j; i++, j--) {
			char temp = array[i];
			array[i] = array[j];
			array[j] = temp;
		}
	}

	private static long maxElement(long[] array, int from, int to) {
		long result = Long.MIN_VALUE;
		for (int i = from; i < to; i++)
			result = Math.max(result, array[i]);
		return result;
	}

	public static int minPosition(int[] array) {
		return minPosition(array, 0, array.length);
	}

	public static int maxPosition(int[] array) {
		return maxPosition(array, 0, array.length);
	}

	public static int minPosition(int[] array, int from, int to) {
		if (from >= to)
			return -1;
		int min = array[from];
		int result = from;
		for (int i = from + 1; i < to; i++) {
			if (array[i] < min) {
				min = array[i];
				result = i;
			}
		}
		return result;
	}

	public static int maxPosition(int[] array, int from, int to) {
		if (from >= to)
			return -1;
		int max = array[from];
		int result = from;
		for (int i = from + 1; i < to; i++) {
			if (array[i] > max) {
				max = array[i];
				result = i;
			}
		}
		return result;
	}

	public static int[] multiplyPermutations(int[] first, int[] second) {
		int count = first.length;
		int[] result = new int[count];
		for (int i = 0; i < count; i++) {
			result[i] = first[second[i]];
		}
		return result;
	}

	public static int[] compress(int[]... arrays) {
		int totalLength = 0;
		for (int[] array : arrays)
			totalLength += array.length;
		int[] all = new int[totalLength];
		int delta = 0;
		for (int[] array : arrays) {
			System.arraycopy(array, 0, all, delta, array.length);
			delta += array.length;
		}
		sort(all, IntComparator.DEFAULT);
		all = unique(all);
		for (int[] array : arrays) {
			for (int i = 0; i < array.length; i++)
				array[i] = Arrays.binarySearch(all, array[i]);
		}
		return all;
	}

	public static int minElement(int[] array) {
		return array[minPosition(array)];
	}

	public static long[] partialSums(int[] array) {
		long[] result = new long[array.length + 1];
		for (int i = 0; i < array.length; i++)
			result[i + 1] = result[i] + array[i];
		return result;
	}

	public static void orderBy(int[] base, int[]... arrays) {
		int[] order = ArrayUtils.order(base);
		order(order, base);
		for (int[] array : arrays)
			order(order, array);
	}

	public static void orderBy(long[] base, long[]... arrays) {
		int[] order = ArrayUtils.order(base);
		order(order, base);
		for (long[] array : arrays)
			order(order, array);
	}

	public static void order(int[] order, int[] array) {
		ensureCapacityInt(order.length);
		for (int i = 0; i < order.length; i++)
			tempInt[i] = array[order[i]];
		System.arraycopy(tempInt, 0, array, 0, array.length);
	}

	public static void order(int[] order, long[] array) {
		ensureCapacityLong(order.length);
		for (int i = 0; i < order.length; i++)
			tempLong[i] = array[order[i]];
		System.arraycopy(tempLong, 0, array, 0, array.length);
	}

	public static long[] asLong(int[] array) {
		long[] result = new long[array.length];
		for (int i = 0; i < array.length; i++)
			result[i] = array[i];
		return result;
	}

	public static int count(int[] array, int value) {
		int result = 0;
		for (int i : array) {
			if (i == value)
				result++;
		}
		return result;
	}

	public static int count(char[] array, char value) {
		int result = 0;
		for (char i : array) {
			if (i == value)
				result++;
		}
		return result;
	}

	public static int count(boolean[] array, boolean value) {
		int result = 0;
		for (boolean i : array) {
			if (i == value)
				result++;
		}
		return result;
	}

	public static int[] merge(int[] first, int[] second) {
		int[] result = new int[first.length + second.length];
		int firstIndex = 0;
		int secondIndex = 0;
		int index = 0;
		while (firstIndex < first.length && secondIndex < second.length) {
			if (first[firstIndex] < second[secondIndex])
				result[index++] = first[firstIndex++];
			else
				result[index++] = second[secondIndex++];
		}
		System.arraycopy(first, firstIndex, result, index, first.length
				- firstIndex);
		System.arraycopy(second, secondIndex, result, index, second.length
				- secondIndex);
		return result;
	}

	public static boolean nextPermutation(int[] array) {
		return nextPermutation(array, IntComparator.DEFAULT);
	}

	private static boolean nextPermutation(int[] array, IntComparator comparator) {
		int size = array.length;
		int last = array[size - 1];
		for (int i = size - 2; i >= 0; i--) {
			int current = array[i];
			if (comparator.compare(last, current) > 0) {
				for (int j = size - 1; j > i; j--) {
					if (comparator.compare(array[j], current) > 0) {
						swap(array, i, j);
						inPlaceReverse(array, i + 1, size);
						return true;
					}
				}
			}
			last = current;
		}
		return false;
	}

	private static void inPlaceReverse(int[] array, int first, int second) {
		for (int i = first, j = second - 1; i < j; i++, j--)
			swap(array, i, j);
	}

	private static void swap(int[] array, int first, int second) {
		if (first == second)
			return;
		int temp = array[first];
		array[first] = array[second];
		array[second] = temp;
	}

	public static <V> void reverse(V[] array) {
		for (int i = 0, j = array.length - 1; i < j; i++, j--) {
			V temp = array[i];
			array[i] = array[j];
			array[j] = temp;
		}
	}

	public static IntComparator compareBy(final int[]... arrays) {
		return new IntComparator() {
			public int compare(Integer first, Integer second) {
				for (int[] array : arrays) {
					if (array[first] != array[second])
						return Integer.compare(array[first], array[second]);
				}
				return 0;
			}
		};
	}

	public static long minElement(long[] array) {
		return array[minPosition(array)];
	}

	public static long maxElement(long[] array) {
		return array[maxPosition(array)];
	}

	public static int minPosition(long[] array) {
		return minPosition(array, 0, array.length);
	}

	public static int maxPosition(long[] array) {
		return maxPosition(array, 0, array.length);
	}

	public static int minPosition(long[] array, int from, int to) {
		if (from >= to)
			return -1;
		long min = array[from];
		int result = from;
		for (int i = from + 1; i < to; i++) {
			if (array[i] < min) {
				min = array[i];
				result = i;
			}
		}
		return result;
	}

	public static int maxPosition(long[] array, int from, int to) {
		if (from >= to)
			return -1;
		long max = array[from];
		int result = from;
		for (int i = from + 1; i < to; i++) {
			if (array[i] > max) {
				max = array[i];
				result = i;
			}
		}
		return result;
	}

	public static int[] createArray(int count, int value) {
		int[] array = new int[count];
		Arrays.fill(array, value);
		return array;
	}

	public static long[] createArray(int count, long value) {
		long[] array = new long[count];
		Arrays.fill(array, value);
		return array;
	}

	public static double[] createArray(int count, double value) {
		double[] array = new double[count];
		Arrays.fill(array, value);
		return array;
	}

	public static boolean[] createArray(int count, boolean value) {
		boolean[] array = new boolean[count];
		Arrays.fill(array, value);
		return array;
	}

	public static char[] createArray(int count, char value) {
		char[] array = new char[count];
		Arrays.fill(array, value);
		return array;
	}

	public static <T> T[] createArray(int count, T value) {
		@SuppressWarnings("unchecked")
		T[] array = (T[]) Array.newInstance(value.getClass(), count);
		Arrays.fill(array, value);
		return array;
	}
}

class Graph {
	public static final int REMOVED_BIT = 0;

	protected int vertexCount;
	protected int edgeCount;

	private int[] firstOutbound;
	private int[] firstInbound;

	private Edge[] edges;
	private int[] nextInbound;
	private int[] nextOutbound;
	private int[] from;
	private int[] to;
	private long[] weight;
	private long[] capacity;
	private int[] reverseEdge;
	private int[] flags;

	public Graph(int vertexCount) {
		this(vertexCount, vertexCount);
	}

	public Graph(int vertexCount, int edgeCapacity) {
		this.vertexCount = vertexCount;
		firstOutbound = new int[vertexCount];
		Arrays.fill(firstOutbound, -1);

		from = new int[edgeCapacity];
		to = new int[edgeCapacity];
		nextOutbound = new int[edgeCapacity];
		flags = new int[edgeCapacity];
	}

	public static Graph createGraph(int vertexCount, int[] from, int[] to) {
		Graph graph = new Graph(vertexCount, from.length);
		for (int i = 0; i < from.length; i++)
			graph.addSimpleEdge(from[i], to[i]);
		return graph;
	}

	public static Graph createWeightedGraph(int vertexCount, int[] from,
			int[] to, long[] weight) {
		Graph graph = new Graph(vertexCount, from.length);
		for (int i = 0; i < from.length; i++)
			graph.addWeightedEdge(from[i], to[i], weight[i]);
		return graph;
	}

	public static Graph createFlowGraph(int vertexCount, int[] from, int[] to,
			long[] capacity) {
		Graph graph = new Graph(vertexCount, from.length * 2);
		for (int i = 0; i < from.length; i++)
			graph.addFlowEdge(from[i], to[i], capacity[i]);
		return graph;
	}

	public static Graph createFlowWeightedGraph(int vertexCount, int[] from,
			int[] to, long[] weight, long[] capacity) {
		Graph graph = new Graph(vertexCount, from.length * 2);
		for (int i = 0; i < from.length; i++)
			graph.addFlowWeightedEdge(from[i], to[i], weight[i], capacity[i]);
		return graph;
	}

	public static Graph createTree(int[] parent) {
		Graph graph = new Graph(parent.length + 1, parent.length);
		for (int i = 0; i < parent.length; i++)
			graph.addSimpleEdge(parent[i], i + 1);
		return graph;
	}

	public int addEdge(int fromID, int toID, long weight, long capacity,
			int reverseEdge) {
		ensureEdgeCapacity(edgeCount + 1);
		if (firstOutbound[fromID] != -1)
			nextOutbound[edgeCount] = firstOutbound[fromID];
		else
			nextOutbound[edgeCount] = -1;
		firstOutbound[fromID] = edgeCount;
		if (firstInbound != null) {
			if (firstInbound[toID] != -1)
				nextInbound[edgeCount] = firstInbound[toID];
			else
				nextInbound[edgeCount] = -1;
			firstInbound[toID] = edgeCount;
		}
		this.from[edgeCount] = fromID;
		this.to[edgeCount] = toID;
		if (capacity != 0) {
			if (this.capacity == null)
				this.capacity = new long[from.length];
			this.capacity[edgeCount] = capacity;
		}
		if (weight != 0) {
			if (this.weight == null)
				this.weight = new long[from.length];
			this.weight[edgeCount] = weight;
		}
		if (reverseEdge != -1) {
			if (this.reverseEdge == null) {
				this.reverseEdge = new int[from.length];
				Arrays.fill(this.reverseEdge, 0, edgeCount, -1);
			}
			this.reverseEdge[edgeCount] = reverseEdge;
		}
		if (edges != null)
			edges[edgeCount] = createEdge(edgeCount);
		return edgeCount++;
	}

	protected final GraphEdge createEdge(int id) {
		return new GraphEdge(id);
	}

	public final int addFlowWeightedEdge(int from, int to, long weight,
			long capacity) {
		if (capacity == 0) {
			return addEdge(from, to, weight, 0, -1);
		} else {
			int lastEdgeCount = edgeCount;
			addEdge(to, from, -weight, 0, lastEdgeCount + entriesPerEdge());
			return addEdge(from, to, weight, capacity, lastEdgeCount);
		}
	}

	protected int entriesPerEdge() {
		return 1;
	}

	public final int addFlowEdge(int from, int to, long capacity) {
		return addFlowWeightedEdge(from, to, 0, capacity);
	}

	public final int addWeightedEdge(int from, int to, long weight) {
		return addFlowWeightedEdge(from, to, weight, 0);
	}

	public final int addSimpleEdge(int from, int to) {
		return addWeightedEdge(from, to, 0);
	}

	public final int vertexCount() {
		return vertexCount;
	}

	public final int edgeCount() {
		return edgeCount;
	}

	protected final int edgeCapacity() {
		return from.length;
	}

	public final Edge edge(int id) {
		initEdges();
		return edges[id];
	}

	public final int firstOutbound(int vertex) {
		int id = firstOutbound[vertex];
		while (id != -1 && isRemoved(id))
			id = nextOutbound[id];
		return id;
	}

	public final int nextOutbound(int id) {
		id = nextOutbound[id];
		while (id != -1 && isRemoved(id))
			id = nextOutbound[id];
		return id;
	}

	public final int firstInbound(int vertex) {
		initInbound();
		int id = firstInbound[vertex];
		while (id != -1 && isRemoved(id))
			id = nextInbound[id];
		return id;
	}

	public final int nextInbound(int id) {
		initInbound();
		id = nextInbound[id];
		while (id != -1 && isRemoved(id))
			id = nextInbound[id];
		return id;
	}

	public final int source(int id) {
		return from[id];
	}

	public final int destination(int id) {
		return to[id];
	}

	public final long weight(int id) {
		if (weight == null)
			return 0;
		return weight[id];
	}

	public final long capacity(int id) {
		if (capacity == null)
			return 0;
		return capacity[id];
	}

	public final long flow(int id) {
		if (reverseEdge == null)
			return 0;
		return capacity[reverseEdge[id]];
	}

	public final void pushFlow(int id, long flow) {
		if (flow == 0)
			return;
		if (flow > 0) {
			if (capacity(id) < flow)
				throw new IllegalArgumentException("Not enough capacity");
		} else {
			if (flow(id) < -flow)
				throw new IllegalArgumentException("Not enough capacity");
		}
		capacity[id] -= flow;
		capacity[reverseEdge[id]] += flow;
	}

	public int transposed(int id) {
		return -1;
	}

	public final int reverse(int id) {
		if (reverseEdge == null)
			return -1;
		return reverseEdge[id];
	}

	public final void addVertices(int count) {
		ensureVertexCapacity(vertexCount + count);
		Arrays.fill(firstOutbound, vertexCount, vertexCount + count, -1);
		if (firstInbound != null)
			Arrays.fill(firstInbound, vertexCount, vertexCount + count, -1);
		vertexCount += count;
	}

	protected final void initEdges() {
		if (edges == null) {
			edges = new Edge[from.length];
			for (int i = 0; i < edgeCount; i++)
				edges[i] = createEdge(i);
		}
	}

	public final void removeVertex(int vertex) {
		int id = firstOutbound[vertex];
		while (id != -1) {
			removeEdge(id);
			id = nextOutbound[id];
		}
		initInbound();
		id = firstInbound[vertex];
		while (id != -1) {
			removeEdge(id);
			id = nextInbound[id];
		}
	}

	private void initInbound() {
		if (firstInbound == null) {
			firstInbound = new int[firstOutbound.length];
			Arrays.fill(firstInbound, 0, vertexCount, -1);
			nextInbound = new int[from.length];
			for (int i = 0; i < edgeCount; i++) {
				nextInbound[i] = firstInbound[to[i]];
				firstInbound[to[i]] = i;
			}
		}
	}

	public final boolean flag(int id, int bit) {
		return (flags[id] >> bit & 1) != 0;
	}

	public final void setFlag(int id, int bit) {
		flags[id] |= 1 << bit;
	}

	public final void removeFlag(int id, int bit) {
		flags[id] &= -1 - (1 << bit);
	}

	public final void removeEdge(int id) {
		setFlag(id, REMOVED_BIT);
	}

	public final void restoreEdge(int id) {
		removeFlag(id, REMOVED_BIT);
	}

	public final boolean isRemoved(int id) {
		return flag(id, REMOVED_BIT);
	}

	public final Iterable<Edge> outbound(final int id) {
		initEdges();
		return new Iterable<Edge>() {
			public Iterator<Edge> iterator() {
				return new EdgeIterator(id, firstOutbound, nextOutbound);
			}
		};
	}

	public final Iterable<Edge> inbound(final int id) {
		initEdges();
		initInbound();
		return new Iterable<Edge>() {
			public Iterator<Edge> iterator() {
				return new EdgeIterator(id, firstInbound, nextInbound);
			}
		};
	}

	protected void ensureEdgeCapacity(int size) {
		if (from.length < size) {
			int newSize = Math.max(size, 2 * from.length);
			if (edges != null)
				edges = resize(edges, newSize);
			from = resize(from, newSize);
			to = resize(to, newSize);
			nextOutbound = resize(nextOutbound, newSize);
			if (nextInbound != null)
				nextInbound = resize(nextInbound, newSize);
			if (weight != null)
				weight = resize(weight, newSize);
			if (capacity != null)
				capacity = resize(capacity, newSize);
			if (reverseEdge != null)
				reverseEdge = resize(reverseEdge, newSize);
			flags = resize(flags, newSize);
		}
	}

	private void ensureVertexCapacity(int size) {
		if (firstOutbound.length < size) {
			int newSize = Math.max(size, 2 * from.length);
			firstOutbound = resize(firstOutbound, newSize);
			if (firstInbound != null)
				firstInbound = resize(firstInbound, newSize);
		}
	}

	protected final int[] resize(int[] array, int size) {
		int[] newArray = new int[size];
		System.arraycopy(array, 0, newArray, 0, array.length);
		return newArray;
	}

	private long[] resize(long[] array, int size) {
		long[] newArray = new long[size];
		System.arraycopy(array, 0, newArray, 0, array.length);
		return newArray;
	}

	private Edge[] resize(Edge[] array, int size) {
		Edge[] newArray = new Edge[size];
		System.arraycopy(array, 0, newArray, 0, array.length);
		return newArray;
	}

	public final boolean isSparse() {
		return vertexCount == 0 || edgeCount * 20 / vertexCount <= vertexCount;
	}

	protected class GraphEdge implements Edge {
		protected int id;

		protected GraphEdge(int id) {
			this.id = id;
		}

		public int getSource() {
			return source(id);
		}

		public int getDestination() {
			return destination(id);
		}

		public long getWeight() {
			return weight(id);
		}

		public long getCapacity() {
			return capacity(id);
		}

		public long getFlow() {
			return flow(id);
		}

		public void pushFlow(long flow) {
			Graph.this.pushFlow(id, flow);
		}

		public boolean getFlag(int bit) {
			return flag(id, bit);
		}

		public void setFlag(int bit) {
			Graph.this.setFlag(id, bit);
		}

		public void removeFlag(int bit) {
			Graph.this.removeFlag(id, bit);
		}

		public int getTransposedID() {
			return transposed(id);
		}

		public Edge getTransposedEdge() {
			int reverseID = getTransposedID();
			if (reverseID == -1)
				return null;
			initEdges();
			return edge(reverseID);
		}

		public int getReverseID() {
			return reverse(id);
		}

		public Edge getReverseEdge() {
			int reverseID = getReverseID();
			if (reverseID == -1)
				return null;
			initEdges();
			return edge(reverseID);
		}

		public int getID() {
			return id;
		}

		public void remove() {
			removeEdge(id);
		}

		public void restore() {
			restoreEdge(id);
		}
	}

	public class EdgeIterator implements Iterator<Edge> {
		private int edgeID;
		private final int[] next;
		private int lastID = -1;

		public EdgeIterator(int id, int[] first, int[] next) {
			this.next = next;
			edgeID = nextEdge(first[id]);
		}

		private int nextEdge(int id) {
			while (id != -1 && isRemoved(id))
				id = next[id];
			return id;
		}

		public boolean hasNext() {
			return edgeID != -1;
		}

		public Edge next() {
			if (edgeID == -1)
				throw new NoSuchElementException();
			lastID = edgeID;
			edgeID = nextEdge(next[lastID]);
			return edges[lastID];
		}

		public void remove() {
			if (lastID == -1)
				throw new IllegalStateException();
			removeEdge(lastID);
			lastID = -1;
		}
	}

}

class MiscUtils {
	public static final int[] DX4 = { 1, 0, -1, 0 };
	public static final int[] DY4 = { 0, -1, 0, 1 };
	public static final int[] DX8 = { 1, 1, 1, 0, -1, -1, -1, 0 };
	public static final int[] DY8 = { -1, 0, 1, 1, 1, 0, -1, -1 };
	public static final int[] DX_KNIGHT = { 2, 1, -1, -2, -2, -1, 1, 2 };
	public static final int[] DY_KNIGHT = { 1, 2, 2, 1, -1, -2, -2, -1 };

	private static final String[] ROMAN_TOKENS = { "M", "CM", "D", "CD", "C",
			"XC", "L", "XL", "X", "IX", "V", "IV", "I" };
	private static final int[] ROMAN_VALUES = { 1000, 900, 500, 400, 100, 90,
			50, 40, 10, 9, 5, 4, 1 };

	public static long josephProblem(long n, int k) {
		if (n == 1)
			return 0;
		if (k == 1)
			return n - 1;
		if (k > n)
			return (josephProblem(n - 1, k) + k) % n;
		long count = n / k;
		long result = josephProblem(n - count, k);
		result -= n % k;
		if (result < 0)
			result += n;
		else
			result += result / (k - 1);
		return result;
	}

	public static boolean isValidCell(int row, int column, int rowCount,
			int columnCount) {
		return row >= 0 && row < rowCount && column >= 0
				&& column < columnCount;
	}

	public static List<Integer> getPath(int[] last, int destination) {
		List<Integer> path = new ArrayList<Integer>();
		while (destination != -1) {
			path.add(destination);
			destination = last[destination];
		}
		inPlaceReverse(path);
		return path;
	}

	private static void inPlaceReverse(List<Integer> list) {
		for (int i = 0, j = list.size() - 1; i < j; i++, j--)
			swap(list, i, j);
	}

	private static void swap(List<Integer> list, int first, int second) {
		if (first == second)
			return;
		int temp = list.get(first);
		list.set(first, list.get(second));
		list.set(second, temp);
	}

	public static List<Integer> getPath(int[][] lastIndex,
			int[][] lastPathNumber, int destination, int pathNumber) {
		List<Integer> path = new ArrayList<Integer>();
		while (destination != -1 || pathNumber != 0) {
			path.add(destination);
			int nextDestination = lastIndex[destination][pathNumber];
			pathNumber = lastPathNumber[destination][pathNumber];
			destination = nextDestination;
		}
		inPlaceReverse(path);
		return path;
	}

	public static long maximalRectangleSum(long[][] array) {
		int n = array.length;
		int m = array[0].length;
		long[][] partialSums = new long[n + 1][m + 1];
		for (int i = 0; i < n; i++) {
			long rowSum = 0;
			for (int j = 0; j < m; j++) {
				rowSum += array[i][j];
				partialSums[i + 1][j + 1] = partialSums[i][j + 1] + rowSum;
			}
		}
		long result = Long.MIN_VALUE;
		for (int i = 0; i < m; i++) {
			for (int j = i; j < m; j++) {
				long minPartialSum = 0;
				for (int k = 1; k <= n; k++) {
					long current = partialSums[k][j + 1] - partialSums[k][i];
					result = Math.max(result, current - minPartialSum);
					minPartialSum = Math.min(minPartialSum, current);
				}
			}
		}
		return result;
	}

	public static int parseIP(String ip) {
		String[] components = ip.split("[.]");
		int result = 0;
		for (int i = 0; i < 4; i++)
			result += (1 << (24 - 8 * i)) * Integer.parseInt(components[i]);
		return result;
	}

	public static String buildIP(int mask) {
		StringBuilder result = new StringBuilder();
		for (int i = 0; i < 4; i++) {
			if (i != 0)
				result.append('.');
			result.append(mask >> (24 - 8 * i) & 255);
		}
		return result.toString();
	}

	public static long binarySearch(long from, long to,
			Function<Long, Boolean> function) {
		while (from < to) {
			long argument = from + (to - from) / 2;
			if (function.value(argument))
				to = argument;
			else
				from = argument + 1;
		}
		return from;
	}

	public static <T> boolean equals(T first, T second) {
		return first == null && second == null || first != null
				&& first.equals(second);
	}

	public static boolean isVowel(char ch) {
		ch = Character.toUpperCase(ch);
		return ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U'
				|| ch == 'Y';
	}

	public static boolean isStrictVowel(char ch) {
		ch = Character.toUpperCase(ch);
		return ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U';
	}

	public static String convertToRoman(int number) {
		StringBuilder result = new StringBuilder();
		for (int i = 0; i < ROMAN_TOKENS.length; i++) {
			while (number >= ROMAN_VALUES[i]) {
				number -= ROMAN_VALUES[i];
				result.append(ROMAN_TOKENS[i]);
			}
		}
		return result.toString();
	}

	public static int convertFromRoman(String number) {
		int result = 0;
		for (int i = 0; i < ROMAN_TOKENS.length; i++) {
			while (number.startsWith(ROMAN_TOKENS[i])) {
				number = number.substring(ROMAN_TOKENS[i].length());
				result += ROMAN_VALUES[i];
			}
		}
		return result;
	}

	public static int distance(int x1, int y1, int x2, int y2) {
		int dx = x1 - x2;
		int dy = y1 - y2;
		return dx * dx + dy * dy;
	}

	public static <T extends Comparable<T>> T min(T first, T second) {
		if (first.compareTo(second) <= 0)
			return first;
		return second;
	}

	public static <T extends Comparable<T>> T max(T first, T second) {
		if (first.compareTo(second) <= 0)
			return second;
		return first;
	}

	public static void decreaseByOne(int[]... arrays) {
		for (int[] array : arrays) {
			for (int i = 0; i < array.length; i++)
				array[i]--;
		}
	}

	public static int[] getIntArray(String s) {
		String[] tokens = s.split(" ");
		int[] result = new int[tokens.length];
		for (int i = 0; i < result.length; i++)
			result[i] = Integer.parseInt(tokens[i]);
		return result;
	}
}

class IntegerUtils {
	public static long gcd(long a, long b) {
		a = Math.abs(a);
		b = Math.abs(b);
		while (b != 0) {
			long temp = a % b;
			a = b;
			b = temp;
		}
		return a;
	}

	public static int gcd(int a, int b) {
		a = Math.abs(a);
		b = Math.abs(b);
		while (b != 0) {
			int temp = a % b;
			a = b;
			b = temp;
		}
		return a;
	}

	public static int[] generatePrimes(int upTo) {
		int[] isPrime = generateBitPrimalityTable(upTo);
		List<Integer> primes = new ArrayList<Integer>();
		for (int i = 0; i < upTo; i++) {
			if ((isPrime[i >> 5] >>> (i & 31) & 1) == 1)
				primes.add(i);
		}
		int[] array = new int[primes.size()];
		for (int i = 0; i < array.length; i++)
			array[i] = primes.get(i);
		return array;
	}

	public static boolean[] generatePrimalityTable(int upTo) {
		boolean[] isPrime = new boolean[upTo];
		if (upTo < 2)
			return isPrime;
		Arrays.fill(isPrime, true);
		isPrime[0] = isPrime[1] = false;
		for (int i = 2; i * i < upTo; i++) {
			if (isPrime[i]) {
				for (int j = i * i; j < upTo; j += i)
					isPrime[j] = false;
			}
		}
		return isPrime;
	}

	public static int[] generateBitPrimalityTable(int upTo) {
		int[] isPrime = new int[(upTo + 31) >> 5];
		if (upTo < 2)
			return isPrime;
		Arrays.fill(isPrime, -1);
		isPrime[0] &= -4;
		for (int i = 2; i * i < upTo; i++) {
			if ((isPrime[i >> 5] >>> (i & 31) & 1) == 1) {
				for (int j = i * i; j < upTo; j += i)
					isPrime[j >> 5] &= -1 - (1 << (j & 31));
			}
		}
		return isPrime;
	}

	public static int[] generateDivisorTable(int upTo) {
		int[] divisor = new int[upTo];
		for (int i = 1; i < upTo; i++)
			divisor[i] = i;
		for (int i = 2; i * i < upTo; i++) {
			if (divisor[i] == i) {
				for (int j = i * i; j < upTo; j += i)
					divisor[j] = i;
			}
		}
		return divisor;
	}

	public static long powerInFactorial(long n, long p) {
		long result = 0;
		while (n != 0) {
			result += n /= p;
		}
		return result;
	}

	public static int sumDigits(CharSequence number) {
		int result = 0;
		for (int i = number.length() - 1; i >= 0; i--)
			result += digitValue(number.charAt(i));
		return result;
	}

	public static int digitValue(char digit) {
		if (Character.isDigit(digit))
			return digit - '0';
		if (Character.isUpperCase(digit))
			return digit + 10 - 'A';
		return digit + 10 - 'a';
	}

	public static int longCompare(long a, long b) {
		if (a < b)
			return -1;
		if (a > b)
			return 1;
		return 0;
	}

	public static long[][] generateBinomialCoefficients(int n) {
		long[][] result = new long[n + 1][n + 1];
		for (int i = 0; i <= n; i++) {
			result[i][0] = 1;
			for (int j = 1; j <= i; j++)
				result[i][j] = result[i - 1][j - 1] + result[i - 1][j];
		}
		return result;
	}

	public static long[][] generateBinomialCoefficients(int n, long module) {
		long[][] result = new long[n + 1][n + 1];
		if (module == 1)
			return result;
		for (int i = 0; i <= n; i++) {
			result[i][0] = 1;
			for (int j = 1; j <= i; j++) {
				result[i][j] = result[i - 1][j - 1] + result[i - 1][j];
				if (result[i][j] >= module)
					result[i][j] -= module;
			}
		}
		return result;
	}

	public static long[] generateBinomialRow(int n, long module) {
		long[] result = generateReverse(n + 1, module);
		result[0] = 1;
		for (int i = 1; i <= n; i++)
			result[i] = result[i - 1] * (n - i + 1) % module * result[i]
					% module;
		return result;
	}

	public static int[] representationInBase(long number, int base) {
		long basePower = base;
		int exponent = 1;
		while (number >= basePower) {
			basePower *= base;
			exponent++;
		}
		int[] representation = new int[exponent];
		for (int i = 0; i < exponent; i++) {
			basePower /= base;
			representation[i] = (int) (number / basePower);
			number %= basePower;
		}
		return representation;
	}

	public static int trueDivide(int a, int b) {
		return (a - trueMod(a, b)) / b;
	}

	public static long trueDivide(long a, long b) {
		return (a - trueMod(a, b)) / b;
	}

	public static int trueMod(int a, int b) {
		a %= b;
		a += b;
		a %= b;
		return a;
	}

	public static long trueMod(long a, long b) {
		a %= b;
		a += b;
		a %= b;
		return a;
	}

	public static long factorial(int n) {
		long result = 1;
		for (int i = 2; i <= n; i++)
			result *= i;
		return result;
	}

	public static long factorial(int n, long mod) {
		long result = 1;
		for (int i = 2; i <= n; i++)
			result = result * i % mod;
		return result % mod;
	}

	public static List<Pair<Long, Integer>> factorize(long number) {
		List<Pair<Long, Integer>> result = new ArrayList<Pair<Long, Integer>>();
		for (long i = 2; i * i <= number; i++) {
			if (number % i == 0) {
				int power = 0;
				do {
					power++;
					number /= i;
				} while (number % i == 0);
				result.add(Pair.makePair(i, power));
			}
		}
		if (number != 1)
			result.add(Pair.makePair(number, 1));
		return result;
	}

	public static List<Long> getDivisors(long number) {
		List<Pair<Long, Integer>> primeDivisors = factorize(number);
		return getDivisorsImpl(primeDivisors, 0, 1, new ArrayList<Long>());
	}

	private static List<Long> getDivisorsImpl(
			List<Pair<Long, Integer>> primeDivisors, int index, long current,
			List<Long> result) {
		if (index == primeDivisors.size()) {
			result.add(current);
			return result;
		}
		long p = primeDivisors.get(index).first;
		int power = primeDivisors.get(index).second;
		for (int i = 0; i <= power; i++) {
			getDivisorsImpl(primeDivisors, index + 1, current, result);
			current *= p;
		}
		return result;
	}

	public static long power(long base, long exponent) {
		if (exponent == 0)
			return 1;
		long result = power(base, exponent >> 1);
		result = result * result;
		if ((exponent & 1) != 0)
			result = result * base;
		return result;
	}

	public static long power(long base, long exponent, long mod) {
		if (base >= mod)
			base %= mod;
		if (exponent == 0)
			return 1 % mod;
		long result = power(base, exponent >> 1, mod);
		result = result * result % mod;
		if ((exponent & 1) != 0)
			result = result * base % mod;
		return result;
	}

	public static long lcm(long a, long b) {
		return a / gcd(a, b) * b;
	}

	public static long[] generateFibonacci(long upTo) {
		int count = 0;
		long last = 0;
		long current = 1;
		while (current <= upTo) {
			long next = last + current;
			last = current;
			current = next;
			count++;
		}
		return generateFibonacci(count, -1);
	}

	public static long[] generateFibonacci(int count, long module) {
		long[] result = new long[count];
		if (module == -1) {
			if (count != 0)
				result[0] = 1;
			if (count > 1)
				result[1] = 1;
			for (int i = 2; i < count; i++)
				result[i] = result[i - 1] + result[i - 2];
		} else {
			if (count != 0)
				result[0] = 1 % module;
			if (count > 1)
				result[1] = 1 % module;
			for (int i = 2; i < count; i++)
				result[i] = (result[i - 1] + result[i - 2]) % module;
		}
		return result;
	}

	public static long[] generateHappy(int digits) {
		long[] happy = new long[(1 << (digits + 1)) - 2];
		happy[0] = 4;
		happy[1] = 7;
		int first = 0;
		int last = 2;
		for (int i = 2; i <= digits; i++) {
			for (int j = 0; j < last - first; j++) {
				happy[last + 2 * j] = 10 * happy[first + j] + 4;
				happy[last + 2 * j + 1] = 10 * happy[first + j] + 7;
			}
			int next = last + 2 * (last - first);
			first = last;
			last = next;
		}
		return happy;
	}

	public static long[] generateFactorial(int count, long module) {
		long[] result = new long[count];
		if (module == -1) {
			if (count != 0)
				result[0] = 1;
			for (int i = 1; i < count; i++)
				result[i] = result[i - 1] * i;
		} else {
			if (count != 0)
				result[0] = 1 % module;
			for (int i = 1; i < count; i++)
				result[i] = (result[i - 1] * i) % module;
		}
		return result;
	}

	public static long reverse(long number, long module) {
		return power(number, module - 2, module);
	}

	public static boolean isPrime(long number) {
		if (number < 2)
			return false;
		for (long i = 2; i * i <= number; i++) {
			if (number % i == 0)
				return false;
		}
		return true;
	}

	public static long[] generateReverse(int upTo, long module) {
		long[] result = new long[upTo];
		if (upTo > 1)
			result[1] = 1;
		for (int i = 2; i < upTo; i++)
			result[i] = (module - module / i * result[((int) (module % i))]
					% module)
					% module;
		return result;
	}

	public static long[] generateReverseFactorials(int upTo, long module) {
		long[] result = generateReverse(upTo, module);
		if (upTo > 0)
			result[0] = 1;
		for (int i = 1; i < upTo; i++)
			result[i] = result[i] * result[i - 1] % module;
		return result;
	}

	public static long[] generatePowers(long base, int count, long mod) {
		long[] result = new long[count];
		if (count != 0)
			result[0] = 1 % mod;
		for (int i = 1; i < count; i++)
			result[i] = result[i - 1] * base % mod;
		return result;
	}

	public static long nextPrime(long from) {
		if (from <= 2)
			return 2;
		from += 1 - (from & 1);
		while (!isPrime(from))
			from += 2;
		return from;
	}

	public static long binomialCoefficient(int n, int m, long mod) {
		if (m < 0 || m > n)
			return 0;
		if (2 * m > n)
			m = n - m;
		long result = 1;
		for (int i = n - m + 1; i <= n; i++)
			result = result * i % mod;
		return result
				* BigInteger.valueOf(factorial(m, mod))
						.modInverse(BigInteger.valueOf(mod)).longValue() % mod;
	}

	public static boolean isSquare(long number) {
		long sqrt = Math.round(Math.sqrt(number));
		return sqrt * sqrt == number;
	}

	public static long findCommon(long aRemainder, long aMod, long bRemainder,
			long bMod) {
		long modGCD = gcd(aMod, bMod);
		long gcdRemainder = aRemainder % modGCD;
		if (gcdRemainder != bRemainder % modGCD)
			return -1;
		aMod /= modGCD;
		aRemainder /= modGCD;
		bMod /= modGCD;
		bRemainder /= modGCD;
		long aReverse = BigInteger.valueOf(aMod)
				.modInverse(BigInteger.valueOf(bMod)).longValue();
		long bReverse = BigInteger.valueOf(bMod)
				.modInverse(BigInteger.valueOf(aMod)).longValue();
		long mod = aMod * bMod;
		return (bReverse * aRemainder % mod * bMod + aReverse * bRemainder
				% mod * aMod)
				% mod * modGCD + gcdRemainder;
	}

	public static long[] generatePowers(long base, long maxValue) {
		if (maxValue <= 0)
			return new long[0];
		int size = 1;
		long current = 1;
		while (maxValue / base >= current) {
			current *= base;
			size++;
		}
		return generatePowers(base, size, Long.MAX_VALUE);
	}
}

interface IntComparator extends Comparator<Integer> {
	public static final IntComparator DEFAULT = new IntComparator() {
		public int compare(Integer first, Integer second) {
			if (first < second)
				return -1;
			if (first > second)
				return 1;
			return 0;
		}
	};

	public static final IntComparator REVERSE = new IntComparator() {
		public int compare(Integer first, Integer second) {
			if (first < second)
				return 1;
			if (first > second)
				return -1;
			return 0;
		}
	};

	public int compare(Integer first, Integer second);
}

class BidirectionalGraph extends Graph {
	public int[] transposedEdge;

	public BidirectionalGraph(int vertexCount) {
		this(vertexCount, vertexCount);
	}

	public BidirectionalGraph(int vertexCount, int edgeCapacity) {
		super(vertexCount, 2 * edgeCapacity);
		transposedEdge = new int[2 * edgeCapacity];
	}

	public static BidirectionalGraph createGraph(int vertexCount, int[] from,
			int[] to) {
		BidirectionalGraph graph = new BidirectionalGraph(vertexCount,
				from.length);
		for (int i = 0; i < from.length; i++)
			graph.addSimpleEdge(from[i], to[i]);
		return graph;
	}

	public static BidirectionalGraph createWeightedGraph(int vertexCount,
			int[] from, int[] to, long[] weight) {
		BidirectionalGraph graph = new BidirectionalGraph(vertexCount,
				from.length);
		for (int i = 0; i < from.length; i++)
			graph.addWeightedEdge(from[i], to[i], weight[i]);
		return graph;
	}

	public static BidirectionalGraph createFlowGraph(int vertexCount,
			int[] from, int[] to, long[] capacity) {
		BidirectionalGraph graph = new BidirectionalGraph(vertexCount,
				from.length * 2);
		for (int i = 0; i < from.length; i++)
			graph.addFlowEdge(from[i], to[i], capacity[i]);
		return graph;
	}

	public static BidirectionalGraph createFlowWeightedGraph(int vertexCount,
			int[] from, int[] to, long[] weight, long[] capacity) {
		BidirectionalGraph graph = new BidirectionalGraph(vertexCount,
				from.length * 2);
		for (int i = 0; i < from.length; i++)
			graph.addFlowWeightedEdge(from[i], to[i], weight[i], capacity[i]);
		return graph;
	}

	@Override
	public int addEdge(int fromID, int toID, long weight, long capacity,
			int reverseEdge) {
		int lastEdgeCount = edgeCount;
		super.addEdge(fromID, toID, weight, capacity, reverseEdge);
		super.addEdge(toID, fromID, weight, capacity, reverseEdge == -1 ? -1
				: reverseEdge + 1);
		this.transposedEdge[lastEdgeCount] = lastEdgeCount + 1;
		this.transposedEdge[lastEdgeCount + 1] = lastEdgeCount;
		return lastEdgeCount;
	}

	@Override
	protected int entriesPerEdge() {
		return 2;
	}

	@Override
	public final int transposed(int id) {
		return transposedEdge[id];
	}

	@Override
	protected void ensureEdgeCapacity(int size) {
		if (size > edgeCapacity()) {
			super.ensureEdgeCapacity(size);
			transposedEdge = resize(transposedEdge, edgeCapacity());
		}
	}
}

class Pair<U, V> implements Comparable<Pair<U, V>> {
	public final U first;
	public final V second;

	public static <U, V> Pair<U, V> makePair(U first, V second) {
		return new Pair<U, V>(first, second);
	}

	private Pair(U first, V second) {
		this.first = first;
		this.second = second;
	}

	@Override
	public boolean equals(Object o) {
		if (this == o)
			return true;
		if (o == null || getClass() != o.getClass())
			return false;

		Pair pair = (Pair) o;

		return !(first != null ? !first.equals(pair.first) : pair.first != null)
				&& !(second != null ? !second.equals(pair.second)
						: pair.second != null);

	}

	@Override
	public int hashCode() {
		int result = first != null ? first.hashCode() : 0;
		result = 31 * result + (second != null ? second.hashCode() : 0);
		return result;
	}

	public Pair<V, U> swap() {
		return makePair(second, first);
	}

	@Override
	public String toString() {
		return "(" + first + "," + second + ")";
	}

	@SuppressWarnings({ "unchecked" })
	public int compareTo(Pair<U, V> o) {
		int value = ((Comparable<U>) first).compareTo(o.first);
		if (value != 0)
			return value;
		return ((Comparable<V>) second).compareTo(o.second);
	}
}

interface Edge {
	public int getSource();

	public int getDestination();

	public long getWeight();

	public long getCapacity();

	public long getFlow();

	public void pushFlow(long flow);

	public boolean getFlag(int bit);

	public void setFlag(int bit);

	public void removeFlag(int bit);

	public int getTransposedID();

	public Edge getTransposedEdge();

	public int getReverseID();

	public Edge getReverseEdge();

	public int getID();

	public void remove();

	public void restore();
}

interface Function<A, V> {
	public abstract V value(A argument);
}package OldAttemptLearning.pimponuser;

import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        Task solver = new Task();
        solver.solve(1, in, out);
        out.close();
    }
}

class Task {

    Map<String, List<Integer>> pos;

    public void solve(int testNumber, InputReader in, OutputWriter out) {
        String S = in.readString();
        pos = new HashMap<String, List<Integer>>();
        Map<Pair<String, String>, Integer> map = new HashMap<Pair<String,String>,Integer>();
        for (int i = 0; i < S.length(); i++) {
            StringBuilder aux = new StringBuilder();
            for (int j = 0; j < 4 && i + j < S.length(); j++) {
                aux.append(S.charAt(i + j));
                String str = aux.toString();
                get(str).add(i);
            }
        }
        int q = in.readInt();
        boolean flag=S.length()>100 && S.substring(0, 5).equals("qrjat"); 
        while (q-- > 0) {
            String A = in.readString(), B = in.readString();
            if (A.compareTo(B)>0) {
                String aux=A;
                A=B;
                B=aux;
            }
            Pair<String, String> pair = Pair.makePair(A, B);
            if (map.containsKey(pair)) {
                out.printLine(map.get(pair));
                continue;
            }
            List<Integer> listA = get(A), listB = get(B);
            int ret = Integer.MAX_VALUE, sizeA = listA.size(), sizeB = listB
                    .size(), lengthA=A.length(), lengthB=B.length();
            for (int i=0, j=0; i<sizeA && j<sizeB; ) {
                int a=listA.get(i), b=listB.get(j);
                ret=Math.min(ret, Math.max(a+lengthA, b+lengthB)-Math.min(a, b));
                if (a<b) i++;
                else j++;
            }
            if (ret==Integer.MAX_VALUE)ret=-1; 
            map.put(pair, ret);
            out.printLine(ret);
        }
    }

    List<Integer> get(String str) {
        if (!pos.containsKey(str))
            pos.put(str, new ArrayList<Integer>());
        return pos.get(str);
    }
}

class Graph {
    public static final int REMOVED_BIT = 0;

    protected int vertexCount;
    protected int edgeCount;

    private int[] firstOutbound;
    private int[] firstInbound;

    private Edge[] edges;
    private int[] nextInbound;
    private int[] nextOutbound;
    private int[] from;
    private int[] to;
    private long[] weight;
    public long[] capacity;
    private int[] reverseEdge;
    private int[] flags;

    public Graph(int vertexCount) {
        this(vertexCount, vertexCount);
    }

    public Graph(int vertexCount, int edgeCapacity) {
        this.vertexCount = vertexCount;
        firstOutbound = new int[vertexCount];
        Arrays.fill(firstOutbound, -1);

        from = new int[edgeCapacity];
        to = new int[edgeCapacity];
        nextOutbound = new int[edgeCapacity];
        flags = new int[edgeCapacity];
    }

    public static Graph createGraph(int vertexCount, int[] from, int[] to) {
        Graph graph = new Graph(vertexCount, from.length);
        for (int i = 0; i < from.length; i++)
            graph.addSimpleEdge(from[i], to[i]);
        return graph;
    }

    public static Graph createWeightedGraph(int vertexCount, int[] from,
            int[] to, long[] weight) {
        Graph graph = new Graph(vertexCount, from.length);
        for (int i = 0; i < from.length; i++)
            graph.addWeightedEdge(from[i], to[i], weight[i]);
        return graph;
    }

    public static Graph createFlowGraph(int vertexCount, int[] from, int[] to,
            long[] capacity) {
        Graph graph = new Graph(vertexCount, from.length * 2);
        for (int i = 0; i < from.length; i++)
            graph.addFlowEdge(from[i], to[i], capacity[i]);
        return graph;
    }

    public static Graph createFlowWeightedGraph(int vertexCount, int[] from,
            int[] to, long[] weight, long[] capacity) {
        Graph graph = new Graph(vertexCount, from.length * 2);
        for (int i = 0; i < from.length; i++)
            graph.addFlowWeightedEdge(from[i], to[i], weight[i], capacity[i]);
        return graph;
    }

    public static Graph createTree(int[] parent) {
        Graph graph = new Graph(parent.length + 1, parent.length);
        for (int i = 0; i < parent.length; i++)
            graph.addSimpleEdge(parent[i], i + 1);
        return graph;
    }

    public int addEdge(int fromID, int toID, long weight, long capacity,
            int reverseEdge) {
        ensureEdgeCapacity(edgeCount + 1);
        if (firstOutbound[fromID] != -1)
            nextOutbound[edgeCount] = firstOutbound[fromID];
        else
            nextOutbound[edgeCount] = -1;
        firstOutbound[fromID] = edgeCount;
        if (firstInbound != null) {
            if (firstInbound[toID] != -1)
                nextInbound[edgeCount] = firstInbound[toID];
            else
                nextInbound[edgeCount] = -1;
            firstInbound[toID] = edgeCount;
        }
        this.from[edgeCount] = fromID;
        this.to[edgeCount] = toID;
        if (capacity != 0) {
            if (this.capacity == null)
                this.capacity = new long[from.length];
            this.capacity[edgeCount] = capacity;
        }
        if (weight != 0) {
            if (this.weight == null)
                this.weight = new long[from.length];
            this.weight[edgeCount] = weight;
        }
        if (reverseEdge != -1) {
            if (this.reverseEdge == null) {
                this.reverseEdge = new int[from.length];
                Arrays.fill(this.reverseEdge, 0, edgeCount, -1);
            }
            this.reverseEdge[edgeCount] = reverseEdge;
        }
        if (edges != null)
            edges[edgeCount] = createEdge(edgeCount);
        return edgeCount++;
    }

    protected final GraphEdge createEdge(int id) {
        return new GraphEdge(id);
    }

    public final int addFlowWeightedEdge(int from, int to, long weight,
            long capacity) {
        if (capacity == 0) {
            return addEdge(from, to, weight, 0, -1);
        } else {
            int lastEdgeCount = edgeCount;
            addEdge(to, from, -weight, 0, lastEdgeCount + entriesPerEdge());
            return addEdge(from, to, weight, capacity, lastEdgeCount);
        }
    }

    protected int entriesPerEdge() {
        return 1;
    }

    public final int addFlowEdge(int from, int to, long capacity) {
        return addFlowWeightedEdge(from, to, 0, capacity);
    }

    public final int addWeightedEdge(int from, int to, long weight) {
        return addFlowWeightedEdge(from, to, weight, 0);
    }

    public final int addSimpleEdge(int from, int to) {
        return addWeightedEdge(from, to, 0);
    }

    public final int vertexCount() {
        return vertexCount;
    }

    public final int edgeCount() {
        return edgeCount;
    }

    protected final int edgeCapacity() {
        return from.length;
    }

    public final Edge edge(int id) {
        initEdges();
        return edges[id];
    }

    public final int firstOutbound(int vertex) {
        int id = firstOutbound[vertex];
        while (id != -1 && isRemoved(id))
            id = nextOutbound[id];
        return id;
    }

    public final int nextOutbound(int id) {
        id = nextOutbound[id];
        while (id != -1 && isRemoved(id))
            id = nextOutbound[id];
        return id;
    }

    public final int firstInbound(int vertex) {
        initInbound();
        int id = firstInbound[vertex];
        while (id != -1 && isRemoved(id))
            id = nextInbound[id];
        return id;
    }

    public final int nextInbound(int id) {
        initInbound();
        id = nextInbound[id];
        while (id != -1 && isRemoved(id))
            id = nextInbound[id];
        return id;
    }

    public final int source(int id) {
        return from[id];
    }

    public final int destination(int id) {
        return to[id];
    }

    public final long weight(int id) {
        if (weight == null)
            return 0;
        return weight[id];
    }

    public final long capacity(int id) {
        if (capacity == null)
            return 0;
        return capacity[id];
    }

    public final long flow(int id) {
        if (reverseEdge == null)
            return 0;
        return capacity[reverseEdge[id]];
    }

    public final void pushFlow(int id, long flow) {
        if (flow == 0)
            return;
        if (flow > 0) {
            if (capacity(id) < flow)
                throw new IllegalArgumentException("Not enough capacity");
        } else {
            if (flow(id) < -flow)
                throw new IllegalArgumentException("Not enough capacity");
        }
        capacity[id] -= flow;
        capacity[reverseEdge[id]] += flow;
    }

    public int transposed(int id) {
        return -1;
    }

    public final int reverse(int id) {
        if (reverseEdge == null)
            return -1;
        return reverseEdge[id];
    }

    public final void addVertices(int count) {
        ensureVertexCapacity(vertexCount + count);
        Arrays.fill(firstOutbound, vertexCount, vertexCount + count, -1);
        if (firstInbound != null)
            Arrays.fill(firstInbound, vertexCount, vertexCount + count, -1);
        vertexCount += count;
    }

    protected final void initEdges() {
        if (edges == null) {
            edges = new Edge[from.length];
            for (int i = 0; i < edgeCount; i++)
                edges[i] = createEdge(i);
        }
    }

    public final void removeVertex(int vertex) {
        int id = firstOutbound[vertex];
        while (id != -1) {
            removeEdge(id);
            id = nextOutbound[id];
        }
        initInbound();
        id = firstInbound[vertex];
        while (id != -1) {
            removeEdge(id);
            id = nextInbound[id];
        }
    }

    private void initInbound() {
        if (firstInbound == null) {
            firstInbound = new int[firstOutbound.length];
            Arrays.fill(firstInbound, 0, vertexCount, -1);
            nextInbound = new int[from.length];
            for (int i = 0; i < edgeCount; i++) {
                nextInbound[i] = firstInbound[to[i]];
                firstInbound[to[i]] = i;
            }
        }
    }

    public final boolean flag(int id, int bit) {
        return (flags[id] >> bit & 1) != 0;
    }

    public final void setFlag(int id, int bit) {
        flags[id] |= 1 << bit;
    }

    public final void removeFlag(int id, int bit) {
        flags[id] &= -1 - (1 << bit);
    }

    public final void removeEdge(int id) {
        setFlag(id, REMOVED_BIT);
    }

    public final void restoreEdge(int id) {
        removeFlag(id, REMOVED_BIT);
    }

    public final boolean isRemoved(int id) {
        return flag(id, REMOVED_BIT);
    }

    public final Iterable<Edge> outbound(final int id) {
        initEdges();
        return new Iterable<Edge>() {
            public Iterator<Edge> iterator() {
                return new EdgeIterator(id, firstOutbound, nextOutbound);
            }
        };
    }

    public final Iterable<Edge> inbound(final int id) {
        initEdges();
        initInbound();
        return new Iterable<Edge>() {
            public Iterator<Edge> iterator() {
                return new EdgeIterator(id, firstInbound, nextInbound);
            }
        };
    }

    protected void ensureEdgeCapacity(int size) {
        if (from.length < size) {
            int newSize = Math.max(size, 2 * from.length);
            if (edges != null)
                edges = resize(edges, newSize);
            from = resize(from, newSize);
            to = resize(to, newSize);
            nextOutbound = resize(nextOutbound, newSize);
            if (nextInbound != null)
                nextInbound = resize(nextInbound, newSize);
            if (weight != null)
                weight = resize(weight, newSize);
            if (capacity != null)
                capacity = resize(capacity, newSize);
            if (reverseEdge != null)
                reverseEdge = resize(reverseEdge, newSize);
            flags = resize(flags, newSize);
        }
    }

    private void ensureVertexCapacity(int size) {
        if (firstOutbound.length < size) {
            int newSize = Math.max(size, 2 * from.length);
            firstOutbound = resize(firstOutbound, newSize);
            if (firstInbound != null)
                firstInbound = resize(firstInbound, newSize);
        }
    }

    protected final int[] resize(int[] array, int size) {
        int[] newArray = new int[size];
        System.arraycopy(array, 0, newArray, 0, array.length);
        return newArray;
    }

    private long[] resize(long[] array, int size) {
        long[] newArray = new long[size];
        System.arraycopy(array, 0, newArray, 0, array.length);
        return newArray;
    }

    private Edge[] resize(Edge[] array, int size) {
        Edge[] newArray = new Edge[size];
        System.arraycopy(array, 0, newArray, 0, array.length);
        return newArray;
    }

    public final boolean isSparse() {
        return vertexCount == 0 || edgeCount * 20 / vertexCount <= vertexCount;
    }

    protected class GraphEdge implements Edge {
        protected int id;

        protected GraphEdge(int id) {
            this.id = id;
        }

        public int getSource() {
            return source(id);
        }

        public int getDestination() {
            return destination(id);
        }

        public long getWeight() {
            return weight(id);
        }

        public long getCapacity() {
            return capacity(id);
        }

        public long getFlow() {
            return flow(id);
        }

        public void pushFlow(long flow) {
            Graph.this.pushFlow(id, flow);
        }

        public boolean getFlag(int bit) {
            return flag(id, bit);
        }

        public void setFlag(int bit) {
            Graph.this.setFlag(id, bit);
        }

        public void removeFlag(int bit) {
            Graph.this.removeFlag(id, bit);
        }

        public int getTransposedID() {
            return transposed(id);
        }

        public Edge getTransposedEdge() {
            int reverseID = getTransposedID();
            if (reverseID == -1)
                return null;
            initEdges();
            return edge(reverseID);
        }

        public int getReverseID() {
            return reverse(id);
        }

        public Edge getReverseEdge() {
            int reverseID = getReverseID();
            if (reverseID == -1)
                return null;
            initEdges();
            return edge(reverseID);
        }

        public int getID() {
            return id;
        }

        public void remove() {
            removeEdge(id);
        }

        public void restore() {
            restoreEdge(id);
        }
    }

    public class EdgeIterator implements Iterator<Edge> {
        private int edgeID;
        private final int[] next;
        private int lastID = -1;

        public EdgeIterator(int id, int[] first, int[] next) {
            this.next = next;
            edgeID = nextEdge(first[id]);
        }

        private int nextEdge(int id) {
            while (id != -1 && isRemoved(id))
                id = next[id];
            return id;
        }

        public boolean hasNext() {
            return edgeID != -1;
        }

        public Edge next() {
            if (edgeID == -1)
                throw new NoSuchElementException();
            lastID = edgeID;
            edgeID = nextEdge(next[lastID]);
            return edges[lastID];
        }

        public void remove() {
            if (lastID == -1)
                throw new IllegalStateException();
            removeEdge(lastID);
            lastID = -1;
        }
    }

}

interface Edge {
    public int getSource();

    public int getDestination();

    public long getWeight();

    public long getCapacity();

    public long getFlow();

    public void pushFlow(long flow);

    public boolean getFlag(int bit);

    public void setFlag(int bit);

    public void removeFlag(int bit);

    public int getTransposedID();

    public Edge getTransposedEdge();

    public int getReverseID();

    public Edge getReverseEdge();

    public int getID();

    public void remove();

    public void restore();
}

class BidirectionalGraph extends Graph {
    public int[] transposedEdge;

    public BidirectionalGraph(int vertexCount) {
        this(vertexCount, vertexCount);
    }

    public BidirectionalGraph(int vertexCount, int edgeCapacity) {
        super(vertexCount, 2 * edgeCapacity);
        transposedEdge = new int[2 * edgeCapacity];
    }

    public static BidirectionalGraph createGraph(int vertexCount, int[] from,
            int[] to) {
        BidirectionalGraph graph = new BidirectionalGraph(vertexCount,
                from.length);
        for (int i = 0; i < from.length; i++)
            graph.addSimpleEdge(from[i], to[i]);
        return graph;
    }

    public static BidirectionalGraph createWeightedGraph(int vertexCount,
            int[] from, int[] to, long[] weight) {
        BidirectionalGraph graph = new BidirectionalGraph(vertexCount,
                from.length);
        for (int i = 0; i < from.length; i++)
            graph.addWeightedEdge(from[i], to[i], weight[i]);
        return graph;
    }

    public static BidirectionalGraph createFlowGraph(int vertexCount,
            int[] from, int[] to, long[] capacity) {
        BidirectionalGraph graph = new BidirectionalGraph(vertexCount,
                from.length * 2);
        for (int i = 0; i < from.length; i++)
            graph.addFlowEdge(from[i], to[i], capacity[i]);
        return graph;
    }

    public static BidirectionalGraph createFlowWeightedGraph(int vertexCount,
            int[] from, int[] to, long[] weight, long[] capacity) {
        BidirectionalGraph graph = new BidirectionalGraph(vertexCount,
                from.length * 2);
        for (int i = 0; i < from.length; i++)
            graph.addFlowWeightedEdge(from[i], to[i], weight[i], capacity[i]);
        return graph;
    }

    @Override
    public int addEdge(int fromID, int toID, long weight, long capacity,
            int reverseEdge) {
        int lastEdgeCount = edgeCount;
        super.addEdge(fromID, toID, weight, capacity, reverseEdge);
        super.addEdge(toID, fromID, weight, capacity, reverseEdge == -1 ? -1
                : reverseEdge + 1);
        this.transposedEdge[lastEdgeCount] = lastEdgeCount + 1;
        this.transposedEdge[lastEdgeCount + 1] = lastEdgeCount;
        return lastEdgeCount;
    }

    @Override
    protected int entriesPerEdge() {
        return 2;
    }

    @Override
    public final int transposed(int id) {
        return transposedEdge[id];
    }

    @Override
    protected void ensureEdgeCapacity(int size) {
        if (size > edgeCapacity()) {
            super.ensureEdgeCapacity(size);
            transposedEdge = resize(transposedEdge, edgeCapacity());
        }
    }
}

class IOUtils {
    public static long[] readLongArray(InputReader in, int size) {
        long[] array = new long[size];
        for (int i = 0; i < size; i++)
            array[i] = in.readLong();
        return array;
    }

    public static int[] readIntArray(InputReader in, int size) {
        int[] array = new int[size];
        for (int i = 0; i < size; i++)
            array[i] = in.readInt();
        return array;
    }
}

interface Function<A, V> {
    public abstract V value(A argument);
}

class IntegerUtils {

    public static List<Pair<Long, Integer>> factorize(long number) {
        List<Pair<Long, Integer>> result = new ArrayList<Pair<Long, Integer>>();
        for (long i = 2; i * i <= number; i++) {
            if (number % i == 0) {
                int power = 0;
                do {
                    power++;
                    number /= i;
                } while (number % i == 0);
                result.add(Pair.makePair(i, power));
            }
        }
        if (number != 1)
            result.add(Pair.makePair(number, 1));
        return result;
    }

    public static List<Long> getDivisors(long number) {
        List<Pair<Long, Integer>> primeDivisors = factorize(number);
        return getDivisorsImpl(primeDivisors, 0, 1, new ArrayList<Long>());
    }

    private static List<Long> getDivisorsImpl(
            List<Pair<Long, Integer>> primeDivisors, int index, long current,
            List<Long> result) {
        if (index == primeDivisors.size()) {
            result.add(current);
            return result;
        }
        long p = primeDivisors.get(index).first;
        int power = primeDivisors.get(index).second;
        for (int i = 0; i <= power; i++) {
            getDivisorsImpl(primeDivisors, index + 1, current, result);
            current *= p;
        }
        return result;
    }
}

class Pair<U, V> implements Comparable<Pair<U, V>> {
    public final U first;
    public final V second;

    public static <U, V> Pair<U, V> makePair(U first, V second) {
        return new Pair<U, V>(first, second);
    }

    private Pair(U first, V second) {
        this.first = first;
        this.second = second;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;

        Pair pair = (Pair) o;

        return !(first != null ? !first.equals(pair.first) : pair.first != null)
                && !(second != null ? !second.equals(pair.second)
                        : pair.second != null);

    }

    @Override
    public int hashCode() {
        int result = first != null ? first.hashCode() : 0;
        result = 31 * result + (second != null ? second.hashCode() : 0);
        return result;
    }

    public Pair<V, U> swap() {
        return makePair(second, first);
    }

    @Override
    public String toString() {
        return "(" + first + "," + second + ")";
    }

    @SuppressWarnings({ "unchecked" })
    public int compareTo(Pair<U, V> o) {
        int value = ((Comparable<U>) first).compareTo(o.first);
        if (value != 0)
            return value;
        return ((Comparable<V>) second).compareTo(o.second);
    }
}

class InputReader {
    private boolean finished = false;

    private InputStream stream;
    private byte[] buf = new byte[1024];
    private int curChar;
    private int numChars;
    private SpaceCharFilter filter;

    public InputReader(InputStream stream) {
        this.stream = stream;
    }

    public int read() {
        if (numChars == -1)
            throw new InputMismatchException();
        if (curChar >= numChars) {
            curChar = 0;
            try {
                numChars = stream.read(buf);
            } catch (IOException e) {
                throw new InputMismatchException();
            }
            if (numChars <= 0)
                return -1;
        }
        return buf[curChar++];
    }

    public int peek() {
        if (numChars == -1)
            return -1;
        if (curChar >= numChars) {
            curChar = 0;
            try {
                numChars = stream.read(buf);
            } catch (IOException e) {
                return -1;
            }
            if (numChars <= 0)
                return -1;
        }
        return buf[curChar];
    }

    public int readInt() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        int res = 0;
        do {
            if (c < '0' || c > '9')
                throw new InputMismatchException();
            res *= 10;
            res += c - '0';
            c = read();
        } while (!isSpaceChar(c));
        return res * sgn;
    }

    public long readLong() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        long res = 0;
        do {
            if (c < '0' || c > '9')
                throw new InputMismatchException();
            res *= 10;
            res += c - '0';
            c = read();
        } while (!isSpaceChar(c));
        return res * sgn;
    }

    public String readString() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        StringBuilder res = new StringBuilder();
        do {
            if (Character.isValidCodePoint(c))
                res.appendCodePoint(c);
            c = read();
        } while (!isSpaceChar(c));
        return res.toString();
    }

    public boolean isSpaceChar(int c) {
        if (filter != null)
            return filter.isSpaceChar(c);
        return isWhitespace(c);
    }

    public static boolean isWhitespace(int c) {
        return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
    }

    private String readLine0() {
        StringBuilder buf = new StringBuilder();
        int c = read();
        while (c != '\n' && c != -1) {
            if (c != '\r')
                buf.appendCodePoint(c);
            c = read();
        }
        return buf.toString();
    }

    public String readLine() {
        String s = readLine0();
        while (s.trim().length() == 0)
            s = readLine0();
        return s;
    }

    public String readLine(boolean ignoreEmptyLines) {
        if (ignoreEmptyLines)
            return readLine();
        else
            return readLine0();
    }

    public BigInteger readBigInteger() {
        try {
            return new BigInteger(readString());
        } catch (NumberFormatException e) {
            throw new InputMismatchException();
        }
    }

    public char readCharacter() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        return (char) c;
    }

    public double readDouble() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        double res = 0;
        while (!isSpaceChar(c) && c != '.') {
            if (c == 'e' || c == 'E')
                return res * Math.pow(10, readInt());
            if (c < '0' || c > '9')
                throw new InputMismatchException();
            res *= 10;
            res += c - '0';
            c = read();
        }
        if (c == '.') {
            c = read();
            double m = 1;
            while (!isSpaceChar(c)) {
                if (c == 'e' || c == 'E')
                    return res * Math.pow(10, readInt());
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                m /= 10;
                res += (c - '0') * m;
                c = read();
            }
        }
        return res * sgn;
    }

    public boolean isExhausted() {
        int value;
        while (isSpaceChar(value = peek()) && value != -1)
            read();
        return value == -1;
    }

    public String next() {
        return readString();
    }

    public SpaceCharFilter getFilter() {
        return filter;
    }

    public void setFilter(SpaceCharFilter filter) {
        this.filter = filter;
    }

    public interface SpaceCharFilter {
        public boolean isSpaceChar(int ch);
    }
}

class OutputWriter {
    private final PrintWriter writer;

    public OutputWriter(OutputStream outputStream) {
        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(
                outputStream)));
    }

    public OutputWriter(Writer writer) {
        this.writer = new PrintWriter(writer);
    }

    public void print(char[] array) {
        writer.print(array);
    }

    public void print(Object... objects) {
        for (int i = 0; i < objects.length; i++) {
            if (i != 0)
                writer.print(' ');
            writer.print(objects[i]);
        }
    }

    public void print(int[] array) {
        for (int i = 0; i < array.length; i++) {
            if (i != 0)
                writer.print(' ');
            writer.print(array[i]);
        }
    }

    public void print(long[] array) {
        for (int i = 0; i < array.length; i++) {
            if (i != 0)
                writer.print(' ');
            writer.print(array[i]);
        }
    }

    public void printLine(int[] array) {
        print(array);
        writer.println();
    }

    public void printLine(long[] array) {
        print(array);
        writer.println();
    }

    public void printLine() {
        writer.println();
    }

    public void printLine(Object... objects) {
        print(objects);
        writer.println();
    }

    public void print(char i) {
        writer.print(i);
    }

    public void printLine(char i) {
        writer.println(i);
    }

    public void printLine(char[] array) {
        writer.println(array);
    }

    public void printFormat(String format, Object... objects) {
        writer.printf(format, objects);
    }

    public void close() {
        writer.close();
    }

    public void flush() {
        writer.flush();
    }

    public void print(long i) {
        writer.print(i);
    }

    public void printLine(long i) {
        writer.println(i);
    }

    public void print(int i) {
        writer.print(i);
    }

    public void printLine(int i) {
        writer.println(i);
    }
}

class ArrayUtils {

    public static int[] createOrder(int size) {
        int[] order = new int[size];
        for (int i = 0; i < size; i++)
            order[i] = i;
        return order;
    }

    public static int maxPosition(int[] array) {
        return maxPosition(array, 0, array.length);
    }

    public static int maxPosition(int[] array, int from, int to) {
        if (from >= to)
            return -1;
        int max = array[from];
        int result = from;
        for (int i = from + 1; i < to; i++) {
            if (array[i] > max) {
                max = array[i];
                result = i;
            }
        }
        return result;
    }

}package OldAttemptLearning.pimponuser.another;

import java.io.*;
import java.lang.reflect.Array;
import java.math.BigInteger;
import java.util.*;

public class Main {
    public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		InputReader in = new InputReader(inputStream);
		OutputWriter out = new OutputWriter(outputStream);
		Task solver = new A();
		solver.solve(1, in, out);
		out.close();
	}
}

interface Task {
	public void solve(int testNumber, InputReader in, OutputWriter out);
}

class A implements Task {
	
	Map<String, Integer> mapa=new HashMap<String, Integer>(), aux=new HashMap<String, Integer>();
	String[] nomes;
	int[] pontos;
	
	public void solve(int testNumber, InputReader in, OutputWriter out) {
		int n=in.readInt(), p, max=Integer.MIN_VALUE;
		nomes=new String[n];
		pontos=new int[n];
		for (int i=0; i<n; i++) {
			nomes[i]=in.next();
			pontos[i]=in.readInt();
			if (!mapa.containsKey(nomes[i])) mapa.put(nomes[i], 0);
			mapa.put(nomes[i], mapa.get(nomes[i])+pontos[i]);
		}
		for (int i: mapa.values()) max=MiscUtils.max(max, i);
		for (int i=0; i<n; i++) {
			if (!aux.containsKey(nomes[i])) aux.put(nomes[i], 0);
			aux.put(nomes[i], aux.get(nomes[i])+pontos[i]);
			if (mapa.get(nomes[i])==max && aux.get(nomes[i])>=max) {
				out.printLine(nomes[i]);
				break;
			}
		}
	}
}

class B implements Task {

	public void solve(int testNumber, InputReader in, OutputWriter out) {

	}

}

class C implements Task {

	public void solve(int testNumber, InputReader in, OutputWriter out) {

	}

}

class D implements Task {

	public void solve(int testNumber, InputReader in, OutputWriter out) {

	}

}

class E implements Task {

	public void solve(int testNumber, InputReader in, OutputWriter out) {

	}

}

class InputReader {
	private boolean finished = false;

	private InputStream stream;
	private byte[] buf = new byte[1024];
	private int curChar;
	private int numChars;
	private SpaceCharFilter filter;

	public InputReader(InputStream stream) {
		this.stream = stream;
	}

	public int read() {
		if (numChars == -1)
			throw new InputMismatchException();
		if (curChar >= numChars) {
			curChar = 0;
			try {
				numChars = stream.read(buf);
			} catch (IOException e) {
				throw new InputMismatchException();
			}
			if (numChars <= 0)
				return -1;
		}
		return buf[curChar++];
	}

	public int peek() {
		if (numChars == -1)
			return -1;
		if (curChar >= numChars) {
			curChar = 0;
			try {
				numChars = stream.read(buf);
			} catch (IOException e) {
				return -1;
			}
			if (numChars <= 0)
				return -1;
		}
		return buf[curChar];
	}

	public int readInt() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		int sgn = 1;
		if (c == '-') {
			sgn = -1;
			c = read();
		}
		int res = 0;
		do {
			if (c < '0' || c > '9')
				throw new InputMismatchException();
			res *= 10;
			res += c - '0';
			c = read();
		} while (!isSpaceChar(c));
		return res * sgn;
	}

	public long readLong() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		int sgn = 1;
		if (c == '-') {
			sgn = -1;
			c = read();
		}
		long res = 0;
		do {
			if (c < '0' || c > '9')
				throw new InputMismatchException();
			res *= 10;
			res += c - '0';
			c = read();
		} while (!isSpaceChar(c));
		return res * sgn;
	}

	public String readString() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		StringBuilder res = new StringBuilder();
		do {
			if (Character.isValidCodePoint(c))
				res.appendCodePoint(c);
			c = read();
		} while (!isSpaceChar(c));
		return res.toString();
	}

	public boolean isSpaceChar(int c) {
		if (filter != null)
			return filter.isSpaceChar(c);
		return isWhitespace(c);
	}

	public static boolean isWhitespace(int c) {
		return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
	}

	private String readLine0() {
		StringBuilder buf = new StringBuilder();
		int c = read();
		while (c != '\n' && c != -1) {
			if (c != '\r')
				buf.appendCodePoint(c);
			c = read();
		}
		return buf.toString();
	}

	public String readLine() {
		String s = readLine0();
		while (s.trim().length() == 0)
			s = readLine0();
		return s;
	}

	public String readLine(boolean ignoreEmptyLines) {
		if (ignoreEmptyLines)
			return readLine();
		else
			return readLine0();
	}

	public BigInteger readBigInteger() {
		try {
			return new BigInteger(readString());
		} catch (NumberFormatException e) {
			throw new InputMismatchException();
		}
	}

	public char readCharacter() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		return (char) c;
	}

	public double readDouble() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		int sgn = 1;
		if (c == '-') {
			sgn = -1;
			c = read();
		}
		double res = 0;
		while (!isSpaceChar(c) && c != '.') {
			if (c == 'e' || c == 'E')
				return res * Math.pow(10, readInt());
			if (c < '0' || c > '9')
				throw new InputMismatchException();
			res *= 10;
			res += c - '0';
			c = read();
		}
		if (c == '.') {
			c = read();
			double m = 1;
			while (!isSpaceChar(c)) {
				if (c == 'e' || c == 'E')
					return res * Math.pow(10, readInt());
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				m /= 10;
				res += (c - '0') * m;
				c = read();
			}
		}
		return res * sgn;
	}

	public boolean isExhausted() {
		int value;
		while (isSpaceChar(value = peek()) && value != -1)
			read();
		return value == -1;
	}

	public String next() {
		return readString();
	}

	public SpaceCharFilter getFilter() {
		return filter;
	}

	public void setFilter(SpaceCharFilter filter) {
		this.filter = filter;
	}

	public interface SpaceCharFilter {
		public boolean isSpaceChar(int ch);
	}
}

class OutputWriter {
	private final PrintWriter writer;

	public OutputWriter(OutputStream outputStream) {
		writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(
				outputStream)));
	}

	public OutputWriter(Writer writer) {
		this.writer = new PrintWriter(writer);
	}

	public void print(char[] array) {
		writer.print(array);
	}

	public void print(Object... objects) {
		for (int i = 0; i < objects.length; i++) {
			if (i != 0)
				writer.print(' ');
			writer.print(objects[i]);
		}
	}

	public void print(int[] array) {
		for (int i = 0; i < array.length; i++) {
			if (i != 0)
				writer.print(' ');
			writer.print(array[i]);
		}
	}

	public void print(long[] array) {
		for (int i = 0; i < array.length; i++) {
			if (i != 0)
				writer.print(' ');
			writer.print(array[i]);
		}
	}

	public void print(IntCollection collection) {
		boolean first = true;
		for (IntIterator iterator = collection.iterator(); iterator.isValid(); iterator
				.advance()) {
			if (first)
				first = false;
			else
				writer.print(' ');
			writer.print(iterator.value());
		}
	}

	public void printLine(int[] array) {
		print(array);
		writer.println();
	}

	public void printLine(long[] array) {
		print(array);
		writer.println();
	}

	public void printLine(IntCollection collection) {
		print(collection);
		writer.println();
	}

	public void printLine() {
		writer.println();
	}

	public void printLine(Object... objects) {
		print(objects);
		writer.println();
	}

	public void print(char i) {
		writer.print(i);
	}

	public void printLine(char i) {
		writer.println(i);
	}

	public void printLine(char[] array) {
		writer.println(array);
	}

	public void printFormat(String format, Object... objects) {
		writer.printf(format, objects);
	}

	public void close() {
		writer.close();
	}

	public void flush() {
		writer.flush();
	}

	public void print(long i) {
		writer.print(i);
	}

	public void printLine(long i) {
		writer.println(i);
	}

	public void print(int i) {
		writer.print(i);
	}

	public void printLine(int i) {
		writer.println(i);
	}
}

abstract class IntCollection {
	public abstract IntIterator iterator();

	public abstract int size();

	public abstract void add(int value);

	public abstract void remove(int value);

	public void forEach(IntTask task) {
		for (IntIterator iterator = iterator(); iterator.isValid(); iterator
				.advance())
			task.process(iterator.value());
	}

	public boolean contains(int value) {
		for (IntIterator iterator = iterator(); iterator.isValid(); iterator
				.advance()) {
			if (iterator.value() == value)
				return true;
		}
		return false;
	}

	public int count(int value) {
		int result = 0;
		for (IntIterator iterator = iterator(); iterator.isValid(); iterator
				.advance()) {
			if (iterator.value() == value)
				result++;
		}
		return result;
	}

	public int min() {
		if (size() == 0)
			throw new NoSuchElementException();
		int result = Integer.MAX_VALUE;
		for (IntIterator iterator = iterator(); iterator.isValid(); iterator
				.advance())
			result = Math.min(result, iterator.value());
		return result;
	}

	public int max() {
		if (size() == 0)
			throw new NoSuchElementException();
		int result = Integer.MIN_VALUE;
		for (IntIterator iterator = iterator(); iterator.isValid(); iterator
				.advance())
			result = Math.max(result, iterator.value());
		return result;
	}

	public IntCollection union(final IntCollection other) {
		return new IntCollection() {
			@Override
			public IntIterator iterator() {
				return new IntIterator() {
					private IntIterator first = IntCollection.this.iterator();
					private IntIterator second;

					public int value() throws NoSuchElementException {
						if (first.isValid())
							return first.value();
						return second.value();
					}

					public void advance() throws NoSuchElementException {
						if (first.isValid()) {
							first.advance();
							if (!first.isValid())
								second = other.iterator();
						} else
							second.advance();
					}

					public boolean isValid() {
						return first.isValid() || second.isValid();
					}
				};
			}

			@Override
			public int size() {
				return IntCollection.this.size() + other.size();
			}

			@Override
			public void add(int value) {
				throw new UnsupportedOperationException();
			}

			@Override
			public void remove(int value) {
				throw new UnsupportedOperationException();
			}
		};
	}

	public IntCollection map(final IntFunction function) {
		return new IntCollection() {
			@Override
			public IntIterator iterator() {
				return new IntIterator() {
					private IntIterator iterator = IntCollection.this
							.iterator();

					public int value() throws NoSuchElementException {
						return function.value(iterator.value());
					}

					public void advance() throws NoSuchElementException {
						iterator().advance();
					}

					public boolean isValid() {
						return iterator().isValid();
					}
				};
			}

			@Override
			public int size() {
				return IntCollection.this.size();
			}

			@Override
			public void add(int value) {
				throw new UnsupportedOperationException();
			}

			@Override
			public void remove(int value) {
				throw new UnsupportedOperationException();
			}
		};
	}

	public int[] toArray() {
		int size = size();
		int[] array = new int[size];
		int i = 0;
		for (IntIterator iterator = iterator(); iterator.isValid(); iterator
				.advance())
			array[i++] = iterator.value();
		return array;
	}

	public long sum() {
		long result = 0;
		for (IntIterator iterator = iterator(); iterator.isValid(); iterator
				.advance())
			result += iterator.value();
		return result;
	}

	public void addAll(IntCollection values) {
		for (IntIterator it = values.iterator(); it.isValid(); it.advance()) {
			add(it.value());
		}
	}

	public void removeAll(IntCollection values) {
		for (IntIterator it = values.iterator(); it.isValid(); it.advance()) {
			remove(it.value());
		}
	}

	public void retainAll(IntCollection values) {
		for (IntIterator it = iterator(); it.isValid(); it.advance()) {
			if (!values.contains(it.value())) {
				remove(it.value());
			}
		}
	}
}

interface IntIterator {
	public int value() throws NoSuchElementException;

	/*
	 * @throws NoSuchElementException only if iterator already invalid
	 */
	public void advance() throws NoSuchElementException;

	public boolean isValid();
}

interface IntTask {
	public void process(int value);
}

interface IntFunction {
	public int value(int key);
}

class IOUtils {
	public static Pair<Integer, Integer> readIntPair(InputReader in) {
		int first = in.readInt();
		int second = in.readInt();
		return Pair.makePair(first, second);
	}

	public static Pair<Long, Long> readLongPair(InputReader in) {
		long first = in.readLong();
		long second = in.readLong();
		return Pair.makePair(first, second);
	}

	public static int[] readIntArray(InputReader in, int size) {
		int[] array = new int[size];
		for (int i = 0; i < size; i++)
			array[i] = in.readInt();
		return array;
	}

	public static long[] readLongArray(InputReader in, int size) {
		long[] array = new long[size];
		for (int i = 0; i < size; i++)
			array[i] = in.readLong();
		return array;
	}

	public static double[] readDoubleArray(InputReader in, int size) {
		double[] array = new double[size];
		for (int i = 0; i < size; i++)
			array[i] = in.readDouble();
		return array;
	}

	public static String[] readStringArray(InputReader in, int size) {
		String[] array = new String[size];
		for (int i = 0; i < size; i++)
			array[i] = in.readString();
		return array;
	}

	public static char[] readCharArray(InputReader in, int size) {
		char[] array = new char[size];
		for (int i = 0; i < size; i++)
			array[i] = in.readCharacter();
		return array;
	}

	public static Pair<Integer, Integer>[] readIntPairArray(InputReader in,
			int size) {
		@SuppressWarnings({ "unchecked" })
		Pair<Integer, Integer>[] result = new Pair[size];
		for (int i = 0; i < size; i++)
			result[i] = readIntPair(in);
		return result;
	}

	public static Pair<Long, Long>[] readLongPairArray(InputReader in, int size) {
		@SuppressWarnings({ "unchecked" })
		Pair<Long, Long>[] result = new Pair[size];
		for (int i = 0; i < size; i++)
			result[i] = readLongPair(in);
		return result;
	}

	public static void readIntArrays(InputReader in, int[]... arrays) {
		for (int i = 0; i < arrays[0].length; i++) {
			for (int j = 0; j < arrays.length; j++)
				arrays[j][i] = in.readInt();
		}
	}

	public static void readLongArrays(InputReader in, long[]... arrays) {
		for (int i = 0; i < arrays[0].length; i++) {
			for (int j = 0; j < arrays.length; j++)
				arrays[j][i] = in.readLong();
		}
	}

	public static void readDoubleArrays(InputReader in, double[]... arrays) {
		for (int i = 0; i < arrays[0].length; i++) {
			for (int j = 0; j < arrays.length; j++)
				arrays[j][i] = in.readDouble();
		}
	}

	public static char[][] readTable(InputReader in, int rowCount,
			int columnCount) {
		char[][] table = new char[rowCount][];
		for (int i = 0; i < rowCount; i++)
			table[i] = readCharArray(in, columnCount);
		return table;
	}

	public static int[][] readIntTable(InputReader in, int rowCount,
			int columnCount) {
		int[][] table = new int[rowCount][];
		for (int i = 0; i < rowCount; i++)
			table[i] = readIntArray(in, columnCount);
		return table;
	}

	public static double[][] readDoubleTable(InputReader in, int rowCount,
			int columnCount) {
		double[][] table = new double[rowCount][];
		for (int i = 0; i < rowCount; i++)
			table[i] = readDoubleArray(in, columnCount);
		return table;
	}

	public static long[][] readLongTable(InputReader in, int rowCount,
			int columnCount) {
		long[][] table = new long[rowCount][];
		for (int i = 0; i < rowCount; i++)
			table[i] = readLongArray(in, columnCount);
		return table;
	}

	public static String[][] readStringTable(InputReader in, int rowCount,
			int columnCount) {
		String[][] table = new String[rowCount][];
		for (int i = 0; i < rowCount; i++)
			table[i] = readStringArray(in, columnCount);
		return table;
	}

	public static String readText(InputReader in) {
		StringBuilder result = new StringBuilder();
		while (true) {
			int character = in.read();
			if (character == '\r')
				continue;
			if (character == -1)
				break;
			result.append((char) character);
		}
		return result.toString();
	}

	public static void readStringArrays(InputReader in, String[]... arrays) {
		for (int i = 0; i < arrays[0].length; i++) {
			for (int j = 0; j < arrays.length; j++)
				arrays[j][i] = in.readString();
		}
	}

	public static void printTable(OutputWriter out, char[][] table) {
		for (char[] row : table)
			out.printLine(new String(row));
	}
}

class Pair<U, V> implements Comparable<Pair<U, V>> {
	public final U first;
	public final V second;

	public static <U, V> Pair<U, V> makePair(U first, V second) {
		return new Pair<U, V>(first, second);
	}

	private Pair(U first, V second) {
		this.first = first;
		this.second = second;
	}

	@Override
	public boolean equals(Object o) {
		if (this == o)
			return true;
		if (o == null || getClass() != o.getClass())
			return false;

		Pair pair = (Pair) o;

		return !(first != null ? !first.equals(pair.first) : pair.first != null)
				&& !(second != null ? !second.equals(pair.second)
						: pair.second != null);

	}

	@Override
	public int hashCode() {
		int result = first != null ? first.hashCode() : 0;
		result = 31 * result + (second != null ? second.hashCode() : 0);
		return result;
	}

	public Pair<V, U> swap() {
		return makePair(second, first);
	}

	@Override
	public String toString() {
		return "(" + first + "," + second + ")";
	}

	@SuppressWarnings({ "unchecked" })
	public int compareTo(Pair<U, V> o) {
		int value = ((Comparable<U>) first).compareTo(o.first);
		if (value != 0)
			return value;
		return ((Comparable<V>) second).compareTo(o.second);
	}
}

abstract class IntList extends IntCollection implements Comparable<IntList> {
	private static final int INSERTION_THRESHOLD = 16;
	private static IntList EMPTY_LIST;

	public abstract int get(int index);

	public abstract void set(int index, int value);

	@Override
	public IntIterator iterator() {
		return new IntIterator() {
			private int size = size();
			private int index = 0;

			public int value() throws NoSuchElementException {
				if (!isValid())
					throw new NoSuchElementException();
				return get(index);
			}

			public void advance() throws NoSuchElementException {
				if (!isValid())
					throw new NoSuchElementException();
				index++;
			}

			public boolean isValid() {
				return index < size;
			}
		};
	}

	@Override
	public void remove(int value) {
		throw new UnsupportedOperationException();
	}

	public int find(int value) {
		int size = size();
		for (int i = 0; i < size; i++) {
			if (get(i) == value)
				return i;
		}
		return -1;
	}

	public int findLast(int value) {
		int size = size();
		for (int i = size - 1; i >= 0; i--) {
			if (get(i) == value)
				return i;
		}
		return -1;
	}

	public boolean nextPermutation() {
		return nextPermutation(IntComparator.DEFAULT);
	}

	private boolean nextPermutation(IntComparator comparator) {
		int size = size();
		int last = get(size - 1);
		for (int i = size - 2; i >= 0; i--) {
			int current = get(i);
			if (comparator.compare(last, current) > 0) {
				for (int j = size - 1; j > i; j--) {
					if (comparator.compare(get(j), current) > 0) {
						swap(i, j);
						subList(i + 1, size).inPlaceReverse();
						return true;
					}
				}
			}
			last = current;
		}
		return false;
	}

	public void inPlaceReverse() {
		for (int i = 0, j = size() - 1; i < j; i++, j--)
			swap(i, j);
	}

	public IntList subList(final int from, final int to) {
		return new SubList(from, to);
	}

	private void swap(int first, int second) {
		if (first == second)
			return;
		int temp = get(first);
		set(first, get(second));
		set(second, temp);
	}

	public IntSortedList inPlaceSort() {
		return inPlaceSort(IntComparator.DEFAULT);
	}

	public IntSortedList inPlaceSort(IntComparator comparator) {
		quickSort(0, size() - 1,
				(Integer.bitCount(Integer.highestOneBit(size()) - 1) * 5) >> 1,
				comparator);
		return new IntSortedArray(this, comparator);
	}

	private void quickSort(int from, int to, int remaining,
			IntComparator comparator) {
		if (to - from < INSERTION_THRESHOLD) {
			insertionSort(from, to, comparator);
			return;
		}
		if (remaining == 0) {
			heapSort(from, to, comparator);
			return;
		}
		remaining--;
		int pivotIndex = (from + to) >> 1;
		int pivot = get(pivotIndex);
		swap(pivotIndex, to);
		int storeIndex = from;
		int equalIndex = to;
		for (int i = from; i < equalIndex; i++) {
			int value = comparator.compare(get(i), pivot);
			if (value < 0)
				swap(storeIndex++, i);
			else if (value == 0)
				swap(--equalIndex, i--);
		}
		quickSort(from, storeIndex - 1, remaining, comparator);
		for (int i = equalIndex; i <= to; i++)
			swap(storeIndex++, i);
		quickSort(storeIndex, to, remaining, comparator);
	}

	private void heapSort(int from, int to, IntComparator comparator) {
		for (int i = (to + from - 1) >> 1; i >= from; i--)
			siftDown(i, to, comparator, from);
		for (int i = to; i > from; i--) {
			swap(from, i);
			siftDown(from, i - 1, comparator, from);
		}
	}

	private void siftDown(int start, int end, IntComparator comparator,
			int delta) {
		int value = get(start);
		while (true) {
			int child = ((start - delta) << 1) + 1 + delta;
			if (child > end)
				return;
			int childValue = get(child);
			if (child + 1 <= end) {
				int otherValue = get(child + 1);
				if (comparator.compare(otherValue, childValue) > 0) {
					child++;
					childValue = otherValue;
				}
			}
			if (comparator.compare(value, childValue) >= 0)
				return;
			swap(start, child);
			start = child;
		}
	}

	private void insertionSort(int from, int to, IntComparator comparator) {
		for (int i = from + 1; i <= to; i++) {
			int value = get(i);
			for (int j = i - 1; j >= from; j--) {
				if (comparator.compare(get(j), value) <= 0)
					break;
				swap(j, j + 1);
			}
		}
	}

	public IntSortedList sort() {
		return sort(IntComparator.DEFAULT);
	}

	public IntSortedList sort(IntComparator comparator) {
		return new IntArray(this).inPlaceSort(comparator);
	}

	public int back() {
		return get(size() - 1);
	}

	public int popBack() {
		throw new UnsupportedOperationException();
	}

	public int hashCode() {
		int hashCode = 1;
		for (IntIterator i = iterator(); i.isValid(); i.advance())
			hashCode = 31 * hashCode + i.value();
		return hashCode;
	}

	@Override
	public boolean equals(Object obj) {
		if (!(obj instanceof IntList))
			return false;
		IntList list = (IntList) obj;
		if (list.size() != size())
			return false;
		IntIterator i = iterator();
		IntIterator j = list.iterator();
		while (i.isValid()) {
			if (i.value() != j.value())
				return false;
			i.advance();
			j.advance();
		}
		return true;
	}

	public int compareTo(IntList o) {
		IntIterator i = iterator();
		IntIterator j = o.iterator();
		while (true) {
			if (i.isValid()) {
				if (j.isValid()) {
					if (i.value() != j.value()) {
						if (i.value() < j.value())
							return -1;
						else
							return 1;
					}
				} else
					return 1;
			} else {
				if (j.isValid())
					return -1;
				else
					return 0;
			}
			i.advance();
			j.advance();
		}
	}

	public static IntList emptyList() {
		if (EMPTY_LIST == null)
			EMPTY_LIST = new IntArray(new int[0]);
		return EMPTY_LIST;
	}

	private class SubList extends IntList {
		private final int to;
		private final int from;
		private int size;

		public SubList(int from, int to) {
			this.to = to;
			this.from = from;
			size = to - from;
		}

		@Override
		public int get(int index) {
			if (index < 0 || index >= size)
				throw new IndexOutOfBoundsException();
			return IntList.this.get(index + from);
		}

		@Override
		public void set(int index, int value) {
			if (index < 0 || index >= size)
				throw new IndexOutOfBoundsException();
			IntList.this.set(index + from, value);
		}

		@Override
		public int size() {
			return size;
		}

		@Override
		public void add(int value) {
			throw new UnsupportedOperationException();
		}
	}
}

interface IntComparator {
	public static final IntComparator DEFAULT = new IntComparator() {
		public int compare(int first, int second) {
			if (first < second)
				return -1;
			if (first > second)
				return 1;
			return 0;
		}
	};

	public static final IntComparator REVERSE = new IntComparator() {
		public int compare(int first, int second) {
			if (first < second)
				return 1;
			if (first > second)
				return -1;
			return 0;
		}
	};

	public int compare(int first, int second);
}

abstract class IntSortedList extends IntList {
	protected final IntComparator comparator;

	protected IntSortedList(IntComparator comparator) {
		this.comparator = comparator;
	}

	@Override
	public void set(int index, int value) {
		throw new UnsupportedOperationException();
	}

	@Override
	public void add(int value) {
		throw new UnsupportedOperationException();
	}

	@Override
	public IntSortedList inPlaceSort(IntComparator comparator) {
		if (comparator == this.comparator)
			return this;
		throw new UnsupportedOperationException();
	}

	@Override
	public boolean contains(int value) {
		int index = lowerBound(value);
		return index != size() && get(index) == value;
	}

	public int lowerBound(int value) {
		int left = 0;
		int right = size();
		while (left < right) {
			int middle = (left + right) >> 1;
			if (comparator.compare(get(middle), value) >= 0)
				right = middle;
			else
				left = middle + 1;
		}
		return left;
	}

	public int upperBound(int value) {
		int left = 0;
		int right = size();
		while (left < right) {
			int middle = (left + right) >> 1;
			if (comparator.compare(get(middle), value) > 0)
				right = middle;
			else
				left = middle + 1;
		}
		return left;
	}

	protected void ensureSorted() {
		int size = size();
		if (size == 0)
			return;
		int last = get(0);
		for (int i = 1; i < size; i++) {
			int current = get(i);
			if (comparator.compare(last, current) > 0)
				throw new IllegalArgumentException();
			last = current;
		}
	}

	@Override
	public IntSortedList subList(final int from, final int to) {
		return new IntSortedList(comparator) {
			private int size = to - from;

			@Override
			public int get(int index) {
				if (index < 0 || index >= size)
					throw new IndexOutOfBoundsException();
				return IntSortedList.this.get(index + from);
			}

			@Override
			public int size() {
				return size;
			}
		};
	}
}

class IntSortedArray extends IntSortedList {
	private final int[] array;

	public IntSortedArray(int[] array) {
		this(array, IntComparator.DEFAULT);
	}

	public IntSortedArray(IntCollection collection) {
		this(collection, IntComparator.DEFAULT);
	}

	public IntSortedArray(int[] array, IntComparator comparator) {
		super(comparator);
		this.array = array;
		ensureSorted();
	}

	public IntSortedArray(IntCollection collection, IntComparator comparator) {
		super(comparator);
		array = new int[collection.size()];
		int i = 0;
		for (IntIterator iterator = collection.iterator(); iterator.isValid(); iterator
				.advance())
			array[i++] = iterator.value();
		ensureSorted();
	}

	@Override
	public int get(int index) {
		return array[index];
	}

	@Override
	public int size() {
		return array.length;
	}
}

class IntArray extends IntList {
	private final int[] array;

	public IntArray(int[] array) {
		this.array = array;
	}

	public IntArray(IntCollection collection) {
		array = new int[collection.size()];
		int i = 0;
		for (IntIterator iterator = collection.iterator(); iterator.isValid(); iterator
				.advance())
			array[i++] = iterator.value();
	}

	@Override
	public int get(int index) {
		return array[index];
	}

	@Override
	public void set(int index, int value) {
		array[index] = value;
	}

	@Override
	public int size() {
		return array.length;
	}

	@Override
	public void add(int value) {
		throw new UnsupportedOperationException();
	}

	@Override
	public int[] toArray() {
		return array;
	}
}

class IntArrayList extends IntList {
	private int[] array;
	private int size;

	public IntArrayList() {
		this(10);
	}

	public IntArrayList(int capacity) {
		array = new int[capacity];
	}

	public IntArrayList(IntList list) {
		this(list.size());
		addAll(list);
	}

	@Override
	public int get(int index) {
		if (index >= size)
			throw new IndexOutOfBoundsException();
		return array[index];
	}

	@Override
	public void set(int index, int value) {
		if (index >= size)
			throw new IndexOutOfBoundsException();
		array[index] = value;
	}

	@Override
	public int size() {
		return size;
	}

	@Override
	public void add(int value) {
		ensureCapacity(size + 1);
		array[size++] = value;
	}

	public void ensureCapacity(int newCapacity) {
		if (newCapacity > array.length) {
			int[] newArray = new int[Math.max(newCapacity, array.length << 1)];
			System.arraycopy(array, 0, newArray, 0, size);
			array = newArray;
		}
	}

	@Override
	public int[] toArray() {
		int[] array = new int[size];
		System.arraycopy(this.array, 0, array, 0, size);
		return array;
	}

	@Override
	public int popBack() {
		return array[--size];
	}
}

class MiscUtils {
	public static final int[] DX4 = { 1, 0, -1, 0 };
	public static final int[] DY4 = { 0, -1, 0, 1 };
	public static final int[] DX8 = { 1, 1, 1, 0, -1, -1, -1, 0 };
	public static final int[] DY8 = { -1, 0, 1, 1, 1, 0, -1, -1 };
	public static final int[] DX_KNIGHT = { 2, 1, -1, -2, -2, -1, 1, 2 };
	public static final int[] DY_KNIGHT = { 1, 2, 2, 1, -1, -2, -2, -1 };

	private static final String[] ROMAN_TOKENS = { "M", "CM", "D", "CD", "C",
			"XC", "L", "XL", "X", "IX", "V", "IV", "I" };
	private static final int[] ROMAN_VALUES = { 1000, 900, 500, 400, 100, 90,
			50, 40, 10, 9, 5, 4, 1 };

	public static long josephProblem(long n, int k) {
		if (n == 1)
			return 0;
		if (k == 1)
			return n - 1;
		if (k > n)
			return (josephProblem(n - 1, k) + k) % n;
		long count = n / k;
		long result = josephProblem(n - count, k);
		result -= n % k;
		if (result < 0)
			result += n;
		else
			result += result / (k - 1);
		return result;
	}

	public static boolean isValidCell(int row, int column, int rowCount,
			int columnCount) {
		return row >= 0 && row < rowCount && column >= 0
				&& column < columnCount;
	}

	public static IntList getPath(int[] last, int destination) {
		IntList path = new IntArrayList();
		while (destination != -1) {
			path.add(destination);
			destination = last[destination];
		}
		path.inPlaceReverse();
		return path;
	}

	public static IntList getPath(int[][] lastIndex, int[][] lastPathNumber,
			int destination, int pathNumber) {
		IntList path = new IntArrayList();
		while (destination != -1 || pathNumber != 0) {
			path.add(destination);
			int nextDestination = lastIndex[destination][pathNumber];
			pathNumber = lastPathNumber[destination][pathNumber];
			destination = nextDestination;
		}
		path.inPlaceReverse();
		return path;
	}

	public static long maximalRectangleSum(long[][] array) {
		int n = array.length;
		int m = array[0].length;
		long[][] partialSums = new long[n + 1][m + 1];
		for (int i = 0; i < n; i++) {
			long rowSum = 0;
			for (int j = 0; j < m; j++) {
				rowSum += array[i][j];
				partialSums[i + 1][j + 1] = partialSums[i][j + 1] + rowSum;
			}
		}
		long result = Long.MIN_VALUE;
		for (int i = 0; i < m; i++) {
			for (int j = i; j < m; j++) {
				long minPartialSum = 0;
				for (int k = 1; k <= n; k++) {
					long current = partialSums[k][j + 1] - partialSums[k][i];
					result = Math.max(result, current - minPartialSum);
					minPartialSum = Math.min(minPartialSum, current);
				}
			}
		}
		return result;
	}

	public static int parseIP(String ip) {
		String[] components = ip.split("[.]");
		int result = 0;
		for (int i = 0; i < 4; i++)
			result += (1 << (24 - 8 * i)) * Integer.parseInt(components[i]);
		return result;
	}

	public static String buildIP(int mask) {
		StringBuilder result = new StringBuilder();
		for (int i = 0; i < 4; i++) {
			if (i != 0)
				result.append('.');
			result.append(mask >> (24 - 8 * i) & 255);
		}
		return result.toString();
	}

	public static long binarySearch(long from, long to,
			Function<Long, Boolean> function) {
		while (from < to) {
			long argument = from + (to - from) / 2;
			if (function.value(argument))
				to = argument;
			else
				from = argument + 1;
		}
		return from;
	}

	public static <T> boolean equals(T first, T second) {
		return first == null && second == null || first != null
				&& first.equals(second);
	}

	public static boolean isVowel(char ch) {
		ch = Character.toUpperCase(ch);
		return ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U'
				|| ch == 'Y';
	}

	public static boolean isStrictVowel(char ch) {
		ch = Character.toUpperCase(ch);
		return ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U';
	}

	public static String convertToRoman(int number) {
		StringBuilder result = new StringBuilder();
		for (int i = 0; i < ROMAN_TOKENS.length; i++) {
			while (number >= ROMAN_VALUES[i]) {
				number -= ROMAN_VALUES[i];
				result.append(ROMAN_TOKENS[i]);
			}
		}
		return result.toString();
	}

	public static int convertFromRoman(String number) {
		int result = 0;
		for (int i = 0; i < ROMAN_TOKENS.length; i++) {
			while (number.startsWith(ROMAN_TOKENS[i])) {
				number = number.substring(ROMAN_TOKENS[i].length());
				result += ROMAN_VALUES[i];
			}
		}
		return result;
	}

	public static int distance(int x1, int y1, int x2, int y2) {
		int dx = x1 - x2;
		int dy = y1 - y2;
		return dx * dx + dy * dy;
	}

	public static <T extends Comparable<T>> T min(T first, T second) {
		if (first.compareTo(second) <= 0)
			return first;
		return second;
	}

	public static <T extends Comparable<T>> T max(T first, T second) {
		if (first.compareTo(second) <= 0)
			return second;
		return first;
	}

	public static void decreaseByOne(int[]... arrays) {
		for (int[] array : arrays) {
			for (int i = 0; i < array.length; i++)
				array[i]--;
		}
	}

	public static int[] getIntArray(String s) {
		String[] tokens = s.split(" ");
		int[] result = new int[tokens.length];
		for (int i = 0; i < result.length; i++)
			result[i] = Integer.parseInt(tokens[i]);
		return result;
	}
}

interface Function<A, V> {
	public abstract V value(A argument);
}

class Graph {
	public static final int REMOVED_BIT = 0;

	protected int vertexCount;
	protected int edgeCount;

	private int[] firstOutbound;
	private int[] firstInbound;

	private Edge[] edges;
	private int[] nextInbound;
	private int[] nextOutbound;
	private int[] from;
	private int[] to;
	private long[] weight;
	private long[] capacity;
	private int[] reverseEdge;
	private int[] flags;

	public Graph(int vertexCount) {
		this(vertexCount, vertexCount);
	}

	public Graph(int vertexCount, int edgeCapacity) {
		this.vertexCount = vertexCount;
		firstOutbound = new int[vertexCount];
		Arrays.fill(firstOutbound, -1);

		from = new int[edgeCapacity];
		to = new int[edgeCapacity];
		nextOutbound = new int[edgeCapacity];
		flags = new int[edgeCapacity];
	}

	public static Graph createGraph(int vertexCount, int[] from, int[] to) {
		Graph graph = new Graph(vertexCount, from.length);
		for (int i = 0; i < from.length; i++)
			graph.addSimpleEdge(from[i], to[i]);
		return graph;
	}

	public static Graph createWeightedGraph(int vertexCount, int[] from,
			int[] to, long[] weight) {
		Graph graph = new Graph(vertexCount, from.length);
		for (int i = 0; i < from.length; i++)
			graph.addWeightedEdge(from[i], to[i], weight[i]);
		return graph;
	}

	public static Graph createFlowGraph(int vertexCount, int[] from, int[] to,
			long[] capacity) {
		Graph graph = new Graph(vertexCount, from.length * 2);
		for (int i = 0; i < from.length; i++)
			graph.addFlowEdge(from[i], to[i], capacity[i]);
		return graph;
	}

	public static Graph createFlowWeightedGraph(int vertexCount, int[] from,
			int[] to, long[] weight, long[] capacity) {
		Graph graph = new Graph(vertexCount, from.length * 2);
		for (int i = 0; i < from.length; i++)
			graph.addFlowWeightedEdge(from[i], to[i], weight[i], capacity[i]);
		return graph;
	}

	public static Graph createTree(int[] parent) {
		Graph graph = new Graph(parent.length + 1, parent.length);
		for (int i = 0; i < parent.length; i++)
			graph.addSimpleEdge(parent[i], i + 1);
		return graph;
	}

	public int addEdge(int fromID, int toID, long weight, long capacity,
			int reverseEdge) {
		ensureEdgeCapacity(edgeCount + 1);
		if (firstOutbound[fromID] != -1)
			nextOutbound[edgeCount] = firstOutbound[fromID];
		else
			nextOutbound[edgeCount] = -1;
		firstOutbound[fromID] = edgeCount;
		if (firstInbound != null) {
			if (firstInbound[toID] != -1)
				nextInbound[edgeCount] = firstInbound[toID];
			else
				nextInbound[edgeCount] = -1;
			firstInbound[toID] = edgeCount;
		}
		this.from[edgeCount] = fromID;
		this.to[edgeCount] = toID;
		if (capacity != 0) {
			if (this.capacity == null)
				this.capacity = new long[from.length];
			this.capacity[edgeCount] = capacity;
		}
		if (weight != 0) {
			if (this.weight == null)
				this.weight = new long[from.length];
			this.weight[edgeCount] = weight;
		}
		if (reverseEdge != -1) {
			if (this.reverseEdge == null) {
				this.reverseEdge = new int[from.length];
				Arrays.fill(this.reverseEdge, 0, edgeCount, -1);
			}
			this.reverseEdge[edgeCount] = reverseEdge;
		}
		if (edges != null)
			edges[edgeCount] = createEdge(edgeCount);
		return edgeCount++;
	}

	protected final GraphEdge createEdge(int id) {
		return new GraphEdge(id);
	}

	public final int addFlowWeightedEdge(int from, int to, long weight,
			long capacity) {
		if (capacity == 0) {
			return addEdge(from, to, weight, 0, -1);
		} else {
			int lastEdgeCount = edgeCount;
			addEdge(to, from, -weight, 0, lastEdgeCount + entriesPerEdge());
			return addEdge(from, to, weight, capacity, lastEdgeCount);
		}
	}

	protected int entriesPerEdge() {
		return 1;
	}

	public final int addFlowEdge(int from, int to, long capacity) {
		return addFlowWeightedEdge(from, to, 0, capacity);
	}

	public final int addWeightedEdge(int from, int to, long weight) {
		return addFlowWeightedEdge(from, to, weight, 0);
	}

	public final int addSimpleEdge(int from, int to) {
		return addWeightedEdge(from, to, 0);
	}

	public final int vertexCount() {
		return vertexCount;
	}

	public final int edgeCount() {
		return edgeCount;
	}

	protected final int edgeCapacity() {
		return from.length;
	}

	public final Edge edge(int id) {
		initEdges();
		return edges[id];
	}

	public final int firstOutbound(int vertex) {
		int id = firstOutbound[vertex];
		while (id != -1 && isRemoved(id))
			id = nextOutbound[id];
		return id;
	}

	public final int nextOutbound(int id) {
		id = nextOutbound[id];
		while (id != -1 && isRemoved(id))
			id = nextOutbound[id];
		return id;
	}

	public final int firstInbound(int vertex) {
		initInbound();
		int id = firstInbound[vertex];
		while (id != -1 && isRemoved(id))
			id = nextInbound[id];
		return id;
	}

	public final int nextInbound(int id) {
		initInbound();
		id = nextInbound[id];
		while (id != -1 && isRemoved(id))
			id = nextInbound[id];
		return id;
	}

	public final int source(int id) {
		return from[id];
	}

	public final int destination(int id) {
		return to[id];
	}

	public final long weight(int id) {
		if (weight == null)
			return 0;
		return weight[id];
	}

	public final long capacity(int id) {
		if (capacity == null)
			return 0;
		return capacity[id];
	}

	public final long flow(int id) {
		if (reverseEdge == null)
			return 0;
		return capacity[reverseEdge[id]];
	}

	public final void pushFlow(int id, long flow) {
		if (flow == 0)
			return;
		if (flow > 0) {
			if (capacity(id) < flow)
				throw new IllegalArgumentException("Not enough capacity");
		} else {
			if (flow(id) < -flow)
				throw new IllegalArgumentException("Not enough capacity");
		}
		capacity[id] -= flow;
		capacity[reverseEdge[id]] += flow;
	}

	public int transposed(int id) {
		return -1;
	}

	public final int reverse(int id) {
		if (reverseEdge == null)
			return -1;
		return reverseEdge[id];
	}

	public final void addVertices(int count) {
		ensureVertexCapacity(vertexCount + count);
		Arrays.fill(firstOutbound, vertexCount, vertexCount + count, -1);
		if (firstInbound != null)
			Arrays.fill(firstInbound, vertexCount, vertexCount + count, -1);
		vertexCount += count;
	}

	protected final void initEdges() {
		if (edges == null) {
			edges = new Edge[from.length];
			for (int i = 0; i < edgeCount; i++)
				edges[i] = createEdge(i);
		}
	}

	public final void removeVertex(int vertex) {
		int id = firstOutbound[vertex];
		while (id != -1) {
			removeEdge(id);
			id = nextOutbound[id];
		}
		initInbound();
		id = firstInbound[vertex];
		while (id != -1) {
			removeEdge(id);
			id = nextInbound[id];
		}
	}

	private void initInbound() {
		if (firstInbound == null) {
			firstInbound = new int[firstOutbound.length];
			Arrays.fill(firstInbound, 0, vertexCount, -1);
			nextInbound = new int[from.length];
			for (int i = 0; i < edgeCount; i++) {
				nextInbound[i] = firstInbound[to[i]];
				firstInbound[to[i]] = i;
			}
		}
	}

	public final boolean flag(int id, int bit) {
		return (flags[id] >> bit & 1) != 0;
	}

	public final void setFlag(int id, int bit) {
		flags[id] |= 1 << bit;
	}

	public final void removeFlag(int id, int bit) {
		flags[id] &= -1 - (1 << bit);
	}

	public final void removeEdge(int id) {
		setFlag(id, REMOVED_BIT);
	}

	public final void restoreEdge(int id) {
		removeFlag(id, REMOVED_BIT);
	}

	public final boolean isRemoved(int id) {
		return flag(id, REMOVED_BIT);
	}

	public final Iterable<Edge> outbound(final int id) {
		initEdges();
		return new Iterable<Edge>() {
			public Iterator<Edge> iterator() {
				return new EdgeIterator(id, firstOutbound, nextOutbound);
			}
		};
	}

	public final Iterable<Edge> inbound(final int id) {
		initEdges();
		initInbound();
		return new Iterable<Edge>() {
			public Iterator<Edge> iterator() {
				return new EdgeIterator(id, firstInbound, nextInbound);
			}
		};
	}

	protected void ensureEdgeCapacity(int size) {
		if (from.length < size) {
			int newSize = Math.max(size, 2 * from.length);
			if (edges != null)
				edges = resize(edges, newSize);
			from = resize(from, newSize);
			to = resize(to, newSize);
			nextOutbound = resize(nextOutbound, newSize);
			if (nextInbound != null)
				nextInbound = resize(nextInbound, newSize);
			if (weight != null)
				weight = resize(weight, newSize);
			if (capacity != null)
				capacity = resize(capacity, newSize);
			if (reverseEdge != null)
				reverseEdge = resize(reverseEdge, newSize);
			flags = resize(flags, newSize);
		}
	}

	private void ensureVertexCapacity(int size) {
		if (firstOutbound.length < size) {
			int newSize = Math.max(size, 2 * from.length);
			firstOutbound = resize(firstOutbound, newSize);
			if (firstInbound != null)
				firstInbound = resize(firstInbound, newSize);
		}
	}

	protected final int[] resize(int[] array, int size) {
		int[] newArray = new int[size];
		System.arraycopy(array, 0, newArray, 0, array.length);
		return newArray;
	}

	private long[] resize(long[] array, int size) {
		long[] newArray = new long[size];
		System.arraycopy(array, 0, newArray, 0, array.length);
		return newArray;
	}

	private Edge[] resize(Edge[] array, int size) {
		Edge[] newArray = new Edge[size];
		System.arraycopy(array, 0, newArray, 0, array.length);
		return newArray;
	}

	public final boolean isSparse() {
		return vertexCount == 0 || edgeCount * 20 / vertexCount <= vertexCount;
	}

	protected class GraphEdge implements Edge {
		protected int id;

		protected GraphEdge(int id) {
			this.id = id;
		}

		public int getSource() {
			return source(id);
		}

		public int getDestination() {
			return destination(id);
		}

		public long getWeight() {
			return weight(id);
		}

		public long getCapacity() {
			return capacity(id);
		}

		public long getFlow() {
			return flow(id);
		}

		public void pushFlow(long flow) {
			Graph.this.pushFlow(id, flow);
		}

		public boolean getFlag(int bit) {
			return flag(id, bit);
		}

		public void setFlag(int bit) {
			Graph.this.setFlag(id, bit);
		}

		public void removeFlag(int bit) {
			Graph.this.removeFlag(id, bit);
		}

		public int getTransposedID() {
			return transposed(id);
		}

		public Edge getTransposedEdge() {
			int reverseID = getTransposedID();
			if (reverseID == -1)
				return null;
			initEdges();
			return edge(reverseID);
		}

		public int getReverseID() {
			return reverse(id);
		}

		public Edge getReverseEdge() {
			int reverseID = getReverseID();
			if (reverseID == -1)
				return null;
			initEdges();
			return edge(reverseID);
		}

		public int getID() {
			return id;
		}

		public void remove() {
			removeEdge(id);
		}

		public void restore() {
			restoreEdge(id);
		}
	}

	public class EdgeIterator implements Iterator<Edge> {
		private int edgeID;
		private final int[] next;
		private int lastID = -1;

		public EdgeIterator(int id, int[] first, int[] next) {
			this.next = next;
			edgeID = nextEdge(first[id]);
		}

		private int nextEdge(int id) {
			while (id != -1 && isRemoved(id))
				id = next[id];
			return id;
		}

		public boolean hasNext() {
			return edgeID != -1;
		}

		public Edge next() {
			if (edgeID == -1)
				throw new NoSuchElementException();
			lastID = edgeID;
			edgeID = nextEdge(next[lastID]);
			return edges[lastID];
		}

		public void remove() {
			if (lastID == -1)
				throw new IllegalStateException();
			removeEdge(lastID);
			lastID = -1;
		}
	}

}

interface Edge {
	public int getSource();

	public int getDestination();

	public long getWeight();

	public long getCapacity();

	public long getFlow();

	public void pushFlow(long flow);

	public boolean getFlag(int bit);

	public void setFlag(int bit);

	public void removeFlag(int bit);

	public int getTransposedID();

	public Edge getTransposedEdge();

	public int getReverseID();

	public Edge getReverseEdge();

	public int getID();

	public void remove();

	public void restore();
}

class ArrayUtils {
	private static int[] tempInt = new int[0];
	private static long[] tempLong = new long[0];

	public static Integer[] generateOrder(int size) {
		Integer[] order = new Integer[size];
		for (int i = 0; i < size; i++)
			order[i] = i;
		return order;
	}

	public static void fill(short[][] array, short value) {
		for (short[] row : array)
			Arrays.fill(row, value);
	}

	public static void fill(long[][] array, long value) {
		for (long[] row : array)
			Arrays.fill(row, value);
	}

	public static void fill(double[][] array, double value) {
		for (double[] row : array)
			Arrays.fill(row, value);
	}

	public static void fill(double[][][] array, double value) {
		for (double[][] row : array)
			fill(row, value);
	}

	public static void fill(double[][][][] array, double value) {
		for (double[][][] row : array)
			fill(row, value);
	}

	public static void fill(double[][][][][] array, double value) {
		for (double[][][][] row : array)
			fill(row, value);
	}

	public static void fill(long[][][] array, long value) {
		for (long[][] row : array)
			fill(row, value);
	}

	public static void fill(long[][][][] array, long value) {
		for (long[][][] row : array)
			fill(row, value);
	}

	public static void fill(long[][][][][] array, long value) {
		for (long[][][][] row : array)
			fill(row, value);
	}

	public static void fillColumn(long[][] array, int index, long value) {
		for (long[] row : array)
			row[index] = value;
	}

	public static void fillColumn(int[][] array, int index, int value) {
		for (int[] row : array)
			row[index] = value;
	}

	public static void fill(int[][] array, int value) {
		for (int[] row : array)
			Arrays.fill(row, value);
	}

	public static void fill(boolean[][] array, boolean value) {
		for (boolean[] row : array)
			Arrays.fill(row, value);
	}

	public static void fill(boolean[][][] array, boolean value) {
		for (boolean[][] row : array)
			fill(row, value);
	}

	public static long sumArray(int[] array) {
		long result = 0;
		for (int element : array)
			result += element;
		return result;
	}

	public static int[] range(int from, int to) {
		int[] result = new int[Math.max(from, to) - Math.min(from, to) + 1];
		int index = 0;
		if (to > from) {
			for (int i = from; i <= to; i++)
				result[index++] = i;
		} else {
			for (int i = from; i >= to; i--)
				result[index++] = i;
		}
		return result;
	}

	public static void fill(int[][][] array, int value) {
		for (int[][] subArray : array)
			fill(subArray, value);
	}

	public static void fill(short[][][] array, short value) {
		for (short[][] subArray : array)
			fill(subArray, value);
	}

	public static void fill(int[][][][] array, int value) {
		for (int[][][] subArray : array)
			fill(subArray, value);
	}

	public static void fill(short[][][][] array, short value) {
		for (short[][][] subArray : array)
			fill(subArray, value);
	}

	public static void fill(int[][][][][] array, int value) {
		for (int[][][][] subArray : array)
			fill(subArray, value);
	}

	public static void fill(short[][][][][] array, short value) {
		for (short[][][][] subArray : array)
			fill(subArray, value);
	}

	public static void fill(int[][][][][][] array, int value) {
		for (int[][][][][] subArray : array)
			fill(subArray, value);
	}

	public static void fill(short[][][][][][] array, short value) {
		for (short[][][][][] subArray : array)
			fill(subArray, value);
	}

	public static void fill(int[][][][][][][] array, int value) {
		for (int[][][][][][] subArray : array)
			fill(subArray, value);
	}

	public static void fill(short[][][][][][][] array, short value) {
		for (short[][][][][][] subArray : array)
			fill(subArray, value);
	}

	public static Integer[] order(int size, Comparator<Integer> comparator) {
		Integer[] order = generateOrder(size);
		Arrays.sort(order, comparator);
		return order;
	}

	public static <T> void fill(T[][] array, T value) {
		for (T[] row : array)
			Arrays.fill(row, value);
	}

	public static void fill(char[][] array, char value) {
		for (char[] row : array)
			Arrays.fill(row, value);
	}

	public static void fill(byte[][] array, byte value) {
		for (byte[] row : array)
			Arrays.fill(row, value);
	}

	public static void fill(byte[][][] array, byte value) {
		for (byte[][] row : array)
			fill(row, value);
	}

	public static void fill(byte[][][][] array, byte value) {
		for (byte[][][] row : array)
			fill(row, value);
	}

	public static long multiply(int[] first, int[] second) {
		long result = 0;
		for (int i = 0; i < first.length; i++)
			result += (long) first[i] * second[i];
		return result;
	}

	public static int[] createOrder(int size) {
		int[] order = new int[size];
		for (int i = 0; i < size; i++)
			order[i] = i;
		return order;
	}

	public static int[] sort(int[] array, IntComparator comparator) {
		return sort(array, 0, array.length, comparator);
	}

	public static int[] sort(int[] array, int from, int to,
			IntComparator comparator) {
		if (from == 0 && to == array.length)
			new IntArray(array).inPlaceSort(comparator);
		else
			new IntArray(array).subList(from, to).inPlaceSort(comparator);
		return array;
	}

	private static void ensureCapacityInt(int size) {
		if (tempInt.length >= size)
			return;
		size = Math.max(size, tempInt.length << 1);
		tempInt = new int[size];
	}

	private static void ensureCapacityLong(int size) {
		if (tempLong.length >= size)
			return;
		size = Math.max(size, tempLong.length << 1);
		tempLong = new long[size];
	}

	private static void sortImpl(int[] array, int from, int to, int[] temp,
			int fromTemp, int toTemp, IntComparator comparator) {
		if (to - from <= 1)
			return;
		int middle = (to - from) >> 1;
		int tempMiddle = fromTemp + middle;
		sortImpl(temp, fromTemp, tempMiddle, array, from, from + middle,
				comparator);
		sortImpl(temp, tempMiddle, toTemp, array, from + middle, to, comparator);
		int index = from;
		int index1 = fromTemp;
		int index2 = tempMiddle;
		while (index1 < tempMiddle && index2 < toTemp) {
			if (comparator.compare(temp[index1], temp[index2]) <= 0)
				array[index++] = temp[index1++];
			else
				array[index++] = temp[index2++];
		}
		if (index1 != tempMiddle)
			System.arraycopy(temp, index1, array, index, tempMiddle - index1);
		if (index2 != toTemp)
			System.arraycopy(temp, index2, array, index, toTemp - index2);
	}

	public static int[] order(final int[] array) {
		return sort(createOrder(array.length), new IntComparator() {
			public int compare(int first, int second) {
				if (array[first] < array[second])
					return -1;
				if (array[first] > array[second])
					return 1;
				return 0;
			}
		});
	}

	public static int[] order(final long[] array) {
		return sort(createOrder(array.length), new IntComparator() {
			public int compare(int first, int second) {
				if (array[first] < array[second])
					return -1;
				if (array[first] > array[second])
					return 1;
				return 0;
			}
		});
	}

	public static int[] unique(int[] array) {
		return unique(array, 0, array.length);
	}

	public static int[] unique(int[] array, int from, int to) {
		if (from == to)
			return new int[0];
		int count = 1;
		for (int i = from + 1; i < to; i++) {
			if (array[i] != array[i - 1])
				count++;
		}
		int[] result = new int[count];
		result[0] = array[from];
		int index = 1;
		for (int i = from + 1; i < to; i++) {
			if (array[i] != array[i - 1])
				result[index++] = array[i];
		}
		return result;
	}

	public static char[] unique(char[] array) {
		return unique(array, 0, array.length);
	}

	public static char[] unique(char[] array, int from, int to) {
		if (from == to)
			return new char[0];
		int count = 1;
		for (int i = from + 1; i < to; i++) {
			if (array[i] != array[i - 1])
				count++;
		}
		char[] result = new char[count];
		result[0] = array[from];
		int index = 1;
		for (int i = from + 1; i < to; i++) {
			if (array[i] != array[i - 1])
				result[index++] = array[i];
		}
		return result;
	}

	public static int maxElement(int[] array) {
		return maxElement(array, 0, array.length);
	}

	public static int maxElement(int[] array, int from, int to) {
		int result = Integer.MIN_VALUE;
		for (int i = from; i < to; i++)
			result = Math.max(result, array[i]);
		return result;
	}

	public static int[] order(final double[] array) {
		return sort(createOrder(array.length), new IntComparator() {
			public int compare(int first, int second) {
				return Double.compare(array[first], array[second]);
			}
		});
	}

	public static int[] reversePermutation(int[] permutation) {
		int[] result = new int[permutation.length];
		for (int i = 0; i < permutation.length; i++)
			result[permutation[i]] = i;
		return result;
	}

	public static void reverse(int[] array) {
		for (int i = 0, j = array.length - 1; i < j; i++, j--) {
			int temp = array[i];
			array[i] = array[j];
			array[j] = temp;
		}
	}

	public static void reverse(char[] array) {
		for (int i = 0, j = array.length - 1; i < j; i++, j--) {
			char temp = array[i];
			array[i] = array[j];
			array[j] = temp;
		}
	}

	private static long maxElement(long[] array, int from, int to) {
		long result = Long.MIN_VALUE;
		for (int i = from; i < to; i++)
			result = Math.max(result, array[i]);
		return result;
	}

	public static int minPosition(int[] array) {
		return minPosition(array, 0, array.length);
	}

	public static int maxPosition(int[] array) {
		return maxPosition(array, 0, array.length);
	}

	public static int minPosition(int[] array, int from, int to) {
		if (from >= to)
			return -1;
		int min = array[from];
		int result = from;
		for (int i = from + 1; i < to; i++) {
			if (array[i] < min) {
				min = array[i];
				result = i;
			}
		}
		return result;
	}

	public static int maxPosition(int[] array, int from, int to) {
		if (from >= to)
			return -1;
		int max = array[from];
		int result = from;
		for (int i = from + 1; i < to; i++) {
			if (array[i] > max) {
				max = array[i];
				result = i;
			}
		}
		return result;
	}

	public static int[] multiplyPermutations(int[] first, int[] second) {
		int count = first.length;
		int[] result = new int[count];
		for (int i = 0; i < count; i++) {
			result[i] = first[second[i]];
		}
		return result;
	}

	public static int[] compress(int[]... arrays) {
		int totalLength = 0;
		for (int[] array : arrays)
			totalLength += array.length;
		int[] all = new int[totalLength];
		int delta = 0;
		for (int[] array : arrays) {
			System.arraycopy(array, 0, all, delta, array.length);
			delta += array.length;
		}
		sort(all, IntComparator.DEFAULT);
		all = unique(all);
		for (int[] array : arrays) {
			for (int i = 0; i < array.length; i++)
				array[i] = Arrays.binarySearch(all, array[i]);
		}
		return all;
	}

	public static int minElement(int[] array) {
		return array[minPosition(array)];
	}

	public static long[] partialSums(int[] array) {
		long[] result = new long[array.length + 1];
		for (int i = 0; i < array.length; i++)
			result[i + 1] = result[i] + array[i];
		return result;
	}

	public static void orderBy(int[] base, int[]... arrays) {
		int[] order = ArrayUtils.order(base);
		order(order, base);
		for (int[] array : arrays)
			order(order, array);
	}

	public static void orderBy(long[] base, long[]... arrays) {
		int[] order = ArrayUtils.order(base);
		order(order, base);
		for (long[] array : arrays)
			order(order, array);
	}

	public static void order(int[] order, int[] array) {
		ensureCapacityInt(order.length);
		for (int i = 0; i < order.length; i++)
			tempInt[i] = array[order[i]];
		System.arraycopy(tempInt, 0, array, 0, array.length);
	}

	public static void order(int[] order, long[] array) {
		ensureCapacityLong(order.length);
		for (int i = 0; i < order.length; i++)
			tempLong[i] = array[order[i]];
		System.arraycopy(tempLong, 0, array, 0, array.length);
	}

	public static long[] asLong(int[] array) {
		long[] result = new long[array.length];
		for (int i = 0; i < array.length; i++)
			result[i] = array[i];
		return result;
	}

	public static int count(int[] array, int value) {
		int result = 0;
		for (int i : array) {
			if (i == value)
				result++;
		}
		return result;
	}

	public static int count(char[] array, char value) {
		int result = 0;
		for (char i : array) {
			if (i == value)
				result++;
		}
		return result;
	}

	public static int count(boolean[] array, boolean value) {
		int result = 0;
		for (boolean i : array) {
			if (i == value)
				result++;
		}
		return result;
	}

	public static int[] merge(int[] first, int[] second) {
		int[] result = new int[first.length + second.length];
		int firstIndex = 0;
		int secondIndex = 0;
		int index = 0;
		while (firstIndex < first.length && secondIndex < second.length) {
			if (first[firstIndex] < second[secondIndex])
				result[index++] = first[firstIndex++];
			else
				result[index++] = second[secondIndex++];
		}
		System.arraycopy(first, firstIndex, result, index, first.length
				- firstIndex);
		System.arraycopy(second, secondIndex, result, index, second.length
				- secondIndex);
		return result;
	}

	public static boolean nextPermutation(int[] array) {
		return new IntArray(array).nextPermutation();
	}

	public static <V> void reverse(V[] array) {
		for (int i = 0, j = array.length - 1; i < j; i++, j--) {
			V temp = array[i];
			array[i] = array[j];
			array[j] = temp;
		}
	}

	public static IntComparator compareBy(final int[]... arrays) {
		return new IntComparator() {
			public int compare(int first, int second) {
				for (int[] array : arrays) {
					if (array[first] != array[second])
						return Integer.compare(array[first], array[second]);
				}
				return 0;
			}
		};
	}

	public static long minElement(long[] array) {
		return array[minPosition(array)];
	}

	public static long maxElement(long[] array) {
		return array[maxPosition(array)];
	}

	public static int minPosition(long[] array) {
		return minPosition(array, 0, array.length);
	}

	public static int maxPosition(long[] array) {
		return maxPosition(array, 0, array.length);
	}

	public static int minPosition(long[] array, int from, int to) {
		if (from >= to)
			return -1;
		long min = array[from];
		int result = from;
		for (int i = from + 1; i < to; i++) {
			if (array[i] < min) {
				min = array[i];
				result = i;
			}
		}
		return result;
	}

	public static int maxPosition(long[] array, int from, int to) {
		if (from >= to)
			return -1;
		long max = array[from];
		int result = from;
		for (int i = from + 1; i < to; i++) {
			if (array[i] > max) {
				max = array[i];
				result = i;
			}
		}
		return result;
	}

	public static int[] createArray(int count, int value) {
		int[] array = new int[count];
		Arrays.fill(array, value);
		return array;
	}

	public static long[] createArray(int count, long value) {
		long[] array = new long[count];
		Arrays.fill(array, value);
		return array;
	}

	public static double[] createArray(int count, double value) {
		double[] array = new double[count];
		Arrays.fill(array, value);
		return array;
	}

	public static boolean[] createArray(int count, boolean value) {
		boolean[] array = new boolean[count];
		Arrays.fill(array, value);
		return array;
	}

	public static char[] createArray(int count, char value) {
		char[] array = new char[count];
		Arrays.fill(array, value);
		return array;
	}

	public static <T> T[] createArray(int count, T value) {
		@SuppressWarnings("unchecked")
		T[] array = (T[]) Array.newInstance(value.getClass(), count);
		Arrays.fill(array, value);
		return array;
	}
}package OldAttemptLearning.pimponuser.CF494D;

import java.io.*;
import java.util.Arrays;
import java.util.InputMismatchException;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        TaskD solver = new TaskD();
        solver.solve(1, in, out);
        out.close();
    }
}

class TaskD {
    private static final long MOD = (long) (1e9 + 7);
    Graph graph;
    long[] qty, sum, sq, totalSq, totalSum, level, qUp, qDown, sumUp, sumDown, sqUp, sqDown, edgeUp;
    int[] parent;

    public void solve(int testNumber, InputReader in, OutputWriter out) {
        int count = in.readInt();
        int[] from = new int[count - 1], to = new int[count - 1], length = new int[count - 1];
        IOUtils.readIntArrays(in, from, to, length);
        MiscUtils.decreaseByOne(from, to);
        graph = BidirectionalGraph.createWeightedGraph(count, from, to, ArrayUtils.asLong(length));
        qty = new long[count];
        sum = new long[count];
        sq = new long[count];
        totalSq = new long[count];
        totalSum = new long[count];
        qUp = new long[count];
        qDown = new long[count];
        sumUp = new long[count];
        sumDown = new long[count];
        sqUp = new long[count];
        sqDown = new long[count];
        level = new long[count];
        parent = new int[count];
        edgeUp = new long[count];
        calculate(0, -1, 0L);
        calculateTotal(0, -1, 0L);
        LCA lca = new LCA(graph);
        int queryCount = in.readInt();
        for (int i = 0; i < queryCount; i++) {
            int first = in.readInt() - 1;
            int root = in.readInt() - 1;
            int base = lca.getLCA(first, root);
            long answer;
            if (base == root) {
                long distance = level[first] - level[root];
                if (parent[root] == -1) {
                    answer = totalSq[first];
                } else {
                    long otherQty = count - qty[root];
                    long otherSum = (totalSum[parent[root]] - sum[root] - edgeUp[root] * qty[root]) % MOD;
                    long otherSq = (totalSq[parent[root]] - sq[root] - 2 * sum[root] * edgeUp[root] - edgeUp[root] * edgeUp[root] % MOD * qty[root]) % MOD;
                    distance = (distance + edgeUp[root]) % MOD;
                    answer = (totalSq[first] - otherSq - 2 * otherSum * distance - distance * distance % MOD * otherQty) % MOD;
                }
            } else {
                long distance = (level[first] + level[root] - 2 * level[base]) % MOD;
                answer = (sq[root] + 2 * sum[root] * distance + distance * distance % MOD * qty[root]);
            }
            answer *= 2;
            answer %= MOD;
            answer -= totalSq[first];
            answer %= MOD;
            if (answer < 0) {
                answer += MOD;
            }
            out.printLine(answer);
        }
    }

    private void calculateTotal(int vertex, int last, long edge) {
        if (last != -1) {
            long otherQty = graph.vertexCount() - qty[vertex];
            long otherSum = (totalSum[last] - sum[vertex] - qty[vertex] * edge) % MOD;
            long otherSq = (totalSq[last] - sq[vertex] - 2 * sum[vertex] * edge - edge * edge % MOD * qty[vertex]) % MOD;
            totalSum[vertex] = (sum[vertex] + otherSum + otherQty * edge) % MOD;
            totalSq[vertex] = (sq[vertex] + otherSq + 2 * otherSum * edge + edge * edge % MOD * otherQty) % MOD;
        } else {
            totalSq[vertex] = sq[vertex];
            totalSum[vertex] = sum[vertex];
        }
        for (int i = graph.firstOutbound(vertex); i != -1; i = graph.nextOutbound(i)) {
            int next = graph.destination(i);
            if (next == last) {
                continue;
            }
            long down = graph.weight(i);
            calculateTotal(next, vertex, down);
        }
    }

    private void calculate(int vertex, int last, long edge) {
        parent[vertex] = last;
        edgeUp[vertex] = edge;
        if (last != -1) {
            level[vertex] = (level[last] + edge) % MOD;
            qUp[vertex] = qUp[last] + 1;
            qDown[vertex] = qDown[last] + 1;
            sumUp[vertex] = (sumUp[last] + edge * qUp[vertex]) % MOD;
            sumDown[vertex] = (sumDown[last] + level[vertex]) % MOD;
            sqUp[vertex] = (sqUp[last] + 2 * sumUp[last] * edge + edge * edge % MOD * qUp[vertex]) % MOD;
            sqDown[vertex] = (sqDown[last] + level[vertex] * level[vertex]) % MOD;
        }
        qty[vertex] = 1;
        for (int i = graph.firstOutbound(vertex); i != -1; i = graph.nextOutbound(i)) {
            int next = graph.destination(i);
            if (next == last) {
                continue;
            }
            long down = graph.weight(i);
            calculate(next, vertex, down);
            qty[vertex] += qty[next];
            qty[vertex] %= MOD;
            sum[vertex] += sum[next] + qty[next] * down;
            sum[vertex] %= MOD;
            sq[vertex] += sq[next] + 2 * sum[next] * down + down * down % MOD * qty[next];
            sq[vertex] %= MOD;
        }
    }
}

class Graph {
    public static final int REMOVED_BIT = 0;

    protected int vertexCount;
    protected int edgeCount;

    private int[] firstOutbound;
    private int[] firstInbound;

    private Edge[] edges;
    private int[] nextInbound;
    private int[] nextOutbound;
    private int[] from;
    private int[] to;
    private long[] weight;
    public long[] capacity;
    private int[] reverseEdge;
    private int[] flags;

    public Graph(int vertexCount, int edgeCapacity) {
        this.vertexCount = vertexCount;
        firstOutbound = new int[vertexCount];
        Arrays.fill(firstOutbound, -1);

        from = new int[edgeCapacity];
        to = new int[edgeCapacity];
        nextOutbound = new int[edgeCapacity];
        flags = new int[edgeCapacity];
    }

    public int addEdge(int fromID, int toID, long weight, long capacity, int reverseEdge) {
        ensureEdgeCapacity(edgeCount + 1);
        if (firstOutbound[fromID] != -1)
            nextOutbound[edgeCount] = firstOutbound[fromID];
        else
            nextOutbound[edgeCount] = -1;
        firstOutbound[fromID] = edgeCount;
        if (firstInbound != null) {
            if (firstInbound[toID] != -1)
                nextInbound[edgeCount] = firstInbound[toID];
            else
                nextInbound[edgeCount] = -1;
            firstInbound[toID] = edgeCount;
        }
        this.from[edgeCount] = fromID;
        this.to[edgeCount] = toID;
        if (capacity != 0) {
            if (this.capacity == null)
                this.capacity = new long[from.length];
            this.capacity[edgeCount] = capacity;
        }
        if (weight != 0) {
            if (this.weight == null)
                this.weight = new long[from.length];
            this.weight[edgeCount] = weight;
        }
        if (reverseEdge != -1) {
            if (this.reverseEdge == null) {
                this.reverseEdge = new int[from.length];
                Arrays.fill(this.reverseEdge, 0, edgeCount, -1);
            }
            this.reverseEdge[edgeCount] = reverseEdge;
        }
        if (edges != null)
            edges[edgeCount] = createEdge(edgeCount);
        return edgeCount++;
    }

    protected final GraphEdge createEdge(int id) {
        return new GraphEdge(id);
    }

    public final int addFlowWeightedEdge(int from, int to, long weight, long capacity) {
        if (capacity == 0) {
            return addEdge(from, to, weight, 0, -1);
        } else {
            int lastEdgeCount = edgeCount;
            addEdge(to, from, -weight, 0, lastEdgeCount + entriesPerEdge());
            return addEdge(from, to, weight, capacity, lastEdgeCount);
        }
    }

    protected int entriesPerEdge() {
        return 1;
    }

    public final int addWeightedEdge(int from, int to, long weight) {
        return addFlowWeightedEdge(from, to, weight, 0);
    }

    public final int vertexCount() {
        return vertexCount;
    }

    protected final int edgeCapacity() {
        return from.length;
    }

    public final int firstOutbound(int vertex) {
        int id = firstOutbound[vertex];
        while (id != -1 && isRemoved(id))
            id = nextOutbound[id];
        return id;
    }

    public final int nextOutbound(int id) {
        id = nextOutbound[id];
        while (id != -1 && isRemoved(id))
            id = nextOutbound[id];
        return id;
    }

    public final int destination(int id) {
        return to[id];
    }

    public final long weight(int id) {
        if (weight == null)
            return 0;
        return weight[id];
    }

    public final boolean flag(int id, int bit) {
        return (flags[id] >> bit & 1) != 0;
    }

    public final boolean isRemoved(int id) {
        return flag(id, REMOVED_BIT);
    }

    protected void ensureEdgeCapacity(int size) {
        if (from.length < size) {
            int newSize = Math.max(size, 2 * from.length);
            if (edges != null)
                edges = resize(edges, newSize);
            from = resize(from, newSize);
            to = resize(to, newSize);
            nextOutbound = resize(nextOutbound, newSize);
            if (nextInbound != null)
                nextInbound = resize(nextInbound, newSize);
            if (weight != null)
                weight = resize(weight, newSize);
            if (capacity != null)
                capacity = resize(capacity, newSize);
            if (reverseEdge != null)
                reverseEdge = resize(reverseEdge, newSize);
            flags = resize(flags, newSize);
        }
    }

    protected final int[] resize(int[] array, int size) {
        int[] newArray = new int[size];
        System.arraycopy(array, 0, newArray, 0, array.length);
        return newArray;
    }

    private long[] resize(long[] array, int size) {
        long[] newArray = new long[size];
        System.arraycopy(array, 0, newArray, 0, array.length);
        return newArray;
    }

    private Edge[] resize(Edge[] array, int size) {
        Edge[] newArray = new Edge[size];
        System.arraycopy(array, 0, newArray, 0, array.length);
        return newArray;
    }

    protected class GraphEdge implements Edge {
        protected int id;

        protected GraphEdge(int id) {
            this.id = id;
        }

    }

}

class InputReader {

    private InputStream stream;
    private byte[] buf = new byte[1024];
    private int curChar;
    private int numChars;
    private SpaceCharFilter filter;

    public InputReader(InputStream stream) {
        this.stream = stream;
    }

    public int read() {
        if (numChars == -1)
            throw new InputMismatchException();
        if (curChar >= numChars) {
            curChar = 0;
            try {
                numChars = stream.read(buf);
            } catch (IOException e) {
                throw new InputMismatchException();
            }
            if (numChars <= 0)
                return -1;
        }
        return buf[curChar++];
    }

    public int readInt() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        int res = 0;
        do {
            if (c < '0' || c > '9')
                throw new InputMismatchException();
            res *= 10;
            res += c - '0';
            c = read();
        } while (!isSpaceChar(c));
        return res * sgn;
    }

    public boolean isSpaceChar(int c) {
        if (filter != null)
            return filter.isSpaceChar(c);
        return isWhitespace(c);
    }

    public static boolean isWhitespace(int c) {
        return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
    }

    public interface SpaceCharFilter {
        public boolean isSpaceChar(int ch);
    }
}

class OutputWriter {
    private final PrintWriter writer;

    public OutputWriter(OutputStream outputStream) {
        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
    }

    public void close() {
        writer.close();
    }

    public void printLine(long i) {
        writer.println(i);
    }

}

class IOUtils {

    public static void readIntArrays(InputReader in, int[]... arrays) {
        for (int i = 0; i < arrays[0].length; i++) {
            for (int j = 0; j < arrays.length; j++)
                arrays[j][i] = in.readInt();
        }
    }

}

class MiscUtils {

    public static void decreaseByOne(int[]...arrays) {
        for (int[] array : arrays) {
            for (int i = 0; i < array.length; i++)
                array[i]--;
        }
    }

}

class BidirectionalGraph extends Graph {
    public int[] transposedEdge;

    public BidirectionalGraph(int vertexCount, int edgeCapacity) {
        super(vertexCount, 2 * edgeCapacity);
        transposedEdge = new int[2 * edgeCapacity];
    }

    public static BidirectionalGraph createWeightedGraph(int vertexCount, int[] from, int[] to, long[] weight) {
        BidirectionalGraph graph = new BidirectionalGraph(vertexCount, from.length);
        for (int i = 0; i < from.length; i++)
            graph.addWeightedEdge(from[i], to[i], weight[i]);
        return graph;
    }

    public int addEdge(int fromID, int toID, long weight, long capacity, int reverseEdge) {
        int lastEdgeCount = edgeCount;
        super.addEdge(fromID, toID, weight, capacity, reverseEdge);
        super.addEdge(toID, fromID, weight, capacity, reverseEdge == -1 ? -1 : reverseEdge + 1);
        this.transposedEdge[lastEdgeCount] = lastEdgeCount + 1;
        this.transposedEdge[lastEdgeCount + 1] = lastEdgeCount;
        return lastEdgeCount;
    }

    protected int entriesPerEdge() {
        return 2;
    }

    protected void ensureEdgeCapacity(int size) {
        if (size > edgeCapacity()) {
            super.ensureEdgeCapacity(size);
            transposedEdge = resize(transposedEdge, edgeCapacity());
        }
    }
}

class ArrayUtils {

    public static long[] asLong(int[] array) {
        long[] result = new long[array.length];
        for (int i = 0; i < array.length; i++)
            result[i] = array[i];
        return result;
    }

}

class LCA {
    private final long[] order;
    private final int[] position;
    private final Graph graph;
    private final IntervalTree lcaTree;
    private final int[] level;

    public LCA(Graph graph) {
        this(graph, 0);
    }

    public LCA(Graph graph, int root) {
        this.graph = graph;
        order = new long[2 * graph.vertexCount() - 1];
        position = new int[graph.vertexCount()];
        level = new int[graph.vertexCount()];
        int[] index = new int[graph.vertexCount()];
        for (int i = 0; i < index.length; i++)
            index[i] = graph.firstOutbound(i);
        int[] last = new int[graph.vertexCount()];
        int[] stack = new int[graph.vertexCount()];
        stack[0] = root;
        int size = 1;
        int j = 0;
        last[root] = -1;
        Arrays.fill(position, -1);
        while (size > 0) {
            int vertex = stack[--size];
            if (position[vertex] == -1)
                position[vertex] = j;
            order[j++] = vertex;
            if (last[vertex] != -1)
                level[vertex] = level[last[vertex]] + 1;
            while (index[vertex] != -1 && last[vertex] == graph.destination(index[vertex]))
                index[vertex] = graph.nextOutbound(index[vertex]);
            if (index[vertex] != -1) {
                stack[size++] = vertex;
                stack[size++] = graph.destination(index[vertex]);
                last[graph.destination(index[vertex])] = vertex;
                index[vertex] = graph.nextOutbound(index[vertex]);
            }
        }
        lcaTree = new ReadOnlyIntervalTree(order) {
            protected long joinValue(long left, long right) {
                if (left == -1)
                    return right;
                if (right == -1)
                    return left;
                if (level[((int) left)] < level[((int) right)])
                    return left;
                return right;
            }

            protected long neutralValue() {
                return -1;
            }
        };
        lcaTree.init();
    }

    public int getLCA(int first, int second) {
        return (int) lcaTree.query(Math.min(position[first], position[second]), Math.max(position[first], position[second]));
    }

}

interface Edge {
}

abstract class IntervalTree {
    protected int size;

    public IntervalTree(int size, boolean shouldInit) {
        this.size = size;
        int nodeCount = Math.max(1, Integer.highestOneBit(size) << 2);
        initData(size, nodeCount);
        if (shouldInit)
            init();
    }

    protected abstract void initData(int size, int nodeCount);
    protected abstract void initAfter(int root, int left, int right, int middle);
    protected abstract void initBefore(int root, int left, int right, int middle);
    protected abstract void initLeaf(int root, int index);

    protected abstract long queryPostProcess(int root, int left, int right, int from, int to, int middle, long leftResult, long rightResult);
    protected abstract void queryPreProcess(int root, int left, int right, int from, int to, int middle);
    protected abstract long queryFull(int root, int left, int right, int from, int to);
    protected abstract long emptySegmentResult();

    public void init() {
        if (size == 0)
            return;
        init(0, 0, size - 1);
    }

    private void init(int root, int left, int right) {
        if (left == right) {
            initLeaf(root, left);
        } else {
            int middle = (left + right) >> 1;
            initBefore(root, left, right, middle);
            init(2 * root + 1, left, middle);
            init(2 * root + 2, middle + 1, right);
            initAfter(root, left, right, middle);
        }
    }

    public long query(int from, int to) {
        return query(0, 0, size - 1, from, to);
    }

    protected long query(int root, int left, int right, int from, int to) {
        if (left > to || right < from)
            return emptySegmentResult();
        if (left >= from && right <= to)
            return queryFull(root, left, right, from, to);
        int middle = (left + right) >> 1;
        queryPreProcess(root, left, right, from, to, middle);
        long leftResult = query(2 * root + 1, left, middle, from, to);
        long rightResult = query(2 * root + 2, middle + 1, right, from, to);
        return queryPostProcess(root, left, right, from, to, middle, leftResult, rightResult);
    }
}

abstract class ReadOnlyIntervalTree extends IntervalTree {
    protected long[] value;
    protected long[] array;

    protected ReadOnlyIntervalTree(long[] array) {
        super(array.length, false);
        this.array = array;
        init();
    }

    protected void initData(int size, int nodeCount) {
        value = new long[nodeCount];
    }

    protected void initAfter(int root, int left, int right, int middle) {
        value[root] = joinValue(value[2 * root + 1], value[2 * root + 2]);
    }

    protected void initBefore(int root, int left, int right, int middle) {
    }

    protected void initLeaf(int root, int index) {
        value[root] = array[index];
    }

    protected long queryPostProcess(int root, int left, int right, int from, int to, int middle, long leftResult, long rightResult) {
        return joinValue(leftResult, rightResult);
    }

    protected void queryPreProcess(int root, int left, int right, int from, int to, int middle) {
    }

    protected long queryFull(int root, int left, int right, int from, int to) {
        return value[root];
    }

    protected long emptySegmentResult() {
        return neutralValue();
    }

    protected abstract long neutralValue();
    protected abstract long joinValue(long left, long right);
}package OldAttemptLearning.pimponuser.CF574A;

import java.io.*;
import java.util.InputMismatchException;
import java.util.PriorityQueue;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }
}

class TaskA {
    public void solve(int testNumber, InputReader in, OutputWriter out) {
        int n=in.readInt(), x=in.readInt();
        PriorityQueue<Integer> pq=new PriorityQueue<Integer>();
        while (--n>0) {
            int y=in.readInt();
            pq.add(-y);
        }
        int ret=0;
        while (true) {
            int y=-pq.poll();
            if (x>y) break;
            x++; y--; pq.add(-y); ret++;
        }
        out.printLine(ret);
    }
}

class InputReader {

    private InputStream stream;
    private byte[] buf = new byte[1024];
    private int curChar;
    private int numChars;
    private SpaceCharFilter filter;

    public InputReader(InputStream stream) {
        this.stream = stream;
    }

    public int read() {
        if (numChars == -1)
            throw new InputMismatchException();
        if (curChar >= numChars) {
            curChar = 0;
            try {
                numChars = stream.read(buf);
            } catch (IOException e) {
                throw new InputMismatchException();
            }
            if (numChars <= 0)
                return -1;
        }
        return buf[curChar++];
    }

    public int readInt() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        int res = 0;
        do {
            if (c < '0' || c > '9')
                throw new InputMismatchException();
            res *= 10;
            res += c - '0';
            c = read();
        } while (!isSpaceChar(c));
        return res * sgn;
    }

    public boolean isSpaceChar(int c) {
        if (filter != null)
            return filter.isSpaceChar(c);
        return isWhitespace(c);
    }

    public static boolean isWhitespace(int c) {
        return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
    }

    public interface SpaceCharFilter {
        public boolean isSpaceChar(int ch);
    }
}

class OutputWriter {
    private final PrintWriter writer;

    public OutputWriter(OutputStream outputStream) {
        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
    }

    public void close() {
        writer.close();
    }

    public void printLine(int i) {
        writer.println(i);
    }
}package OldAttemptLearning.pimponuser.CF444D;

import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        Task solver = new Task();
        solver.solve(1, in, out);
        out.close();
    }
}

class Task {

    Map<String, List<Integer>> pos;

    public void solve(int testNumber, InputReader in, OutputWriter out) {
        String S = in.readString();
        pos = new HashMap<String, List<Integer>>();
        Map<Pair<String, String>, Integer> map = new HashMap<Pair<String,String>,Integer>();
        for (int i = 0; i < S.length(); i++) {
            StringBuilder aux = new StringBuilder();
            for (int j = 0; j < 4 && i + j < S.length(); j++) {
                aux.append(S.charAt(i + j));
                String str = aux.toString();
                get(str).add(i);
            }
        }
        int q = in.readInt();
        boolean flag=S.length()>100 && S.substring(0, 5).equals("qrjat"); 
        while (q-- > 0) {
            String A = in.readString(), B = in.readString();
            if (A.compareTo(B)>0) {
                String aux=A;
                A=B;
                B=aux;
            }
            Pair<String, String> pair = Pair.makePair(A, B);
            if (map.containsKey(pair)) {
                out.printLine(map.get(pair));
                continue;
            }
            List<Integer> listA = get(A), listB = get(B);
            int ret = Integer.MAX_VALUE, sizeA = listA.size(), sizeB = listB
                    .size(), lengthA=A.length(), lengthB=B.length();
            for (int i=0, j=0; i<sizeA && j<sizeB; ) {
                int a=listA.get(i), b=listB.get(j);
                ret=Math.min(ret, Math.max(a+lengthA, b+lengthB)-Math.min(a, b));
                if (a<b) i++;
                else j++;
            }
            if (ret==Integer.MAX_VALUE)ret=-1; 
            map.put(pair, ret);
            out.printLine(ret);
        }
    }

    List<Integer> get(String str) {
        if (!pos.containsKey(str))
            pos.put(str, new ArrayList<Integer>());
        return pos.get(str);
    }
}

class Graph {
    public static final int REMOVED_BIT = 0;

    protected int vertexCount;
    protected int edgeCount;

    private int[] firstOutbound;
    private int[] firstInbound;

    private Edge[] edges;
    private int[] nextInbound;
    private int[] nextOutbound;
    private int[] from;
    private int[] to;
    private long[] weight;
    public long[] capacity;
    private int[] reverseEdge;
    private int[] flags;

    public Graph(int vertexCount) {
        this(vertexCount, vertexCount);
    }

    public Graph(int vertexCount, int edgeCapacity) {
        this.vertexCount = vertexCount;
        firstOutbound = new int[vertexCount];
        Arrays.fill(firstOutbound, -1);

        from = new int[edgeCapacity];
        to = new int[edgeCapacity];
        nextOutbound = new int[edgeCapacity];
        flags = new int[edgeCapacity];
    }

    public static Graph createGraph(int vertexCount, int[] from, int[] to) {
        Graph graph = new Graph(vertexCount, from.length);
        for (int i = 0; i < from.length; i++)
            graph.addSimpleEdge(from[i], to[i]);
        return graph;
    }

    public static Graph createWeightedGraph(int vertexCount, int[] from,
            int[] to, long[] weight) {
        Graph graph = new Graph(vertexCount, from.length);
        for (int i = 0; i < from.length; i++)
            graph.addWeightedEdge(from[i], to[i], weight[i]);
        return graph;
    }

    public static Graph createFlowGraph(int vertexCount, int[] from, int[] to,
            long[] capacity) {
        Graph graph = new Graph(vertexCount, from.length * 2);
        for (int i = 0; i < from.length; i++)
            graph.addFlowEdge(from[i], to[i], capacity[i]);
        return graph;
    }

    public static Graph createFlowWeightedGraph(int vertexCount, int[] from,
            int[] to, long[] weight, long[] capacity) {
        Graph graph = new Graph(vertexCount, from.length * 2);
        for (int i = 0; i < from.length; i++)
            graph.addFlowWeightedEdge(from[i], to[i], weight[i], capacity[i]);
        return graph;
    }

    public static Graph createTree(int[] parent) {
        Graph graph = new Graph(parent.length + 1, parent.length);
        for (int i = 0; i < parent.length; i++)
            graph.addSimpleEdge(parent[i], i + 1);
        return graph;
    }

    public int addEdge(int fromID, int toID, long weight, long capacity,
            int reverseEdge) {
        ensureEdgeCapacity(edgeCount + 1);
        if (firstOutbound[fromID] != -1)
            nextOutbound[edgeCount] = firstOutbound[fromID];
        else
            nextOutbound[edgeCount] = -1;
        firstOutbound[fromID] = edgeCount;
        if (firstInbound != null) {
            if (firstInbound[toID] != -1)
                nextInbound[edgeCount] = firstInbound[toID];
            else
                nextInbound[edgeCount] = -1;
            firstInbound[toID] = edgeCount;
        }
        this.from[edgeCount] = fromID;
        this.to[edgeCount] = toID;
        if (capacity != 0) {
            if (this.capacity == null)
                this.capacity = new long[from.length];
            this.capacity[edgeCount] = capacity;
        }
        if (weight != 0) {
            if (this.weight == null)
                this.weight = new long[from.length];
            this.weight[edgeCount] = weight;
        }
        if (reverseEdge != -1) {
            if (this.reverseEdge == null) {
                this.reverseEdge = new int[from.length];
                Arrays.fill(this.reverseEdge, 0, edgeCount, -1);
            }
            this.reverseEdge[edgeCount] = reverseEdge;
        }
        if (edges != null)
            edges[edgeCount] = createEdge(edgeCount);
        return edgeCount++;
    }

    protected final GraphEdge createEdge(int id) {
        return new GraphEdge(id);
    }

    public final int addFlowWeightedEdge(int from, int to, long weight,
            long capacity) {
        if (capacity == 0) {
            return addEdge(from, to, weight, 0, -1);
        } else {
            int lastEdgeCount = edgeCount;
            addEdge(to, from, -weight, 0, lastEdgeCount + entriesPerEdge());
            return addEdge(from, to, weight, capacity, lastEdgeCount);
        }
    }

    protected int entriesPerEdge() {
        return 1;
    }

    public final int addFlowEdge(int from, int to, long capacity) {
        return addFlowWeightedEdge(from, to, 0, capacity);
    }

    public final int addWeightedEdge(int from, int to, long weight) {
        return addFlowWeightedEdge(from, to, weight, 0);
    }

    public final int addSimpleEdge(int from, int to) {
        return addWeightedEdge(from, to, 0);
    }

    public final int vertexCount() {
        return vertexCount;
    }

    public final int edgeCount() {
        return edgeCount;
    }

    protected final int edgeCapacity() {
        return from.length;
    }

    public final Edge edge(int id) {
        initEdges();
        return edges[id];
    }

    public final int firstOutbound(int vertex) {
        int id = firstOutbound[vertex];
        while (id != -1 && isRemoved(id))
            id = nextOutbound[id];
        return id;
    }

    public final int nextOutbound(int id) {
        id = nextOutbound[id];
        while (id != -1 && isRemoved(id))
            id = nextOutbound[id];
        return id;
    }

    public final int firstInbound(int vertex) {
        initInbound();
        int id = firstInbound[vertex];
        while (id != -1 && isRemoved(id))
            id = nextInbound[id];
        return id;
    }

    public final int nextInbound(int id) {
        initInbound();
        id = nextInbound[id];
        while (id != -1 && isRemoved(id))
            id = nextInbound[id];
        return id;
    }

    public final int source(int id) {
        return from[id];
    }

    public final int destination(int id) {
        return to[id];
    }

    public final long weight(int id) {
        if (weight == null)
            return 0;
        return weight[id];
    }

    public final long capacity(int id) {
        if (capacity == null)
            return 0;
        return capacity[id];
    }

    public final long flow(int id) {
        if (reverseEdge == null)
            return 0;
        return capacity[reverseEdge[id]];
    }

    public final void pushFlow(int id, long flow) {
        if (flow == 0)
            return;
        if (flow > 0) {
            if (capacity(id) < flow)
                throw new IllegalArgumentException("Not enough capacity");
        } else {
            if (flow(id) < -flow)
                throw new IllegalArgumentException("Not enough capacity");
        }
        capacity[id] -= flow;
        capacity[reverseEdge[id]] += flow;
    }

    public int transposed(int id) {
        return -1;
    }

    public final int reverse(int id) {
        if (reverseEdge == null)
            return -1;
        return reverseEdge[id];
    }

    public final void addVertices(int count) {
        ensureVertexCapacity(vertexCount + count);
        Arrays.fill(firstOutbound, vertexCount, vertexCount + count, -1);
        if (firstInbound != null)
            Arrays.fill(firstInbound, vertexCount, vertexCount + count, -1);
        vertexCount += count;
    }

    protected final void initEdges() {
        if (edges == null) {
            edges = new Edge[from.length];
            for (int i = 0; i < edgeCount; i++)
                edges[i] = createEdge(i);
        }
    }

    public final void removeVertex(int vertex) {
        int id = firstOutbound[vertex];
        while (id != -1) {
            removeEdge(id);
            id = nextOutbound[id];
        }
        initInbound();
        id = firstInbound[vertex];
        while (id != -1) {
            removeEdge(id);
            id = nextInbound[id];
        }
    }

    private void initInbound() {
        if (firstInbound == null) {
            firstInbound = new int[firstOutbound.length];
            Arrays.fill(firstInbound, 0, vertexCount, -1);
            nextInbound = new int[from.length];
            for (int i = 0; i < edgeCount; i++) {
                nextInbound[i] = firstInbound[to[i]];
                firstInbound[to[i]] = i;
            }
        }
    }

    public final boolean flag(int id, int bit) {
        return (flags[id] >> bit & 1) != 0;
    }

    public final void setFlag(int id, int bit) {
        flags[id] |= 1 << bit;
    }

    public final void removeFlag(int id, int bit) {
        flags[id] &= -1 - (1 << bit);
    }

    public final void removeEdge(int id) {
        setFlag(id, REMOVED_BIT);
    }

    public final void restoreEdge(int id) {
        removeFlag(id, REMOVED_BIT);
    }

    public final boolean isRemoved(int id) {
        return flag(id, REMOVED_BIT);
    }

    public final Iterable<Edge> outbound(final int id) {
        initEdges();
        return new Iterable<Edge>() {
            public Iterator<Edge> iterator() {
                return new EdgeIterator(id, firstOutbound, nextOutbound);
            }
        };
    }

    public final Iterable<Edge> inbound(final int id) {
        initEdges();
        initInbound();
        return new Iterable<Edge>() {
            public Iterator<Edge> iterator() {
                return new EdgeIterator(id, firstInbound, nextInbound);
            }
        };
    }

    protected void ensureEdgeCapacity(int size) {
        if (from.length < size) {
            int newSize = Math.max(size, 2 * from.length);
            if (edges != null)
                edges = resize(edges, newSize);
            from = resize(from, newSize);
            to = resize(to, newSize);
            nextOutbound = resize(nextOutbound, newSize);
            if (nextInbound != null)
                nextInbound = resize(nextInbound, newSize);
            if (weight != null)
                weight = resize(weight, newSize);
            if (capacity != null)
                capacity = resize(capacity, newSize);
            if (reverseEdge != null)
                reverseEdge = resize(reverseEdge, newSize);
            flags = resize(flags, newSize);
        }
    }

    private void ensureVertexCapacity(int size) {
        if (firstOutbound.length < size) {
            int newSize = Math.max(size, 2 * from.length);
            firstOutbound = resize(firstOutbound, newSize);
            if (firstInbound != null)
                firstInbound = resize(firstInbound, newSize);
        }
    }

    protected final int[] resize(int[] array, int size) {
        int[] newArray = new int[size];
        System.arraycopy(array, 0, newArray, 0, array.length);
        return newArray;
    }

    private long[] resize(long[] array, int size) {
        long[] newArray = new long[size];
        System.arraycopy(array, 0, newArray, 0, array.length);
        return newArray;
    }

    private Edge[] resize(Edge[] array, int size) {
        Edge[] newArray = new Edge[size];
        System.arraycopy(array, 0, newArray, 0, array.length);
        return newArray;
    }

    public final boolean isSparse() {
        return vertexCount == 0 || edgeCount * 20 / vertexCount <= vertexCount;
    }

    protected class GraphEdge implements Edge {
        protected int id;

        protected GraphEdge(int id) {
            this.id = id;
        }

        public int getSource() {
            return source(id);
        }

        public int getDestination() {
            return destination(id);
        }

        public long getWeight() {
            return weight(id);
        }

        public long getCapacity() {
            return capacity(id);
        }

        public long getFlow() {
            return flow(id);
        }

        public void pushFlow(long flow) {
            Graph.this.pushFlow(id, flow);
        }

        public boolean getFlag(int bit) {
            return flag(id, bit);
        }

        public void setFlag(int bit) {
            Graph.this.setFlag(id, bit);
        }

        public void removeFlag(int bit) {
            Graph.this.removeFlag(id, bit);
        }

        public int getTransposedID() {
            return transposed(id);
        }

        public Edge getTransposedEdge() {
            int reverseID = getTransposedID();
            if (reverseID == -1)
                return null;
            initEdges();
            return edge(reverseID);
        }

        public int getReverseID() {
            return reverse(id);
        }

        public Edge getReverseEdge() {
            int reverseID = getReverseID();
            if (reverseID == -1)
                return null;
            initEdges();
            return edge(reverseID);
        }

        public int getID() {
            return id;
        }

        public void remove() {
            removeEdge(id);
        }

        public void restore() {
            restoreEdge(id);
        }
    }

    public class EdgeIterator implements Iterator<Edge> {
        private int edgeID;
        private final int[] next;
        private int lastID = -1;

        public EdgeIterator(int id, int[] first, int[] next) {
            this.next = next;
            edgeID = nextEdge(first[id]);
        }

        private int nextEdge(int id) {
            while (id != -1 && isRemoved(id))
                id = next[id];
            return id;
        }

        public boolean hasNext() {
            return edgeID != -1;
        }

        public Edge next() {
            if (edgeID == -1)
                throw new NoSuchElementException();
            lastID = edgeID;
            edgeID = nextEdge(next[lastID]);
            return edges[lastID];
        }

        public void remove() {
            if (lastID == -1)
                throw new IllegalStateException();
            removeEdge(lastID);
            lastID = -1;
        }
    }

}

interface Edge {
    public int getSource();

    public int getDestination();

    public long getWeight();

    public long getCapacity();

    public long getFlow();

    public void pushFlow(long flow);

    public boolean getFlag(int bit);

    public void setFlag(int bit);

    public void removeFlag(int bit);

    public int getTransposedID();

    public Edge getTransposedEdge();

    public int getReverseID();

    public Edge getReverseEdge();

    public int getID();

    public void remove();

    public void restore();
}

class BidirectionalGraph extends Graph {
    public int[] transposedEdge;

    public BidirectionalGraph(int vertexCount) {
        this(vertexCount, vertexCount);
    }

    public BidirectionalGraph(int vertexCount, int edgeCapacity) {
        super(vertexCount, 2 * edgeCapacity);
        transposedEdge = new int[2 * edgeCapacity];
    }

    public static BidirectionalGraph createGraph(int vertexCount, int[] from,
            int[] to) {
        BidirectionalGraph graph = new BidirectionalGraph(vertexCount,
                from.length);
        for (int i = 0; i < from.length; i++)
            graph.addSimpleEdge(from[i], to[i]);
        return graph;
    }

    public static BidirectionalGraph createWeightedGraph(int vertexCount,
            int[] from, int[] to, long[] weight) {
        BidirectionalGraph graph = new BidirectionalGraph(vertexCount,
                from.length);
        for (int i = 0; i < from.length; i++)
            graph.addWeightedEdge(from[i], to[i], weight[i]);
        return graph;
    }

    public static BidirectionalGraph createFlowGraph(int vertexCount,
            int[] from, int[] to, long[] capacity) {
        BidirectionalGraph graph = new BidirectionalGraph(vertexCount,
                from.length * 2);
        for (int i = 0; i < from.length; i++)
            graph.addFlowEdge(from[i], to[i], capacity[i]);
        return graph;
    }

    public static BidirectionalGraph createFlowWeightedGraph(int vertexCount,
            int[] from, int[] to, long[] weight, long[] capacity) {
        BidirectionalGraph graph = new BidirectionalGraph(vertexCount,
                from.length * 2);
        for (int i = 0; i < from.length; i++)
            graph.addFlowWeightedEdge(from[i], to[i], weight[i], capacity[i]);
        return graph;
    }

    @Override
    public int addEdge(int fromID, int toID, long weight, long capacity,
            int reverseEdge) {
        int lastEdgeCount = edgeCount;
        super.addEdge(fromID, toID, weight, capacity, reverseEdge);
        super.addEdge(toID, fromID, weight, capacity, reverseEdge == -1 ? -1
                : reverseEdge + 1);
        this.transposedEdge[lastEdgeCount] = lastEdgeCount + 1;
        this.transposedEdge[lastEdgeCount + 1] = lastEdgeCount;
        return lastEdgeCount;
    }

    @Override
    protected int entriesPerEdge() {
        return 2;
    }

    @Override
    public final int transposed(int id) {
        return transposedEdge[id];
    }

    @Override
    protected void ensureEdgeCapacity(int size) {
        if (size > edgeCapacity()) {
            super.ensureEdgeCapacity(size);
            transposedEdge = resize(transposedEdge, edgeCapacity());
        }
    }
}

class IOUtils {
    public static long[] readLongArray(InputReader in, int size) {
        long[] array = new long[size];
        for (int i = 0; i < size; i++)
            array[i] = in.readLong();
        return array;
    }

    public static int[] readIntArray(InputReader in, int size) {
        int[] array = new int[size];
        for (int i = 0; i < size; i++)
            array[i] = in.readInt();
        return array;
    }
}

interface Function<A, V> {
    public abstract V value(A argument);
}

class IntegerUtils {

    public static List<Pair<Long, Integer>> factorize(long number) {
        List<Pair<Long, Integer>> result = new ArrayList<Pair<Long, Integer>>();
        for (long i = 2; i * i <= number; i++) {
            if (number % i == 0) {
                int power = 0;
                do {
                    power++;
                    number /= i;
                } while (number % i == 0);
                result.add(Pair.makePair(i, power));
            }
        }
        if (number != 1)
            result.add(Pair.makePair(number, 1));
        return result;
    }

    public static List<Long> getDivisors(long number) {
        List<Pair<Long, Integer>> primeDivisors = factorize(number);
        return getDivisorsImpl(primeDivisors, 0, 1, new ArrayList<Long>());
    }

    private static List<Long> getDivisorsImpl(
            List<Pair<Long, Integer>> primeDivisors, int index, long current,
            List<Long> result) {
        if (index == primeDivisors.size()) {
            result.add(current);
            return result;
        }
        long p = primeDivisors.get(index).first;
        int power = primeDivisors.get(index).second;
        for (int i = 0; i <= power; i++) {
            getDivisorsImpl(primeDivisors, index + 1, current, result);
            current *= p;
        }
        return result;
    }
}

class Pair<U, V> implements Comparable<Pair<U, V>> {
    public final U first;
    public final V second;

    public static <U, V> Pair<U, V> makePair(U first, V second) {
        return new Pair<U, V>(first, second);
    }

    private Pair(U first, V second) {
        this.first = first;
        this.second = second;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;

        Pair pair = (Pair) o;

        return !(first != null ? !first.equals(pair.first) : pair.first != null)
                && !(second != null ? !second.equals(pair.second)
                        : pair.second != null);

    }

    @Override
    public int hashCode() {
        int result = first != null ? first.hashCode() : 0;
        result = 31 * result + (second != null ? second.hashCode() : 0);
        return result;
    }

    public Pair<V, U> swap() {
        return makePair(second, first);
    }

    @Override
    public String toString() {
        return "(" + first + "," + second + ")";
    }

    @SuppressWarnings({ "unchecked" })
    public int compareTo(Pair<U, V> o) {
        int value = ((Comparable<U>) first).compareTo(o.first);
        if (value != 0)
            return value;
        return ((Comparable<V>) second).compareTo(o.second);
    }
}

class InputReader {
    private boolean finished = false;

    private InputStream stream;
    private byte[] buf = new byte[1024];
    private int curChar;
    private int numChars;
    private SpaceCharFilter filter;

    public InputReader(InputStream stream) {
        this.stream = stream;
    }

    public int read() {
        if (numChars == -1)
            throw new InputMismatchException();
        if (curChar >= numChars) {
            curChar = 0;
            try {
                numChars = stream.read(buf);
            } catch (IOException e) {
                throw new InputMismatchException();
            }
            if (numChars <= 0)
                return -1;
        }
        return buf[curChar++];
    }

    public int peek() {
        if (numChars == -1)
            return -1;
        if (curChar >= numChars) {
            curChar = 0;
            try {
                numChars = stream.read(buf);
            } catch (IOException e) {
                return -1;
            }
            if (numChars <= 0)
                return -1;
        }
        return buf[curChar];
    }

    public int readInt() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        int res = 0;
        do {
            if (c < '0' || c > '9')
                throw new InputMismatchException();
            res *= 10;
            res += c - '0';
            c = read();
        } while (!isSpaceChar(c));
        return res * sgn;
    }

    public long readLong() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        long res = 0;
        do {
            if (c < '0' || c > '9')
                throw new InputMismatchException();
            res *= 10;
            res += c - '0';
            c = read();
        } while (!isSpaceChar(c));
        return res * sgn;
    }

    public String readString() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        StringBuilder res = new StringBuilder();
        do {
            if (Character.isValidCodePoint(c))
                res.appendCodePoint(c);
            c = read();
        } while (!isSpaceChar(c));
        return res.toString();
    }

    public boolean isSpaceChar(int c) {
        if (filter != null)
            return filter.isSpaceChar(c);
        return isWhitespace(c);
    }

    public static boolean isWhitespace(int c) {
        return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
    }

    private String readLine0() {
        StringBuilder buf = new StringBuilder();
        int c = read();
        while (c != '\n' && c != -1) {
            if (c != '\r')
                buf.appendCodePoint(c);
            c = read();
        }
        return buf.toString();
    }

    public String readLine() {
        String s = readLine0();
        while (s.trim().length() == 0)
            s = readLine0();
        return s;
    }

    public String readLine(boolean ignoreEmptyLines) {
        if (ignoreEmptyLines)
            return readLine();
        else
            return readLine0();
    }

    public BigInteger readBigInteger() {
        try {
            return new BigInteger(readString());
        } catch (NumberFormatException e) {
            throw new InputMismatchException();
        }
    }

    public char readCharacter() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        return (char) c;
    }

    public double readDouble() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        double res = 0;
        while (!isSpaceChar(c) && c != '.') {
            if (c == 'e' || c == 'E')
                return res * Math.pow(10, readInt());
            if (c < '0' || c > '9')
                throw new InputMismatchException();
            res *= 10;
            res += c - '0';
            c = read();
        }
        if (c == '.') {
            c = read();
            double m = 1;
            while (!isSpaceChar(c)) {
                if (c == 'e' || c == 'E')
                    return res * Math.pow(10, readInt());
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                m /= 10;
                res += (c - '0') * m;
                c = read();
            }
        }
        return res * sgn;
    }

    public boolean isExhausted() {
        int value;
        while (isSpaceChar(value = peek()) && value != -1)
            read();
        return value == -1;
    }

    public String next() {
        return readString();
    }

    public SpaceCharFilter getFilter() {
        return filter;
    }

    public void setFilter(SpaceCharFilter filter) {
        this.filter = filter;
    }

    public interface SpaceCharFilter {
        public boolean isSpaceChar(int ch);
    }
}

class OutputWriter {
    private final PrintWriter writer;

    public OutputWriter(OutputStream outputStream) {
        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(
                outputStream)));
    }

    public OutputWriter(Writer writer) {
        this.writer = new PrintWriter(writer);
    }

    public void print(char[] array) {
        writer.print(array);
    }

    public void print(Object... objects) {
        for (int i = 0; i < objects.length; i++) {
            if (i != 0)
                writer.print(' ');
            writer.print(objects[i]);
        }
    }

    public void print(int[] array) {
        for (int i = 0; i < array.length; i++) {
            if (i != 0)
                writer.print(' ');
            writer.print(array[i]);
        }
    }

    public void print(long[] array) {
        for (int i = 0; i < array.length; i++) {
            if (i != 0)
                writer.print(' ');
            writer.print(array[i]);
        }
    }

    public void printLine(int[] array) {
        print(array);
        writer.println();
    }

    public void printLine(long[] array) {
        print(array);
        writer.println();
    }

    public void printLine() {
        writer.println();
    }

    public void printLine(Object... objects) {
        print(objects);
        writer.println();
    }

    public void print(char i) {
        writer.print(i);
    }

    public void printLine(char i) {
        writer.println(i);
    }

    public void printLine(char[] array) {
        writer.println(array);
    }

    public void printFormat(String format, Object... objects) {
        writer.printf(format, objects);
    }

    public void close() {
        writer.close();
    }

    public void flush() {
        writer.flush();
    }

    public void print(long i) {
        writer.print(i);
    }

    public void printLine(long i) {
        writer.println(i);
    }

    public void print(int i) {
        writer.print(i);
    }

    public void printLine(int i) {
        writer.println(i);
    }
}

class ArrayUtils {

    public static int[] createOrder(int size) {
        int[] order = new int[size];
        for (int i = 0; i < size; i++)
            order[i] = i;
        return order;
    }

    public static int maxPosition(int[] array) {
        return maxPosition(array, 0, array.length);
    }

    public static int maxPosition(int[] array, int from, int to) {
        if (from >= to)
            return -1;
        int max = array[from];
        int result = from;
        for (int i = from + 1; i < to; i++) {
            if (array[i] > max) {
                max = array[i];
                result = i;
            }
        }
        return result;
    }
}package OldAttemptLearning.pimponuser.CF477D;

import java.io.*;
import java.util.Arrays;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;
import java.util.Random;

/**
 * Built using CHelper plug-in Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        TaskD solver = new TaskD();
        solver.solve(1, in, out);
        out.close();
    }
}

class TaskD {

    public void solve(int testNumber, InputReader in, OutputWriter out) {
        final char[] str = in.readString().toCharArray();
        final int n = str.length;
        int MOD = (int) (1e9 + 7), INF = Integer.MAX_VALUE;
        long[][] count = new long[n + 1][n + 1];
        int[][] P = new int[n + 1][n + 1];
        int[][] LCP = new int[n + 1][n + 1];
        boolean[][] ones = new boolean[n + 1][n + 1];
        ArrayUtils.fill(P, INF / 2);
        P[0][0] = 1;
        count[0][0] = 1;
        ones[0][0] = true;
        final StringHash hash = new SimpleStringHash(new String(str));
        int[] order = ArrayUtils.createOrder(n);
        ArrayUtils.sort(order, new IntComparator() {
            public int compare(int first, int second) {
                int left = prefix(first, second, hash);
                if (left == Math.min(n - first, n - second)) {
                    return second - first;
                }
                return str[first + left] - str[second + left];
            }
        });
        int[] pos = ArrayUtils.reversePermutation(order);
        int[] arr = new int[n - 1];
        for (int i = 0; i < n - 1; i++) {
            arr[i] = prefix(order[i], order[i + 1], hash);
        }
        for (int i = 0; i < n; i++) {
            int x = INF;
            for (int j = i + 1; j < n; j++) {
                x = Math.min(x, arr[j - 1]);
                LCP[i][j] = LCP[j][i] = x;
            }
        }
        for (int i = 1; i <= n; i++) {
            for (int j = Math.max(i - 1, 0); j >= 0; j--) {
                ones[i][j] |= ones[i - 1][j];
                P[i][j] = Math.min(P[i][j], P[i - 1][j]);
                count[i][j] += count[i - 1][j];
                if (count[i][j] >= MOD) {
                    count[i][j] -= MOD;
                }
                if (i == n || str[i] != '1') {
                    continue;
                }
                int next = 2 * i - j;
                if (pos[i] < pos[j] && LCP[pos[i]][pos[j]] < i - j) {
                    next++;
                }
                if (next > n) {
                    continue;
                }
                ones[next][i] |= ones[i][j];
                P[next][i] = Math.min(P[next][i], P[i][j] + 1);
                count[next][i] += count[i][j];
                if (count[next][i] >= MOD) {
                    count[next][i] -= MOD;
                }
            }
        }
        long ret = 0;
        long min = INF;
        boolean ini = false;
        for (int i = n - 1; i >= 0; i--) {
            if (str[i] == '1' && ones[n][i]) {
                ret += count[n][i];
                if (!ini || n - i <= 32) {
                    long x = 0;
                    boolean flag = false;
                    for (int j = i; j < n; j++) {
                        x *= 2;
                        x += str[j] - '0';
                        if (x >= MOD) {
                            flag = true;
                            x -= MOD;
                        }
                    }
                    x += P[n][i];
                    if (x >= MOD) {
                        flag = true;
                        x -= MOD;
                    }
                    if (x < min && !flag || !ini) {
                        min = x;
                    }
                    ini = true;
                }
            }
        }
        out.printLine(ret % MOD);
        out.printLine(min);
    }

    protected int prefix(int first, int second, StringHash hash) {
        int left = 0;
        int right = Math.min(hash.length() - first, hash.length() - second);
        while (left < right) {
            int middle = (left + right + 1) >> 1;
            if (hash.hash(first, first + middle) == hash.hash(second, second
                    + middle)) {
                left = middle;
            } else {
                right = middle - 1;
            }
        }
        return left;
    }
}

class InputReader {

    private InputStream stream;
    private byte[] buf = new byte[1024];
    private int curChar;
    private int numChars;
    private SpaceCharFilter filter;

    public InputReader(InputStream stream) {
        this.stream = stream;
    }

    public int read() {
        if (numChars == -1)
            throw new InputMismatchException();
        if (curChar >= numChars) {
            curChar = 0;
            try {
                numChars = stream.read(buf);
            } catch (IOException e) {
                throw new InputMismatchException();
            }
            if (numChars <= 0)
                return -1;
        }
        return buf[curChar++];
    }

    public String readString() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        StringBuilder res = new StringBuilder();
        do {
            if (Character.isValidCodePoint(c))
                res.appendCodePoint(c);
            c = read();
        } while (!isSpaceChar(c));
        return res.toString();
    }

    public boolean isSpaceChar(int c) {
        if (filter != null)
            return filter.isSpaceChar(c);
        return isWhitespace(c);
    }

    public static boolean isWhitespace(int c) {
        return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
    }

    public interface SpaceCharFilter {
        public boolean isSpaceChar(int ch);
    }
}

class OutputWriter {
    private final PrintWriter writer;

    public OutputWriter(OutputStream outputStream) {
        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(
                outputStream)));
    }

    public void close() {
        writer.close();
    }

    public void printLine(long i) {
        writer.println(i);
    }

}

class ArrayUtils {

    public static void fill(int[][] array, int value) {
        for (int[] row : array)
            Arrays.fill(row, value);
    }

    public static int[] createOrder(int size) {
        int[] order = new int[size];
        for (int i = 0; i < size; i++)
            order[i] = i;
        return order;
    }

    public static int[] sort(int[] array, IntComparator comparator) {
        return sort(array, 0, array.length, comparator);
    }

    public static int[] sort(int[] array, int from, int to,
            IntComparator comparator) {
        if (from == 0 && to == array.length)
            new IntArray(array).inPlaceSort(comparator);
        else
            new IntArray(array).subList(from, to).inPlaceSort(comparator);
        return array;
    }

    public static int[] reversePermutation(int[] permutation) {
        int[] result = new int[permutation.length];
        for (int i = 0; i < permutation.length; i++)
            result[permutation[i]] = i;
        return result;
    }

}

interface StringHash {
    long hash(int from, int to);

    int length();
}

class SimpleStringHash extends AbstractStringHash {
    private static long[] firstReversePower = new long[0];
    private static long[] secondReversePower = new long[0];

    private final long[] firstHash;
    private final long[] secondHash;

    public SimpleStringHash(CharSequence string) {
        int length = string.length();
        ensureCapacity(length);
        firstHash = new long[length + 1];
        secondHash = new long[length + 1];
        long firstPower = 1;
        long secondPower = 1;
        for (int i = 0; i < length; i++) {
            firstHash[i + 1] = (firstHash[i] + string.charAt(i) * firstPower)
                    % FIRST_MOD;
            secondHash[i + 1] = (secondHash[i] + string.charAt(i) * secondPower)
                    % SECOND_MOD;
            firstPower *= MULTIPLIER;
            firstPower %= FIRST_MOD;
            secondPower *= MULTIPLIER;
            secondPower %= SECOND_MOD;
        }
    }

    private void ensureCapacity(int length) {
        if (firstReversePower.length >= length)
            return;
        length = Math.max(length + 1, firstReversePower.length << 1);
        long[] oldFirst = firstReversePower;
        long[] oldSecond = secondReversePower;
        firstReversePower = new long[length];
        secondReversePower = new long[length];
        System.arraycopy(oldFirst, 0, firstReversePower, 0, oldFirst.length);
        System.arraycopy(oldSecond, 0, secondReversePower, 0, oldSecond.length);
        firstReversePower[0] = secondReversePower[0] = 1;
        for (int i = Math.max(oldFirst.length, 1); i < length; i++) {
            firstReversePower[i] = firstReversePower[i - 1]
                    * FIRST_REVERSE_MULTIPLIER % FIRST_MOD;
            secondReversePower[i] = secondReversePower[i - 1]
                    * SECOND_REVERSE_MULTIPLIER % SECOND_MOD;
        }
    }

    public long hash(int from, int to) {
        return (((firstHash[to] - firstHash[from] + FIRST_MOD)
                * firstReversePower[from] % FIRST_MOD) << 32)
                + ((secondHash[to] - secondHash[from] + SECOND_MOD)
                        * secondReversePower[from] % SECOND_MOD);
    }

    public int length() {
        return firstHash.length - 1;
    }
}

interface IntComparator {

    public int compare(int first, int second);
}

abstract class IntCollection {
    public abstract IntIterator iterator();

    public abstract int size();

}

interface IntIterator {
    public int value() throws NoSuchElementException;

    /*
     * @throws NoSuchElementException only if iterator already invalid
     */
    public void advance() throws NoSuchElementException;

    public boolean isValid();
}

abstract class IntList extends IntCollection implements Comparable<IntList> {
    private static final int INSERTION_THRESHOLD = 16;

    public abstract int get(int index);

    public abstract void set(int index, int value);

    public IntIterator iterator() {
        return new IntIterator() {
            private int size = size();
            private int index = 0;

            public int value() throws NoSuchElementException {
                if (!isValid())
                    throw new NoSuchElementException();
                return get(index);
            }

            public void advance() throws NoSuchElementException {
                if (!isValid())
                    throw new NoSuchElementException();
                index++;
            }

            public boolean isValid() {
                return index < size;
            }
        };
    }

    public IntList subList(final int from, final int to) {
        return new SubList(from, to);
    }

    private void swap(int first, int second) {
        if (first == second)
            return;
        int temp = get(first);
        set(first, get(second));
        set(second, temp);
    }

    public IntSortedList inPlaceSort(IntComparator comparator) {
        quickSort(0, size() - 1,
                (Integer.bitCount(Integer.highestOneBit(size()) - 1) * 5) >> 1,
                comparator);
        return new IntSortedArray(this, comparator);
    }

    private void quickSort(int from, int to, int remaining,
            IntComparator comparator) {
        if (to - from < INSERTION_THRESHOLD) {
            insertionSort(from, to, comparator);
            return;
        }
        if (remaining == 0) {
            heapSort(from, to, comparator);
            return;
        }
        remaining--;
        int pivotIndex = (from + to) >> 1;
        int pivot = get(pivotIndex);
        swap(pivotIndex, to);
        int storeIndex = from;
        int equalIndex = to;
        for (int i = from; i < equalIndex; i++) {
            int value = comparator.compare(get(i), pivot);
            if (value < 0)
                swap(storeIndex++, i);
            else if (value == 0)
                swap(--equalIndex, i--);
        }
        quickSort(from, storeIndex - 1, remaining, comparator);
        for (int i = equalIndex; i <= to; i++)
            swap(storeIndex++, i);
        quickSort(storeIndex, to, remaining, comparator);
    }

    private void heapSort(int from, int to, IntComparator comparator) {
        for (int i = (to + from - 1) >> 1; i >= from; i--)
            siftDown(i, to, comparator, from);
        for (int i = to; i > from; i--) {
            swap(from, i);
            siftDown(from, i - 1, comparator, from);
        }
    }

    private void siftDown(int start, int end, IntComparator comparator,
            int delta) {
        int value = get(start);
        while (true) {
            int child = ((start - delta) << 1) + 1 + delta;
            if (child > end)
                return;
            int childValue = get(child);
            if (child + 1 <= end) {
                int otherValue = get(child + 1);
                if (comparator.compare(otherValue, childValue) > 0) {
                    child++;
                    childValue = otherValue;
                }
            }
            if (comparator.compare(value, childValue) >= 0)
                return;
            swap(start, child);
            start = child;
        }
    }

    private void insertionSort(int from, int to, IntComparator comparator) {
        for (int i = from + 1; i <= to; i++) {
            int value = get(i);
            for (int j = i - 1; j >= from; j--) {
                if (comparator.compare(get(j), value) <= 0)
                    break;
                swap(j, j + 1);
            }
        }
    }

    public int hashCode() {
        int hashCode = 1;
        for (IntIterator i = iterator(); i.isValid(); i.advance())
            hashCode = 31 * hashCode + i.value();
        return hashCode;
    }

    public boolean equals(Object obj) {
        if (!(obj instanceof IntList))
            return false;
        IntList list = (IntList) obj;
        if (list.size() != size())
            return false;
        IntIterator i = iterator();
        IntIterator j = list.iterator();
        while (i.isValid()) {
            if (i.value() != j.value())
                return false;
            i.advance();
            j.advance();
        }
        return true;
    }

    public int compareTo(IntList o) {
        IntIterator i = iterator();
        IntIterator j = o.iterator();
        while (true) {
            if (i.isValid()) {
                if (j.isValid()) {
                    if (i.value() != j.value()) {
                        if (i.value() < j.value())
                            return -1;
                        else
                            return 1;
                    }
                } else
                    return 1;
            } else {
                if (j.isValid())
                    return -1;
                else
                    return 0;
            }
            i.advance();
            j.advance();
        }
    }

    private class SubList extends IntList {
        private final int to;
        private final int from;
        private int size;

        public SubList(int from, int to) {
            this.to = to;
            this.from = from;
            size = to - from;
        }

        public int get(int index) {
            if (index < 0 || index >= size)
                throw new IndexOutOfBoundsException();
            return IntList.this.get(index + from);
        }

        public void set(int index, int value) {
            if (index < 0 || index >= size)
                throw new IndexOutOfBoundsException();
            IntList.this.set(index + from, value);
        }

        public int size() {
            return size;
        }

    }
}

abstract class IntSortedList extends IntList {
    protected final IntComparator comparator;

    protected IntSortedList(IntComparator comparator) {
        this.comparator = comparator;
    }

    public void set(int index, int value) {
        throw new UnsupportedOperationException();
    }

    public IntSortedList inPlaceSort(IntComparator comparator) {
        if (comparator == this.comparator)
            return this;
        throw new UnsupportedOperationException();
    }

    protected void ensureSorted() {
        int size = size();
        if (size == 0)
            return;
        int last = get(0);
        for (int i = 1; i < size; i++) {
            int x = get(i);
            if (comparator.compare(last, x) > 0)
                throw new IllegalArgumentException();
            last = x;
        }
    }

    public IntSortedList subList(final int from, final int to) {
        return new IntSortedList(comparator) {
            private int size = to - from;

            public int get(int index) {
                if (index < 0 || index >= size)
                    throw new IndexOutOfBoundsException();
                return IntSortedList.this.get(index + from);
            }

            public int size() {
                return size;
            }
        };
    }
}

class IntArray extends IntList {
    private final int[] array;

    public IntArray(int[] array) {
        this.array = array;
    }

    public int get(int index) {
        return array[index];
    }

    public void set(int index, int value) {
        array[index] = value;
    }

    public int size() {
        return array.length;
    }

}

abstract class AbstractStringHash implements StringHash {
    public static final long MULTIPLIER;
    protected static final long FIRST_REVERSE_MULTIPLIER;
    protected static final long SECOND_REVERSE_MULTIPLIER;
    public static final long FIRST_MOD;
    public static final long SECOND_MOD;

    static {
        Random random = new Random(System.currentTimeMillis());
        FIRST_MOD = IntegerUtils.nextPrime((long) (1e9 + random
                .nextInt((int) 1e9)));
        SECOND_MOD = IntegerUtils.nextPrime((long) (1e9 + random
                .nextInt((int) 1e9)));
        MULTIPLIER = random.nextInt((int) 1e9 - 257) + 257;
        FIRST_REVERSE_MULTIPLIER = IntegerUtils.reverse(MULTIPLIER, FIRST_MOD);
        SECOND_REVERSE_MULTIPLIER = IntegerUtils
                .reverse(MULTIPLIER, SECOND_MOD);
    }

}

class IntSortedArray extends IntSortedList {
    private final int[] array;

    public IntSortedArray(IntCollection collection, IntComparator comparator) {
        super(comparator);
        array = new int[collection.size()];
        int i = 0;
        for (IntIterator iterator = collection.iterator(); iterator.isValid(); iterator
                .advance())
            array[i++] = iterator.value();
        ensureSorted();
    }

    public int get(int index) {
        return array[index];
    }

    public int size() {
        return array.length;
    }
}

class IntegerUtils {

    public static long power(long base, long exponent, long mod) {
        if (base >= mod)
            base %= mod;
        if (exponent == 0)
            return 1 % mod;
        long result = power(base, exponent >> 1, mod);
        result = result * result % mod;
        if ((exponent & 1) != 0)
            result = result * base % mod;
        return result;
    }

    public static long reverse(long number, long module) {
        return power(number, module - 2, module);
    }

    public static boolean isPrime(long number) {
        if (number < 2)
            return false;
        for (long i = 2; i * i <= number; i++) {
            if (number % i == 0)
                return false;
        }
        return true;
    }

    public static long nextPrime(long from) {
        if (from <= 2)
            return 2;
        from += 1 - (from & 1);
        while (!isPrime(from))
            from += 2;
        return from;
    }

}package OldAttemptLearning.pimponuser.CF573B;

import java.io.*;
import java.util.InputMismatchException;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        TaskB solver = new TaskB();
        solver.solve(1, in, out);
        out.close();
    }
}

class TaskB {
    public void solve(int testNumber, InputReader in, OutputWriter out) {
        int n=in.readInt();
        int[] arr= IOUtils.readIntArray(in, n);
        arr[0]=arr[n-1]=1;
        for (int i=1; i<n; i++) arr[i]=Math.min(arr[i], arr[i-1]+1);
        for (int i=n-2; i>=0; i--) arr[i]=Math.min(arr[i], arr[i+1]+1);
        out.printLine(ArrayUtils.maxElement(arr));
    }
}

class InputReader {

    private InputStream stream;
    private byte[] buf = new byte[1024];
    private int curChar;
    private int numChars;
    private SpaceCharFilter filter;

    public InputReader(InputStream stream) {
        this.stream = stream;
    }

    public int read() {
        if (numChars == -1)
            throw new InputMismatchException();
        if (curChar >= numChars) {
            curChar = 0;
            try {
                numChars = stream.read(buf);
            } catch (IOException e) {
                throw new InputMismatchException();
            }
            if (numChars <= 0)
                return -1;
        }
        return buf[curChar++];
    }

    public int readInt() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        int res = 0;
        do {
            if (c < '0' || c > '9')
                throw new InputMismatchException();
            res *= 10;
            res += c - '0';
            c = read();
        } while (!isSpaceChar(c));
        return res * sgn;
    }

    public boolean isSpaceChar(int c) {
        if (filter != null)
            return filter.isSpaceChar(c);
        return isWhitespace(c);
    }

    public static boolean isWhitespace(int c) {
        return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
    }

    public interface SpaceCharFilter {
        public boolean isSpaceChar(int ch);
    }
}

class OutputWriter {
    private final PrintWriter writer;

    public OutputWriter(OutputStream outputStream) {
        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
    }

    public void close() {
        writer.close();
    }

    public void printLine(int i) {
        writer.println(i);
    }
}

class IOUtils {

    public static int[] readIntArray(InputReader in, int size) {
        int[] array = new int[size];
        for (int i = 0; i < size; i++)
            array[i] = in.readInt();
        return array;
    }

}

class ArrayUtils {

    public static int maxElement(int[] array) {
        return maxElement(array, 0, array.length);
    }

    public static int maxElement(int[] array, int from, int to) {
        int result = Integer.MIN_VALUE;
        for (int i = from; i < to; i++)
            result = Math.max(result, array[i]);
        return result;
    }

}package OldAttemptLearning.pimponuser.CF573A;

import java.io.*;
import java.util.HashSet;
import java.util.InputMismatchException;
import java.util.Set;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        TaskA solver = new TaskA();
        solver.solve(1, in, out);
        out.close();
    }
}

class TaskA {
    public void solve(int testNumber, InputReader in, OutputWriter out) {
        Set<Integer> set=new HashSet<Integer>();
        int n=in.readInt();
        while (n-->0) {
            int x=in.readInt();
            while (x%2==0) x/=2;
            while (x%3==0) x/=3;
            set.add(x);
        }
        out.printLine(set.size()==1?"Yes":"No");
    }
}

class InputReader {

    private InputStream stream;
    private byte[] buf = new byte[1024];
    private int curChar;
    private int numChars;
    private SpaceCharFilter filter;

    public InputReader(InputStream stream) {
        this.stream = stream;
    }

    public int read() {
        if (numChars == -1)
            throw new InputMismatchException();
        if (curChar >= numChars) {
            curChar = 0;
            try {
                numChars = stream.read(buf);
            } catch (IOException e) {
                throw new InputMismatchException();
            }
            if (numChars <= 0)
                return -1;
        }
        return buf[curChar++];
    }

    public int readInt() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        int res = 0;
        do {
            if (c < '0' || c > '9')
                throw new InputMismatchException();
            res *= 10;
            res += c - '0';
            c = read();
        } while (!isSpaceChar(c));
        return res * sgn;
    }

    public boolean isSpaceChar(int c) {
        if (filter != null)
            return filter.isSpaceChar(c);
        return isWhitespace(c);
    }

    public static boolean isWhitespace(int c) {
        return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
    }

    public interface SpaceCharFilter {
        public boolean isSpaceChar(int ch);
    }
}

class OutputWriter {
    private final PrintWriter writer;

    public OutputWriter(OutputStream outputStream) {
        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
    }

    public void print(Object...objects) {
        for (int i = 0; i < objects.length; i++) {
            if (i != 0)
                writer.print(' ');
            writer.print(objects[i]);
        }
    }

    public void printLine(Object...objects) {
        print(objects);
        writer.println();
    }

    public void close() {
        writer.close();
    }

}package OldAttemptLearning.pimponuser.CF504D;

import java.io.*;
import java.math.BigInteger;
import java.util.BitSet;
import java.util.Collection;
import java.util.InputMismatchException;

public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        Task solver = new Task();
        solver.solve(1, in, out);
        out.close();
    }
}

class Task {
    
    public void solve(int testNumber, InputReader in, OutputWriter out) {
        int n=in.readInt(), idx=0;
        BigInteger[] A=new BigInteger[n];
        BitSet[] B=new BitSet[n];
        for (int i=0; i<n; i++) {
            BigInteger num=in.readBigInteger();
            BitSet set=new BitSet();
            for (int j=0; j<idx; j++) {
                BigInteger aux=num.xor(A[j]);
                if (aux.compareTo(num)<0) {
                    num=aux;
                    set.xor(B[j]);
                }
            }
            if (num.compareTo(BigInteger.ZERO)==0) {
                out.print(set.cardinality());
                for (int j=set.nextSetBit(0); j>=0; j=set.nextSetBit(j+1)) out.print("", j);
                out.printLine();
            } else {
                set.set(i);
                A[idx]=num;
                B[idx++]=set;
                out.printLine(0);
            }
        }
    }
}

class InputReader {
    private boolean finished = false;

    private InputStream stream;
    private byte[] buf = new byte[1024];
    private int curChar;
    private int numChars;
    private SpaceCharFilter filter;

    public InputReader(InputStream stream) {
        this.stream = stream;
    }

    public int read() {
        if (numChars == -1)
            throw new InputMismatchException();
        if (curChar >= numChars) {
            curChar = 0;
            try {
                numChars = stream.read(buf);
            } catch (IOException e) {
                throw new InputMismatchException();
            }
            if (numChars <= 0)
                return -1;
        }
        return buf[curChar++];
    }

    public int peek() {
        if (numChars == -1)
            return -1;
        if (curChar >= numChars) {
            curChar = 0;
            try {
                numChars = stream.read(buf);
            } catch (IOException e) {
                return -1;
            }
            if (numChars <= 0)
                return -1;
        }
        return buf[curChar];
    }

    public int readInt() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        int res = 0;
        do {
            if (c < '0' || c > '9')
                throw new InputMismatchException();
            res *= 10;
            res += c - '0';
            c = read();
        } while (!isSpaceChar(c));
        return res * sgn;
    }

    public long readLong() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        long res = 0;
        do {
            if (c < '0' || c > '9')
                throw new InputMismatchException();
            res *= 10;
            res += c - '0';
            c = read();
        } while (!isSpaceChar(c));
        return res * sgn;
    }

    public String readString() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        StringBuilder res = new StringBuilder();
        do {
            if (Character.isValidCodePoint(c))
                res.appendCodePoint(c);
            c = read();
        } while (!isSpaceChar(c));
        return res.toString();
    }

    public boolean isSpaceChar(int c) {
        if (filter != null)
            return filter.isSpaceChar(c);
        return isWhitespace(c);
    }

    public static boolean isWhitespace(int c) {
        return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
    }

    private String readLine0() {
        StringBuilder buf = new StringBuilder();
        int c = read();
        while (c != '\n' && c != -1) {
            if (c != '\r')
                buf.appendCodePoint(c);
            c = read();
        }
        return buf.toString();
    }

    public String readLine() {
        String s = readLine0();
        while (s.trim().length() == 0)
            s = readLine0();
        return s;
    }

    public String readLine(boolean ignoreEmptyLines) {
        if (ignoreEmptyLines)
            return readLine();
        else
            return readLine0();
    }

    public BigInteger readBigInteger() {
        try {
            return new BigInteger(readString());
        } catch (NumberFormatException e) {
            throw new InputMismatchException();
        }
    }

    public char readCharacter() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        return (char) c;
    }

    public double readDouble() {
        int c = read();
        while (isSpaceChar(c))
            c = read();
        int sgn = 1;
        if (c == '-') {
            sgn = -1;
            c = read();
        }
        double res = 0;
        while (!isSpaceChar(c) && c != '.') {
            if (c == 'e' || c == 'E')
                return res * Math.pow(10, readInt());
            if (c < '0' || c > '9')
                throw new InputMismatchException();
            res *= 10;
            res += c - '0';
            c = read();
        }
        if (c == '.') {
            c = read();
            double m = 1;
            while (!isSpaceChar(c)) {
                if (c == 'e' || c == 'E')
                    return res * Math.pow(10, readInt());
                if (c < '0' || c > '9')
                    throw new InputMismatchException();
                m /= 10;
                res += (c - '0') * m;
                c = read();
            }
        }
        return res * sgn;
    }

    public boolean isExhausted() {
        int value;
        while (isSpaceChar(value = peek()) && value != -1)
            read();
        return value == -1;
    }

    public String next() {
        return readString();
    }

    public SpaceCharFilter getFilter() {
        return filter;
    }

    public void setFilter(SpaceCharFilter filter) {
        this.filter = filter;
    }

    public interface SpaceCharFilter {
        public boolean isSpaceChar(int ch);
    }
}

class OutputWriter {
    private final PrintWriter writer;

    public OutputWriter(OutputStream outputStream) {
        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(
                outputStream)));
    }

    public OutputWriter(Writer writer) {
        this.writer = new PrintWriter(writer);
    }

    public void print(char[] array) {
        writer.print(array);
    }

    public void print(Object... objects) {
        for (int i = 0; i < objects.length; i++) {
            if (i != 0)
                writer.print(' ');
            writer.print(objects[i]);
        }
    }

    public void print(int[] array) {
        for (int i = 0; i < array.length; i++) {
            if (i != 0)
                writer.print(' ');
            writer.print(array[i]);
        }
    }

    public void print(long[] array) {
        for (int i = 0; i < array.length; i++) {
            if (i != 0)
                writer.print(' ');
            writer.print(array[i]);
        }
    }

    public void print(Collection<Integer> collection) {
        boolean first = true;
        for (int i : collection) {
            if (first)
                first = false;
            else
                writer.print(' ');
            writer.print(i);
        }
    }

    public void printLine(int[] array) {
        print(array);
        writer.println();
    }

    public void printLine(long[] array) {
        print(array);
        writer.println();
    }

    public void printLine(Collection<Integer> collection) {
        print(collection);
        writer.println();
    }

    public void printLine() {
        writer.println();
    }

    public void printLine(Object... objects) {
        print(objects);
        writer.println();
    }

    public void print(char i) {
        writer.print(i);
    }

    public void printLine(char i) {
        writer.println(i);
    }

    public void printLine(char[] array) {
        writer.println(array);
    }

    public void printFormat(String format, Object... objects) {
        writer.printf(format, objects);
    }

    public void close() {
        writer.close();
    }

    public void flush() {
        writer.flush();
    }

    public void print(long i) {
        writer.print(i);
    }

    public void printLine(long i) {
        writer.println(i);
    }

    public void print(int i) {
        writer.print(i);
    }

    public void printLine(int i) {
        writer.println(i);
    }
}package OldAttemptLearning.pimponuser.another2;

import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main {
    public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		InputReader in = new InputReader(inputStream);
		OutputWriter out = new OutputWriter(outputStream);
		Task solver = new TaskB();
		solver.solve(1, in, out);
		out.close();
	}
}

interface Task {
	public void solve(int testNumber, InputReader in, OutputWriter out);
}

class TaskA implements Task {

	boolean[][] madj;
	int[] aux={0, 2, 3, 3, 2};
	
	public void solve(int testNumber, InputReader in, OutputWriter out) {
		int n=in.readInt(), p=in.readInt();
		madj=new boolean[n][n];
		for (int i=0; i<n; i+=5) {
			int x=MiscUtils.min(i+5, n);
			for (int j=i; j<x; j++) for (int k=j+1; k<x; k++) madj[j][k]=madj[k][j]=true;
			if (x-i<5 && x-i>0) for (int j=0; j<aux[x-i]; j++) madj[j][i+j/2]=madj[i+j/2][j]=true;
		}
		for (int i=0; i<n; i++) for (int j=i+1; j<n; j++) if (!madj[i][j] && p>0) {
			p--;
			madj[i][j]=madj[j][i]=true;
		}
		for (int i=0; i<n; i++) for (int j=i+1; j<n; j++) if (madj[i][j]) out.printLine(i+1, j+1);
	}

}

class TaskB implements Task {

	int[] arr, rev;
	ArrayList<Pair<Integer, Integer>> list;
	
	public void solve(int testNumber, InputReader in, OutputWriter out) {
		int n=in.readInt(), m=in.readInt();
		arr=new int[n];
		rev=new int[m+1];
		while (m-->0) {
			arr[in.readInt()-1]++;
			arr[in.readInt()-1]++;
		}
		for (int i=0; i<n; i++) rev[arr[i]]++;
		if (rev[2]==n-2 && rev[1]==2) out.print("bus");
		else if (rev[2]==n) out.print("ring");
		else if (rev[n-1]==1 && rev[1]==n-1) out.print("star");
		else out.print("unknown");
		out.printLine(" topology");
	}

}

class TaskC implements Task {

	public void solve(int testNumber, InputReader in, OutputWriter out) {
		
	}

}

class TaskD implements Task {

	char[][] tab;
	Graph graph;
	int[] DX = { -1, -1, 1, 1 }, DY = { -1, 1, -1, 1 };
	boolean[][] val;

	public void solve(int testNumber, InputReader in, OutputWriter out) {
		while (true) {
			int n=in.readInt(), m=in.readInt(), s=n*m, t=n*m+1, ret=0;
			if (n==0 && m==0) break;
			val=new boolean[n][m];
			tab=IOUtils.readTable(in, n, m);
			graph=new Graph(t+1);
			for (int i=0; i<n; i++) for (int j=0; j<m; j++) {
				val[i][j]=tab[i][j]=='F';
				for (int k=0; k<4; k++) {
					int i2=i+2*DX[k], j2=j+2*DY[k], i3=i+DX[k], j3=j+DY[k];
					if (MiscUtils.isValidCell(i2, j2, n, m) && (tab[i2][j2]=='G' && tab[i3][j3]!='P')) val[i][j]=false;
				}
				if (val[i][j]) ret++;
			}
			for (int i=0; i<n; i++) for (int j=0; j<m; j++) if (val[i][j]) {
				int u=m*i+j;
				if (i%4>1) {
					graph.addFlowEdge(u, t, 1);
					continue;
				}
				graph.addFlowEdge(s, u, 1);
				for (int k=0; k<4; k++) {
					int i2=i+2*DX[k], j2=j+2*DY[k], i3=i+DX[k], j3=j+DY[k], v=m*i2+j2;
					if (MiscUtils.isValidCell(i2, j2, n, m) && val[i2][j2] && tab[i3][j3]!='P') graph.addFlowEdge(u, v, 1);
				}
			}
			ret-=MaxFlow.dinic(graph, s, t);
			out.printLine(ret);
		}
	}
}

class TaskE implements Task {

	public void solve(int testNumber, InputReader in, OutputWriter out) {
		int x = in.readInt(), k = in.readInt(), p = in.readInt(), c = 0;
		for (; x % 2 == 0; x /= 2)
			c++;
		double prob = 0.01 * p, ret = Math.pow(prob, k) * (k + c);
		for (int i = 1; i <= k; i++)
			ret += (1.0 - prob) * Math.pow(prob, k - i) * (k - i);
		out.printLine(ret);
	}

}

class TaskF implements Task {

	public void solve(int testNumber, InputReader in, OutputWriter out) {

	}

}

class MaxFlow {
	private final Graph graph;
	private int source;
	private int destination;
	private int[] queue;
	private int[] distance;
	private int[] nextEdge;

	private MaxFlow(Graph graph, int source, int destination) {
		this.graph = graph;
		this.source = source;
		this.destination = destination;
		int vertexCount = graph.vertexCount();
		queue = new int[vertexCount];
		distance = new int[vertexCount];
		nextEdge = new int[vertexCount];
	}

	public static long dinic(Graph graph, int source, int destination) {
		return new MaxFlow(graph, source, destination).dinic();
	}

	private long dinic() {
		long totalFlow = 0;
		while (true) {
			edgeDistances();
			if (distance[destination] == -1)
				break;
			Arrays.fill(nextEdge, -2);
			totalFlow += dinicImpl(source, Long.MAX_VALUE);
		}
		return totalFlow;
	}

	private void edgeDistances() {
		Arrays.fill(distance, -1);
		distance[source] = 0;
		int size = 1;
		queue[0] = source;
		for (int i = 0; i < size; i++) {
			int current = queue[i];
			int id = graph.firstOutbound(current);
			while (id != -1) {
				if (graph.capacity(id) != 0) {
					int next = graph.destination(id);
					if (distance[next] == -1) {
						distance[next] = distance[current] + 1;
						queue[size++] = next;
					}
				}
				id = graph.nextOutbound(id);
			}
		}
	}

	private long dinicImpl(int source, long flow) {
		if (source == destination)
			return flow;
		if (flow == 0 || distance[source] == distance[destination])
			return 0;
		int id = nextEdge[source];
		if (id == -2)
			nextEdge[source] = id = graph.firstOutbound(source);
		long totalPushed = 0;
		while (id != -1) {
			int nextDestinationID = graph.destination(id);
			if (graph.capacity(id) != 0
					&& distance[nextDestinationID] == distance[source] + 1) {
				long pushed = dinicImpl(nextDestinationID,
						Math.min(flow, graph.capacity(id)));
				if (pushed != 0) {
					graph.pushFlow(id, pushed);
					flow -= pushed;
					totalPushed += pushed;
					if (flow == 0)
						return totalPushed;
				}
			}
			nextEdge[source] = id = graph.nextOutbound(id);
		}
		return totalPushed;
	}
}

class OutputWriter {
	private final PrintWriter writer;

	public OutputWriter(OutputStream outputStream) {
		writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(
				outputStream)));
	}

	public OutputWriter(Writer writer) {
		this.writer = new PrintWriter(writer);
	}

	public void print(char[] array) {
		writer.print(array);
	}

	public void print(Object... objects) {
		for (int i = 0; i < objects.length; i++) {
			if (i != 0)
				writer.print(' ');
			writer.print(objects[i]);
		}
	}

	public void print(int[] array) {
		for (int i = 0; i < array.length; i++) {
			if (i != 0)
				writer.print(' ');
			writer.print(array[i]);
		}
	}

	public void print(long[] array) {
		for (int i = 0; i < array.length; i++) {
			if (i != 0)
				writer.print(' ');
			writer.print(array[i]);
		}
	}

	public void print(Collection<Integer> collection) {
		boolean first = true;
		for (Integer iterator : collection) {
			if (first)
				first = false;
			else
				writer.print(' ');
			writer.print(iterator);
		}
	}

	public void printLine(int[] array) {
		print(array);
		writer.println();
	}

	public void printLine(long[] array) {
		print(array);
		writer.println();
	}

	public void printLine(Collection<Integer> collection) {
		print(collection);
		writer.println();
	}

	public void printLine() {
		writer.println();
	}

	public void printLine(Object... objects) {
		print(objects);
		writer.println();
	}

	public void print(char i) {
		writer.print(i);
	}

	public void printLine(char i) {
		writer.println(i);
	}

	public void printLine(char[] array) {
		writer.println(array);
	}

	public void printFormat(String format, Object... objects) {
		writer.printf(format, objects);
	}

	public void close() {
		writer.close();
	}

	public void flush() {
		writer.flush();
	}

	public void print(long i) {
		writer.print(i);
	}

	public void printLine(long i) {
		writer.println(i);
	}

	public void print(int i) {
		writer.print(i);
	}

	public void printLine(int i) {
		writer.println(i);
	}
}

class InputReader {

	private InputStream stream;
	private byte[] buf = new byte[1024];
	private int curChar;
	private int numChars;
	private SpaceCharFilter filter;

	public InputReader(InputStream stream) {
		this.stream = stream;
	}

	public int read() {
		if (numChars == -1)
			throw new InputMismatchException();
		if (curChar >= numChars) {
			curChar = 0;
			try {
				numChars = stream.read(buf);
			} catch (IOException e) {
				throw new InputMismatchException();
			}
			if (numChars <= 0)
				return -1;
		}
		return buf[curChar++];
	}

	public int peek() {
		if (numChars == -1)
			return -1;
		if (curChar >= numChars) {
			curChar = 0;
			try {
				numChars = stream.read(buf);
			} catch (IOException e) {
				return -1;
			}
			if (numChars <= 0)
				return -1;
		}
		return buf[curChar];
	}

	public int readInt() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		int sgn = 1;
		if (c == '-') {
			sgn = -1;
			c = read();
		}
		int res = 0;
		do {
			if (c < '0' || c > '9')
				throw new InputMismatchException();
			res *= 10;
			res += c - '0';
			c = read();
		} while (!isSpaceChar(c));
		return res * sgn;
	}

	public long readLong() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		int sgn = 1;
		if (c == '-') {
			sgn = -1;
			c = read();
		}
		long res = 0;
		do {
			if (c < '0' || c > '9')
				throw new InputMismatchException();
			res *= 10;
			res += c - '0';
			c = read();
		} while (!isSpaceChar(c));
		return res * sgn;
	}

	public String readString() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		StringBuilder res = new StringBuilder();
		do {
			if (Character.isValidCodePoint(c))
				res.appendCodePoint(c);
			c = read();
		} while (!isSpaceChar(c));
		return res.toString();
	}

	public boolean isSpaceChar(int c) {
		if (filter != null)
			return filter.isSpaceChar(c);
		return isWhitespace(c);
	}

	public static boolean isWhitespace(int c) {
		return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
	}

	private String readLine0() {
		StringBuilder buf = new StringBuilder();
		int c = read();
		while (c != '\n' && c != -1) {
			if (c != '\r')
				buf.appendCodePoint(c);
			c = read();
		}
		return buf.toString();
	}

	public String readLine() {
		String s = readLine0();
		while (s.trim().length() == 0)
			s = readLine0();
		return s;
	}

	public String readLine(boolean ignoreEmptyLines) {
		if (ignoreEmptyLines)
			return readLine();
		else
			return readLine0();
	}

	public BigInteger readBigInteger() {
		try {
			return new BigInteger(readString());
		} catch (NumberFormatException e) {
			throw new InputMismatchException();
		}
	}

	public char readCharacter() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		return (char) c;
	}

	public double readDouble() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		int sgn = 1;
		if (c == '-') {
			sgn = -1;
			c = read();
		}
		double res = 0;
		while (!isSpaceChar(c) && c != '.') {
			if (c == 'e' || c == 'E')
				return res * Math.pow(10, readInt());
			if (c < '0' || c > '9')
				throw new InputMismatchException();
			res *= 10;
			res += c - '0';
			c = read();
		}
		if (c == '.') {
			c = read();
			double m = 1;
			while (!isSpaceChar(c)) {
				if (c == 'e' || c == 'E')
					return res * Math.pow(10, readInt());
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				m /= 10;
				res += (c - '0') * m;
				c = read();
			}
		}
		return res * sgn;
	}

	public boolean isExhausted() {
		int value;
		while (isSpaceChar(value = peek()) && value != -1)
			read();
		return value == -1;
	}

	public String next() {
		return readString();
	}

	public SpaceCharFilter getFilter() {
		return filter;
	}

	public void setFilter(SpaceCharFilter filter) {
		this.filter = filter;
	}

	public interface SpaceCharFilter {
		public boolean isSpaceChar(int ch);
	}
}

class IOUtils {
	public static Pair<Integer, Integer> readIntPair(InputReader in) {
		int first = in.readInt();
		int second = in.readInt();
		return Pair.makePair(first, second);
	}

	public static Pair<Long, Long> readLongPair(InputReader in) {
		long first = in.readLong();
		long second = in.readLong();
		return Pair.makePair(first, second);
	}

	public static int[] readIntArray(InputReader in, int size) {
		int[] array = new int[size];
		for (int i = 0; i < size; i++)
			array[i] = in.readInt();
		return array;
	}

	public static long[] readLongArray(InputReader in, int size) {
		long[] array = new long[size];
		for (int i = 0; i < size; i++)
			array[i] = in.readLong();
		return array;
	}

	public static double[] readDoubleArray(InputReader in, int size) {
		double[] array = new double[size];
		for (int i = 0; i < size; i++)
			array[i] = in.readDouble();
		return array;
	}

	public static String[] readStringArray(InputReader in, int size) {
		String[] array = new String[size];
		for (int i = 0; i < size; i++)
			array[i] = in.readString();
		return array;
	}

	public static char[] readCharArray(InputReader in, int size) {
		char[] array = new char[size];
		for (int i = 0; i < size; i++)
			array[i] = in.readCharacter();
		return array;
	}

	public static Pair<Integer, Integer>[] readIntPairArray(InputReader in,
			int size) {
		@SuppressWarnings({ "unchecked" })
		Pair<Integer, Integer>[] result = new Pair[size];
		for (int i = 0; i < size; i++)
			result[i] = readIntPair(in);
		return result;
	}

	public static Pair<Long, Long>[] readLongPairArray(InputReader in, int size) {
		@SuppressWarnings({ "unchecked" })
		Pair<Long, Long>[] result = new Pair[size];
		for (int i = 0; i < size; i++)
			result[i] = readLongPair(in);
		return result;
	}

	public static void readIntArrays(InputReader in, int[]... arrays) {
		for (int i = 0; i < arrays[0].length; i++) {
			for (int j = 0; j < arrays.length; j++)
				arrays[j][i] = in.readInt();
		}
	}

	public static void readLongArrays(InputReader in, long[]... arrays) {
		for (int i = 0; i < arrays[0].length; i++) {
			for (int j = 0; j < arrays.length; j++)
				arrays[j][i] = in.readLong();
		}
	}

	public static void readDoubleArrays(InputReader in, double[]... arrays) {
		for (int i = 0; i < arrays[0].length; i++) {
			for (int j = 0; j < arrays.length; j++)
				arrays[j][i] = in.readDouble();
		}
	}

	public static char[][] readTable(InputReader in, int rowCount,
			int columnCount) {
		char[][] table = new char[rowCount][];
		for (int i = 0; i < rowCount; i++)
			table[i] = readCharArray(in, columnCount);
		return table;
	}

	public static int[][] readIntTable(InputReader in, int rowCount,
			int columnCount) {
		int[][] table = new int[rowCount][];
		for (int i = 0; i < rowCount; i++)
			table[i] = readIntArray(in, columnCount);
		return table;
	}

	public static double[][] readDoubleTable(InputReader in, int rowCount,
			int columnCount) {
		double[][] table = new double[rowCount][];
		for (int i = 0; i < rowCount; i++)
			table[i] = readDoubleArray(in, columnCount);
		return table;
	}

	public static long[][] readLongTable(InputReader in, int rowCount,
			int columnCount) {
		long[][] table = new long[rowCount][];
		for (int i = 0; i < rowCount; i++)
			table[i] = readLongArray(in, columnCount);
		return table;
	}

	public static String[][] readStringTable(InputReader in, int rowCount,
			int columnCount) {
		String[][] table = new String[rowCount][];
		for (int i = 0; i < rowCount; i++)
			table[i] = readStringArray(in, columnCount);
		return table;
	}

	public static String readText(InputReader in) {
		StringBuilder result = new StringBuilder();
		while (true) {
			int character = in.read();
			if (character == '\r')
				continue;
			if (character == -1)
				break;
			result.append((char) character);
		}
		return result.toString();
	}

	public static void readStringArrays(InputReader in, String[]... arrays) {
		for (int i = 0; i < arrays[0].length; i++) {
			for (int j = 0; j < arrays.length; j++)
				arrays[j][i] = in.readString();
		}
	}

	public static void printTable(OutputWriter out, char[][] table) {
		for (char[] row : table)
			out.printLine(new String(row));
	}
}

class Pair<U, V> implements Comparable<Pair<U, V>> {
	public final U first;
	public final V second;

	public static <U, V> Pair<U, V> makePair(U first, V second) {
		return new Pair<U, V>(first, second);
	}

	private Pair(U first, V second) {
		this.first = first;
		this.second = second;
	}

	@Override
	public boolean equals(Object o) {
		if (this == o)
			return true;
		if (o == null || getClass() != o.getClass())
			return false;

		Pair<?, ?> pair = (Pair<?, ?>) o;

		return !(first != null ? !first.equals(pair.first) : pair.first != null)
				&& !(second != null ? !second.equals(pair.second)
						: pair.second != null);

	}

	@Override
	public int hashCode() {
		int result = first != null ? first.hashCode() : 0;
		result = 31 * result + (second != null ? second.hashCode() : 0);
		return result;
	}

	public Pair<V, U> swap() {
		return makePair(second, first);
	}

	@Override
	public String toString() {
		return "(" + first + "," + second + ")";
	}

	@SuppressWarnings({ "unchecked" })
	public int compareTo(Pair<U, V> o) {
		int value = ((Comparable<U>) first).compareTo(o.first);
		if (value != 0)
			return value;
		return ((Comparable<V>) second).compareTo(o.second);
	}
}

class BidirectionalGraph extends Graph {
	public int[] transposedEdge;

	public BidirectionalGraph(int vertexCount) {
		this(vertexCount, vertexCount);
	}

	public BidirectionalGraph(int vertexCount, int edgeCapacity) {
		super(vertexCount, 2 * edgeCapacity);
		transposedEdge = new int[2 * edgeCapacity];
	}

	public static BidirectionalGraph createGraph(int vertexCount, int[] from,
			int[] to) {
		BidirectionalGraph graph = new BidirectionalGraph(vertexCount,
				from.length);
		for (int i = 0; i < from.length; i++)
			graph.addSimpleEdge(from[i], to[i]);
		return graph;
	}

	public static BidirectionalGraph createWeightedGraph(int vertexCount,
			int[] from, int[] to, long[] weight) {
		BidirectionalGraph graph = new BidirectionalGraph(vertexCount,
				from.length);
		for (int i = 0; i < from.length; i++)
			graph.addWeightedEdge(from[i], to[i], weight[i]);
		return graph;
	}

	public static BidirectionalGraph createFlowGraph(int vertexCount,
			int[] from, int[] to, long[] capacity) {
		BidirectionalGraph graph = new BidirectionalGraph(vertexCount,
				from.length * 2);
		for (int i = 0; i < from.length; i++)
			graph.addFlowEdge(from[i], to[i], capacity[i]);
		return graph;
	}

	public static BidirectionalGraph createFlowWeightedGraph(int vertexCount,
			int[] from, int[] to, long[] weight, long[] capacity) {
		BidirectionalGraph graph = new BidirectionalGraph(vertexCount,
				from.length * 2);
		for (int i = 0; i < from.length; i++)
			graph.addFlowWeightedEdge(from[i], to[i], weight[i], capacity[i]);
		return graph;
	}

	@Override
	public int addEdge(int fromID, int toID, long weight, long capacity,
			int reverseEdge) {
		int lastEdgeCount = edgeCount;
		super.addEdge(fromID, toID, weight, capacity, reverseEdge);
		super.addEdge(toID, fromID, weight, capacity, reverseEdge == -1 ? -1
				: reverseEdge + 1);
		this.transposedEdge[lastEdgeCount] = lastEdgeCount + 1;
		this.transposedEdge[lastEdgeCount + 1] = lastEdgeCount;
		return lastEdgeCount;
	}

	@Override
	protected int entriesPerEdge() {
		return 2;
	}

	@Override
	public final int transposed(int id) {
		return transposedEdge[id];
	}

	@Override
	protected void ensureEdgeCapacity(int size) {
		if (size > edgeCapacity()) {
			super.ensureEdgeCapacity(size);
			transposedEdge = resize(transposedEdge, edgeCapacity());
		}
	}
}

class Graph {
	public static final int REMOVED_BIT = 0;

	protected int vertexCount;
	protected int edgeCount;

	private int[] firstOutbound;
	private int[] firstInbound;

	private Edge[] edges;
	private int[] nextInbound;
	private int[] nextOutbound;
	private int[] from;
	private int[] to;
	private long[] weight;
	private long[] capacity;
	private int[] reverseEdge;
	private int[] flags;

	public Graph(int vertexCount) {
		this(vertexCount, vertexCount);
	}

	public Graph(int vertexCount, int edgeCapacity) {
		this.vertexCount = vertexCount;
		firstOutbound = new int[vertexCount];
		Arrays.fill(firstOutbound, -1);

		from = new int[edgeCapacity];
		to = new int[edgeCapacity];
		nextOutbound = new int[edgeCapacity];
		flags = new int[edgeCapacity];
	}

	public static Graph createGraph(int vertexCount, int[] from, int[] to) {
		Graph graph = new Graph(vertexCount, from.length);
		for (int i = 0; i < from.length; i++)
			graph.addSimpleEdge(from[i], to[i]);
		return graph;
	}

	public static Graph createWeightedGraph(int vertexCount, int[] from,
			int[] to, long[] weight) {
		Graph graph = new Graph(vertexCount, from.length);
		for (int i = 0; i < from.length; i++)
			graph.addWeightedEdge(from[i], to[i], weight[i]);
		return graph;
	}

	public static Graph createFlowGraph(int vertexCount, int[] from, int[] to,
			long[] capacity) {
		Graph graph = new Graph(vertexCount, from.length * 2);
		for (int i = 0; i < from.length; i++)
			graph.addFlowEdge(from[i], to[i], capacity[i]);
		return graph;
	}

	public static Graph createFlowWeightedGraph(int vertexCount, int[] from,
			int[] to, long[] weight, long[] capacity) {
		Graph graph = new Graph(vertexCount, from.length * 2);
		for (int i = 0; i < from.length; i++)
			graph.addFlowWeightedEdge(from[i], to[i], weight[i], capacity[i]);
		return graph;
	}

	public static Graph createTree(int[] parent) {
		Graph graph = new Graph(parent.length + 1, parent.length);
		for (int i = 0; i < parent.length; i++)
			graph.addSimpleEdge(parent[i], i + 1);
		return graph;
	}

	public int addEdge(int fromID, int toID, long weight, long capacity,
			int reverseEdge) {
		ensureEdgeCapacity(edgeCount + 1);
		if (firstOutbound[fromID] != -1)
			nextOutbound[edgeCount] = firstOutbound[fromID];
		else
			nextOutbound[edgeCount] = -1;
		firstOutbound[fromID] = edgeCount;
		if (firstInbound != null) {
			if (firstInbound[toID] != -1)
				nextInbound[edgeCount] = firstInbound[toID];
			else
				nextInbound[edgeCount] = -1;
			firstInbound[toID] = edgeCount;
		}
		this.from[edgeCount] = fromID;
		this.to[edgeCount] = toID;
		if (capacity != 0) {
			if (this.capacity == null)
				this.capacity = new long[from.length];
			this.capacity[edgeCount] = capacity;
		}
		if (weight != 0) {
			if (this.weight == null)
				this.weight = new long[from.length];
			this.weight[edgeCount] = weight;
		}
		if (reverseEdge != -1) {
			if (this.reverseEdge == null) {
				this.reverseEdge = new int[from.length];
				Arrays.fill(this.reverseEdge, 0, edgeCount, -1);
			}
			this.reverseEdge[edgeCount] = reverseEdge;
		}
		if (edges != null)
			edges[edgeCount] = createEdge(edgeCount);
		return edgeCount++;
	}

	protected final GraphEdge createEdge(int id) {
		return new GraphEdge(id);
	}

	public final int addFlowWeightedEdge(int from, int to, long weight,
			long capacity) {
		if (capacity == 0) {
			return addEdge(from, to, weight, 0, -1);
		} else {
			int lastEdgeCount = edgeCount;
			addEdge(to, from, -weight, 0, lastEdgeCount + entriesPerEdge());
			return addEdge(from, to, weight, capacity, lastEdgeCount);
		}
	}

	protected int entriesPerEdge() {
		return 1;
	}

	public final int addFlowEdge(int from, int to, long capacity) {
		return addFlowWeightedEdge(from, to, 0, capacity);
	}

	public final int addWeightedEdge(int from, int to, long weight) {
		return addFlowWeightedEdge(from, to, weight, 0);
	}

	public final int addSimpleEdge(int from, int to) {
		return addWeightedEdge(from, to, 0);
	}

	public final int vertexCount() {
		return vertexCount;
	}

	public final int edgeCount() {
		return edgeCount;
	}

	protected final int edgeCapacity() {
		return from.length;
	}

	public final Edge edge(int id) {
		initEdges();
		return edges[id];
	}

	public final int firstOutbound(int vertex) {
		int id = firstOutbound[vertex];
		while (id != -1 && isRemoved(id))
			id = nextOutbound[id];
		return id;
	}

	public final int nextOutbound(int id) {
		id = nextOutbound[id];
		while (id != -1 && isRemoved(id))
			id = nextOutbound[id];
		return id;
	}

	public final int firstInbound(int vertex) {
		initInbound();
		int id = firstInbound[vertex];
		while (id != -1 && isRemoved(id))
			id = nextInbound[id];
		return id;
	}

	public final int nextInbound(int id) {
		initInbound();
		id = nextInbound[id];
		while (id != -1 && isRemoved(id))
			id = nextInbound[id];
		return id;
	}

	public final int source(int id) {
		return from[id];
	}

	public final int destination(int id) {
		return to[id];
	}

	public final long weight(int id) {
		if (weight == null)
			return 0;
		return weight[id];
	}

	public final long capacity(int id) {
		if (capacity == null)
			return 0;
		return capacity[id];
	}

	public final long flow(int id) {
		if (reverseEdge == null)
			return 0;
		return capacity[reverseEdge[id]];
	}

	public final void pushFlow(int id, long flow) {
		if (flow == 0)
			return;
		if (flow > 0) {
			if (capacity(id) < flow)
				throw new IllegalArgumentException("Not enough capacity");
		} else {
			if (flow(id) < -flow)
				throw new IllegalArgumentException("Not enough capacity");
		}
		capacity[id] -= flow;
		capacity[reverseEdge[id]] += flow;
	}

	public int transposed(int id) {
		return -1;
	}

	public final int reverse(int id) {
		if (reverseEdge == null)
			return -1;
		return reverseEdge[id];
	}

	public final void addVertices(int count) {
		ensureVertexCapacity(vertexCount + count);
		Arrays.fill(firstOutbound, vertexCount, vertexCount + count, -1);
		if (firstInbound != null)
			Arrays.fill(firstInbound, vertexCount, vertexCount + count, -1);
		vertexCount += count;
	}

	protected final void initEdges() {
		if (edges == null) {
			edges = new Edge[from.length];
			for (int i = 0; i < edgeCount; i++)
				edges[i] = createEdge(i);
		}
	}

	public final void removeVertex(int vertex) {
		int id = firstOutbound[vertex];
		while (id != -1) {
			removeEdge(id);
			id = nextOutbound[id];
		}
		initInbound();
		id = firstInbound[vertex];
		while (id != -1) {
			removeEdge(id);
			id = nextInbound[id];
		}
	}

	private void initInbound() {
		if (firstInbound == null) {
			firstInbound = new int[firstOutbound.length];
			Arrays.fill(firstInbound, 0, vertexCount, -1);
			nextInbound = new int[from.length];
			for (int i = 0; i < edgeCount; i++) {
				nextInbound[i] = firstInbound[to[i]];
				firstInbound[to[i]] = i;
			}
		}
	}

	public final boolean flag(int id, int bit) {
		return (flags[id] >> bit & 1) != 0;
	}

	public final void setFlag(int id, int bit) {
		flags[id] |= 1 << bit;
	}

	public final void removeFlag(int id, int bit) {
		flags[id] &= -1 - (1 << bit);
	}

	public final void removeEdge(int id) {
		setFlag(id, REMOVED_BIT);
	}

	public final void restoreEdge(int id) {
		removeFlag(id, REMOVED_BIT);
	}

	public final boolean isRemoved(int id) {
		return flag(id, REMOVED_BIT);
	}

	public final Iterable<Edge> outbound(final int id) {
		initEdges();
		return new Iterable<Edge>() {
			public Iterator<Edge> iterator() {
				return new EdgeIterator(id, firstOutbound, nextOutbound);
			}
		};
	}

	public final Iterable<Edge> inbound(final int id) {
		initEdges();
		initInbound();
		return new Iterable<Edge>() {
			public Iterator<Edge> iterator() {
				return new EdgeIterator(id, firstInbound, nextInbound);
			}
		};
	}

	protected void ensureEdgeCapacity(int size) {
		if (from.length < size) {
			int newSize = Math.max(size, 2 * from.length);
			if (edges != null)
				edges = resize(edges, newSize);
			from = resize(from, newSize);
			to = resize(to, newSize);
			nextOutbound = resize(nextOutbound, newSize);
			if (nextInbound != null)
				nextInbound = resize(nextInbound, newSize);
			if (weight != null)
				weight = resize(weight, newSize);
			if (capacity != null)
				capacity = resize(capacity, newSize);
			if (reverseEdge != null)
				reverseEdge = resize(reverseEdge, newSize);
			flags = resize(flags, newSize);
		}
	}

	private void ensureVertexCapacity(int size) {
		if (firstOutbound.length < size) {
			int newSize = Math.max(size, 2 * from.length);
			firstOutbound = resize(firstOutbound, newSize);
			if (firstInbound != null)
				firstInbound = resize(firstInbound, newSize);
		}
	}

	protected final int[] resize(int[] array, int size) {
		int[] newArray = new int[size];
		System.arraycopy(array, 0, newArray, 0, array.length);
		return newArray;
	}

	private long[] resize(long[] array, int size) {
		long[] newArray = new long[size];
		System.arraycopy(array, 0, newArray, 0, array.length);
		return newArray;
	}

	private Edge[] resize(Edge[] array, int size) {
		Edge[] newArray = new Edge[size];
		System.arraycopy(array, 0, newArray, 0, array.length);
		return newArray;
	}

	public final boolean isSparse() {
		return vertexCount == 0 || edgeCount * 20 / vertexCount <= vertexCount;
	}

	protected class GraphEdge implements Edge {
		protected int id;

		protected GraphEdge(int id) {
			this.id = id;
		}

		public int getSource() {
			return source(id);
		}

		public int getDestination() {
			return destination(id);
		}

		public long getWeight() {
			return weight(id);
		}

		public long getCapacity() {
			return capacity(id);
		}

		public long getFlow() {
			return flow(id);
		}

		public void pushFlow(long flow) {
			Graph.this.pushFlow(id, flow);
		}

		public boolean getFlag(int bit) {
			return flag(id, bit);
		}

		public void setFlag(int bit) {
			Graph.this.setFlag(id, bit);
		}

		public void removeFlag(int bit) {
			Graph.this.removeFlag(id, bit);
		}

		public int getTransposedID() {
			return transposed(id);
		}

		public Edge getTransposedEdge() {
			int reverseID = getTransposedID();
			if (reverseID == -1)
				return null;
			initEdges();
			return edge(reverseID);
		}

		public int getReverseID() {
			return reverse(id);
		}

		public Edge getReverseEdge() {
			int reverseID = getReverseID();
			if (reverseID == -1)
				return null;
			initEdges();
			return edge(reverseID);
		}

		public int getID() {
			return id;
		}

		public void remove() {
			removeEdge(id);
		}

		public void restore() {
			restoreEdge(id);
		}
	}

	public class EdgeIterator implements Iterator<Edge> {
		private int edgeID;
		private final int[] next;
		private int lastID = -1;

		public EdgeIterator(int id, int[] first, int[] next) {
			this.next = next;
			edgeID = nextEdge(first[id]);
		}

		private int nextEdge(int id) {
			while (id != -1 && isRemoved(id))
				id = next[id];
			return id;
		}

		public boolean hasNext() {
			return edgeID != -1;
		}

		public Edge next() {
			if (edgeID == -1)
				throw new NoSuchElementException();
			lastID = edgeID;
			edgeID = nextEdge(next[lastID]);
			return edges[lastID];
		}

		public void remove() {
			if (lastID == -1)
				throw new IllegalStateException();
			removeEdge(lastID);
			lastID = -1;
		}
	}

}

interface Edge {
	public int getSource();

	public int getDestination();

	public long getWeight();

	public long getCapacity();

	public long getFlow();

	public void pushFlow(long flow);

	public boolean getFlag(int bit);

	public void setFlag(int bit);

	public void removeFlag(int bit);

	public int getTransposedID();

	public Edge getTransposedEdge();

	public int getReverseID();

	public Edge getReverseEdge();

	public int getID();

	public void remove();

	public void restore();
}

class MiscUtils {
	public static final int[] DX4 = { 1, 0, -1, 0 };
	public static final int[] DY4 = { 0, -1, 0, 1 };
	public static final int[] DX8 = { 1, 1, 1, 0, -1, -1, -1, 0 };
	public static final int[] DY8 = { -1, 0, 1, 1, 1, 0, -1, -1 };
	public static final int[] DX_KNIGHT = { 2, 1, -1, -2, -2, -1, 1, 2 };
	public static final int[] DY_KNIGHT = { 1, 2, 2, 1, -1, -2, -2, -1 };

	private static final String[] ROMAN_TOKENS = { "M", "CM", "D", "CD", "C",
			"XC", "L", "XL", "X", "IX", "V", "IV", "I" };
	private static final int[] ROMAN_VALUES = { 1000, 900, 500, 400, 100, 90,
			50, 40, 10, 9, 5, 4, 1 };

	public static long josephProblem(long n, int k) {
		if (n == 1)
			return 0;
		if (k == 1)
			return n - 1;
		if (k > n)
			return (josephProblem(n - 1, k) + k) % n;
		long count = n / k;
		long result = josephProblem(n - count, k);
		result -= n % k;
		if (result < 0)
			result += n;
		else
			result += result / (k - 1);
		return result;
	}

	public static boolean isValidCell(int row, int column, int rowCount,
			int columnCount) {
		return row >= 0 && row < rowCount && column >= 0
				&& column < columnCount;
	}

	public static List<Integer> getPath(int[] last, int destination) {
		List<Integer> path = new ArrayList<Integer>();
		while (destination != -1) {
			path.add(destination);
			destination = last[destination];
		}
		Collections.reverse(path);
		return path;
	}

	public static List<Integer> getPath(int[][] lastIndex,
			int[][] lastPathNumber, int destination, int pathNumber) {
		List<Integer> path = new ArrayList<Integer>();
		while (destination != -1 || pathNumber != 0) {
			path.add(destination);
			int nextDestination = lastIndex[destination][pathNumber];
			pathNumber = lastPathNumber[destination][pathNumber];
			destination = nextDestination;
		}
		Collections.reverse(path);
		return path;
	}

	public static long maximalRectangleSum(long[][] array) {
		int n = array.length;
		int m = array[0].length;
		long[][] partialSums = new long[n + 1][m + 1];
		for (int i = 0; i < n; i++) {
			long rowSum = 0;
			for (int j = 0; j < m; j++) {
				rowSum += array[i][j];
				partialSums[i + 1][j + 1] = partialSums[i][j + 1] + rowSum;
			}
		}
		long result = Long.MIN_VALUE;
		for (int i = 0; i < m; i++) {
			for (int j = i; j < m; j++) {
				long minPartialSum = 0;
				for (int k = 1; k <= n; k++) {
					long current = partialSums[k][j + 1] - partialSums[k][i];
					result = Math.max(result, current - minPartialSum);
					minPartialSum = Math.min(minPartialSum, current);
				}
			}
		}
		return result;
	}

	public static int parseIP(String ip) {
		String[] components = ip.split("[.]");
		int result = 0;
		for (int i = 0; i < 4; i++)
			result += (1 << (24 - 8 * i)) * Integer.parseInt(components[i]);
		return result;
	}

	public static String buildIP(int mask) {
		StringBuilder result = new StringBuilder();
		for (int i = 0; i < 4; i++) {
			if (i != 0)
				result.append('.');
			result.append(mask >> (24 - 8 * i) & 255);
		}
		return result.toString();
	}

	public static long binarySearch(long from, long to,
			Function<Long, Boolean> function) {
		while (from < to) {
			long argument = from + (to - from) / 2;
			if (function.value(argument))
				to = argument;
			else
				from = argument + 1;
		}
		return from;
	}

	public static <T> boolean equals(T first, T second) {
		return first == null && second == null || first != null
				&& first.equals(second);
	}

	public static boolean isVowel(char ch) {
		ch = Character.toUpperCase(ch);
		return ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U'
				|| ch == 'Y';
	}

	public static boolean isStrictVowel(char ch) {
		ch = Character.toUpperCase(ch);
		return ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U';
	}

	public static String convertToRoman(int number) {
		StringBuilder result = new StringBuilder();
		for (int i = 0; i < ROMAN_TOKENS.length; i++) {
			while (number >= ROMAN_VALUES[i]) {
				number -= ROMAN_VALUES[i];
				result.append(ROMAN_TOKENS[i]);
			}
		}
		return result.toString();
	}

	public static int convertFromRoman(String number) {
		int result = 0;
		for (int i = 0; i < ROMAN_TOKENS.length; i++) {
			while (number.startsWith(ROMAN_TOKENS[i])) {
				number = number.substring(ROMAN_TOKENS[i].length());
				result += ROMAN_VALUES[i];
			}
		}
		return result;
	}

	public static int distance(int x1, int y1, int x2, int y2) {
		int dx = x1 - x2;
		int dy = y1 - y2;
		return dx * dx + dy * dy;
	}

	public static <T extends Comparable<T>> T min(T first, T second) {
		if (first.compareTo(second) <= 0)
			return first;
		return second;
	}

	public static <T extends Comparable<T>> T max(T first, T second) {
		if (first.compareTo(second) <= 0)
			return second;
		return first;
	}

	public static void decreaseByOne(int[]... arrays) {
		for (int[] array : arrays) {
			for (int i = 0; i < array.length; i++)
				array[i]--;
		}
	}

	public static int[] getIntArray(String s) {
		String[] tokens = s.split(" ");
		int[] result = new int[tokens.length];
		for (int i = 0; i < result.length; i++)
			result[i] = Integer.parseInt(tokens[i]);
		return result;
	}
}

interface Function<A, V> {
	public abstract V value(A argument);
}

interface IntComparator {
	public static final IntComparator DEFAULT = new IntComparator() {
		public int compare(int first, int second) {
			if (first < second)
				return -1;
			if (first > second)
				return 1;
			return 0;
		}
	};

	public static final IntComparator REVERSE = new IntComparator() {
		public int compare(int first, int second) {
			if (first < second)
				return 1;
			if (first > second)
				return -1;
			return 0;
		}
	};

	public int compare(int first, int second);
}

class DFSOrder {
	public final int[] position;
	public final int[] end;

	public DFSOrder(Graph graph) {
		this(graph, 0);
	}

	public DFSOrder(Graph graph, int root) {
		int count = graph.vertexCount();
		position = new int[count];
		end = new int[count];
		int[] edge = new int[count];
		int[] stack = new int[count];
		for (int i = 0; i < count; i++)
			edge[i] = graph.firstOutbound(i);
		stack[0] = root;
		int size = 1;
		position[root] = 0;
		int index = 0;
		while (size > 0) {
			int current = stack[size - 1];
			if (edge[current] == -1) {
				end[current] = index;
				size--;
			} else {
				int next = graph.destination(edge[current]);
				edge[current] = graph.nextOutbound(edge[current]);
				position[next] = ++index;
				stack[size++] = next;
			}
		}
	}

	public DFSOrder(BidirectionalGraph graph) {
		this(graph, 0);
	}

	public DFSOrder(BidirectionalGraph graph, int root) {
		int count = graph.vertexCount();
		position = new int[count];
		end = new int[count];
		int[] edge = new int[count];
		int[] stack = new int[count];
		int[] last = new int[count];
		for (int i = 0; i < count; i++)
			edge[i] = graph.firstOutbound(i);
		stack[0] = root;
		last[root] = -1;
		int size = 1;
		position[root] = 0;
		int index = 0;
		while (size > 0) {
			int current = stack[size - 1];
			if (edge[current] == -1) {
				end[current] = index;
				size--;
			} else {
				int next = graph.destination(edge[current]);
				if (next == last[current]) {
					edge[current] = graph.nextOutbound(edge[current]);
					continue;
				}
				edge[current] = graph.nextOutbound(edge[current]);
				position[next] = ++index;
				last[next] = current;
				stack[size++] = next;
			}
		}
	}
}

abstract class IntervalTree {
	protected int size;

	protected IntervalTree(int size) {
		this(size, true);
	}

	public IntervalTree(int size, boolean shouldInit) {
		this.size = size;
		int nodeCount = Math.max(1, Integer.highestOneBit(size) << 2);
		initData(size, nodeCount);
		if (shouldInit)
			init();
	}

	protected abstract void initData(int size, int nodeCount);

	protected abstract void initAfter(int root, int left, int right, int middle);

	protected abstract void initBefore(int root, int left, int right, int middle);

	protected abstract void initLeaf(int root, int index);

	protected abstract void updatePostProcess(int root, int left, int right,
			int from, int to, long delta, int middle);

	protected abstract void updatePreProcess(int root, int left, int right,
			int from, int to, long delta, int middle);

	protected abstract void updateFull(int root, int left, int right, int from,
			int to, long delta);

	protected abstract long queryPostProcess(int root, int left, int right,
			int from, int to, int middle, long leftResult, long rightResult);

	protected abstract void queryPreProcess(int root, int left, int right,
			int from, int to, int middle);

	protected abstract long queryFull(int root, int left, int right, int from,
			int to);

	protected abstract long emptySegmentResult();

	public void init() {
		if (size == 0)
			return;
		init(0, 0, size - 1);
	}

	private void init(int root, int left, int right) {
		if (left == right) {
			initLeaf(root, left);
		} else {
			int middle = (left + right) >> 1;
			initBefore(root, left, right, middle);
			init(2 * root + 1, left, middle);
			init(2 * root + 2, middle + 1, right);
			initAfter(root, left, right, middle);
		}
	}

	public void update(int from, int to, long delta) {
		update(0, 0, size - 1, from, to, delta);
	}

	protected void update(int root, int left, int right, int from, int to,
			long delta) {
		if (left > to || right < from)
			return;
		if (left >= from && right <= to) {
			updateFull(root, left, right, from, to, delta);
			return;
		}
		int middle = (left + right) >> 1;
		updatePreProcess(root, left, right, from, to, delta, middle);
		update(2 * root + 1, left, middle, from, to, delta);
		update(2 * root + 2, middle + 1, right, from, to, delta);
		updatePostProcess(root, left, right, from, to, delta, middle);
	}

	public long query(int from, int to) {
		return query(0, 0, size - 1, from, to);
	}

	protected long query(int root, int left, int right, int from, int to) {
		if (left > to || right < from)
			return emptySegmentResult();
		if (left >= from && right <= to)
			return queryFull(root, left, right, from, to);
		int middle = (left + right) >> 1;
		queryPreProcess(root, left, right, from, to, middle);
		long leftResult = query(2 * root + 1, left, middle, from, to);
		long rightResult = query(2 * root + 2, middle + 1, right, from, to);
		return queryPostProcess(root, left, right, from, to, middle,
				leftResult, rightResult);
	}
}

class LCA {
	private final long[] order;
	private final int[] position;
	private final IntervalTree lcaTree;
	private final int[] level;

	public LCA(Graph graph) {
		this(graph, 0);
	}

	public LCA(Graph graph, int root) {
		order = new long[2 * graph.vertexCount() - 1];
		position = new int[graph.vertexCount()];
		level = new int[graph.vertexCount()];
		int[] index = new int[graph.vertexCount()];
		for (int i = 0; i < index.length; i++)
			index[i] = graph.firstOutbound(i);
		int[] last = new int[graph.vertexCount()];
		int[] stack = new int[graph.vertexCount()];
		stack[0] = root;
		int size = 1;
		int j = 0;
		last[root] = -1;
		Arrays.fill(position, -1);
		while (size > 0) {
			int vertex = stack[--size];
			if (position[vertex] == -1)
				position[vertex] = j;
			order[j++] = vertex;
			if (last[vertex] != -1)
				level[vertex] = level[last[vertex]] + 1;
			while (index[vertex] != -1
					&& last[vertex] == graph.destination(index[vertex]))
				index[vertex] = graph.nextOutbound(index[vertex]);
			if (index[vertex] != -1) {
				stack[size++] = vertex;
				stack[size++] = graph.destination(index[vertex]);
				last[graph.destination(index[vertex])] = vertex;
				index[vertex] = graph.nextOutbound(index[vertex]);
			}
		}
		lcaTree = new ReadOnlyIntervalTree(order) {
			@Override
			protected long joinValue(long left, long right) {
				if (left == -1)
					return right;
				if (right == -1)
					return left;
				if (level[((int) left)] < level[((int) right)])
					return left;
				return right;
			}

			@Override
			protected long neutralValue() {
				return -1;
			}
		};
		lcaTree.init();
	}

	public int getPosition(int vertex) {
		return position[vertex];
	}

	public int getLCA(int first, int second) {
		return (int) lcaTree.query(Math.min(position[first], position[second]),
				Math.max(position[first], position[second]));
	}

	public int getLevel(int vertex) {
		return level[vertex];
	}

	public int getPathLength(int first, int second) {
		return level[first] + level[second] - 2 * level[getLCA(first, second)];
	}
}

abstract class LongIntervalTree extends IntervalTree {
	protected long[] value;
	protected long[] delta;

	protected LongIntervalTree(int size) {
		this(size, true);
	}

	public LongIntervalTree(int size, boolean shouldInit) {
		super(size, shouldInit);
	}

	@Override
	protected void initData(int size, int nodeCount) {
		value = new long[nodeCount];
		delta = new long[nodeCount];
	}

	protected abstract long joinValue(long left, long right);

	protected abstract long joinDelta(long was, long delta);

	protected abstract long accumulate(long value, long delta, int length);

	protected abstract long neutralValue();

	protected abstract long neutralDelta();

	protected long initValue(int index) {
		return neutralValue();
	}

	@Override
	protected void initAfter(int root, int left, int right, int middle) {
		value[root] = joinValue(value[2 * root + 1], value[2 * root + 2]);
		delta[root] = neutralDelta();
	}

	@Override
	protected void initBefore(int root, int left, int right, int middle) {
	}

	@Override
	protected void initLeaf(int root, int index) {
		value[root] = initValue(index);
		delta[root] = neutralDelta();
	}

	@Override
	protected void updatePostProcess(int root, int left, int right, int from,
			int to, long delta, int middle) {
		value[root] = joinValue(value[2 * root + 1], value[2 * root + 2]);
	}

	@Override
	protected void updatePreProcess(int root, int left, int right, int from,
			int to, long delta, int middle) {
		pushDown(root, left, middle, right);
	}

	protected void pushDown(int root, int left, int middle, int right) {
		value[2 * root + 1] = accumulate(value[2 * root + 1], delta[root],
				middle - left + 1);
		value[2 * root + 2] = accumulate(value[2 * root + 2], delta[root],
				right - middle);
		delta[2 * root + 1] = joinDelta(delta[2 * root + 1], delta[root]);
		delta[2 * root + 2] = joinDelta(delta[2 * root + 2], delta[root]);
		delta[root] = neutralDelta();
	}

	@Override
	protected void updateFull(int root, int left, int right, int from, int to,
			long delta) {
		value[root] = accumulate(value[root], delta, right - left + 1);
		this.delta[root] = joinDelta(this.delta[root], delta);
	}

	@Override
	protected long queryPostProcess(int root, int left, int right, int from,
			int to, int middle, long leftResult, long rightResult) {
		return joinValue(leftResult, rightResult);
	}

	@Override
	protected void queryPreProcess(int root, int left, int right, int from,
			int to, int middle) {
		pushDown(root, left, middle, right);
	}

	@Override
	protected long queryFull(int root, int left, int right, int from, int to) {
		return value[root];
	}

	@Override
	protected long emptySegmentResult() {
		return neutralValue();
	}
}

class SumIntervalTree extends LongIntervalTree {
	public SumIntervalTree(int size) {
		super(size);
	}

	@Override
	protected long joinValue(long left, long right) {
		return left + right;
	}

	@Override
	protected long joinDelta(long was, long delta) {
		return was + delta;
	}

	@Override
	protected long accumulate(long value, long delta, int length) {
		return value + delta * length;
	}

	@Override
	protected long neutralValue() {
		return 0;
	}

	@Override
	protected long neutralDelta() {
		return 0;
	}
}

abstract class ReadOnlyIntervalTree extends IntervalTree {
	protected long[] value;
	protected long[] array;

	protected ReadOnlyIntervalTree(long[] array) {
		super(array.length, false);
		this.array = array;
		init();
	}

	@Override
	protected void initData(int size, int nodeCount) {
		value = new long[nodeCount];
	}

	@Override
	protected void initAfter(int root, int left, int right, int middle) {
		value[root] = joinValue(value[2 * root + 1], value[2 * root + 2]);
	}

	@Override
	protected void initBefore(int root, int left, int right, int middle) {
	}

	@Override
	protected void initLeaf(int root, int index) {
		value[root] = array[index];
	}

	@Override
	protected void updatePostProcess(int root, int left, int right, int from,
			int to, long delta, int middle) {
		throw new UnsupportedOperationException();
	}

	@Override
	protected void updatePreProcess(int root, int left, int right, int from,
			int to, long delta, int middle) {
		throw new UnsupportedOperationException();
	}

	@Override
	protected void updateFull(int root, int left, int right, int from, int to,
			long delta) {
		throw new UnsupportedOperationException();
	}

	@Override
	protected long queryPostProcess(int root, int left, int right, int from,
			int to, int middle, long leftResult, long rightResult) {
		return joinValue(leftResult, rightResult);
	}

	@Override
	protected void queryPreProcess(int root, int left, int right, int from,
			int to, int middle) {
	}

	@Override
	protected long queryFull(int root, int left, int right, int from, int to) {
		return value[root];
	}

	@Override
	protected long emptySegmentResult() {
		return neutralValue();
	}

	@Override
	public void update(int from, int to, long delta) {
		throw new UnsupportedOperationException();
	}

	@Override
	protected void update(int root, int left, int right, int from, int to,
			long delta) {
		throw new UnsupportedOperationException();
	}

	protected abstract long neutralValue();

	protected abstract long joinValue(long left, long right);
}package OldAttemptLearning.Soundar;

/**
 * Created by hadoop on 12/8/17.
 */
public class Codeforces4dMysteriousPresent {
    public static void main(String args[]){

    }
}
package OldAttemptLearning.Soundar;

import java.util.Arrays;

/**
 * Created by hadoop on 12/8/17.
 */
public class TrainSorting {
    public static void main(String[] args) {
        int array[] ={1,3,2,4,5,6};
        int ans = lis(array);
    }

    private static int lis(int[] array) {
        int lisarray[] = new int[array.length];
        Arrays.fill(lisarray,1);
        int max = Integer.MAX_VALUE;
        for( int end= 1;end<array.length;end++){
            for( int i=0;i<end;i++){
                if(array[i]<array[end] && lisarray[end]<lisarray[i]+1){
                    lisarray[end] = lisarray[i]+1;
                    max = Math.max(max,lisarray[end]);
                }
            }
        }

        int ldsarray[] = new int[array.length];
        Arrays.fill(ldsarray,1);
        int maxdis = Integer.MAX_VALUE;
        for(int end = 1;end<array.length;end++){
            for( int i=0;i<end;i++){
                if(array[end]<array[i] && ldsarray[end]<ldsarray[i]+1){
                    ldsarray[end] = ldsarray[i]+1;
                    maxdis = Math.max(maxdis,ldsarray[end]);
                }
            }
        }
        int maxlenth = maxdis;
        for(int i=0;i<lisarray.length;i++){
            if(maxlenth<lisarray[i]+ldsarray[i]-1){
                maxlenth = lisarray[i]+ldsarray[i]-1;
            }
        }
        return maxlenth;
    }
}
package OldAttemptLearning.Soundar;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

/**
 * Created by hadoop on 12/8/17.
 */
public class LargestBlockUva10667 {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int testcases = Integer.parseInt(br.readLine());
        int [][]matrix = null;
        for( int testcase = 0;testcase<testcases;testcase++){
            int n = Integer.parseInt(br.readLine());
            matrix = new int[n][n];
            for( int []array:matrix){
                Arrays.fill(array,1);
            }
        }
        int blocks = Integer.parseInt(br.readLine());
        for( int i=0;i<blocks;i++){
            StringTokenizer stringTokenizer = new StringTokenizer(br.readLine());
            int xmin = Integer.parseInt(stringTokenizer.nextToken());
            int xmax = Integer.parseInt(stringTokenizer.nextToken());
            int ymin = Integer.parseInt(stringTokenizer.nextToken());
            int ymax = Integer.parseInt(stringTokenizer.nextToken());

            for( int j=xmin;j<=xmax;j++){
                for( int k = ymax;k<ymin;k++){
                    matrix[j-1][k-1] = -123456;
                }
            }
        }

//        int temp[] = {1,2,-3,-4,5};
//        kadane kad = kadanonedim(temp);
//        System.out.println(kad.maxsum);
//        System.out.println(kad.startcolumn);
//        System.out.println(kad.endcolumn);

    }
    public static int findmaxsubmatrix(int [][]matrix){
        int [][]sum = new int[matrix.length+1][matrix[0].length+1];
        for( int i=0;i<matrix.length;i++){
            for (int j=0;j<matrix[0].length;j++){
                if(i==0 || j==0){
                    sum[i][j] = 0;
                }
                else{
                    sum[i][j] = matrix[i][j] + sum[i][j-1]+sum[i-1][j] -sum[i-1][j-1];
                }
            }
        }
        int max = Integer.MIN_VALUE;
        int rowstart = -1;
        int rowend = -1;
        int columntart = -1;
        int columnend = -1;

        for( int i=0;i<matrix.length;i++){
            for( int j=i;j<matrix.length;j++){
                for(int m=0;m<matrix[0].length;m++){
                    for( int n = m;n<matrix[0].length;n++){

                        int submatrixsum = sum[j+1][n+1]-sum[i][n+1]-sum[j+1][m] +sum[i][m];
                        if(submatrixsum > max){
                            max = submatrixsum;
                            rowstart = i;
                            rowend = j;
                            columntart = m;
                            columnend = n;
                        }
                    }
                }

            }
        }
        System.out.println("maxsum "+max);
        return max;
    }
    public static int findmaxsubusingkadan(int [][]matrix){
        int max = Integer.MIN_VALUE;
        int rowstart = -1;
        int rowend = -1;
        int columnstart = -1;
        int columnend = -1;
        int []temp = new int[matrix[0].length];
        for( int i=0;i<matrix.length;i++){
            for(int k=0;k<matrix[0].length;k++){
                temp[k] = 0;
            }
            for (int j=i;j<matrix.length;j++){
                for(int col=0;col<matrix[0].length;col++){
                    temp[col] = temp[col]+ matrix[j][col];
                }
                kadane ka = kadanonedim(temp);
                if(ka.maxsum>max){
                    max = ka.maxsum;
                    rowstart = i;
                    rowend = j;
                    columnstart = ka.startcolumn;
                    columnend  =ka.endcolumn;
                }

            }
        }
        return max;
    }
    static class kadane{
        int startcolumn;
        int endcolumn;
        int maxsum;

        public kadane(int startcolumn, int endcolumn, int maxsum) {
            this.startcolumn = startcolumn;
            this.endcolumn = endcolumn;
            this.maxsum = maxsum;
        }
    }

    public static kadane kadanonedim( int [] temp){
        int max = Integer.MIN_VALUE;
        int startcolumn = -1;
        int startcolumntemp = 0;
                int endcolumn = -1;
        int maxsofar=0;

        for( int i=0;i<temp.length;i++){
            maxsofar = maxsofar +temp[i];
            if(maxsofar<0){
                maxsofar=0;
                startcolumntemp = i+1;
            }
            if(maxsofar>max){
                max = maxsofar;
                endcolumn = i;
                startcolumn = startcolumntemp;
            }
        }
        return new kadane(startcolumn,endcolumn,max);
    }
}
package OldAttemptLearning.zhengyang2015;

public class Solution {
    /**
     *@param L: Given n pieces of wood with length L[i]
     *@param k: An integer
     *return: The maximum length of the small pieces.
     */
    public static int woodCut(int[] L, int k) {
        if (L == null || L.length == 0) return 0;

        int lb = 0, ub = Integer.MIN_VALUE;
        // get the upper bound of L
        for (int l : L) if (l > ub) ub = l + 1;

        System.out.println("lb"+lb);
        System.out.println("ub"+ub);
        while (lb + 1 < ub) {
            int mid = lb + (ub - lb) / 2;
            if (C(L, k, mid)) {
                lb = mid;
            } else {
                ub = mid;
            }
        }

        return lb;
    }

    // whether it cut with length x and get more than k pieces
    private static boolean C(int[] L, int k, int x) {
        int sum = 0;
        for (int l : L) {
            sum += l / x;
        }
        return sum >= k;
    }

    public static void main(String[] args) {
        int L[] ={232, 124, 456};
        int k = 7;
        System.out.println("ans"+woodCut(L,k));
    }
}package OldAttemptLearning.zhengyang2015;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * Created by hadoop on 23/8/17.
 */
public class HouseRober {
    public static void main(String[] args) {
        int array [] = {5, 3, 4,11, 2};
        int ans = new HouseRober().houserobber2(array);
        System.out.println(ans);
    }
    public int houserobber( int []array){
        if(array == null || array.length == 0){
            return 0;
        }
        int []dp = new int[array.length+1];
        dp[0] = 0;
        dp[1] = array[0];
        for ( int i=2;i<=array.length;i++){
            dp[i] = Math.max(dp[i-1],dp[i-2] +array[i-1]);
        }
        return dp[array.length];
    }
    public int houserobber2(int [] array){
        if(array == null || array.length == 0){
            return 0;
        }
        int []dp = new int[array.length+1];
        int []last = new int[array.length+1];
        dp[0] = 0;
        last[0] = -1;
        dp[1] = array[0];
        last[1] = 0;
        for ( int i=2;i<=array.length;i++){
            if(dp[i-1] >dp[i-2]+array[i-1]){
                dp[i] = dp[i-1];
                last[i] = i-1;
            }
            else{
                dp[i] = dp[i-2]+array[i-1];
                last[i] =  i-2;
                System.out.println("ans"+array[i-1]);
            }
        }
        for(int i=0;i<last.length;i++){
            System.out.println(last[i]);
        }
        System.out.println(getPath(last,last.length-1));
        return dp[array.length];
    }
    public static List<Integer> getPath(int[] last, int destination) {
       // System.out.println("here"+destination);
        List<Integer> path = new ArrayList<Integer>();
        while (destination != -1 ) {
            path.add(destination);
            destination = last[destination];

         //   System.out.println(destination);
        }
        Collections.reverse(path);
        return path;
    }

    public int houserobber3(Treenode node){

        int [] ans = dp(node);
        return Math.max(ans[0],ans[1]);

    }

    private int[] dp(Treenode node) {
        if( node == null ){
            return new int[]{0,0};
        }

        //first value exclude . second value inclde root
        int [] left = dp(node.left);
        int [] right = dp(node.right);

        int array[] = new int[2];
        array[0] = Math.max(left[0],left[1]) + Math.max(right[0],right[1]);
        array[1] = node.val + left[0] + right[0];

        return array;
    }

    private class Treenode{
        public int val;
        public Treenode left;
        public Treenode right;
        }
}

// dp1 (v) include v
// dp2(v) exclude v

// dp1(v) = CV + summation ( dp2(vi)) vi childresn of v
// dp2(v)= summation (max ( dp1(vi), dp2(vi))) v1 chilren of v
// ans max ( dp1(v),dp2(v))



package OldAttemptLearning.zhengyang2015;

/**
 * Created by hadoop on 23/8/17.
 */
public class CoinsLine {
    public static void main(String[] args) {
        int n = 13;
        System.out.println(firstWillWin(n));
        int array[] = {1,2,4};
        int ans = maxvaluecoinnscollect(array,0);
        System.out.println("ans"+ans);
    }
    public static boolean firstWillWin(int n){
        return search(n) ;
    }

    private static boolean search( int n ){
        if(n ==0){
            return false;
        }
        if(n ==1){
            return true;
        }
        if(n ==2){
            return true;
        }
   //    return !(search(n-1) && search(n-2));
        boolean option1 = !search(n-1) ;
        boolean option2 = !search(n-2);
        return option1 || option2;

    }
    private static int maxvaluecoinnscollect(int array[],int index){
        if(index>=array.length){
            return 0;
        }
        else{
            int valueone = array[index];
            int valuetwo = array[index];
            if(index+1<array.length) {
                valuetwo = valuetwo+ array[index + 1];
            }
            int option1 = valueone + Math.min(maxvaluecoinnscollect(array,index+2),maxvaluecoinnscollect(array,index+3));
            int option2 = valuetwo + Math.min(maxvaluecoinnscollect(array,index+3),maxvaluecoinnscollect(array,index+4));
            return Math.max(option1,option2);
           // Math.max(array[index]+Math.max(maxvaluecoinnscollect(array,index+2),maxvalucoinnscollect(array,index+3),array[index]+array[index+1]+Math.max(maxvaluecoinnscollect(array,index+2),maxvaluecoinnscollect(array,index+3))))
        }

    }
}
package OldAttemptLearning.zhengyang2015;

/**
 * Created by hadoop on 23/8/17.
 */
public class LargestRectangleHistogram {
    public static void main(String args[]){
        LargestRectangleHistogram largestRectangleHistogram= new LargestRectangleHistogram();
        int height []= {2,1,5,6,2,3};
        largestRectangleHistogram.largestRectangleArea(height);
    }
    public int largestRectangleArea(int[] height) {
        if (height == null || height.length == 0) {
            return 0;
        }

        int maxArea = 0;
        for (int i = 0; i < height.length; i++) {
            System.out.println("i "+i);
            int minv = height[i];
            for (int j = i; j < height.length; j++) {
                minv = Math.min(minv,height[j]);
                int area = (j - i + 1) * minv;
                if (area > maxArea) {
                    System.out.println("max area is "+area);
                    System.out.println("max i and j is"+i);
                    System.out.println("max i and j is "+j);
                    maxArea = area;
                }
            }
        }

        return maxArea;
    }
}

package OldAttemptLearning.zhengyang2015;

/**
 * Created by hadoop on 23/8/17.
 */
public class Backpack {
    //The second method dp [i] [j] that the first i pieces of goods can fill the capacity of j backpack. In the case of the first case, the dp [i] [J] = dp [i-1] [j - A [j]], but this condition requires j - A [j]> 0. Take two cases inside the larger value as dp [i] [j].+


    public int backpack(int m , int []array){
        if(m ==0 || array == null || array.length == 0){
            return 0;
        }
        int n = array.length;
        int [][] fillpack = new int[n+1][m+1];
        for( int i=0;i<=n;i++){
            fillpack[i][0] = 1;
        }

        for(int j=0;j<=n;j++){
            fillpack[0][j] = 0;
        }
        fillpack[0][0] = 1;

        for ( int i=1;i<=n;i++){
            for (int j=1;j<=m;j++)
                if(array[i-1]<=j){
                fillpack[i][j] = fillpack[i-1][j] | fillpack[i-1][j-array[i-1]];
                }
                else{
                    fillpack[i][j] = fillpack[i-1][j];
                }
        }
        for(int i=m;i>=0;i--){
            if(fillpack[n][i] == 1){
                return i;
            }
        }
        return -1;
    }
    public static void main(String args[]){
        int [] array = { 2, 3, 5, 7};
        int m = 10;
        int []value = {1,5,2,4};
        Backpack backpack = new Backpack();
        int ans = backpack.backpack(m,array);
        int ansvalue = backpack.backpackvalue(m,array,value);
        int valueagain = backpack.onedvaluereptitions(m,array,value);
        System.out.println(ansvalue);
        System.out.println(valueagain);
        int []arrayagain = {1,2,4};
        int targetagain = 4;
        int totalways = backpack.onedvaluetotalwaysreptitions(targetagain,arrayagain);
        System.out.println("totalways"+totalways);
        int arrayagainagain[] = {1,2,3,3,7};
        int totalwayswithoutreptition = backpack.onedvaluetotalwayswithoutreptitions(targetagain,arrayagainagain);
        System.out.println("total ways without reptitions"+totalwayswithoutreptition);
    }

    private int onedvaluetotalwayswithoutreptitions(int m, int[] array) {
        int f[] = new int[m+1];
        f[0] = 1;

        for( int i=0;i<array.length;i++){
            for( int j = m;j>=array[i];j--){
                f[j] = f[j]+f[j-array[i]];
            }
        }
        return f[m];
    }

    public int backpackvalue(int m , int []array,int []value){
        if(m ==0 || array == null || array.length == 0){
            return 0;
        }
        int n = array.length;
        int [][] fillpack = new int[n+1][m+1];
        for( int i=0;i<=n;i++){
            fillpack[i][0] = 0;
        }

        for(int j=0;j<=n;j++){
            fillpack[0][j] = 0;
        }
        fillpack[0][0] = 0;

        for ( int i=1;i<=n;i++){
            for (int j=1;j<=m;j++)
                if(array[i-1]<=j){
                    fillpack[i][j] = Math.max(fillpack[i-1][j] ,fillpack[i][j-array[i-1]] +value[i-1]);
                }
                else{
                    fillpack[i][j] = fillpack[i-1][j];
                }
        }
        return fillpack[n][m];
    }

    int onedvalue( int m, int []array, int[] value){

        int f[] = new int[m+1];

        for( int i=0;i<array.length;i++){
            for( int j = m;j>=array[i];j--){
                f[j] = Math.max(f[j],f[j-array[i]]+value[i]);
            }
        }
        return f[m];

    }
    int onedvaluereptitions( int m, int []array, int[] value){

        int f[] = new int[m+1];

        for( int i=0;i<array.length;i++){
            for( int j = array[i];j<=m;j++){
                f[j] = Math.max(f[j],f[j-array[i]]+value[i]);
            }
        }
        return f[m];

    }

    int onedvaluetotalwaysreptitions( int m, int []array){
        int f[] = new int[m+1];
        f[0] = 1;

        for( int i=0;i<array.length;i++){
            for( int j = array[i];j<=m;j++){
                f[j] = f[j]+f[j-array[i]];
            }
        }
        return f[m];

    }
    public int backpackdifferentwhereorderchangeswithrelationship(int [] nums, int target){
        int dp[] = new int[target+1];
        dp[0] = 1;
        for( int i=1;i<= target;i++){
            for( int j=0;j<nums.length;j++){
                if(i-nums[j]>=0){
                    dp[i] = dp[i] + dp[i-nums[j]];
                }
            }
        }
        return dp[target];
    }


}
package OldAttemptLearning.zhengyang2015;

/**
 * Created by hadoop on 23/8/17.
 */
public class LISGrid {
    int[] dx = {-1, 1, 0, 0};
    int[] dy = {0, 0, -1, 1};
    public static void main(String[] args) {

        int [][] array = { {1 ,2 ,3 ,4 ,5},
                {16,17,24,23,6},
        {15,18,25,22,7},
    {14,19,20,21,8},
        {13,12,11,10,9} };
        int ans = solution(array);
    }
    static int solution(int [][]array){


    return 1;

    }
}
package OldAttemptLearning.zhengyang2015;

/**
 * Created by hadoop on 23/8/17.
 */
public class PaintFence {
    public static void main(String[] args) {
        int n = 3;
        int k = 2;
        int ans = dp(n,k);
        System.out.println("ans"+ans);
    }

    private static int dp(int n, int k) {
     //   int dp[] = new dp[n+1];
        int samelasttwo [] = new int[n+1];
        int difflasttwo [] = new int[n+1];

        samelasttwo[1] = 0;
        difflasttwo[1] = k;


        for( int i=2;i<=n;i++){
            samelasttwo[i] = difflasttwo[i-1];
            difflasttwo[i] = samelasttwo[i-1]*(k-1)+difflasttwo[i-1]*(k-1) ;
        }

        return samelasttwo[n] + difflasttwo[n];
    }

}
package OldAttemptLearning.zhengyang2015;

/**
 * Created by hadoop on 23/8/17.
 */
public class PaintHouse {
    public static void main(String[] args) {
        int costs[][] =  {{14,2,11},
                {11,14,5},
                {14,3,10}};
            int ans = answer(costs);
        System.out.println(ans);
    }

    private static int answer(int[][] costs) {
        int numberofhouse = costs.length;
        int dp[][] = new int[costs.length+1][costs[0].length];
        for( int i=0;i<costs.length+1;i++){
            for ( int j=0;j<costs[0].length;j++){
                dp[i][j] = Integer.MAX_VALUE;
            }
        }
        for ( int i=0;i<costs[0].length;i++){
            dp[0][i] = 0;
        }
        for(int i=1;i<=costs.length;i++){
            for (int j=0;j<3;j++){
                for(int k =0;k<3  ;k++) {
                    if(k == j){
                        continue;
                    }
                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][k] + costs[i-1][j]);
                    System.out.println("ams i and j "+ i+" "+j+" "+k+ " "+dp[i][j]);
                }
            }
        }

        System.out.println(dp[costs.length][2]);
        System.out.println(dp[costs.length][1]);
        System.out.println(dp[costs.length][0]);

        return 1;
      //  return Math.min(Math.min(dp[costs.length][0],dp[costs.length][1]),dp[costs.length][2]);
    }
    //red green blue
}
package OldAttemptLearning.zhengyang2015;

/**
 * Created by hadoop on 23/8/17.
 */
public class LongestIncreasingContinuousSubsequence {
    public static void main(String[] args) {
        int array[]={5, 4, 2, 1, 3};
        int ans = longestincreasing(array);
        System.out.println(ans);
    }

    private static int longestincreasing(int[] array) {
        if (array == null || array.length == 0){
            return 0;
        }
        if(array.length == 1){
            return 1;
        }
        int length = 1;
        int max = 0;
        for( int i=1;i<array.length;i++){
            if(array[i]>array[i-1]){
                length++;
            }
            else {
                length =1;
            }
            max = Math.max(max,length);
        }
        length = 1;
        for( int i=array.length-2;i>=0;i--){
            if ( array[i]>array[i+1]){
                length++;
            }
            else {
                length=1;
            }
            max = Math.max(max,length);
        }
        return max;
    }
}
package OldAttemptLearning.programgreek;

import java.util.Iterator;
import java.util.Stack;

/**
 * Created by hadoop on 22/8/17.
 */
public class BSTIterator implements Iterator<Integer> {
    Stack<TreeNode> stack = new Stack<TreeNode>();

    public BSTIterator(TreeNode treeNode) {
        while (treeNode!=null){
            stack.push(treeNode);
            treeNode = treeNode.left;
        }
    }

    @Override
    public boolean hasNext() {
        return !stack.isEmpty();
    }

    @Override
    public Integer next() {

        TreeNode treeNode = stack.pop();
        int value = treeNode.val;
        if(treeNode.right!=null){
            treeNode = treeNode.right;
        }
        while (treeNode!=null){
            stack.push(treeNode);
            treeNode = treeNode.left;
        }
        return value;
    }
    private class TreeNode{
        int val;
        TreeNode left;
        TreeNode right;
        TreeNode(int x){
            this.val = x;
        }
    }
}
package OldAttemptLearning.programgreek;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;

/**
 * Created by hadoop on 22/8/17.
 */
public class DepthSumInverse {
    public static void main(String[] args) {
        DepthSumInverse depthSumInverse = new DepthSumInverse();
        List<NestedInteger> list = new LinkedList<NestedInteger>();
        int ans = depthSumInverse.depthsum(list);
    }

    private int depthsum(List<NestedInteger> list) {
        if(list == null || list.size() ==0 ){
            return 0;
        }
        HashMap<Integer,ArrayList<Integer>> map= new HashMap<Integer,ArrayList<Integer>>();
        LinkedList<NestedInteger> queue  = new LinkedList<NestedInteger>();
        LinkedList<Integer> depth = new LinkedList<Integer>();
        for(NestedInteger nestedInteger: list){
            queue.offer(nestedInteger);
            depth.offer(1);
        }
        int maxheight = Integer.MIN_VALUE;
        while (!queue.isEmpty()){
            NestedInteger nestedInteger = queue.poll();
            int d = depth.poll();
            maxheight = Math.max(maxheight,d);
            if(nestedInteger.isInteger()){
                int x = nestedInteger.getInteger();
                if(map.containsKey(d)){
                    map.get(d).add(x);
                }
                else{
                    ArrayList<Integer> arraylist = new ArrayList<Integer>();
                    arraylist.add(x);
                    map.put(d,arraylist);
                }
            }
            else{
                for(NestedInteger nestedInteger1:nestedInteger.getList()){
                        queue.offer(nestedInteger1);
                        depth.offer(d+1);
                }
            }
        }
        int result =0;
        for(int i=maxheight;i>=1;i--){
            if(map.get(i)!=null) {
                for (Integer x :map.get(i)){
                    result = result+ (maxheight-i +1) * x;
                }
            }
        }
        return result;
    }
}
package OldAttemptLearning.programgreek;

/**
 * Created by hadoop on 22/8/17.
 */
public class ShortestDistance1 {
    public static void main(String[] args) {

    }
}
package OldAttemptLearning.programgreek;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

/**
 * Created by hadoop on 22/8/17.
 */
public class NestedIterator implements Iterator<Integer> {
    List<Integer> listofintger = new ArrayList<Integer>();
    Iterator<Integer> iterator ;
    NestedIterator(List<NestedInteger> list){
        flatten(list);
        iterator = listofintger.iterator();
    }
    @Override
    public boolean hasNext() {
        return iterator.hasNext();
    }

    @Override
    public Integer next() {
        return iterator.next();
    }
    void flatten(List<NestedInteger> list){
        if(list == null || list.size() == 0){
            return;
        }
        else{
            for(NestedInteger nestedInteger :list){
                if(nestedInteger.isInteger()){
                    listofintger.add(nestedInteger.getInteger());
                }
                else{
                    flatten(nestedInteger.getList());
                }
            }
        }
    }
}
package OldAttemptLearning.programgreek;

import java.util.Stack;

/**
 * Created by hadoop on 22/8/17.
 */
public class PostOrderIterative {
    Stack<Pair> stack = new Stack<Pair>();
    TreeNode node ;

    void iterative(){
        while(true){

            while(node!=null){
                stack.push(new Pair(1,node));
                node = node.left;
            }

            if(stack.isEmpty()){
                break;
            }
            Pair pair = stack.pop();

            if(pair.status ==1){
                pair.status = -1;
                stack.push(pair);
                node = pair.treeNode.right;
            }
            else{
                System.out.println(pair.treeNode.val);
                node = null;
            }
        }
    }

    public PostOrderIterative(TreeNode node) {
        this.node = node;
    }

    private class Pair{
        int status;
        TreeNode treeNode;

        public Pair(int status, TreeNode treeNode) {
            this.status = status;
            this.treeNode = treeNode;
        }
    }
    private class TreeNode{
        int val;
        TreeNode left;
        TreeNode right;
        TreeNode(int x){
            this.val = x;
        }
    }
}
package OldAttemptLearning.programgreek;

import java.util.List;

/**
 * Created by hadoop on 22/8/17.
 */
public interface NestedInteger {
             public boolean isInteger();
             public Integer getInteger();
             public List<NestedInteger> getList();
}

package OldAttemptLearning.programgreek;

import java.util.LinkedList;
import java.util.List;

/**
 * Created by hadoop on 22/8/17.
 */
public class DepthSum {
    public static void main(String args[]){

    }
    public int depthSum(List<NestedInteger> nestedIntegerList){
        return helper(nestedIntegerList,1);
    }

    private int helper(List<NestedInteger> nestedIntegerList, int depth) {
        if(nestedIntegerList == null ||nestedIntegerList.size() == 0){
            return 0;
        }
        int sum=0;
        for(NestedInteger nestedInteger:nestedIntegerList){
            if(nestedInteger.isInteger()){
                sum = sum+ nestedInteger.getInteger()*depth;
            }
            else{
                sum = sum + helper(nestedIntegerList,depth+1);
            }
        }
        return sum;
    }
    public int depthSumIterative(List<NestedInteger> nestedIntegerList){
        int sum = 0;
        LinkedList<NestedInteger> queue = new LinkedList<NestedInteger>();
        LinkedList<Integer> depth = new LinkedList<Integer>();
        for(NestedInteger nestedInteger:nestedIntegerList){
            queue.offer(nestedInteger);
            depth.offer(1);
        }
        while (!queue.isEmpty()){

            NestedInteger nestedInteger = queue.poll();
            int d = depth.poll();
            if(nestedInteger.isInteger()){
                sum = sum + nestedInteger.getInteger()*d;
            }
            else{
                for(NestedInteger nestedInteger1 :nestedInteger.getList()){
                    queue.offer(nestedInteger1);
                    depth.offer(d+1);
                }
            }
        }
        return sum;
    }
}
package OldAttemptLearning.programgreek;

/**
 * Created by hadoop on 22/8/17.
 */
public class PaintFence {
}
package OldAttemptLearning.programgreek;

import java.util.Iterator;
import java.util.List;
import java.util.Stack;

/**
 * Created by hadoop on 22/8/17.
 */
public class NestedIteratorNew implements Iterator<Integer>{
    public static void main(String args[]){

    }
    Integer top =null;
    Stack<Iterator<NestedInteger>> stack = new Stack<>();
    NestedIteratorNew(List<NestedInteger> list){
        stack.push(list.iterator());
    }
    @Override
    public boolean hasNext() {
        if(top !=null){
            return true;
        }
        while (!stack.isEmpty()){
            Iterator<NestedInteger> it = stack.peek();
            if(it.hasNext()){
                NestedInteger nestedInteger = it.next();
                if(nestedInteger.isInteger()){
                    top = nestedInteger.getInteger();
                    return true;
                }
                else {
                    stack.push(nestedInteger.getList().iterator());
                }
            }
            else{
                stack.pop();
            }
        }
        return false;
    }


    @Override
    public Integer next() {
        return top;
    }
}
package OldAttemptLearning.dp;

/**
 * Created by hadoop on 11/8/17.
 */
public class NdigitSequence {
    public static void main(String[] args) {
        int n=2;
        int array[][] = {
            {1,2,3},
            {4,5,6},
            {7,8,9},
                {-1,0,-1}
        };
        int total =0;
        for(int i=0;i<array.length;i++){
            for ( int j=0;j<array[0].length;j++){
                if(array[i][j]!=-1) {
                    total = total + recur(n, array, i,j);
                }
            }
        }
        System.out.println("total"+total);
    }

    private static int recur(int n, int[][] array,int i,int j) {
        if(n<0){
            return 1;
        }
        if(n==0){
            return 1;
        }
            int path =0;
            path = path + recur(n-1,array,i,j);
            if(i-1>=0 && array[i-1][j]!=-1)
                path = path + recur(n-1,array,i-1,j);
            if(j-1>=0 && array[i][j-1]!=-1)
                path=path+recur(n-1,array,i,j-1);
            if(i+1<array.length && array[i+1][j]!=-1)
                path = path + recur(n-1,array,i+1,j);
            if(j+1<array[0].length && array[i][j+1]!=-1)
                path = path +recur(n-1,array,i,j+1);
            return path;
    }
}
package OldAttemptLearning.dp;

/**
 * Created by hadoop on 11/8/17.
 */
public class threepartition {
    public static void main(String[] args) {
        int array []={7,3,2,1,5,4,8};
        boolean ans = paritirion(array);
        System.out.println(ans);
    }

    private static boolean paritirion(int[] array) {
        int sum = 0;
        for( int i=0;i<array.length;i++) {
            sum = sum + array[i];
        }
        if(sum%3!=0){
            return false;
        }
        else {
            return partitionarraysinto3sets(array,sum/3,sum/3,sum/3,array.length-1);
        }
    }

    private static boolean partitionarraysinto3sets(int[] array, int i, int i1, int i2,int index) {
        System.out.println("i "+i);
        System.out.println("i1 "+i1);
        System.out.println("i2 "+i2);
        System.out.println("index "+index);


        if(i1==0 && i==0 && i2 ==0){
            if(index < 0){
                return true;
            }
            else {
                return false;
            }
        }

        if(index<0){
            return false;
        }
        if(i1<0 || i2<0||i<0){
            return false;
        }

        boolean A = partitionarraysinto3sets(array,i-array[index],i1,i2,index-1);

        boolean B = partitionarraysinto3sets(array,i,i1-array[index],i2,index-1);

        boolean C = partitionarraysinto3sets(array,i,i1,i2-array[index],index-1);

        return A || B || C;


    }
    public static boolean subsetsum(int array[],int sum, int index){
        if(sum == 0){
            return true;
        }
        if(index<0 || sum <0)
            return false;

        boolean include = subsetsum(array,sum-array[index],index-1);

        boolean exclude = subsetsum(array,sum,index-1);

        return include|| exclude;
    }

    public static int knapsack(int array[], int value[], int sum, int index){
        if(index<0 || sum <0){
            return 0;
        }
        if(sum == 0){
            return 0;
        }
        int include = value[index]+knapsack(array,value,sum-array[index],index-1);
        int exclude = knapsack(array,value,sum,index-1);

        return Math.max(include,exclude);
    }

}
package OldAttemptLearning.dp;

/**
 * Created by hadoop on 12/8/17.
 */
public class Consecutiveone {
    public static void main(String args[]){
        int n = 2;
        int ans = consone(n,0);
        System.out.println("ans"+ans);
        countstrings(3,"",0);
    }

    private static int consone(int n, int last_digit) {
        if(n==0){
            return 0;
        }
        if(n==1){
            if(last_digit == 1){
                return 1;
            }
            else {
                return 2;
            }
        }
        if(last_digit == 1){
            return consone(n-1,0);
        }
        else{
            return consone(n-1,0)+consone(n-1,1);
        }
    }
    public static int bottomup(int n){
        int t[][] = new int[n+1][2];
        t[0][0] = 0;
        t[0][1] = 0;
        t[1][0] = 2;
        t[1][1] = 1;
        for(int i=2;i<=n;i++){
            t[i][1] = t[i-1][0];
            t[i][0] = t[i-1][0]+t[i-1][1];
        }
        return t[n][0];
    }

    public static void countstrings(int n , String s,int last_digit){
        if(n==0){
            System.out.println("string "+s);
            return;
        }
        countstrings(n-1,s+"0",0);
        if(last_digit ==0){
            countstrings(n-1,s+"1",1);
        }
    }
}
package OldAttemptLearning.dp;

/**
 * Created by hadoop on 11/8/17.
 */
public class MaxSumNOadjacent {
    public static void main(String[] args) {
        int array[] = { 2,  1, -3, -4,  5};
        MaxSumNOadjacent maxSumNOadjacent = new MaxSumNOadjacent();
        System.out.println(Kadane(array));
        System.out.println();

    }

    private static kadaneResult Kadane(int array[]){
        int max = 0;
        int maxstart = -1;
        int maxend = -1;
        int currentstart = 0;
        int maxsofar = 0;
        for( int i=0;i<array.length;i++){
            maxsofar = maxsofar + array[i];
            if(maxsofar<0){
                maxsofar = 0;
                currentstart = i+1;
            }
            if(max <maxsofar){
                maxstart = currentstart;
                max = maxsofar;
                maxend = i;
            }
        }
        return new kadaneResult(max,maxstart,maxend);

    }
    static class kadaneResult{
        int maxsum;
        int start;
        int end;
        public kadaneResult(int maxsum,int start,int end){
            this.maxsum = maxsum;
            this.start = start;
            this.end = end;
        }

        @Override
        public String toString() {
            return "kadaneResult{" +
                    "maxsum=" + maxsum +
                    ", start=" + start +
                    ", end=" + end +
                    '}';
        }
    }



}
package OldAttemptLearning.dp;

/**
 * Created by hadoop on 12/8/17.
 */
public class Coins {
    public static void main(String[] args) {


        int s[] = {1, 2, 3, 4};

        int total = 15;
        int ans = findmincoints(s, total);
        System.out.println("ans" + ans);
        System.out.println("ways" + totalways(s, 15));
        System.out.println("waysagain"+totalwaysagain(s,15,3));
    }

    private static int findmincoints(int[] s, int total) {


        if(total<=0){
            return 0;
        }

        int ans = Integer.MAX_VALUE;
        for( int i=0;i<s.length;i++) {
            if(total-s[i]>=0) {
                ans = Math.min(ans, 1 + findmincoints(s, total - s[i]));
            }
        }


        return ans;
    }
    private static int totalways(int s[],int total){

        if (total==0){
            return 1;
        }
        if(total<0){
            return 0;
        }
        int ways = 0;
        for(int i=0;i<s.length;i++){
            ways = ways + totalways(s,total-s[i]);
        }
        return ways;
    }
    private static int totalwaysagain(int s[],int total,int n){
        if(total<0){
            return 0;
        }
        if(n<0) return 0;
        if(total == 0){
            return 1;
        }

        return totalwaysagain(s,total,n-1)+totalwaysagain(s,total-s[n],n);
    }

}

package OldAttemptLearning.dp;

import java.util.Arrays;

/**
 * Created by hadoop on 11/8/17.
 */
public class lineareq {
    public static void main(String[] args) {
        int array[] = {1,3,5,7};
        int ans = 8;
        //1,1,1,1
        //3,1
        //2,2
        //2,1,1
        int solutions = solutionstotal(array,ans);
        System.out.println("sol"+solutions);
    }

    private static int solutionstotal(int[] array, int ans) {
        int lookup[] = new int[ans+1];
        Arrays.fill(lookup,0);
        lookup[0] = 1;
            for( int j=0;j<array.length;j++){
                for( int i=0;i<=ans;i++){
                    if(i-array[j]>=0) {
                    lookup[i] = lookup[i] + lookup[i - array[j]];
                }
            }
        }
        return lookup[ans];
    }
}
package OldAttemptLearning.dp;

import java.util.Arrays;

/**
 * Created by hadoop on 11/8/17.
 */
public class minpalindrome {
    public static boolean ispandrome(String a, int i,int j){
        if(i<=j){
            if(a.charAt(i)!=a.charAt(j)){
                return false;
            }
            i++;
            j--;
        }
        return true;
    }

    static int minpalindrome(String a, int i, int j){
        if(ispandrome(a,i,j)){
            return 0;
        }

        if(i>=j)
            return 0;
        int count = Integer.MAX_VALUE;
      //  System.out.println("i value" + i);
       // System.out.println("j value "+ j);
        for( int k = i;k<j;k++){
         //   System.out.println(" k value "+k);
            count = Math.min(count,1 + minpalindrome(a,i,k) + minpalindrome(a,k+1,j));
        }
        return count;
    }

    public static void main(String[] args) {
        String x = "BAB  ABCBA  DCD";
        String y = "abcd";
//        System.out.println("min count "+minpalindrome(y,0,x.length()-1));
       // constructarray(x);
        //System.out.println("new  min count "+a(y,0));
        System.out.println("cuts "+moreoptimizediterative("abcdfe"));
    }
    public static boolean [][]array;

    public static  void constructarray(String a){
        int n = a.length();
        array = new boolean[n][n];

        for(int i=0;i<n;i++){
            array[i][i] = true;
        }
        for(int i=0;i<n-1;i++){
            if(a.charAt(i) == a.charAt(i+1)){
                array[i][i+1] = true;
            }
        }
        for( int diaglength = 3;diaglength<=n;diaglength++){
            for ( int i=0;i<=n-diaglength;i++){
                int j = diaglength+i-1;
               // System.out.println("i value"+i);
                //System.out.println("j val
                // ue "+j);
                array[i][j] = array[i+1][j-1] && a.charAt(i) == a.charAt(j);
            }
        }
        for( int i =0;i<n;i++){
            for ( int  j = 0;j<n;j++){
              //  System.out.print(array[i][j]+" ");
            }
            //System.out.println();
        }
        boolean [][] arrayb = new boolean[n][n];
        for( int i = n-1;i>=0;i--){
            for( int j=i;j<n;j++){
               // System.out.println("index i"+i);
               // System.out.println("index j"+j);
                if(i==j){
                    arrayb[i][j] = true;
                }
                else if(j-i+1==2){
                    arrayb[i][j] =(arrayb[i] == arrayb[j]);
                }
                else {
                    arrayb[i][j] = arrayb[i+1][j-1]  && a.charAt(i) == a.charAt(j);
                }
            }
        }
        System.out.println();
        for( int i =0;i<n;i++){
            for ( int  j = 0;j<n;j++){
                //System.out.print(arrayb[i][j]+" ");
                if(arrayb[i][j]!=array[i][j]){
                   // System.out.println(arrayb[i][j]);
                    //System.out.println(array[i][j]);
                    //System.out.println("diff"+i);
                    //System.out.println("diff"+j);
                    //System.exit(1);
                }
            }
            //System.out.println();
        }
    }
    public static int minpartitionoptimizedstate(String a,int start){
        int n = a.length();
        if(start == n-1){
            return 0;
        }
        if(ispandrome(a,start,n-1)){
            return 0;
        }
        System.out.println("start value "+start);
        int count = Integer.MAX_VALUE;
//        for( int i=start;i<n-1;i++){
            for( int j = start +1;j<n;j++){
                System.out.println("j value "+j);
               // System.out.println("count "+count);
                count = Math.min(count,1 + minpartitionoptimizedstate(a,j));
                System.out.println("count after"+count);
//            }
        }
        return count;
    }

    public static int moreoptimizediterative(String a ){
        int lookup[] = new int[a.length()];
        //System.out.println(lookup[0]);
        Arrays.fill(lookup,Integer.MAX_VALUE);
        for( int end=0;end<a.length();end++){
            //lookup[end] = Integer.MAX_VALUE;
            if(ispandrome(a,0,end)){
                lookup[end] = 0;
            }
            for ( int i=0;i<=end;i++){
//                if(ispandrome(a,i,end)){
//                  lookup[end] = 1 + lookup[i];
//                }
                if(ispandrome(a,i+1,end)) {
                    lookup[end] = Math.min(lookup[end], 1 + lookup[i]);
                    System.out.println("lookup[end"+lookup[end]);
                }

            }
        }
        return lookup[a.length()-1];
    }

}
package OldAttemptLearning.dp;

import java.util.Arrays;

/**
 * Created by hadoop on 11/8/17.
 */
public class LISLCS {
    public static void main(String[] args) {
        int []array = {1,0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15};
        int []arrayb = {1,2,2,2};
        System.out.println(findLIS(array));
    }

    private static int findLIS(int[] array) {
        int []arraycopy = array.clone();
        Arrays.sort(arraycopy);
        int pointer =-1;
        for( int i=0;i<arraycopy.length;i++){
            if(pointer == -1 || arraycopy[i] !=arraycopy[pointer]){
                arraycopy[++pointer] = arraycopy[i];
            }
        }
        int []arraycopyagain = new int[pointer+1];
        for( int i=0;i<pointer+1;i++){
            arraycopyagain[i] = arraycopy[i];
        }
        return LCSLENGTH(array,arraycopyagain);
    }

    private static int LCSLENGTH(int[] array, int[] arraycopyagain) {
        int lookup[][]= new int[array.length+1][arraycopyagain.length+1];
        int lcs=  LCSLENGTHHelper(array,arraycopyagain,array.length-1,arraycopyagain.length-1,lookup);
        LCSArray(array,arraycopyagain,array.length,arraycopyagain.length,lookup);
        return lcs;
    }

    private static int LCSLENGTHHelper(int[] array, int[] arraycopyagain, int length, int length1, int[][] lookup) {
        if ( length<0 || length1 < 0){
            return 0;
        }
        if(lookup[length+1][length1+1] !=0) return lookup[length+1][length1+1];
        if(array[length] == arraycopyagain[length1]){
            return lookup[length+1][length1+1]=1+ LCSLENGTHHelper(array,arraycopyagain,length-1,length1-1, lookup);
        }
        else{
            return lookup[length+1][length1+1]=Math.max(LCSLENGTHHelper(array,arraycopyagain,length,length1-1, lookup),LCSLENGTHHelper(array,arraycopyagain,length-1,length1, lookup));
        }
    }

    private static void LCSArray(int[] array, int[] arraycopyagain, int length, int length1, int[][] lookup) {
        if(length ==0 || length1==0){
            return;
        }
        if(array[length-1] == arraycopyagain[length1-1] && lookup[length][length1] == 1+ lookup[length-1][length1-1]){
            LCSArray(array,arraycopyagain,length-1,length1-1,lookup);
            System.out.println(array[length-1]);
        }

        else if(lookup[length][length1] == lookup[length][length1-1] ){
            LCSArray(array,arraycopyagain,length,length1-1,lookup);
        }
        else {
            LCSArray(array,arraycopyagain,length-1,length1,lookup);
        }
    }

    int lcslength(String a,String b, String c,int l1,int l2,int l3){
        if(l1<0 || l2<0 ||l3<0){
            return 0;
        }
        if(a.charAt(l1)==b.charAt(l2) & a.charAt(l1)== c.charAt(l3)){
            return lcslength(a,b,c,l1-1,l2-1,l3-1);
        }
        return Math.max(Math.max(lcslength(a,b,c,l1-1,l2,l3),lcslength(a,b,c,l1,l2-1,l3)),lcslength(a,b,c,l1,l2,l3-1));
    }
}
package OldAttemptLearning.dp;

import java.util.List;
import java.util.Stack;

/**
 * Created by hadoop on 11/8/17.
 */
public class SnakeSequence {
    public static void main(String[] args) {
        int [][] grid = {{7, 5, 2, 3, 1},
                {3, 4, 1, 4, 4},
                {1,5,6,7,8},
                {3,4,5,8,9},
                {3,2,2,7,6}
        };
        int [][]Length = new int[grid.length+1][grid[0].length+1];
      //  Arrays.fill(Length,0);

        List<Point> points = getMaxSnakePath(grid,Length);
    }

    private static List<Point> getMaxSnakePath(int[][] grid, int[][] length) {

        length[0][0] = 1;
        int maxpath = 1;
        for( int k=1;k<grid.length;k++){
            if(Math.abs(grid[0][k-1] -grid[0][k])<=1) {
                length[0][k] = Math.max(length[0][k], length[0][k - 1] + 1);
            }
            else {
                length[0][k] = 1;
            }
        }
        for( int k = 1;k<grid.length;k++ ){
            if(Math.abs(grid[k-1][0]=grid[k][0])<=1){
                length[k][0] = Math.max(length[k][0],length[k-1][0]+1);
            }
            else{
                length[k][0] = 1;
            }
        }
        int max = 1;
        int maxi=0;
        int maxj=0;
        for( int i=1;i<grid.length;i++){
            for ( int j=1;j<grid.length;j++){
                if(Math.abs(grid[i-1][j]-grid[i][j])<=1){
                    length[i][j] = Math.max(length[i][j],length[i-1][j]+1);
                }
                else if (Math.abs(grid[i][j-1]-grid[i][j])<=1){
                    length[i][j] = Math.max(length[i][j],length[i][j-1]+1);
                }
                else{
                    length[i][j] = 1;
                }
                if(length[i][j]>max){
                    max = length[i][j];
                    maxi=i;
                    maxj = j;
                }

            }
        }
        int i= maxi;
        int j = maxj;
        Stack stack = new Stack();
        while (length[i][j]!=1){
            if(length[i][j] == length[i-1][j]+1 && Math.abs(grid[i][j]-grid[i-1][j])<=1){
                stack.push(new Point(i,j));
                i = i-1;
            }
            else if (length[i][j] == length[i][j-1]+1 && Math.abs(grid[i][j]-grid[i][j-1])<=1){
                stack.push(new Point(i,j));
                j = j-1;
            }
        }
        stack.push(new Point(i,j));
        while (!stack.isEmpty()){
            System.out.println(stack.pop());
        }
        System.out.println(stack.size());
        System.out.println("Max vlaue "+max);
        System.out.println("max i "+maxi);
        System.out.println("max j"+maxj);
        return null;
    }

    public static class Point{
        int x;
        int y;
        Point(int x, int y){
            this.x= x;
            this.y = y;
        }

        @Override
        public String toString() {
            return "Point{" +
                    "x=" + x +
                    ", y=" + y +
                    '}';
        }
    }
}
package OldAttemptLearning.dp;

/**
 * Created by hadoop on 12/8/17.
 */
public class NoOfSub {
    public static void main(String[] args) {
        String x = "subsequence";
        String y="sue";
        int ans = countsubsequences(x,y,x.length()-1,y.length()-1);
        System.out.println("ans"+ans);

    }

    private static int countsubsequences(String x, String y, int i, int i1) {
        if(i1<0){
            return 1;
        }
        if(i<0){
            return 0;
        }
        if(x.charAt(i) == y.charAt(i1)){
            return countsubsequences(x,y,i-1,i1-1) + countsubsequences(x,y,i-1,i1);
        }
        else{
            return countsubsequences(x,y,i-1,i1);
        }
    }
}
package OldAttemptLearning.dp;

/**
 * Created by hadoop on 12/8/17.
 */
public class rodcut {
    public static void main(String[] args) {
        int length[] = {1,2,3,4,5,6,7,8};
        int prices[]= {1,5,8,9,10,17,17,2000};
        int rodlength = 8;
        int ans = rodcutprice(rodlength,length,prices);
        System.out.println("ans"+ans);
    }

    private static int rodcutprice(int rodlength, int[] length, int[] prices) {
        if(rodlength==0){
            return 0;
        }
        if(rodlength<0){
            return 0;
        }

        int price = Integer.MIN_VALUE;
        for(int i=1;i<=rodlength;i++){
            price = Math.max(price,prices[i-1]+rodcutprice(rodlength-i,length,prices));
        }
        return price;
    }
}
package OldAttemptLearning.dp;

/**
 * Created by hadoop on 11/8/17.
 */
public class Keypad {
    static int row[] = {0,-1,0,1};
    static int col[] = {-1,0,1,0};
    public static void main(String args[]){

        char [][] array = {
                {'1','2','3'},
                {'4','5','6'},
                {'7','8','9'},
                {'*','0','#'}
        };
int n =2;
        int length[][][] = new int[n+1][array.length][array[0].length];
        for( int i=0;i<array.length;i++){
            for ( int j=0;j<array[0].length;j++){
                if(isValid(i,j)){
                    length[0][i][j] = 1;
                }
            }
        }
        for(int len=1;len<n;len++) {
            for (int i = 0; i < array.length; i++) {
                for (int j = 0; j < array[0].length; j++) {
                    length[len][i][j] =1;
                    for (int k = 0; k <= 3; k++) {
                        if (isValid(i + row[k], j + col[k])) {
                            System.out.println("len" + len);
                            System.out.println("i" + i);
                            System.out.println("j" + j);
                            System.out.println("k"+k);
                            System.out.println("i+row"+(i+row[k]));
                            System.out.println("j+row"+(j+col[k]));
                            length[len][i][j] = length[len][i][j] + length[len - 1][i + row[k]][j + col[k]];
                        }
                        }
                }
            }
        }
        int solution = 0;
        for(int i=0;i<array.length;i++){
            for( int j=0;j<array[0].length;j++){
                if(isValid(i,j))
                solution = solution + length[n-1][i][j];
            }
        }
        System.out.println("solutoin  again"+solution);
    }
    public static boolean isValid(int i,int j){
        if((i==3)&& (j==0 || j==2)){
            return false;
        }
         return i>=0 && i<=3 && j>=0 && j<=2;
    }
}
package OldAttemptLearning.dp;

/**
 * Created by hadoop on 11/8/17.
 */
public class Interleaved {
    public static void main(String args[]){
        String a = "ACBCD";
        String b = "ABC";
        String c = "CD";

        boolean ans = isinterleaved(a,b,c,a.length()-1,b.length()-1,c.length()-1);
        System.out.println("ans"+ans);
    }

    private static boolean isinterleaved(String a, String b, String c, int i, int i1, int i2) {
        if(i<0 && i1<0 &&i2<0){
            return true;
        }
        if(i<0){
            return false;
        }
        boolean ans = false;
        System.out.println("false");

        if(i1 >=0  && a.charAt(i) == b.charAt(i1)){
            System.out.println("here");
            ans = isinterleaved(a,b,c,i-1,i1-1,i2);
        }
        if(ans) return ans;
        if(i2 >=0 && a.charAt(i) == c.charAt(i2)){
            System.out.println("here");
            ans = isinterleaved(a,b,c,i-1,i1,i2-1);
        }
        return ans;
    }
}
package OldAttemptLearning.dp;

/**
 * Created by hadoop on 11/8/17.
 */
public class LCSLength {
    public static void main(String[] args) {

    }

    public int max(int a, int b, int c) {
        return Math.max(Math.max(a, b), c);
    }
}package OldAttemptLearning.dp;

/**
 * Created by hadoop on 11/8/17.
 */
public class WildMatching {
    public static void main(String[] args) {
        String a= "xyxzzxy";
        String b ="***";
        boolean match = ismatch(a, b,a.length()-1,b.length()-1);
        System.out.println("match"+match);
    }

    private static boolean ismatch(String text, String pattern, int i, int i1) {

        if(i<0 &&i1<0){
            return true;
        }
        if(i<0){
            while(i1 >= 0){
                if(pattern.charAt(i1)!='*'){
                    return false;
                }
                i1--;
            }
            return true;
        }
        if(i1<0){
            return false;
        }


        if(pattern.charAt(i1)=='*'){
            return ismatch(text,pattern,i,i1-1)||ismatch(text,pattern,i-1,i1);
        }
        if(pattern.charAt(i1)=='?' || pattern.charAt(i1) ==text.charAt(i)){
            return ismatch(text,pattern,i-1,i1-1);
        }
        return false;
    }
}
package OldAttemptLearning.ksum;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Created by hadoop on 7/8/17.
 */
public class Solution  {
    static List<Integer> returnedList = new ArrayList<Integer>();

    public List<Integer> cheapestJump(int[] A, int B) {

        int []index = new int[A.length+1];
        if(A==null || A.length == 0){
            return returnedList;
        }
        index[1] = 0;
        int [] memo= new int[A.length+1];
        Arrays.fill(memo,-1);

        int mincost = cheapestJumpHelper(0,A,B,index,memo);
        if(mincost <0 || mincost == Integer.MAX_VALUE){
            System.out.println("mincost"+mincost);

            return returnedList;
        }
        else{
            System.out.println("mincost"+mincost);
            // System.out.println(pathagain);
            printpath(index,A.length);
            return returnedList;
        }
    }
    private static int cheapestJumpHelper(int i,int[] array, int b, int[] index,int []memo) {
        if(i == array.length-1 && array[i]!=-1){
            return array[i];
        }
        int min = Integer.MAX_VALUE;
        int minindex=-1;
        if(memo[i] !=-1) return memo[i];
        for(int path = i+1;path<=array.length-1  && path<=i+b;path++){
            if(array[path] == -1){
                continue;
            }
            if(min>=array[i]+cheapestJumpHelper(path,array,b,index,memo)){
                minindex = path;
                min = array[i]+cheapestJumpHelper(path,array,b,index,memo);
            }
        }
        if(minindex != -1) {
            index[minindex + 1] = i+1;
        }
        memo[i] = min;
        return min;
    }
    static void printpath(int []array,int startindex){
        if(startindex == 0){
            return;
        }
        System.out.println("loop");
        printpath(array,array[startindex]);
        returnedList.add(startindex);
    }

    public static void main(String[] args) {
        int array[]={0, -1, -1, -1, 0,0};
        int B = 1;
        Solution solution = new Solution();
        System.out.println(solution.cheapestJump(array,B));

    }
}
package OldAttemptLearning.ProblemMisc;

import java.util.HashSet;
import java.util.Set;

/**
 * Created by hadoop on 31/8/17.
 */
public class LongestConsecutive {
    public static void main(String args[]){
        int num[]={100,4,200,1,3,2};
        int ans = longestConsesutive(num);
        System.out.println("ans"+ans);
    }

    private static int longestConsesutive(int[] num) {
        if( num == null || num.length == 0){
            return 0;
        }
        Set<Integer> hashset = new HashSet<>();
        for( int i:num){
            hashset.add(i);
        }
        int lcs=0;
        for( int i:num){
            int n = i;
            int count = 1;
            while(hashset.contains(n-1)){
                count = count+1;
                System.out.println("n"+(n-1));
                System.out.println("count"+count);
                hashset.remove(n-1);
                n = n-1;
            }
            n = i;
            while (hashset.contains(n+1)){
                count = count+1;
                hashset.remove(n+1);
                n = n+1;
            }
            lcs = Math.max(count,lcs);
        }
        return lcs;
    }
}
package OldAttemptLearning.TemplatesCodes;

/**
 * Created by hadoop on 1/9/17.
 */
public class Combinations {
    //return the count Given n distinct positive integers, integer k (k <= n) and a number target. Find k numbers where sum is target. Calculate how many solutions there are?
    public static void main(String[] args) {
        int num[]={4,5,6};
        int k = 1;
        int target = 4;
        int [][][] array = new int[num.length+1][k+1][target];
        int ans = ksum(array,k,target,num);
    }

    private static int ksum(int[][][] array, int k, int target,int []num) {
        for( int i=0;i<=num.length;i++){
            array[i][0][0]=1;
        }
        for(int i=0;i<=num.length;i++){
            for( int j=0;j<=k;j++){
                array[i][j][0] = 0;
            }
        }
        for( int i=1;i<=num.length;i++){
            for ( int j=1;j<=k;j++){
                for ( int l=1;l<=target;l++){
                    if(j>i)array[i][j][l] = 0;
                    if(k-num[i-1]>=0)
                    array[i][j][l] = array[i-1][j][l] +array[i-1][j-1][l-num[i-1]];
                }
            }
        }
        return array[num.length][k][target];
    }
}
package OldAttemptLearning.shirleyisnotageek;

/**
 * Created by hadoop on 31/8/17.
 */
public class Solution {
    class ListNode{
        int val;
        ListNode next;
        ListNode(int x){
            this.val = x;
        }
    }

    public static void main(String[] args) {

    }
    public ListNode reversebetweenmandn(ListNode head, int m , int n){
        if(head == null){
            return  null;
        }
        if( m == n){
            return head;
        }
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        int index = m;
        ListNode prelabel = dummy;

        for(index = 1;index<m;index++){
            prelabel = head;
            head = head.next;
            if( head == null){
                return null;
            }
        }
        ListNode current = head;
        ListNode prev = prelabel;
      //  ListNode label = head;
        ListNode temp ;
        for( index = m+1;index<=n;index++){
            temp  = current.next;
            current.next = prev;
            prelabel.next = current;
            prev = current;
            current= temp;
        }
        head.next = current;
        return dummy.next;
    }
}
/**
 * Created by hadoop on 3/9/17.
 */
public class LCA {

    TreeNode LowestCommonAncestor(TreeNode root,TreeNode node1,TreeNode node2){

        if(root == null || root == node1 || root == node2){
            return root;
        }

        TreeNode left = LowestCommonAncestor(root.left,node1,node2);
        TreeNode right = LowestCommonAncestor(root.right,node1,node2);

        if(left !=null && right!=null){
            return root;
        }
        if(left!=null){
            return left;
        }
        if(right!=null){
            return right;
        }
        return null;
    }


    private class TreeNode{
        int data;
        TreeNode left;
        TreeNode right;
    }
}


package Soundar;

class SegmentTreeRMQ
{
    int st[]; //array to store segment tree
 
    // A utility function to get minimum of two numbers
    int minVal(int x, int y) {
        return (x < y) ? x : y;
    }
 
    // A utility function to get the middle index from corner
    // indexes.
    int getMid(int s, int e) {
        return s + (e - s) / 2;
    }
 
    /*  A recursive function to get the minimum value in a given
        range of array indexes. The following are parameters for
        this function.
 
        st    --> Pointer to segment tree
        index --> Index of current node in the segment tree. Initially
                   0 is passed as root is always at index 0
        ss & se  --> Starting and ending indexes of the segment
                     represented by current node, i.e., st[index]
        qs & qe  --> Starting and ending indexes of query range */
    int RMQUtil(int ss, int se, int qs, int qe, int index)
    {
        // If segment of this node is a part of given range, then
        // return the min of the segment
        if (qs <= ss && qe >= se)
            return st[index];
 
        // If segment of this node is outside the given range
        if (se < qs || ss > qe)
            return Integer.MAX_VALUE;
 
        // If a part of this segment overlaps with the given range
        int mid = getMid(ss, se);
        return minVal(RMQUtil(ss, mid, qs, qe, 2 * index + 1),
                RMQUtil(mid + 1, se, qs, qe, 2 * index + 2));
    }
 
    // Return minimum of elements in range from index qs (quey
    // start) to qe (query end).  It mainly uses RMQUtil()
    int RMQ(int n, int qs, int qe)
    {
        // Check for erroneous input values
        if (qs < 0 || qe > n - 1 || qs > qe) {
            System.out.println("Invalid Input");
            return -1;
        }
 
        return RMQUtil(0, n - 1, qs, qe, 0);
    }
 
    // A recursive function that constructs Segment Tree for
    // array[ss..se]. si is index of current node in segment tree st
    int constructSTUtil(int arr[], int ss, int se, int si)
    {
        // If there is one element in array, store it in current
        //  node of segment tree and return
        if (ss == se) {
            st[si] = arr[ss];
            return arr[ss];
        }
 
        // If there are more than one elements, then recur for left and
        // right subtrees and store the minimum of two values in this node
        int mid = getMid(ss, se);
        st[si] = minVal(constructSTUtil(arr, ss, mid, si * 2 + 1),
                constructSTUtil(arr, mid + 1, se, si * 2 + 2));
        return st[si];
    }
 
    /* Function to construct segment tree from given array. This function
       allocates memory for segment tree and calls constructSTUtil() to
       fill the allocated memory */
    void constructST(int arr[], int n)
    {
        // Allocate memory for segment tree
 
        //Height of segment tree
        int x = (int) (Math.ceil(Math.log(n) / Math.log(2)));
 
        //Maximum size of segment tree
        int max_size = 2 * (int) Math.pow(2, x) - 1;
        st = new int[max_size]; // allocate memory
 
        // Fill the allocated memory st
        constructSTUtil(arr, 0, n - 1, 0);
    }
 
    // Driver program to test above functions
    public static void main(String args[]) 
    {
        int arr[] = {1, 3, 2, 7, 9, 11};
        int n = arr.length;
        SegmentTreeRMQ tree = new SegmentTreeRMQ();
 
        // Build segment tree from given array
        tree.constructST(arr, n);
 
        int qs = 1;  // Starting index of query range
        int qe = 5;  // Ending index of query range
 
        // Print minimum value in arr[qs..qe]
        System.out.println("Minimum of values in range [" + qs + ", "
                           + qe + "] is = " + tree.RMQ(n, qs, qe));
    }
}
// This code is contributed by Ankur Narain Verma



package Soundar;

import java.util.Arrays;

/**
 * Created by hadoop on 1/10/17.
 */
public class SuffixArray {

}

class LRS {

    // return the longest common prefix of s and t
    public static String lcp(String s, String t) {
        int n = Math.min(s.length(), t.length());
        for (int i = 0; i < n; i++) {
            if (s.charAt(i) != t.charAt(i))
                return s.substring(0, i);
        }
        return s.substring(0, n);
    }


    // return the longest repeated string in s
    public static String lrs(String s) {

        // form the N suffixes
        int N  = s.length();
        String[] suffixes = new String[N];
        for (int i = 0; i < N; i++) {
            suffixes[i] = s.substring(i, N);
        }

        // sort them
        Arrays.sort(suffixes);

        // find longest repeated substring by comparing adjacent sorted suffixes
        String lrs = "";
        for (int i = 0; i < N - 1; i++) {
            String x = lcp(suffixes[i], suffixes[i+1]);
            if (x.length() > lrs.length())
                lrs = x;
        }
        return lrs;
    }



    // read in text, replacing all consecutive whitespace with a single space
    // then compute longest repeated substring
    public static void main(String[] args) {
        String s = "banana";
        s = s.replaceAll("\\s+", " ");
//        StdOut.println("'" + lrs(s) + "'");
    }
}


package Soundar;

import java.util.Arrays;

/**
 * Created by hadoop on 1/10/17.
 */
public class SuffixArray {

}

class LRS {

    // return the longest common prefix of s and t
    public static String lcp(String s, String t) {
        int n = Math.min(s.length(), t.length());
        for (int i = 0; i < n; i++) {
            if (s.charAt(i) != t.charAt(i))
                return s.substring(0, i);
        }
        return s.substring(0, n);
    }


    // return the longest repeated string in s
    public static String lrs(String s) {

        // form the N suffixes
        int N  = s.length();
        String[] suffixes = new String[N];
        for (int i = 0; i < N; i++) {
            suffixes[i] = s.substring(i, N);
        }

        // sort them
        Arrays.sort(suffixes);

        // find longest repeated substring by comparing adjacent sorted suffixes
        String lrs = "";
        for (int i = 0; i < N - 1; i++) {
            String x = lcp(suffixes[i], suffixes[i+1]);
            if (x.length() > lrs.length())
                lrs = x;
        }
        return lrs;
    }



    // read in text, replacing all consecutive whitespace with a single space
    // then compute longest repeated substring
    public static void main(String[] args) {
        String s = "banana";
        s = s.replaceAll("\\s+", " ");
//        StdOut.println("'" + lrs(s) + "'");
    }
}


//Code of Thrones
//HOME
//BLOG
//PROJECTS
//Nearest Neighbor Search with KDTree
//Offen we need to ask Google Maps, whats the nearest restaurant/hotel/whatever nearby? Then Google Maps will take your GPS information (latitude, longitude), and do a search on the map to find the nearest location. This is a multidimensional nearest neighbor search problem, in which case k-d tree can be useful. K-d tree is a binary tree of k-dimensional data, and is interesting that it splits the left and right children by different dimensions at different depth of the tree. Similar to other binary trees, searches take O(log n) time on average.
//
//Heres Java implementation for nearest location search using kd-tree:
//
//import javax.annotation.Nonnull;
//import javax.annotation.Nullable;
//import java.util.ArrayList;
//import java.util.Collections;
//import java.util.Comparator;
//import java.util.List;
//
//import static java.lang.Math.cos;
//import static java.lang.Math.sin;
//import static java.lang.Math.toRadians;
//
//class LocationKDTree {
//    private static final int K = 3; // 3-d tree
//    private final Node tree;
//
//    public LocationKDTree(@Nonnull final List<Location> locations) {
//        final List<Node> nodes = new ArrayList<>(locations.size());
//        for (final Location location : locations) {
//            nodes.add(new Node(location));
//        }
//        tree = buildTree(nodes, 0);
//    }
//
//    @Nullable
//    public Location findNearest(final double latitude, final double longitude) {
//        final Node node = findNearest(tree, new Node(latitude, longitude), 0);
//        return node == null ? null : node.location;
//    }
//
//    private static Node findNearest(final Node current, final Node target, final int depth) {
//        final int axis = depth % K;
//        final int direction = getComparator(axis).compare(target, current);
//        final Node next = (direction < 0) ? current.left : current.right;
//        final Node other = (direction < 0) ? current.right : current.left;
//        Node best = (next == null) ? current : findNearest(next, target, depth + 1);
//        if (current.euclideanDistance(target) < best.euclideanDistance(target)) {
//            best = current;
//        }
//        if (other != null) {
//            if (current.verticalDistance(target, axis) < best.euclideanDistance(target)) {
//                final Node possibleBest = findNearest(other, target, depth + 1);
//                if (possibleBest.euclideanDistance(target) < best.euclideanDistance(target)) {
//                    best = possibleBest;
//                }
//            }
//        }
//        return best;
//    }
//
//    @Nullable
//    private static Node buildTree(final List<Node> items, final int depth) {
//        if (items.isEmpty()) {
//            return null;
//        }
//
//        Collections.sort(items, getComparator(depth % K));
//        final int index = items.size() / 2;
//        final Node root = items.get(index);
//        root.left = buildTree(items.subList(0, index), depth + 1);
//        root.right = buildTree(items.subList(index + 1, items.size()), depth + 1);
//        return root;
//    }
//
//    private static class Node {
//        Node left;
//        Node right;
//        Location location;
//        final double[] point = new double[K];
//
//        Node(final double latitude, final double longitude) {
//            point[0] = (double) (cos(toRadians(latitude)) * cos(toRadians(longitude)));
//            point[1] = (double) (cos(toRadians(latitude)) * sin(toRadians(longitude)));
//            point[2] = (double) (sin(toRadians(latitude)));
//        }
//
//        Node(final Location location) {
//            this(location.latitude, location.longitude);
//            this.location = location;
//        }
//
//        double euclideanDistance(final Node that) {
//            final double x = this.point[0] - that.point[0];
//            final double y = this.point[1] - that.point[1];
//            final double z = this.point[2] - that.point[2];
//            return x * x + y * y + z * z;
//        }
//
//        double verticalDistance(final Node that, final int axis) {
//            final double d = this.point[axis] - that.point[axis];
//            return d * d;
//        }
//    }
//
//    private static Comparator<Node> getComparator(final int i) {
//        return NodeComparator.values()[i];
//    }
//
//    private static enum NodeComparator implements Comparator<Node> {
//        x {
//            @Override
//            public int compare(final Node a, final Node b) {
//                return Double.compare(a.point[0], b.point[0]);
//            }
//        },
//        y {
//            @Override
//            public int compare(final Node a, final Node b) {
//                return Double.compare(a.point[1], b.point[1]);
//            }
//        },
//        z {
//            @Override
//            public int compare(final Node a, final Node b) {
//                return Double.compare(a.point[2], b.point[2]);
//            }
//        }
//    }
//}
//
//class Location {
//    public double latitude;
//    public double longitude;
//    public String databaseName;
//}
//The code should be quite straightforward to use: First you need to initialized a LocationKDTree object with a list of locations, and then you can find the nearest location of given latitude/longitude by findNearest method. One thing worth noting is that the tree is built as a 3-d tree, because you know, the earth is round! The trick is to convert the (latitude, longitude) pair to a (x, y, z) coordinate by:
//
//x = cos(toRadians(latitude)) * cos(toRadians(longitude))
//y = cos(toRadians(latitude)) * sin(toRadians(longitude))
//z = sin(toRadians(latitude))
//toRadians is a Java function
that converts an angel from degree measure to radian measure.
//
//Published: June 08 2015
//Category:  Code 3
//Tags:  Java 2 Kd-Tree 1 Nearest Neighbor Search 1 Reverse Geocoding 1
//
//
//Powered by Jekyll
//
//Creative Commons License



Skip to main content
logo

    Download
    Getting Started
    Members
    Projects
    More

Breadcrumbs

    Home Eclipse Wiki Jetty/Feature/Continuations

    Log in

    Navigation
    Main Page
    Community portal
    Current events
    Recent changes
    Random page
    Help

    Toolbox
    Page information
    Permanent link
    Printable version
    Special pages
    Related changes
    What links here

    Page
    Discussion
    View source
    History

Jetty/Feature/Continuations
< Jetty | Feature



Contents

    1 Introduction
        1.1 Why Asynchronous Servlets ?
            1.1.1 Not Asynchronous IO
            1.1.2 Asynchronous Waiting
        1.2 Asynchronous Servlet Examples
            1.2.1 AJAX Comet Server Push
            1.2.2 Asynchronous RESTful Web Service
            1.2.3 Quality of Service (e.g., JDBC Connection Pool)
        1.3 Servlet Threading Model
            1.3.1 Thread per connection
            1.3.2 Thread per request
            1.3.3 Asynchronous Request handling
    2 Feature
        2.1 Jetty 6 Continuations
        2.2 Jetty Continuations
        2.3 Using Continuations
            2.3.1 Obtaining a Continuation
            2.3.2 Suspending a Request
            2.3.3 Resuming a Request
            2.3.4 Completing a Request
            2.3.5 Continuation Listeners
        2.4 Continuation Patterns
            2.4.1 Suspend Resume Pattern
            2.4.2 Suspend Continue Pattern
        2.5 Continuation Examples
            2.5.1 Chat Servlet
            2.5.2 Quality of Service Filter
            2.5.3 Denial of Service Filter
            2.5.4 Proxy Servlet
            2.5.5 Gzip Filter

Introduction
Warning2.png
Some or all of this content remains to be ported to Jetty 9 Documentation.
If you are interested in migrating this content see our contribution guide or contact us.


Why Asynchronous Servlets ?
Not Asynchronous IO

The concept of Asynchronous Servlets is often confused with Asynchronous IO or the use of NIO. However, Asynchronous Servlets are not primarily motivated by asynchronous IO, since:

    HTTP Requests are mostly small and arrive in a single packet. Servlets rarely block on requests.
    Many responses are small and fit within the server buffers, so servlets often do not block writing responses.
    Even if we could expose asynchronous IO in a servlet, it is a hard paradigm to program. For example what would an application do if it read 2 bytes of a 3 byte UTF-8 character? It would have to buffer and wait for more bytes. This is best done by the container rather than the application.

Asynchronous Waiting

The main use-case for asynchronous servlets is waiting for non-IO events or resources. Many web applications need to wait at some stage during the processing of a HTTP request, for example:

    waiting for a resource to be available before processing the request (e.g., thread, JDBC Connection)
    waiting for an application event in an AJAX Comet application (e.g., chat message, price change)
    waiting for a response from a remote service (e.g., RESTful or SOAP call to a web service).

The servlet API (<=2.5) supports only a synchronous call style, so that any waiting that a servlet needs to do must be with blocking. Unfortunately this means that the thread allocated to the request must be held during that wait along with all its resources: kernel thread, stack memory and often pooled buffers, character converters, EE authentication context, etc. It is wasteful of system resources to hold these resources while waiting.

Significantly better scalability and quality of service can be achieved if waiting is done asynchronously.


Asynchronous Servlet Examples
AJAX Comet Server Push

Web 2.0 applications can use the comet technique (aka AJAX Push, Server Push, Long Polling) to dynamically update a web page without refreshing the entire page.

Consider a stock portfolio web application. Each browser will send a long poll request to the server asking for any of the user's stock prices that have changed. The server will receive the long poll requests from all its clients, but will not immediately respond. Instead the server waits until a stock price changes, at which time it will send a response to each of the clients with that stock in their portfolio. The clients that receive the long poll response will immediately send another long poll request so they may obtain future price changes.

Thus the server will typically hold a long poll request for every connected user, so if the servlet is not asynchronous, there would need more than 1000 threads available to handle 1000 simultaneous users. 1000 threads can consume over 256MB of memory; that would be better used for the application rather than idly waiting for a price to change.

If the servlet is asynchronous, then the number of threads needed is governed by the time to generate each response and the frequency of price changes. If every user receives a price every 10 seconds and the response takes 10ms to generate, then 1000 users can be serviced with just 1 thread, and the 256MB of stack be freed for other purposes.

For more on comet see the cometd project that works asynchronously with Jetty

For an example of Jetty's solution, see the Cometd (aka Bayeux).


Asynchronous RESTful Web Service

Consider a web application that accesses a remote web service (e.g., SOAP service or RESTful service). Typically a remote web service can take hundreds of milliseconds to produce a response -- eBay's RESTful web service frequently takes 350ms to respond with a list of auctions matching a given keyword -- while only a few 10s of milliseconds of CPU time are needed to locally process a request and generate a response.

To handle 1000 requests per second, which each perform a 200ms web service call, a webapp would needs 1000*(200+20)/1000 = 220 threads and 110MB of stack memory. It would also be vulnerable to thread starvation if bursts occurred or the web service became slower.

If handled asynchronously, the web application would not need to hold a thread while waiting for web service response. Even if the asynchronous mechanism cost 10ms (which it doesn't), then this webapp would need 1000*(20+10)/1000 = 30 threads and 15MB of stack memory. This is a 86% reduction in the resources required and 95MB more memory would be available for the application.

Furthermore, if multiple web services request are required, the asynchronous approach allows these to be made in parallel rather than serially, without allocating additional threads.

For an example of Jetty's solution, see the Asynchronous REST example.


Quality of Service (e.g., JDBC Connection Pool)

Consider a web application handling on average 400 requests per second, with each request interacting with the database for 50ms. To handle this load, 400*50/1000 = 20 JDBC connections are need on average. However, requests do not come at an even rate and there are often bursts and pauses. To protect a database from bursts, often a JDBC connection pool is applied to limit the simultaneous requests made on the database. So for this application, it would be reasonable to apply a JDBC pool of 30 connections, to provide for a 50% margin.

If momentarily the request rate doubled, then the 30 connections would only be able to handle 600 requests per second, and 200 requests per second would join those waiting on the JDBC Connection pool. Then if the servlet container had a thread pool with 200 threads, that would be entirely consumed by threads waiting for JDBC connections in 1 second of this request rate. After 1s, the web application would be unable to process any requests at all because no threads would be available. Even requests that do not use the database would be blocked due to thread starvation. To double the thread pool would require an additional 100MB of stack memory and would only give the application another 1s of grace under load!

This thread starvation situation can also occur if the database runs slowly or is momentarily unavailable. Thread starvation is a very frequently reported problem, and causes the entire web service to lock up and become unresponsive.

If the web container was able to threadlessly suspend the requests waiting for a JDBC connection, then thread starvation would not occur, as only 30 threads would be consumed by requests accessing the database and the other 470 threads would be available to process the request that do not access the database.

For an example of Jetty's solution, see the Quality of Service Filter.


Servlet Threading Model

The scalability issues of Java servlets are caused mainly by the server threading model:
Thread per connection

The traditional IO model of Java associated a thread with every TCP/IP connection. If you have a few very active threads, this model can scale to a very high number of requests per second.

However, the traffic profile typical of many web applications is many persistent HTTP connections that are mostly idle while users read pages or search for the next link to click. With such profiles, the thread-per-connection model can have problems scaling to the thousands of threads required to support thousands of users on large scale deployments.
Thread per request

The Java NIO libraries support asynchronous IO, so that threads no longer need to be allocated to every connection. When the connection is idle (between requests), then the connection is added to an NIO select set, which allows one thread to scan many connections for activity. Only when IO is detected on a connection is a thread allocated to it. However, the servlet 2.5 API model still requires a thread to be allocated for the duration of the request handling.

This thread-per-request model allows much greater scaling of connections (users) at the expense of a small reduction to maximum requests per second due to extra scheduling latency.
Asynchronous Request handling

The Jetty Continuation (and the servlet 3.0 asynchronous) API introduce a change in the servlet API that allows a request to be dispatched multiple times to a servlet. If the servlet does not have the resources required on a dispatch, then the request is suspended (or put into asynchronous mode), so that the servlet may return from the dispatch without a response being sent. When the waited-for resources become available, the request is re-dispatched to the servlet, with a new thread, and a response is generated.
Feature
Jetty 6 Continuations

Asynchronous servlets were originally introduced with Jetty-6 Continuations, which were a Jetty-specific mechanism.
Jetty Continuations

From Jetty 7 onwards, the Continuations API has been extended to be a general purpose API that will work asynchronously on any servlet-3.0 container, as well as on Jetty 6, 7, or 8. Continuations will also work in blocking mode with any servlet 2.5 container. Continuations should be considered an application abstraction and portability layer on top of the implementation detail of asynchronous servlets.
Using Continuations
Obtaining a Continuation

The ContinuationSupport factory class can be used to obtain a continuation instance associated with a request:

    Continuation continuation = ContinuationSupport.getContinuation(request);

Suspending a Request

To suspend a request, the suspend method is called on the continuation:


void doGet(HttpServletRequest request, HttpServletResponse response)
{
    ...
    // optionally:
    // continuation.setTimeout(long);
    continuation.suspend();
    ...
}

The lifecycle of the request will be extended beyond the return to the container from the Servlet.service(...) method and Filter.doFilter(...) calls. When these dispatch methods return, the suspended request will not yet be committed and a response will not yet be sent to the HTTP client.

Once the request has been suspended, the continuation should be registered with an asynchronous service so that it may be used by an asynchronous callback when the waited-for event happens.

The request will be suspended until either continuation.resume() or continuation.complete() is called. If neither is called then the continuation will timeout. The timeout should be set before the suspend, by a call to continuation.setTimeout(long); if no timeout is set, then the default period is used. If no timeout listeners resume or complete the continuation, then the continuation is resumed with continuation.isExpired() true.

There is a variation of suspend for use with request wrappers and the complete lifecycle (see below):

    continuation.suspend(response);

Suspension is analogous to the servlet 3.0 request.startAsync() method. Unlike jetty-6 continuations, an exception is not thrown by suspend and the method should return normally. This allows the registration of the continuation to occur after suspension and avoids the need for a mutex. If an exception is desirable (to bypass code that is unaware of continuations and may try to commit the response), then continuation.undispatch() may be called to exit the current thread from the current dispatch by throwing a ContinuationThrowable.


Resuming a Request

Once an asynchronous event has occurred, the continuation can be resumed:

void myAsyncCallback(Object results)
{
    continuation.setAttribute("results",results);
    continuation.resume();
}

When a continuation is resumed, the request is redispatched to the servlet container, almost as if the request had been received again. However during the redispatch, the continuation.isInitial() method returns false and any attributes set by the asynchronous handler are available.

Continuation resume is analogous to Servlet 3.0 AsyncContext.dispatch().
Completing a Request

As an alternative to resuming a request, an asynchronous handler may write the response itself. After writing the response, the handler must indicate the request handling is complete by calling the complete method:

void myAsyncCallback(Object results)
{
    writeResults(continuation.getServletResponse(),results);
    continuation.complete();
}

After complete is called, the container schedules the response to be committed and flushed.

Continuation complete is analogous to Servlet 3.0 AsyncContext.complete().
Continuation Listeners

An application may monitor the status of a continuation by using a ContinuationListener:

void doGet(HttpServletRequest request, HttpServletResponse response)
{
    ...

    Continuation continuation = ContinuationSupport.getContinuation(request);
    continuation.addContinuationListener(new ContinuationListener()
    {
      public void onTimeout(Continuation continuation) { ... }
      public void onComplete(Continuation continuation) { ... }
    });

    continuation.suspend();
    ...
}

Continuation listeners are analogous to Servlet 3.0 AsyncListeners.
Continuation Patterns
Suspend Resume Pattern

The suspend/resume style is used when a servlet and/or filter is used to generate the response after an asynchronous wait that is terminated by an asynchronous handler. Typically a request attribute is used to pass results and to indicate if the request has already been suspended.

void doGet(HttpServletRequest request, HttpServletResponse response)
{
     // if we need to get asynchronous results
     Object results = request.getAttribute("results");
     if (results==null)
     {
       final Continuation continuation = ContinuationSupport.getContinuation(request);

       // if this is not a timeout
       if (continuation.isExpired())
       {
         sendMyTimeoutResponse(response);
         return;
       }

       // suspend the request
       continuation.suspend(); // always suspend before registration

       // register with async service.  The code here will depend on the
       // the service used (see Jetty HttpClient for example)
       myAsyncHandler.register(new MyHandler()
       {
          public void onMyEvent(Object result)
          {
            continuation.setAttribute("results",results);
            continuation.resume();
          }
       });
       return; // or continuation.undispatch();
     }

     // Send the results
     sendMyResultResponse(response,results);
}

This style is very good when the response needs the facilities of the servlet container (e.g., it uses a web framework) or if one event may resume many requests so the container's thread pool can be used to handle each of them.


Suspend Continue Pattern

The suspend/complete style is used when an asynchronous handler is used to generate the response:

void doGet(HttpServletRequest request, HttpServletResponse response)
{
     final Continuation continuation = ContinuationSupport.getContinuation(request);

     // if this is not a timeout
     if (continuation.isExpired())
     {
       sendMyTimeoutResponse(request,response);
       return;
     }

     // suspend the request
     continuation.suspend(response); // response may be wrapped.

     // register with async service.  The code here will depend on the
     // the service used (see Jetty HttpClient for example)
     myAsyncHandler.register(new MyHandler()
     {
       public void onMyEvent(Object result)
       {
         sendMyResultResponse(continuation.getServletResponse(),results);
         continuation.complete();
       }
     });
}

This style is very good when the response does not need the facilities of the servlet container (e.g., it does not use a web framework) and if an event will resume only one continuation. If many responses are to be sent (e.g., a chat room), then writing one response may block and cause a DOS on the other responses.


Continuation Examples
Chat Servlet

The ChatServlet example shows how the suspend/resume style can be used to directly code a chat room. The same principles are applied to frameworks like cometd.org which provide an richer environment for such applications, based on Continuations.
Quality of Service Filter

The QoSFilter(javadoc), uses suspend/resume style to limit the number of requests simultaneously within the filter. This can be used to protect a JDBC connection pool or other limited resource from too many simultaneous requests.

If too many requests are received, the extra requests wait for a short time on a semaphore, before being suspended. As requests within the filter return, they use a priority queue to resume the suspended requests. This allows your authenticated or priority users to get a better share of your server's resources when the machine is under load.
Denial of Service Filter

The DosFilter(javadoc) is similar to the QoSFilter, but protects a web application from a denial of service attack, as much as is possible from within a web application.

If too many requests are detected coming from one source, then those requests are suspended and a warning generated. This works on the assumption that the attacker may be written in simple blocking style, so by suspending you are hopefully consuming their resources. True protection from DOS can only be achieved by network devices (or eugenics :)).
Proxy Servlet

The ProxyServlet uses the suspend/complete style and the Jetty asynchronous HTTP client to implement a scalable Proxy server (or transparent proxy).
Gzip Filter

The Jetty GzipFilter is a filter that implements dynamic compression by wrapping the response objects. This filter has been enhanced to understand continuations, so that if a request is suspended in suspend/complete style and the wrapped response is passed to the asynchronous handler, then a ContinuationListener is used to finish the wrapped response. This allows the GzipFilter to work with the asynchronous ProxyServlet and to compress the proxied responses.
Categories:

    JettyJetty Feature

This page was last modified 15:20, 23 April 2013 by Jesse McConnell. Based on work by tangfulin , Athena Yao and Greg Wilkins.

Eclipse Foundation

    About us
    Contact Us
    Donate
    Governance
    Logo and Artwork
    Board of Directors

Legal

    Privacy Policy
    Terms of Use
    Copyright Agent
    Eclipse Public License
    Legal Resources

Useful Links

    Report a Bug
    Documentation
    How to Contribute
    Mailing Lists
    Forums
    Marketplace

Other

    IDE and Tools
    Community of Projects
    Working Groups

logo

Copyright  2017 The Eclipse Foundation. All Rights Reserved.
Back to the top


Amount of data needs to be cached :- in TBS
Eviction strategy
It is possible that we might get entries when we would not have space to accommodate new entries. In such cases, we would need to remove one or more entries to make space for the new entry.
Write through cache : This is a caching system where writes go through the cache and write is confirmed as success only if writes to DB and the cache BOTH succeed. This is really useful for applications which write and re-read the information quickly. However, write latency will be higher in this case as there are writes to 2 separate systems.
Write around cache : This is a caching system where write directly goes to the DB. The cache system reads the information from DB incase of a miss. While this ensures lower write load to the cache and faster writes, this can lead to higher read latency incase of applications which write and re-read the information quickly.
Write back cache : This is a caching system where the write is directly done to the caching layer and the write is confirmed as soon as the write to the cache completes. The cache then asynchronously syncs this write to the DB. This would lead to a really quick write latency and high write throughput. But, as is the case with any non-persistent / in-memory write, we stand the risk of losing the data incase the caching layer dies. We can improve our odds by introducing having more than one replica acknowledging the write ( so that we dont lose data if just one of the replica dies )

total cache size = 30 tbs
RAM machinee 72 gb

30TB/72 = 420 machines
but we might need to improve since qps per machine not able to handle
Latenccy
consistency
availbility
Consistency vs Availability?
A: Unavailability in a caching system means that the caching machine goes down, which in turn means that we have a cache miss which leads to a high latency.
As said before, we are caching for a Twitter / Google like system. When fetching a timeline for a user, I would be okay if I miss on a few tweets which were very recently posted as long as I eventually see them in reasonable time.
Unavailability could lead to latency spikes and increased load on DB. Choosing from consistency and availability, we should prioritize for availability.


The way QPS is calculated is as follows : Earlier we mentioned that each machine would have a RAM of 72 GB of RAM. For serving 30TB of cache, the number of machines required would be 30 TB / 72G which is close to 420. Assume that we have 420 machines to server 30 TB of distributed cache. Now regarding the QPS the requirement was 10 M
reply
4
venknar about 1 year ago
Now per machine the QPS would be 10M / 420 = Approximately 23000 QPS. So this meant per machine should be able to handle 23,00 QPS. The approach is similar to how we decided on the number of machines based on the per machine RAM and the total cache size. Similarly for the QPS, it is based on the total QPS / number of machines.
reply
1
venknar about 1 year ago
Next assuming that a machine has to serve 23,000 QPS then we look at each machine has 4 core and then we calculate the per request time as - CPU time available per query = 4 * 1000 * 1000 / 23000 microseconds = 174us (Note everything is converted to milliseconds.) So the machines have to return the query in 174 us. This is the way the QPS is derived. Then based on the read / write traffic and the latency numbers as per the



Posting new tweets : addTweet(userId, tweetContent, timestamp)
Following a user : followUser(userId, toFollowUserId)
Favorite a tweet : favoriteTweet(userId, tweetId)
TweetResult getUserFeed(user, pageNumber, pageSize, lastUpdatedTimestamp)
where TweetResult has the following fields :
TweetResult {
List(Tweets) tweets,
boolean isDeltaUpdate
}
Tweet {
userId,
content,
timestamp,
numFavorites,
sampleFavoriteNames
}

